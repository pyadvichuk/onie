Kernel Magnolia Driver

diff --git a/drivers/gpio/gpio-ich.c b/drivers/gpio/gpio-ich.c
index 4f6d643..d3ef178 100644
--- a/drivers/gpio/gpio-ich.c
+++ b/drivers/gpio/gpio-ich.c
@@ -109,7 +109,7 @@ struct ichx_desc {
 	int outlvl_cache[3];	/* cached output values */
 } ichx_priv;
 
-static int modparam_gpiobase = -1;	/* dynamic */
+static int modparam_gpiobase = 0;//el6661 -1;	/* dynamic */
 module_param_named(gpiobase, modparam_gpiobase, int, 0444);
 MODULE_PARM_DESC(gpiobase, "The GPIO number base. -1 means dynamic, "
 			   "which is the default.");
@@ -477,6 +477,14 @@ static int ichx_gpio_probe(struct platform_device *pdev)
 	ichx_priv.pm_base = res_pm;
 
 init:
+
+#ifdef CONFIG_INVENTEC_MAGNOLIA
+	//inventec set default suspend well output value
+	//0x0B09E000;
+	#define DEFAULT_SUS_WELL_OUT_LVL_MAGNOLIA ((1<<13) | (1<<14) | (1<<15) | (1<<16) | (1<<24) | (1<<25) | (1<<27) )
+	ichx_priv.outlvl_cache[1] = DEFAULT_SUS_WELL_OUT_LVL_MAGNOLIA;
+#endif
+
 	ichx_gpiolib_setup(&ichx_priv.chip);
 	err = gpiochip_add_data(&ichx_priv.chip, NULL);
 	if (err) {
diff --git a/drivers/mfd/lpc_ich.c b/drivers/mfd/lpc_ich.c
index c8dee47..882e3f7 100644
--- a/drivers/mfd/lpc_ich.c
+++ b/drivers/mfd/lpc_ich.c
@@ -488,7 +488,6 @@ enum lpc_chipsets {
 	[LPC_PPT] = {
 		.name = "Panther Point",
 		.iTCO_version = 2,
-		.gpio_version = ICH_V5_GPIO,
 	},
 	[LPC_LPT] = {
 		.name = "Lynx Point",
diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig
index b8a21d7..1207e9e 100644
--- a/drivers/platform/x86/Kconfig
+++ b/drivers/platform/x86/Kconfig
@@ -1027,4 +1027,11 @@ config INTEL_TELEMETRY
 	  used to get various SoC events and parameters
 	  directly via debugfs files. Various tools may use
 	  this interface for SoC state monitoring.
+
+config INVENTEC_MAGNOLIA
+	tristate "Inventec Magnolia"
+	depends on X86
+	---help---
+	  This driver provides support for i2c topology on Magnolia.
+
 endif # X86_PLATFORM_DEVICES
diff --git a/drivers/platform/x86/Makefile b/drivers/platform/x86/Makefile
index 2efa86d..3f6c8ab 100644
--- a/drivers/platform/x86/Makefile
+++ b/drivers/platform/x86/Makefile
@@ -71,3 +71,4 @@ obj-$(CONFIG_INTEL_TELEMETRY)	+= intel_telemetry_core.o \
 				   intel_telemetry_pltdrv.o \
 				   intel_telemetry_debugfs.o
 obj-$(CONFIG_INTEL_PMC_CORE)    += intel_pmc_core.o
+obj-$(CONFIG_INVENTEC_MAGNOLIA)	+= inv_magnolia.o inv_psoc.o inv_cpld.o
diff --git a/drivers/platform/x86/inv_cpld.c b/drivers/platform/x86/inv_cpld.c
new file mode 100644
index 0000000..683ffa0
--- /dev/null
+++ b/drivers/platform/x86/inv_cpld.c
@@ -0,0 +1,415 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/i2c.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/err.h>
+#include <linux/mutex.h>
+
+//#include "I2CHostCommunication.h"
+
+#define USE_SMBUS    1
+
+/* definition */
+#define CPLD_INFO_OFFSET   0x00
+#define CPLD_PSU_OFFSET    0x08
+#define CPLD_LED_OFFSET    0x0E
+#define CPLD_LED_STATU_OFFSET    0x0D
+#define CPLD_CTL_OFFSET    0x0C
+
+
+
+/* Each client has this additional data */
+struct cpld_data {
+	struct device		*hwmon_dev;
+	struct mutex		update_lock;
+};
+
+/*-----------------------------------------------------------------------*/
+
+static ssize_t cpld_i2c_read(struct i2c_client *client, u8 *buf, u8 offset, size_t count)
+{
+#if USE_SMBUS    
+	int i;
+	
+    for(i=0; i<count; i++) {
+        buf[i] = i2c_smbus_read_byte_data(client, offset+i);
+    }	
+    return count;
+#else
+	struct i2c_msg msg[2];
+	char msgbuf[2];
+	int status;
+
+	memset(msg, 0, sizeof(msg));
+	
+	msgbuf[0] = offset;
+	
+	msg[0].addr = client->addr;
+	msg[0].buf = msgbuf;
+	msg[0].len = 1;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = buf;
+	msg[1].len = count;
+	
+	status = i2c_transfer(client->adapter, msg, 2);
+	
+	if(status == 2)
+	    status = count;
+	    
+	return status;    
+#endif	
+}
+
+static ssize_t cpld_i2c_write(struct i2c_client *client, char *buf, unsigned offset, size_t count)
+{
+#if USE_SMBUS    
+	int i;
+	
+    for(i=0; i<count; i++) {
+        i2c_smbus_write_byte_data(client, offset+i, buf[i]);
+    }	
+    return count;
+#else
+	struct i2c_msg msg;
+	int status;
+    u8 writebuf[64];
+	
+	int i = 0;
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+
+	/* msg.buf is u8 and casts will mask the values */
+	msg.buf = writebuf;
+	
+	msg.buf[i++] = offset;
+	memcpy(&msg.buf[i], buf, count);
+	msg.len = i + count;
+	
+	status = i2c_transfer(client->adapter, &msg, 1);
+	if (status == 1)
+		status = count;
+	
+    return status;	
+#endif    
+}
+
+/*-----------------------------------------------------------------------*/
+
+/* sysfs attributes for hwmon */
+
+static ssize_t show_info(struct device *dev, struct device_attribute *da,
+			 char *buf)
+{
+	u32 status;
+	//struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct cpld_data *data = i2c_get_clientdata(client);
+	u8 b[4];
+    
+    memset(b, 0, 4);
+    
+	mutex_lock(&data->update_lock);
+    status = cpld_i2c_read(client, b, CPLD_INFO_OFFSET, 4);
+	mutex_unlock(&data->update_lock);
+	
+	if(status != 4) return sprintf(buf, "read cpld info fail\n");
+	
+	status = sprintf (buf,   "The CPLD release date is %02d/%02d/%d.\n", b[2] & 0xf, (b[3] & 0x1f), 2014+(b[2] >> 4));	/* mm/dd/yyyy*/
+	status = sprintf (buf, "%sThe PCB  version is %X%X\n", buf,  b[0]>>4, b[0]&0xf);
+	status = sprintf (buf, "%sThe CPLD version is %d.%d\n", buf, b[1]>>4, b[1]&0xf);
+	
+	return strlen(buf);
+}
+
+
+static ssize_t show_ctl(struct device *dev, struct device_attribute *da,
+			 char *buf)
+{
+	u32 status;
+	//struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct cpld_data *data = i2c_get_clientdata(client);
+	u8 b[1];
+    
+	mutex_lock(&data->update_lock);
+	
+    status = cpld_i2c_read(client, b, CPLD_CTL_OFFSET, 1);
+	
+	mutex_unlock(&data->update_lock);
+	
+	if(status != 1) return sprintf(buf, "read cpld ctl fail\n");
+	    
+	
+	status = sprintf (buf, "0x%X\n", b[0]);
+	    
+	return strlen(buf);
+}
+
+static ssize_t set_ctl(struct device *dev,
+			   struct device_attribute *devattr,
+			   const char *buf, size_t count)
+{
+	//struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct cpld_data *data = i2c_get_clientdata(client);
+	u8 byte;
+
+	u8 temp = simple_strtol(buf, NULL, 10);
+    
+	mutex_lock(&data->update_lock);
+        cpld_i2c_read(client, &byte, CPLD_CTL_OFFSET, 1);
+	if(temp) byte |= (1<<0);
+	else     byte &= ~(1<<0);
+	cpld_i2c_write(client, &byte, CPLD_CTL_OFFSET, 1);
+	mutex_unlock(&data->update_lock);
+
+	return count;
+}
+
+
+static char* led_str[] = {
+    "OFF",     //000
+    "0.5 Hz",  //001
+    "1 Hz",    //010
+    "2 Hz",    //011
+    "NA",      //100
+    "NA",      //101
+    "NA",      //110
+    "ON",      //111
+};
+
+static ssize_t show_led(struct device *dev, struct device_attribute *da,
+			 char *buf)
+{
+	u32 status;
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct cpld_data *data = i2c_get_clientdata(client);
+	u8 byte;
+	int shift = (attr->index == 0)?3:0;
+    
+	mutex_lock(&data->update_lock);
+    status = cpld_i2c_read(client, &byte, CPLD_LED_OFFSET, 1);
+	mutex_unlock(&data->update_lock);
+	
+	if(status != 1) return sprintf(buf, "read cpld offset 0x%x\n", CPLD_LED_OFFSET);
+	
+    byte = (byte >> shift) & 0x7;
+	
+	/*
+	    0: off
+	    1: 0.5hz
+	    2: 1 hz
+	    3: 2 hz
+	    4~6: not define
+	    7: on
+	*/
+	
+	status = sprintf (buf, "%d: %s\n", byte, led_str[byte]);
+	    
+	return strlen(buf);
+}
+
+static ssize_t set_led(struct device *dev,
+			   struct device_attribute *devattr,
+			   const char *buf, size_t count)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct cpld_data *data = i2c_get_clientdata(client);
+
+	u8 temp = simple_strtol(buf, NULL, 16);
+	u8 byte;
+	int shift = (attr->index == 0)?3:0;
+    
+    temp &= 0x7;    
+    //validate temp value: 0,1,2,3,7, TBD
+    
+	mutex_lock(&data->update_lock);
+    cpld_i2c_read(client, &byte, CPLD_LED_OFFSET, 1);
+    byte &= ~(0x7<<shift);
+    byte |= (temp<<shift);
+	cpld_i2c_write(client, &byte, CPLD_LED_OFFSET, 1);
+	mutex_unlock(&data->update_lock);
+
+	return count;
+}
+
+/*
+CPLD report the PSU0 status
+000 = PSU normal operation
+100 = PSU fault
+010 = PSU unpowered
+111 = PSU not installed
+
+7 6 | 5 4 3 |  2 1 0
+----------------------
+    | psu0  |  psu1
+*/
+static char* psu_str[] = {
+    "normal",           //000
+    "NA",               //001
+    "unpowered",        //010
+    "NA",               //011
+    "fault",            //100
+    "NA",               //101
+    "NA",               //110
+    "not installed",    //111
+};
+
+static ssize_t show_psu(struct device *dev, struct device_attribute *da,
+			 char *buf)
+{
+	u32 status;
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct cpld_data *data = i2c_get_clientdata(client);
+	u8 byte;
+	int shift = (attr->index == 1)?0:3;
+    
+	mutex_lock(&data->update_lock);
+    status = cpld_i2c_read(client, &byte, CPLD_PSU_OFFSET, 1);
+	mutex_unlock(&data->update_lock);
+	
+    byte = (byte >> shift) & 0x7;
+	
+	status = sprintf (buf, "%d : %s\n", byte, psu_str[byte]);
+	    
+	return strlen(buf);
+}
+
+
+static SENSOR_DEVICE_ATTR(info,  S_IRUGO,			        show_info, 0, 0);
+static SENSOR_DEVICE_ATTR(ctl, S_IWUSR|S_IRUGO,			show_ctl, set_ctl, 0);
+
+static SENSOR_DEVICE_ATTR(grn_led, S_IWUSR|S_IRUGO,			show_led, set_led, 0);
+static SENSOR_DEVICE_ATTR(red_led, S_IWUSR|S_IRUGO,			show_led, set_led, 1);
+
+static SENSOR_DEVICE_ATTR(psu0,  S_IRUGO,			        show_psu, 0, 0);
+static SENSOR_DEVICE_ATTR(psu1,  S_IRUGO,			        show_psu, 0, 1);
+			
+static struct attribute *cpld_attributes[] = {
+    //info
+	&sensor_dev_attr_info.dev_attr.attr,
+	&sensor_dev_attr_ctl.dev_attr.attr,
+
+	&sensor_dev_attr_grn_led.dev_attr.attr,
+	&sensor_dev_attr_red_led.dev_attr.attr,
+
+	&sensor_dev_attr_psu0.dev_attr.attr,
+	&sensor_dev_attr_psu1.dev_attr.attr,
+	
+	NULL
+};
+
+static const struct attribute_group cpld_group = {
+	.attrs = cpld_attributes,
+};
+
+/*-----------------------------------------------------------------------*/
+
+/* device probe and removal */
+
+static int
+cpld_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct cpld_data *data;
+	int status;
+
+    printk("+%s\n", __func__);
+    
+	if (!i2c_check_functionality(client->adapter,
+			I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA))
+		return -EIO;
+
+	data = kzalloc(sizeof(struct cpld_data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	i2c_set_clientdata(client, data);
+	mutex_init(&data->update_lock);
+	
+	/* Register sysfs hooks */
+	status = sysfs_create_group(&client->dev.kobj, &cpld_group);
+	if (status)
+		goto exit_free;
+
+	data->hwmon_dev = hwmon_device_register(&client->dev);
+	if (IS_ERR(data->hwmon_dev)) {
+		status = PTR_ERR(data->hwmon_dev);
+		goto exit_remove;
+	}
+
+	dev_info(&client->dev, "%s: sensor '%s'\n",
+		 dev_name(data->hwmon_dev), client->name);
+
+	return 0;
+
+exit_remove:
+	sysfs_remove_group(&client->dev.kobj, &cpld_group);
+exit_free:
+	i2c_set_clientdata(client, NULL);
+	kfree(data);
+	return status;
+}
+
+static int cpld_remove(struct i2c_client *client)
+{
+	struct cpld_data *data = i2c_get_clientdata(client);
+
+	hwmon_device_unregister(data->hwmon_dev);
+	sysfs_remove_group(&client->dev.kobj, &cpld_group);
+	i2c_set_clientdata(client, NULL);
+	kfree(data);
+	return 0;
+}
+
+static const struct i2c_device_id cpld_ids[] = {
+	{ "inv_cpld", 0, },
+	{ /* LIST END */ }
+};
+MODULE_DEVICE_TABLE(i2c, cpld_ids);
+
+static struct i2c_driver cpld_driver = {
+	.class		= I2C_CLASS_HWMON,
+	.driver = {
+		.name	= "inv_cpld",
+	},
+	.probe		= cpld_probe,
+	.remove		= cpld_remove,
+	.id_table	= cpld_ids,
+};
+
+/*-----------------------------------------------------------------------*/
+
+/* module glue */
+
+static int __init inv_cpld_init(void)
+{
+	return i2c_add_driver(&cpld_driver);
+}
+
+static void __exit inv_cpld_exit(void)
+{
+	i2c_del_driver(&cpld_driver);
+}
+
+MODULE_AUTHOR("eddie.lan <eddie.lan@inventec>");
+MODULE_DESCRIPTION("inv cpld driver");
+MODULE_LICENSE("GPL");
+
+module_init(inv_cpld_init);
+module_exit(inv_cpld_exit);
diff --git a/drivers/platform/x86/inv_magnolia.c b/drivers/platform/x86/inv_magnolia.c
new file mode 100644
index 0000000..e4f4c26
--- /dev/null
+++ b/drivers/platform/x86/inv_magnolia.c
@@ -0,0 +1,336 @@
+#include <linux/i2c.h>
+//#include <linux/i2c-algo-bit.h>
+#include <linux/i2c-gpio.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+
+#include <linux/i2c/pca954x.h>
+#include <linux/platform_data/pca953x.h>
+#include <linux/platform_data/at24.h>
+
+//#include <asm/gpio.h>
+#define IO_EXPAND_BASE    64
+#define IO_EXPAND_NGPIO   16
+
+struct inv_i2c_board_info {
+    int ch;
+    int size;
+    struct i2c_board_info *board_info;
+};
+
+/////////////////////////////////////////////////////////////////////////////////////////
+static struct at24_platform_data at24c64_eeprom_data = {
+        .byte_len = 256,//SZ_64K/8
+        .page_size = 1,
+        .flags = 0,//AT24_FLAG_ADDR8,
+};
+
+static int	pca9555_setup(struct i2c_client *client, unsigned gpio, unsigned ngpio, void *context)
+{
+    //TBD
+    printk("%s : gpio=%d, ngpio=%d\n ", __func__, gpio, ngpio);
+    return 0;
+}
+
+static struct pca954x_platform_mode mux_modes_0[] = {
+    {.adap_id = 2,},    {.adap_id = 3,},
+    {.adap_id = 4,},    {.adap_id = 5,},
+    {.adap_id = 6,},    {.adap_id = 7,},
+    {.adap_id = 8,},    {.adap_id = 9,},
+};
+static struct pca954x_platform_mode mux_modes_0_0[] = {
+    {.adap_id = 10,},    {.adap_id = 11,},
+    {.adap_id = 12,},    {.adap_id = 13,},
+    {.adap_id = 14,},    {.adap_id = 15,},
+    {.adap_id = 16,},    {.adap_id = 17,},
+};
+
+static struct pca954x_platform_mode mux_modes_0_1[] = {
+    {.adap_id = 18,},    {.adap_id = 19,},
+    {.adap_id = 20,},    {.adap_id = 21,},
+    {.adap_id = 22,},    {.adap_id = 23,},
+    {.adap_id = 24,},    {.adap_id = 25,},
+};
+
+static struct pca954x_platform_mode mux_modes_0_2[] = {
+    {.adap_id = 26,},    {.adap_id = 27,},
+    {.adap_id = 28,},    {.adap_id = 29,},
+    {.adap_id = 30,},    {.adap_id = 31,},
+    {.adap_id = 32,},    {.adap_id = 33,},
+};
+
+static struct pca954x_platform_mode mux_modes_0_3[] = {
+    {.adap_id = 34,},    {.adap_id = 35,},
+    {.adap_id = 36,},    {.adap_id = 37,},
+    {.adap_id = 38,},    {.adap_id = 39,},
+    {.adap_id = 40,},    {.adap_id = 41,},
+};
+
+static struct pca954x_platform_mode mux_modes_0_4[] = {
+    {.adap_id = 42,},    {.adap_id = 43,},
+    {.adap_id = 44,},    {.adap_id = 45,},
+    {.adap_id = 46,},    {.adap_id = 47,},
+    {.adap_id = 48,},    {.adap_id = 49,},
+};
+
+static struct pca954x_platform_mode mux_modes_0_5[] = {
+    {.adap_id = 50,},    {.adap_id = 51,},
+    {.adap_id = 52,},    {.adap_id = 53,},
+    {.adap_id = 54,},    {.adap_id = 55,},
+    {.adap_id = 56,},    {.adap_id = 57,},
+};
+
+static struct pca954x_platform_mode mux_modes_0_6[] = {
+    {.adap_id = 58,},    {.adap_id = 59,},
+    {.adap_id = 60,},    {.adap_id = 61,},
+    {.adap_id = 62,},    {.adap_id = 63,},
+    {.adap_id = 64,},    {.adap_id = 65,},
+};
+
+//no i2c device driver attach to mux 7
+
+
+static struct pca954x_platform_data mux_data_0 = {
+        .modes          = mux_modes_0,
+        .num_modes      = 8,
+};
+static struct pca954x_platform_data mux_data_0_0 = {
+        .modes          = mux_modes_0_0,
+        .num_modes      = 8,
+};
+static struct pca954x_platform_data mux_data_0_1 = {
+        .modes          = mux_modes_0_1,
+        .num_modes      = 8,
+};
+static struct pca954x_platform_data mux_data_0_2 = {
+        .modes          = mux_modes_0_2,
+        .num_modes      = 8,
+};
+static struct pca954x_platform_data mux_data_0_3 = {
+        .modes          = mux_modes_0_3,
+        .num_modes      = 8,
+};
+static struct pca954x_platform_data mux_data_0_4 = {
+        .modes          = mux_modes_0_4,
+        .num_modes      = 8,
+};
+static struct pca954x_platform_data mux_data_0_5 = {
+        .modes          = mux_modes_0_5,
+        .num_modes      = 8,
+};
+static struct pca954x_platform_data mux_data_0_6 = {
+        .modes          = mux_modes_0_6,
+        .num_modes      = 8,
+};
+
+
+#define IO_EXPAND_BASE_CHIP    (IO_EXPAND_BASE) //64
+#define IO_EXPAND_BASE_CHIP00  (IO_EXPAND_BASE + IO_EXPAND_NGPIO)
+#define IO_EXPAND_BASE_CHIP01  (IO_EXPAND_BASE_CHIP00 + IO_EXPAND_NGPIO)
+#define IO_EXPAND_BASE_CHIP10  (IO_EXPAND_BASE_CHIP01 + IO_EXPAND_NGPIO)
+#define IO_EXPAND_BASE_CHIP11  (IO_EXPAND_BASE_CHIP10 + IO_EXPAND_NGPIO)
+#define IO_EXPAND_BASE_CHIP20  (IO_EXPAND_BASE_CHIP11 + IO_EXPAND_NGPIO)
+#define IO_EXPAND_BASE_CHIP21  (IO_EXPAND_BASE_CHIP20 + IO_EXPAND_NGPIO)
+#define IO_EXPAND_BASE_CHIP30  (IO_EXPAND_BASE_CHIP21 + IO_EXPAND_NGPIO)
+#define IO_EXPAND_BASE_CHIP31  (IO_EXPAND_BASE_CHIP30 + IO_EXPAND_NGPIO)
+#define IO_EXPAND_BASE_CHIP40  (IO_EXPAND_BASE_CHIP31 + IO_EXPAND_NGPIO)
+#define IO_EXPAND_BASE_CHIP41  (IO_EXPAND_BASE_CHIP40 + IO_EXPAND_NGPIO)
+#define IO_EXPAND_BASE_CHIP50  (IO_EXPAND_BASE_CHIP41 + IO_EXPAND_NGPIO)
+#define IO_EXPAND_BASE_CHIP51  (IO_EXPAND_BASE_CHIP50 + IO_EXPAND_NGPIO)
+#define IO_EXPAND_BASE_CHIP60  (IO_EXPAND_BASE_CHIP51 + IO_EXPAND_NGPIO)
+#define IO_EXPAND_BASE_CHIP61  (IO_EXPAND_BASE_CHIP60 + IO_EXPAND_NGPIO)
+
+static struct pca953x_platform_data   pca9555_data = {
+    .gpio_base = IO_EXPAND_BASE_CHIP,
+    .setup     = pca9555_setup,
+};
+
+#if 0
+static struct pca953x_platform_data   pca9555_data00 = {
+    .gpio_base = IO_EXPAND_BASE_CHIP00,
+    .setup     = pca9555_setup,
+};
+static struct pca953x_platform_data   pca9555_data01 = {
+    .gpio_base = IO_EXPAND_BASE_CHIP01,
+    .setup     = pca9555_setup,
+};
+static struct pca953x_platform_data   pca9555_data10 = {
+    .gpio_base = IO_EXPAND_BASE_CHIP10,
+    .setup     = pca9555_setup,
+};
+static struct pca953x_platform_data   pca9555_data11 = {
+    .gpio_base = IO_EXPAND_BASE_CHIP11,
+    .setup     = pca9555_setup,
+};
+static struct pca953x_platform_data   pca9555_data20 = {
+    .gpio_base = IO_EXPAND_BASE_CHIP20,
+    .setup     = pca9555_setup,
+};
+static struct pca953x_platform_data   pca9555_data21 = {
+    .gpio_base = IO_EXPAND_BASE_CHIP21,
+    .setup     = pca9555_setup,
+};
+static struct pca953x_platform_data   pca9555_data30 = {
+    .gpio_base = IO_EXPAND_BASE_CHIP30,
+    .setup     = pca9555_setup,
+};
+static struct pca953x_platform_data   pca9555_data31 = {
+    .gpio_base = IO_EXPAND_BASE_CHIP31,
+    .setup     = pca9555_setup,
+};
+static struct pca953x_platform_data   pca9555_data40 = {
+    .gpio_base = IO_EXPAND_BASE_CHIP40,
+    .setup     = pca9555_setup,
+};
+static struct pca953x_platform_data   pca9555_data41 = {
+    .gpio_base = IO_EXPAND_BASE_CHIP41,
+    .setup     = pca9555_setup,
+};
+static struct pca953x_platform_data   pca9555_data50 = {
+    .gpio_base = IO_EXPAND_BASE_CHIP50,
+    .setup     = pca9555_setup,
+};
+static struct pca953x_platform_data   pca9555_data51 = {
+    .gpio_base = IO_EXPAND_BASE_CHIP51,
+    .setup     = pca9555_setup,
+};
+static struct pca953x_platform_data   pca9555_data60 = {
+    .gpio_base = IO_EXPAND_BASE_CHIP60,
+    .setup     = pca9555_setup,
+};
+static struct pca953x_platform_data   pca9555_data61 = {
+    .gpio_base = IO_EXPAND_BASE_CHIP61,
+    .setup     = pca9555_setup,
+};
+#endif
+
+static struct i2c_board_info xlp_i2c_device_info0[] __initdata = {
+//        {"24c02",            0, 0x57, &at24c64_eeprom_data, 0, 0},	//VPD
+        {"inv_psoc",         0, 0x66, 0, 0, 0},//psoc
+        {"inv_cpld",         0, 0x55, 0, 0, 0},//cpld
+        {"pca9555",          0, 0x22, &pca9555_data, 0, 0},	
+        {"pca9548",          0, 0x71, &mux_data_0, 0, 0},	
+};
+
+static struct i2c_board_info xlp_i2c_device_info1[] __initdata = {
+        {"inv_psoc",         0, 0x66, 0, 0, 0},//psoc
+        {"inv_cpld",         0, 0x55, 0, 0, 0},//cpld
+};
+
+static struct i2c_board_info xlp_i2c_device_info2[] __initdata = {
+        {"pca9548",         0, 0x72, &mux_data_0_0, 0, 0},	
+//        {"pca9555",         0, 0x20, &pca9555_data00, 0, 0},	
+//        {"pca9555",         0, 0x21, &pca9555_data01, 0, 0},	
+};
+
+static struct i2c_board_info xlp_i2c_device_info3[] __initdata = {
+        {"pca9548",         0, 0x72, &mux_data_0_1, 0, 0},	
+//        {"pca9555",         0, 0x20, &pca9555_data10, 0, 0},	
+//        {"pca9555",         0, 0x21, &pca9555_data11, 0, 0},	
+};
+
+static struct i2c_board_info xlp_i2c_device_info4[] __initdata = {
+        {"pca9548",         0, 0x72, &mux_data_0_2, 0, 0},	
+//        {"pca9555",         0, 0x20, &pca9555_data20, 0, 0},	
+//        {"pca9555",         0, 0x21, &pca9555_data21, 0, 0},	
+};
+
+static struct i2c_board_info xlp_i2c_device_info5[] __initdata = {
+        {"pca9548",         0, 0x72, &mux_data_0_3, 0, 0},	
+//        {"pca9555",         0, 0x20, &pca9555_data30, 0, 0},	
+//        {"pca9555",         0, 0x21, &pca9555_data31, 0, 0},	
+};
+static struct i2c_board_info xlp_i2c_device_info6[] __initdata = {
+        {"pca9548",         0, 0x72, &mux_data_0_4, 0, 0},	
+//        {"pca9555",         0, 0x20, &pca9555_data40, 0, 0},	
+//        {"pca9555",         0, 0x21, &pca9555_data41, 0, 0},	
+};
+static struct i2c_board_info xlp_i2c_device_info7[] __initdata = {
+        {"pca9548",         0, 0x72, &mux_data_0_5, 0, 0},	
+//        {"pca9555",         0, 0x20, &pca9555_data50, 0, 0},	
+//        {"pca9555",         0, 0x21, &pca9555_data51, 0, 0},	
+};
+static struct i2c_board_info xlp_i2c_device_info8[] __initdata = {
+        {"pca9548",         0, 0x72, &mux_data_0_6, 0, 0},	
+//        {"pca9555",         0, 0x20, &pca9555_data60, 0, 0},	
+//        {"pca9555",         0, 0x21, &pca9555_data61, 0, 0},	
+};
+
+
+static struct inv_i2c_board_info i2cdev_list[] = {
+    {0, ARRAY_SIZE(xlp_i2c_device_info0),  xlp_i2c_device_info0 },  //smbus 0
+//    {1, ARRAY_SIZE(xlp_i2c_device_info1),  xlp_i2c_device_info1 },  //smbus 1 or gpio11+12
+    
+    {2, ARRAY_SIZE(xlp_i2c_device_info2),  xlp_i2c_device_info2 },  //mux 0
+    {3, ARRAY_SIZE(xlp_i2c_device_info3),  xlp_i2c_device_info3 },  //mux 1
+    {4, ARRAY_SIZE(xlp_i2c_device_info4),  xlp_i2c_device_info4 },  //mux 2
+    {5, ARRAY_SIZE(xlp_i2c_device_info5),  xlp_i2c_device_info5 },  //mux 3
+    {6, ARRAY_SIZE(xlp_i2c_device_info6),  xlp_i2c_device_info6 },  //mux 4
+    {7, ARRAY_SIZE(xlp_i2c_device_info7),  xlp_i2c_device_info7 },  //mux 5
+    {8, ARRAY_SIZE(xlp_i2c_device_info8),  xlp_i2c_device_info8 },  //mux 6
+};
+
+/////////////////////////////////////////////////////////////////////////////////////////
+static struct 	i2c_gpio_platform_data 	i2c_gpio_platdata = {
+	.scl_pin = 8,
+	.sda_pin = 9,
+    
+	.udelay  = 5, //5:100kHz
+	.sda_is_open_drain = 0,
+	.scl_is_open_drain = 0,
+	.scl_is_output_only = 0
+};
+
+static struct 	platform_device 	magnolia_device_i2c_gpio = {
+	.name 	= "i2c-gpio",
+	.id  	= 0, // adapter number
+	.dev.platform_data = &i2c_gpio_platdata,
+};
+
+static int __init plat_magnolia_init(void)
+{
+    struct i2c_adapter *adap = NULL;
+    struct i2c_client *e = NULL;
+    int ret = 0;
+    int i,j;
+
+    printk("el6661 plat_magnolia_init  \n");
+
+#if 1
+    //use i2c-gpio    
+    //register i2c gpio
+    //config gpio8,9 to gpio function
+    outl( inl(0x500) | (1<<8 | 1<<9), 0x500);
+    
+	ret = platform_device_register(&magnolia_device_i2c_gpio);
+	if (ret) {
+		printk(KERN_ERR "i2c-gpio: magnolia_device_i2c_gpio register fail %d\n", ret);
+	}
+#endif
+    
+    for(i=0; i<ARRAY_SIZE(i2cdev_list); i++) {
+        
+        adap = i2c_get_adapter( i2cdev_list[i].ch );
+        if (adap == NULL) {
+            printk("magnolia get channel %d adapter fail\n", i2cdev_list[i].ch);
+            continue;
+            return -ENODEV;
+        }
+    
+        i2c_put_adapter(adap);
+        for(j=0; j<i2cdev_list[i].size; j++) {
+            e = i2c_new_device(adap, &i2cdev_list[i].board_info[j] );
+        }
+    }
+
+    return ret;    
+}
+
+module_init(plat_magnolia_init);
+//arch_initcall(plat_magnolia_init);
+
+MODULE_AUTHOR("Inventec");
+MODULE_DESCRIPTION("Magnolia Platform devices");
+MODULE_LICENSE("GPL");
diff --git a/drivers/platform/x86/inv_psoc.c b/drivers/platform/x86/inv_psoc.c
new file mode 100644
index 0000000..daeae60
--- /dev/null
+++ b/drivers/platform/x86/inv_psoc.c
@@ -0,0 +1,915 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/i2c.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/err.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+
+//#include "I2CHostCommunication.h"
+
+#define USE_SMBUS    1
+
+#define FAN_NUM  4 
+#define PSU_NUM  2 
+
+struct __attribute__ ((__packed__))  psoc_psu_layout {
+    u16 psu1_iin;
+    u16 psu2_iin;
+    u16 psu1_iout;
+    u16 psu2_iout;
+    
+    u16 psu1_pin;
+    u16 psu2_pin;
+    u16 psu1_pout;
+    u16 psu2_pout;
+    
+    u16 psu1_vin;
+    u16 psu2_vin;
+    u16 psu1_vout;
+    u16 psu2_vout;
+};
+
+struct __attribute__ ((__packed__))  psoc_layout {
+    u8 ctl;                 //offset: 0
+    u16 switch_temp;        //offset: 1
+    u8 reserve0;            //offset: 3
+
+    u8 fw_upgrade;          //offset: 4
+
+    //i2c bridge
+    u8 i2c_st;              //offset: 5
+    u8 i2c_ctl;             //offset: 6
+    u8 i2c_addr;            //offset: 7
+    u8 i2c_data[0x20];      //offset: 8 
+
+    //gpo
+    u8 led_ctl;             //offset: 28
+
+    u8 gpio;                //offset: 29
+
+    //pwm duty
+    u8 pwm[FAN_NUM];        //offset: 2a
+    u8 pwm_psu[PSU_NUM];    //offset: 2e
+
+    //fan rpm
+    u16 fan[FAN_NUM*2];     //offset: 30
+    
+    u8  reserve1[4];        //offset: 40
+
+    //gpi 
+    u8 gpi_fan;             //offset: 44 
+
+    //psu state
+    u8 psu_state;           //offset: 45
+
+    //temperature
+    u16 temp[5];            //offset: 46
+    u16 temp_psu[PSU_NUM];  //offset: 50
+
+    //version
+    u8 version[2];          //offset: 54
+    
+    u8  reserve2[4];        //offset: 56
+    struct psoc_psu_layout psu_info;      //offset: 5a
+};        
+
+/* definition */
+/* definition */
+#define PSOC_OFF(m)    offsetof(struct psoc_layout, m)
+#define PSOC_PSU_OFF(m)    offsetof(struct psoc_psu_layout, m)
+
+#define SWITCH_TMP_OFFSET       PSOC_OFF(switch_temp)
+#define PWM_OFFSET              PSOC_OFF(pwm)
+#define THERMAL_OFFSET          PSOC_OFF(temp)
+#define RPM_OFFSET              PSOC_OFF(fan)
+#define DIAG_FLAG_OFFSET        PSOC_OFF(ctl)
+#define FAN_LED_OFFSET          PSOC_OFF(led_ctl)
+#define FAN_GPI_OFFSET          PSOC_OFF(gpi_fan)
+#define PSOC_PSU_OFFSET         PSOC_OFF(psu_state)
+#define VERSION_OFFSET          PSOC_OFF(version)
+#define PSU_INFO_OFFSET         PSOC_OFF(psu_info)
+
+/* Each client has this additional data */
+struct psoc_data {
+	struct device		*hwmon_dev;
+	struct mutex		update_lock;
+	u32                 diag;
+};
+
+/*-----------------------------------------------------------------------*/
+
+static ssize_t psoc_i2c_read(struct i2c_client *client, u8 *buf, u8 offset, size_t count)
+{
+#if USE_SMBUS    
+	int i;
+	
+    for(i=0; i<count; i++) {
+        buf[i] = i2c_smbus_read_byte_data(client, offset+i);
+    }	
+    return count;
+#else
+	struct i2c_msg msg[2];
+	char msgbuf[2];
+	int status;
+
+	memset(msg, 0, sizeof(msg));
+	
+	msgbuf[0] = offset;
+	
+	msg[0].addr = client->addr;
+	msg[0].buf = msgbuf;
+	msg[0].len = 1;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = buf;
+	msg[1].len = count;
+	
+	status = i2c_transfer(client->adapter, msg, 2);
+	
+	if(status == 2)
+	    status = count;
+	    
+	return status;    
+#endif	
+}
+
+static ssize_t psoc_i2c_write(struct i2c_client *client, char *buf, unsigned offset, size_t count)
+{
+#if USE_SMBUS    
+	int i;
+	
+    for(i=0; i<count; i++) {
+        i2c_smbus_write_byte_data(client, offset+i, buf[i]);
+    }	
+    return count;
+#else
+	struct i2c_msg msg;
+	int status;
+    u8 writebuf[256];
+	
+	int i = 0;
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+
+	/* msg.buf is u8 and casts will mask the values */
+	msg.buf = writebuf;
+	
+	msg.buf[i++] = offset;
+	memcpy(&msg.buf[i], buf, count);
+	msg.len = i + count;
+	
+	status = i2c_transfer(client->adapter, &msg, 1);
+	if (status == 1)
+		status = count;
+	
+    return status;	
+#endif    
+}
+
+#if 0
+static u32 psoc_read32(struct i2c_client *client, u8 offset)
+{
+	u32 value = 0;
+	u8 buf[4];
+    
+    if( psoc_i2c_read(client, buf, offset, 4) == 4)
+        value = (buf[0]<<24 | buf[1]<<16 | buf[2]<<8 | buf[3]);
+    
+	return value;
+}
+#endif
+
+static u16 psoc_read16(struct i2c_client *client, u8 offset)
+{
+	u16 value = 0;
+	u8 buf[2];
+    
+    if(psoc_i2c_read(client, buf, offset, 2) == 2)
+        value = (buf[0]<<8 | buf[1]<<0);
+    
+	return value;
+}
+
+static u8 psoc_read8(struct i2c_client *client, u8 offset)
+{
+	u8 value = 0;
+	u8 buf = 0;
+    
+    if(psoc_i2c_read(client, &buf, offset, 1) == 1)
+        value = buf;
+    
+	return value;
+}
+
+//PSOC i2c bridge regsters
+#define PSOC_I2C_STATUS         0x05
+#define PSOC_I2C_CNTRL          0x06
+#define PSOC_I2C_ADDR           0x07
+#define PSOC_I2C_DATA           0x08
+
+//status bit definition
+#define PSOC_I2C_START          (1 << 0)
+#define PSOC_PMB_SEL            (1 << 7)
+
+//addr bits definition
+#define PSOC_I2C_READ           (1 << 0)
+
+//PMBUS registers definition
+#define PMBUS_READ_VIN                  (0x88)
+#define PMBUS_READ_IIN                  (0x89)
+#define PMBUS_READ_VOUT                 (0x8B)
+#define PMBUS_READ_IOUT                 (0x8C)
+#define PMBUS_READ_POUT                 (0x96)
+#define PMBUS_READ_PIN                  (0x97)
+
+static int psoc_i2c_bridge_read(struct i2c_client *client,
+                                unsigned char bus, 
+                                unsigned char chip, 
+                                char *addr,          int alen, 
+                                unsigned char *data, int len )
+{
+    unsigned char txdata[28], rxdata[28];
+    int index, timeout;
+    
+	txdata[PSOC_I2C_STATUS] = 0;		/* the status */
+	txdata[PSOC_I2C_CNTRL] = ((alen & 3) << 5) | (len & 0x1f);	/* the sizes */
+	txdata[PSOC_I2C_ADDR] = (chip << 1) | PSOC_I2C_READ;		/* read address */
+	for(index = 0; index < alen; index++)
+		txdata[PSOC_I2C_DATA + index] = addr[index];		/* the chip address */
+	for(; index < alen+len; index++)
+		txdata[PSOC_I2C_DATA + index] = 0;		/* clear the chip data */
+		
+    psoc_i2c_write(client, &txdata[PSOC_I2C_CNTRL], PSOC_I2C_CNTRL, 2 + alen + len);
+    
+    //delay a while ???
+    //---------------------------------------------------------------------
+    //start write
+	txdata[PSOC_I2C_STATUS] = PSOC_I2C_START | PSOC_PMB_SEL;	/* the start bit for the PM bus */
+    psoc_i2c_write(client, &txdata[PSOC_I2C_STATUS], PSOC_I2C_STATUS, 1);
+    
+    //delay a while
+    timeout = 40; //40*20==>800 ms
+    do {
+        psoc_i2c_read(client, &rxdata[PSOC_I2C_STATUS], PSOC_I2C_STATUS, 1);
+        
+        //check rxdata[5] error bit(1) and complete bit(0) ,TBD
+		if((rxdata[PSOC_I2C_STATUS] & 0x2) == 0x2) {
+		    //printk("i2c bridge fail!!!\n");
+			timeout = 0;
+			break;
+		}
+		if((rxdata[PSOC_I2C_STATUS] & PSOC_I2C_START) == 0) {
+		    /* comand complete */
+            psoc_i2c_read(client, &rxdata[PSOC_I2C_DATA+alen], PSOC_I2C_DATA+alen, len);
+			break;	
+		}
+		
+        //delay
+        msleep(20);
+    } while(timeout--);
+
+ 	if(timeout <= 0) {
+ 	    return -1;
+ 	}
+    
+    //---------------------------------------------------------------------
+    
+    for(index=0; index < len; index++) {
+        data[index] = rxdata[PSOC_I2C_DATA + alen + index];
+    }
+    
+    return 0;
+}
+
+
+/*
+CPLD report the PSU0 status
+000 = PSU normal operation
+100 = PSU fault
+010 = PSU unpowered
+111 = PSU not installed
+
+7 6 | 5 4 3 |  2 1 0
+----------------------
+    | psu1  |  psu0
+*/
+static char* psu_str[] = {
+    "normal",           //000
+    "NA",               //001
+    "unpowered",        //010
+    "NA",               //011
+    "fault",            //100
+    "NA",               //101
+    "NA",               //110
+    "not installed",    //111
+};
+
+static ssize_t show_psu_st(struct device *dev, struct device_attribute *da,
+			 char *buf)
+{
+	u32 status;
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psoc_data *data = i2c_get_clientdata(client);
+	u8 byte;
+	int shift = (attr->index == 0)?3:0;
+    
+	mutex_lock(&data->update_lock);
+    status = psoc_i2c_read(client, &byte, PSOC_PSU_OFFSET, 1);
+	mutex_unlock(&data->update_lock);
+	
+    byte = (byte >> shift) & 0x7;
+	
+	status = sprintf (buf, "%d : %s\n", byte, psu_str[byte]);
+	    
+	return strlen(buf);
+}
+
+/*-----------------------------------------------------------------------*/
+
+/* sysfs attributes for hwmon */
+
+static ssize_t show_thermal(struct device *dev, struct device_attribute *da,
+			 char *buf)
+{
+	u16 status;
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psoc_data *data = i2c_get_clientdata(client);
+	u8 offset = attr->index * 2 + THERMAL_OFFSET;
+    
+	mutex_lock(&data->update_lock);
+	
+	status = psoc_read16(client, offset);
+	
+	mutex_unlock(&data->update_lock);
+	
+	return sprintf(buf, "%d\n",
+		       (s8)(status>>8) * 1000  );
+}
+
+
+static ssize_t show_pwm(struct device *dev, struct device_attribute *da,
+			 char *buf)
+{
+	int status;
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psoc_data *data = i2c_get_clientdata(client);
+	u8 offset = attr->index  + PWM_OFFSET;
+    
+	mutex_lock(&data->update_lock);
+	
+	status = psoc_read8(client, offset);
+	
+	mutex_unlock(&data->update_lock);
+	
+	return sprintf(buf, "%d\n",
+		       status);
+}
+
+static ssize_t set_pwm(struct device *dev,
+			   struct device_attribute *devattr,
+			   const char *buf, size_t count)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psoc_data *data = i2c_get_clientdata(client);
+	u8 offset = attr->index  + PWM_OFFSET;
+
+	u8 pwm = simple_strtol(buf, NULL, 10);
+	if(pwm > 255) pwm = 255;
+	
+	if(data->diag) {    
+    	mutex_lock(&data->update_lock);
+    	psoc_i2c_write(client, &pwm, offset, 1);
+    	mutex_unlock(&data->update_lock);
+    }
+	
+	return count;
+}
+
+
+static ssize_t show_rpm(struct device *dev, struct device_attribute *da,
+			 char *buf)
+{
+	int status;
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psoc_data *data = i2c_get_clientdata(client);
+	u8 offset = attr->index*2  + RPM_OFFSET;
+    
+	mutex_lock(&data->update_lock);
+	
+	status = psoc_read16(client, offset);
+	
+	mutex_unlock(&data->update_lock);
+	
+	return sprintf(buf, "%d\n",
+		       status);
+}
+
+static ssize_t show_switch_tmp(struct device *dev, struct device_attribute *da,
+			 char *buf)
+{
+	u16 status;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psoc_data *data = i2c_get_clientdata(client);
+	u16 temp = 0;
+    
+	mutex_lock(&data->update_lock);
+    status = psoc_i2c_read(client, (u8*)&temp, SWITCH_TMP_OFFSET, 2);
+	mutex_unlock(&data->update_lock);
+	
+	status = sprintf (buf, "%d\n",  (s8)(temp>>8) * 1000  );
+	    
+	return strlen(buf);
+}
+
+static ssize_t set_switch_tmp(struct device *dev,
+			   struct device_attribute *devattr,
+			   const char *buf, size_t count)
+{
+	//struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psoc_data *data = i2c_get_clientdata(client);
+
+	long temp = simple_strtol(buf, NULL, 10);
+    u16 temp2 =  ( (temp/1000) <<8 ) & 0xFF00 ;
+    
+    //printk("set_switch_tmp temp=%d, temp2=0x%x (%x,%x)\n", temp, temp2, ( ( (temp/1000) <<8 ) & 0xFF00 ),  (( (temp%1000) / 10 ) & 0xFF));
+    
+	mutex_lock(&data->update_lock);
+	psoc_i2c_write(client, (u8*)&temp2, SWITCH_TMP_OFFSET, 2);
+	mutex_unlock(&data->update_lock);
+	
+	return count;
+}
+
+static ssize_t show_diag(struct device *dev, struct device_attribute *da,
+			 char *buf)
+{
+	u16 status;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psoc_data *data = i2c_get_clientdata(client);
+	u8 diag_flag = 0;
+    
+	mutex_lock(&data->update_lock);
+    status = psoc_i2c_read(client, (u8*)&diag_flag, DIAG_FLAG_OFFSET, 1);
+	mutex_unlock(&data->update_lock);
+	
+	data->diag = (diag_flag & 0x80)?1:0;
+	status = sprintf (buf, "%d\n", data->diag);
+	    
+	return strlen(buf);
+}
+
+static ssize_t set_diag(struct device *dev,
+			   struct device_attribute *devattr,
+			   const char *buf, size_t count)
+{
+	//struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psoc_data *data = i2c_get_clientdata(client);
+	u8 value = 0;
+	u8 diag = simple_strtol(buf, NULL, 10);
+	
+    diag = diag?1:0;
+	data->diag = diag;
+	    
+	mutex_lock(&data->update_lock);
+	psoc_i2c_read(client, (u8*)&value, DIAG_FLAG_OFFSET, 1);
+	if(diag) value |= (1<<7);
+	else     value &= ~(1<<7);
+	psoc_i2c_write(client, (u8*)&value, DIAG_FLAG_OFFSET, 1);
+	mutex_unlock(&data->update_lock);
+	
+	return count;
+}
+
+static ssize_t show_version(struct device *dev, struct device_attribute *da,
+			 char *buf)
+{
+	u16 status;
+	//struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psoc_data *data = i2c_get_clientdata(client);
+    
+	mutex_lock(&data->update_lock);
+	
+	status = psoc_read16(client, VERSION_OFFSET);
+	
+	mutex_unlock(&data->update_lock);
+	
+	return sprintf(buf, "ver: %x.%x\n", (status & 0xFF00)>>8,  (status & 0xFF) );
+}
+
+
+static ssize_t show_fan_led(struct device *dev, struct device_attribute *da,
+			 char *buf)
+{
+	int status;
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psoc_data *data = i2c_get_clientdata(client);
+	u8 bit = attr->index;
+    
+	mutex_lock(&data->update_lock);
+	
+	status = psoc_read8(client, FAN_LED_OFFSET);
+	
+	mutex_unlock(&data->update_lock);
+	
+	return sprintf(buf, "%d\n",
+		       (status & (1<<bit))?1:0 );
+}
+
+static ssize_t set_fan_led(struct device *dev,
+			   struct device_attribute *devattr,
+			   const char *buf, size_t count)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psoc_data *data = i2c_get_clientdata(client);
+	u8 bit = attr->index;
+	u8 led_state = 0;
+
+	u8 v = simple_strtol(buf, NULL, 10);
+	
+	if(data->diag) {    
+    	mutex_lock(&data->update_lock);
+    	led_state = psoc_read8(client, FAN_LED_OFFSET);
+    	if(v) led_state |=  (1<<bit);
+    	else  led_state &= ~(1<<bit);    
+    	psoc_i2c_write(client, &led_state, FAN_LED_OFFSET, 1);
+    	mutex_unlock(&data->update_lock);
+    }
+	
+	return count;
+}
+
+static ssize_t show_value8(struct device *dev, struct device_attribute *da,
+			 char *buf)
+{
+	int status;
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psoc_data *data = i2c_get_clientdata(client);
+	u8 offset = attr->index;
+    
+	mutex_lock(&data->update_lock);
+	
+	status = psoc_read8(client, offset);
+	
+	mutex_unlock(&data->update_lock);
+	
+	return sprintf(buf, "0x%02X\n", status );
+}
+
+static long pmbus_reg2data_linear(int data, int linear16)
+{
+    s16 exponent;
+    s32 mantissa;
+    long val;
+
+    if (linear16) { /* LINEAR16 */
+        exponent = -9;
+        mantissa = (u16) data;
+    } else {  /* LINEAR11 */
+        exponent = ((s16)data) >> 11;
+        exponent = ((s16)( data & 0xF800) ) >> 11;
+        mantissa = ((s32)((data & 0x7ff) << 5)) >> 5;
+    }
+    
+    //printk("data=%d,  m=%d, e=%d\n", data, exponent, mantissa);
+    val = mantissa;
+
+    /* scale result to micro-units for power sensors */
+    val = val * 1000L;
+
+    if (exponent >= 0)
+        val <<= exponent;
+    else
+        val >>= -exponent;
+
+    return val;
+}
+
+static ssize_t show_psu(struct device *dev, struct device_attribute *da,
+			 char *buf)
+{
+	int status;
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psoc_data *data = i2c_get_clientdata(client);
+	u8 reg =  attr->index & 0xFF;
+	u8 chip = (attr->index >> 16)? 0x59:0x58;
+	u8 bus  = 1;
+	unsigned char value[2] = {0,0};;    
+    
+	mutex_lock(&data->update_lock);
+	psoc_i2c_bridge_read(client, bus, chip, &reg, 1, value, 2);
+	mutex_unlock(&data->update_lock);
+	
+	status =  value[1]<<8 | value[0];
+	//status1 =  value[1]<<8 | value[0];
+	
+	return sprintf(buf, "%ld\n", pmbus_reg2data_linear(status, (reg==PMBUS_READ_VOUT)?1:0) );
+}
+
+static ssize_t show_psu_psoc(struct device *dev, struct device_attribute *da,
+			 char *buf)
+{
+	u16 status;
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct psoc_data *data = i2c_get_clientdata(client);
+	u8 offset = attr->index + PSU_INFO_OFFSET;
+    
+	mutex_lock(&data->update_lock);
+	status = psoc_read16(client, offset);
+	mutex_unlock(&data->update_lock);
+	
+	return sprintf(buf, "%ld \n", pmbus_reg2data_linear(status, strstr(attr->dev_attr.attr.name, "vout")? 1:0 ));
+}
+
+
+
+static SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO,			show_thermal, 0, 0);
+static SENSOR_DEVICE_ATTR(temp2_input, S_IRUGO,			show_thermal, 0, 1);
+static SENSOR_DEVICE_ATTR(temp3_input, S_IRUGO,			show_thermal, 0, 2);
+static SENSOR_DEVICE_ATTR(temp4_input, S_IRUGO,			show_thermal, 0, 3);
+static SENSOR_DEVICE_ATTR(temp5_input, S_IRUGO,			show_thermal, 0, 4);
+static SENSOR_DEVICE_ATTR(thermal_psu1, S_IRUGO,		show_thermal, 0, 5);
+static SENSOR_DEVICE_ATTR(thermal_psu2, S_IRUGO,		show_thermal, 0, 6);
+
+static SENSOR_DEVICE_ATTR(pwm1, S_IWUSR|S_IRUGO,			show_pwm, set_pwm, 0);
+static SENSOR_DEVICE_ATTR(pwm2, S_IWUSR|S_IRUGO,			show_pwm, set_pwm, 1);
+static SENSOR_DEVICE_ATTR(pwm3, S_IWUSR|S_IRUGO,			show_pwm, set_pwm, 2);
+static SENSOR_DEVICE_ATTR(pwm4, S_IWUSR|S_IRUGO,			show_pwm, set_pwm, 3);
+static SENSOR_DEVICE_ATTR(pwm_psu1, S_IWUSR|S_IRUGO,		show_pwm, set_pwm, 4);
+static SENSOR_DEVICE_ATTR(pwm_psu2, S_IWUSR|S_IRUGO,		show_pwm, set_pwm, 5);
+
+static SENSOR_DEVICE_ATTR(psu0,  S_IRUGO,			        show_psu_st, 0, 0);
+static SENSOR_DEVICE_ATTR(psu1,  S_IRUGO,			        show_psu_st, 0, 1);
+
+static SENSOR_DEVICE_ATTR(fan1_input, S_IRUGO,			show_rpm, 0, 0);
+static SENSOR_DEVICE_ATTR(fan2_input, S_IRUGO,			show_rpm, 0, 1);
+static SENSOR_DEVICE_ATTR(fan3_input, S_IRUGO,			show_rpm, 0, 2);
+static SENSOR_DEVICE_ATTR(fan4_input, S_IRUGO,			show_rpm, 0, 3);
+static SENSOR_DEVICE_ATTR(fan5_input, S_IRUGO,			show_rpm, 0, 4);
+static SENSOR_DEVICE_ATTR(fan6_input, S_IRUGO,			show_rpm, 0, 5);
+static SENSOR_DEVICE_ATTR(fan7_input, S_IRUGO,			show_rpm, 0, 6);
+static SENSOR_DEVICE_ATTR(fan8_input, S_IRUGO,			show_rpm, 0, 7);
+static SENSOR_DEVICE_ATTR(rpm_psu1, S_IRUGO,		show_rpm, 0, 8);
+static SENSOR_DEVICE_ATTR(rpm_psu2, S_IRUGO,		show_rpm, 0, 9);
+
+static SENSOR_DEVICE_ATTR(switch_tmp, S_IWUSR|S_IRUGO,			show_switch_tmp, set_switch_tmp, 0);
+
+static SENSOR_DEVICE_ATTR(diag, S_IWUSR|S_IRUGO,			show_diag, set_diag, 0);
+static SENSOR_DEVICE_ATTR(version, S_IRUGO,			show_version, 0, 0);
+
+static SENSOR_DEVICE_ATTR(fan_led_grn1, S_IWUSR|S_IRUGO,			show_fan_led, set_fan_led, 0);
+static SENSOR_DEVICE_ATTR(fan_led_grn2, S_IWUSR|S_IRUGO,			show_fan_led, set_fan_led, 1);
+static SENSOR_DEVICE_ATTR(fan_led_grn3, S_IWUSR|S_IRUGO,			show_fan_led, set_fan_led, 2);
+static SENSOR_DEVICE_ATTR(fan_led_grn4, S_IWUSR|S_IRUGO,			show_fan_led, set_fan_led, 3);
+static SENSOR_DEVICE_ATTR(fan_led_red1, S_IWUSR|S_IRUGO,			show_fan_led, set_fan_led, 4);
+static SENSOR_DEVICE_ATTR(fan_led_red2, S_IWUSR|S_IRUGO,			show_fan_led, set_fan_led, 5);
+static SENSOR_DEVICE_ATTR(fan_led_red3, S_IWUSR|S_IRUGO,			show_fan_led, set_fan_led, 6);
+static SENSOR_DEVICE_ATTR(fan_led_red4, S_IWUSR|S_IRUGO,			show_fan_led, set_fan_led, 7);
+
+static SENSOR_DEVICE_ATTR(fan_gpi,      S_IRUGO,			        show_value8,  0,           FAN_GPI_OFFSET);
+
+static SENSOR_DEVICE_ATTR(psu1_vin,      S_IRUGO,			        show_psu,  0,           PMBUS_READ_VIN);
+static SENSOR_DEVICE_ATTR(psu1_vout,     S_IRUGO,			        show_psu,  0,           PMBUS_READ_VOUT);
+static SENSOR_DEVICE_ATTR(psu1_iin,      S_IRUGO,			        show_psu,  0,           PMBUS_READ_IIN);
+static SENSOR_DEVICE_ATTR(psu1_iout,     S_IRUGO,			        show_psu,  0,           PMBUS_READ_IOUT);
+static SENSOR_DEVICE_ATTR(psu1_pin,      S_IRUGO,			        show_psu,  0,           PMBUS_READ_PIN);
+static SENSOR_DEVICE_ATTR(psu1_pout,     S_IRUGO,			        show_psu,  0,           PMBUS_READ_POUT);
+
+
+static SENSOR_DEVICE_ATTR(psu2_vin,      S_IRUGO,			        show_psu,  0,           (1<<16) | PMBUS_READ_VIN);
+static SENSOR_DEVICE_ATTR(psu2_vout,     S_IRUGO,			        show_psu,  0,           (1<<16) | PMBUS_READ_VOUT);
+static SENSOR_DEVICE_ATTR(psu2_iin,      S_IRUGO,			        show_psu,  0,           (1<<16) | PMBUS_READ_IIN);
+static SENSOR_DEVICE_ATTR(psu2_iout,     S_IRUGO,			        show_psu,  0,           (1<<16) | PMBUS_READ_IOUT);
+static SENSOR_DEVICE_ATTR(psu2_pin,      S_IRUGO,			        show_psu,  0,           (1<<16) | PMBUS_READ_PIN);
+static SENSOR_DEVICE_ATTR(psu2_pout,     S_IRUGO,			        show_psu,  0,           (1<<16) | PMBUS_READ_POUT);
+
+
+static SENSOR_DEVICE_ATTR(psoc_psu1_vin,      S_IRUGO,			        show_psu_psoc,  0,           PSOC_PSU_OFF(psu1_vin));
+static SENSOR_DEVICE_ATTR(psoc_psu1_vout,     S_IRUGO,			        show_psu_psoc,  0,           PSOC_PSU_OFF(psu1_vout));
+static SENSOR_DEVICE_ATTR(psoc_psu1_iin,      S_IRUGO,			        show_psu_psoc,  0,           PSOC_PSU_OFF(psu1_iin));
+static SENSOR_DEVICE_ATTR(psoc_psu1_iout,     S_IRUGO,			        show_psu_psoc,  0,           PSOC_PSU_OFF(psu1_iout));
+static SENSOR_DEVICE_ATTR(psoc_psu1_pin,      S_IRUGO,			        show_psu_psoc,  0,           PSOC_PSU_OFF(psu1_pin));
+static SENSOR_DEVICE_ATTR(psoc_psu1_pout,     S_IRUGO,			        show_psu_psoc,  0,           PSOC_PSU_OFF(psu1_pout));
+
+
+static SENSOR_DEVICE_ATTR(psoc_psu2_vin,      S_IRUGO,			        show_psu_psoc,  0,           PSOC_PSU_OFF(psu2_vin)); 
+static SENSOR_DEVICE_ATTR(psoc_psu2_vout,     S_IRUGO,			        show_psu_psoc,  0,           PSOC_PSU_OFF(psu2_vout));
+static SENSOR_DEVICE_ATTR(psoc_psu2_iin,      S_IRUGO,			        show_psu_psoc,  0,           PSOC_PSU_OFF(psu2_iin)); 
+static SENSOR_DEVICE_ATTR(psoc_psu2_iout,     S_IRUGO,			        show_psu_psoc,  0,           PSOC_PSU_OFF(psu2_iout));
+static SENSOR_DEVICE_ATTR(psoc_psu2_pin,      S_IRUGO,			        show_psu_psoc,  0,           PSOC_PSU_OFF(psu2_pin)); 
+static SENSOR_DEVICE_ATTR(psoc_psu2_pout,     S_IRUGO,			        show_psu_psoc,  0,           PSOC_PSU_OFF(psu2_pout));
+			
+static struct attribute *psoc_attributes[] = {
+    //thermal
+	&sensor_dev_attr_temp1_input.dev_attr.attr,
+	&sensor_dev_attr_temp2_input.dev_attr.attr,
+	&sensor_dev_attr_temp3_input.dev_attr.attr,
+	&sensor_dev_attr_temp4_input.dev_attr.attr,
+	&sensor_dev_attr_temp5_input.dev_attr.attr,
+	
+	&sensor_dev_attr_thermal_psu1.dev_attr.attr,
+	&sensor_dev_attr_thermal_psu2.dev_attr.attr,
+
+
+    //pwm
+	&sensor_dev_attr_pwm1.dev_attr.attr,
+	&sensor_dev_attr_pwm2.dev_attr.attr,
+	&sensor_dev_attr_pwm3.dev_attr.attr,
+	&sensor_dev_attr_pwm4.dev_attr.attr,
+	&sensor_dev_attr_pwm_psu1.dev_attr.attr,
+	&sensor_dev_attr_pwm_psu2.dev_attr.attr,
+	
+	//rpm
+	&sensor_dev_attr_fan1_input.dev_attr.attr,
+	&sensor_dev_attr_fan2_input.dev_attr.attr,
+	&sensor_dev_attr_fan3_input.dev_attr.attr,
+	&sensor_dev_attr_fan4_input.dev_attr.attr,
+	&sensor_dev_attr_fan5_input.dev_attr.attr,
+	&sensor_dev_attr_fan6_input.dev_attr.attr,
+	&sensor_dev_attr_fan7_input.dev_attr.attr,
+	&sensor_dev_attr_fan8_input.dev_attr.attr,
+	
+	&sensor_dev_attr_rpm_psu1.dev_attr.attr,
+	&sensor_dev_attr_rpm_psu2.dev_attr.attr,
+    
+    //switch temperature
+	&sensor_dev_attr_switch_tmp.dev_attr.attr,
+
+    //diag flag
+	&sensor_dev_attr_diag.dev_attr.attr,
+	
+	//version
+	&sensor_dev_attr_version.dev_attr.attr,
+	
+	//fan led 
+	&sensor_dev_attr_fan_led_grn1.dev_attr.attr,
+	&sensor_dev_attr_fan_led_grn2.dev_attr.attr,
+	&sensor_dev_attr_fan_led_grn3.dev_attr.attr,
+	&sensor_dev_attr_fan_led_grn4.dev_attr.attr,
+	&sensor_dev_attr_fan_led_red1.dev_attr.attr,
+	&sensor_dev_attr_fan_led_red2.dev_attr.attr,
+	&sensor_dev_attr_fan_led_red3.dev_attr.attr,
+	&sensor_dev_attr_fan_led_red4.dev_attr.attr,
+
+	//fan GPI 
+	&sensor_dev_attr_fan_gpi.dev_attr.attr,
+	
+	//psu
+	&sensor_dev_attr_psu1_vin.dev_attr.attr,
+	&sensor_dev_attr_psu1_vout.dev_attr.attr,
+	&sensor_dev_attr_psu1_iin.dev_attr.attr,
+	&sensor_dev_attr_psu1_iout.dev_attr.attr,
+	&sensor_dev_attr_psu1_pin.dev_attr.attr,
+	&sensor_dev_attr_psu1_pout.dev_attr.attr,
+	&sensor_dev_attr_psu2_vin.dev_attr.attr,
+	&sensor_dev_attr_psu2_vout.dev_attr.attr,
+	&sensor_dev_attr_psu2_iin.dev_attr.attr,
+	&sensor_dev_attr_psu2_iout.dev_attr.attr,
+	&sensor_dev_attr_psu2_pin.dev_attr.attr,
+	&sensor_dev_attr_psu2_pout.dev_attr.attr,
+
+	&sensor_dev_attr_psu0.dev_attr.attr,
+	&sensor_dev_attr_psu1.dev_attr.attr,
+
+
+	//psu_psoc, new added on psoc 1.9
+	&sensor_dev_attr_psoc_psu1_vin.dev_attr.attr,
+	&sensor_dev_attr_psoc_psu1_vout.dev_attr.attr,
+	&sensor_dev_attr_psoc_psu1_iin.dev_attr.attr,
+	&sensor_dev_attr_psoc_psu1_iout.dev_attr.attr,
+	&sensor_dev_attr_psoc_psu1_pin.dev_attr.attr,
+	&sensor_dev_attr_psoc_psu1_pout.dev_attr.attr,
+	&sensor_dev_attr_psoc_psu2_vin.dev_attr.attr,
+	&sensor_dev_attr_psoc_psu2_vout.dev_attr.attr,
+	&sensor_dev_attr_psoc_psu2_iin.dev_attr.attr,
+	&sensor_dev_attr_psoc_psu2_iout.dev_attr.attr,
+	&sensor_dev_attr_psoc_psu2_pin.dev_attr.attr,
+	&sensor_dev_attr_psoc_psu2_pout.dev_attr.attr,
+
+	NULL
+};
+
+static const struct attribute_group psoc_group = {
+	.attrs = psoc_attributes,
+};
+
+/*-----------------------------------------------------------------------*/
+
+/* device probe and removal */
+
+static int
+psoc_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct psoc_data *data;
+	int status;
+
+    printk("+%s\n", __func__);
+    
+	if (!i2c_check_functionality(client->adapter,
+			I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA))
+		return -EIO;
+
+	data = kzalloc(sizeof(struct psoc_data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	i2c_set_clientdata(client, data);
+	mutex_init(&data->update_lock);
+	data->diag    = 0;
+	
+	/* Register sysfs hooks */
+	status = sysfs_create_group(&client->dev.kobj, &psoc_group);
+	if (status)
+		goto exit_free;
+
+	data->hwmon_dev = hwmon_device_register(&client->dev);
+	if (IS_ERR(data->hwmon_dev)) {
+		status = PTR_ERR(data->hwmon_dev);
+		goto exit_remove;
+	}
+
+	dev_info(&client->dev, "%s: sensor '%s'\n",
+		 dev_name(data->hwmon_dev), client->name);
+
+	return 0;
+
+exit_remove:
+	sysfs_remove_group(&client->dev.kobj, &psoc_group);
+exit_free:
+	i2c_set_clientdata(client, NULL);
+	kfree(data);
+	return status;
+}
+
+static int psoc_remove(struct i2c_client *client)
+{
+	struct psoc_data *data = i2c_get_clientdata(client);
+
+	hwmon_device_unregister(data->hwmon_dev);
+	sysfs_remove_group(&client->dev.kobj, &psoc_group);
+	i2c_set_clientdata(client, NULL);
+	kfree(data);
+	return 0;
+}
+
+static const struct i2c_device_id psoc_ids[] = {
+	{ "inv_psoc", 0, },
+	{ /* LIST END */ }
+};
+MODULE_DEVICE_TABLE(i2c, psoc_ids);
+
+static struct i2c_driver psoc_driver = {
+	.class		= I2C_CLASS_HWMON,
+	.driver = {
+		.name	= "inv_psoc",
+	},
+	.probe		= psoc_probe,
+	.remove		= psoc_remove,
+	.id_table	= psoc_ids,
+};
+
+/*-----------------------------------------------------------------------*/
+
+/* module glue */
+
+static int __init inv_psoc_init(void)
+{
+	return i2c_add_driver(&psoc_driver);
+}
+
+static void __exit inv_psoc_exit(void)
+{
+	i2c_del_driver(&psoc_driver);
+}
+
+MODULE_AUTHOR("eddie.lan <eddie.lan@inventec>");
+MODULE_DESCRIPTION("inv psoc driver");
+MODULE_LICENSE("GPL");
+
+module_init(inv_psoc_init);
+module_exit(inv_psoc_exit);
