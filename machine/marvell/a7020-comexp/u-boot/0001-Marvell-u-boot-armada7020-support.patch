From 5d353eff37791f083a26d29cbe155f06b95cacef Mon Sep 17 00:00:00 2001
From: Gil Tabibian <gilt@marvell.com>
Date: Tue, 27 Aug 2019 22:04:31 +0530
Subject: [PATCH] Marvell u-boot armada7020 support

Signed-off-by: Gil Tabibian <gilt@marvell.com>
---
 MAINTAINERS                                        |   16 +
 Makefile                                           |    9 +-
 README                                             |    7 +
 arch/arm/Kconfig                                   |   26 +-
 arch/arm/Makefile                                  |    4 +
 arch/arm/cpu/armv8/cache_v8.c                      |   39 +-
 arch/arm/dts/Makefile                              |   39 +-
 arch/arm/dts/armada-3720-db.dts                    |   87 +-
 arch/arm/dts/armada-3720-ddr3-db-v1-A.dts          |   43 +
 arch/arm/dts/armada-3720-ddr3-db-v1-B.dts          |   55 +
 arch/arm/dts/armada-3720-ddr3-db-v1-C.dts          |   62 +
 arch/arm/dts/armada-3720-ddr3-db-v2-B.dts          |   55 +
 arch/arm/dts/armada-3720-ddr3-db-v2-C.dts          |   62 +
 arch/arm/dts/armada-3720-ddr4-db-v1-A.dts          |   47 +
 arch/arm/dts/armada-3720-ddr4-db-v1-B.dts          |   56 +
 arch/arm/dts/armada-3720-ddr4-db-v3-A.dts          |   33 +
 arch/arm/dts/armada-3720-ddr4-db-v3-B.dts          |   56 +
 arch/arm/dts/armada-3720-ddr4-db-v3-C.dts          |   63 +
 arch/arm/dts/armada-3720-espressobin-emmc.dts      |   19 +
 arch/arm/dts/armada-3720-espressobin.dts           |  125 +-
 arch/arm/dts/armada-375-db.dts                     |    2 +
 arch/arm/dts/armada-37xx.dtsi                      |   56 +-
 arch/arm/dts/armada-388-gp.dts                     |    6 +
 arch/arm/dts/armada-38x.dtsi                       |    8 +
 arch/arm/dts/armada-3900-db.dtsi                   |  235 +
 arch/arm/dts/armada-3900-vd-A.dts                  |  107 +
 arch/arm/dts/armada-3900-vd-B.dts                  |  108 +
 arch/arm/dts/armada-3900.dtsi                      |   67 +
 arch/arm/dts/armada-7020-amc.dts                   |  212 +
 arch/arm/dts/armada-7020-comexp.dts                |  199 +
 arch/arm/dts/armada-7040-db-B.dts                  |  221 +
 arch/arm/dts/armada-7040-db-C.dts                  |  222 +
 arch/arm/dts/armada-7040-db-D.dts                  |  201 +
 arch/arm/dts/armada-7040-db-E.dts                  |  233 +
 arch/arm/dts/armada-7040-db-nand.dts               |  223 -
 arch/arm/dts/armada-7040-db.dts                    |  111 +-
 arch/arm/dts/armada-7040-dev-info.dtsi             |   73 +
 arch/arm/dts/armada-7040-pcac.dts                  |  222 +
 arch/arm/dts/armada-7040.dtsi                      |   56 -
 arch/arm/dts/armada-70x0-db.dtsi                   |   90 +
 arch/arm/dts/armada-70x0.dtsi                      |   69 +
 arch/arm/dts/armada-8020.dtsi                      |   74 +-
 arch/arm/dts/armada-8040-db-B.dts                  |  339 +
 arch/arm/dts/armada-8040-db-C.dts                  |  334 +
 arch/arm/dts/armada-8040-db-D.dts                  |  316 +
 arch/arm/dts/armada-8040-db-E.dts                  |  331 +
 arch/arm/dts/armada-8040-db-F.dts                  |  395 +
 arch/arm/dts/armada-8040-db-G.dts                  |  344 +
 arch/arm/dts/armada-8040-db-H.dts                  |  351 +
 arch/arm/dts/armada-8040-db.dts                    |  170 +-
 arch/arm/dts/armada-8040-dev-info.dtsi             |   64 +
 arch/arm/dts/armada-8040-mcbin-single-shot.dts     |   28 +
 arch/arm/dts/armada-8040-mcbin.dts                 |  207 +-
 arch/arm/dts/armada-8040-ocp.dts                   |  318 +
 arch/arm/dts/armada-8040-ucpe.dts                  |  383 +
 arch/arm/dts/armada-8040.dtsi                      |   90 +-
 arch/arm/dts/armada-80x0-db.dtsi                   |  143 +
 arch/arm/dts/armada-8k.dtsi                        |   21 +
 arch/arm/dts/armada-ap806-quad.dtsi                |   82 -
 arch/arm/dts/armada-ap806.dtsi                     |  224 +-
 arch/arm/dts/armada-ap807.dtsi                     |   42 +
 arch/arm/dts/armada-ap80x-quad.dtsi                |   45 +
 arch/arm/dts/armada-ap80x.dtsi                     |  133 +
 arch/arm/dts/armada-common.dtsi                    |   30 +
 arch/arm/dts/armada-cp110-master.dtsi              |  369 -
 arch/arm/dts/armada-cp110-slave.dtsi               |  342 -
 arch/arm/dts/armada-cp110.dtsi                     |  329 +
 arch/arm/dts/cn9130-crb-A.dts                      |   57 +
 arch/arm/dts/cn9130-crb-B.dts                      |   61 +
 arch/arm/dts/cn9130-crb.dtsi                       |  229 +
 arch/arm/dts/cn9130-db-A.dts                       |  222 +
 arch/arm/dts/cn9130-db-B.dts                       |  234 +
 arch/arm/dts/cn9130-db-dev-info.dtsi               |   44 +
 arch/arm/dts/cn9130-db.dtsi                        |  133 +
 arch/arm/dts/cn9130.dtsi                           |   87 +
 arch/arm/dts/cn9131-db-A.dts                       |   56 +
 arch/arm/dts/cn9131-db-B.dts                       |   71 +
 arch/arm/dts/cn9131-db.dtsi                        |  178 +
 arch/arm/dts/cn9132-db-A.dts                       |  109 +
 arch/arm/dts/cn9132-db-B.dts                       |  109 +
 arch/arm/dts/cn9132-db.dtsi                        |  134 +
 arch/arm/dts/thunderx-88xx.dts                     |   31 -
 arch/arm/dts/thunderx-88xx.dtsi                    |  363 -
 arch/arm/include/asm/arch-armada8k/cache_llc.h     |    5 +
 arch/arm/include/asm/arch-mvebu/thermal.h          |   34 +
 arch/arm/include/asm/arch-octeontx/atf.h           |   14 +
 arch/arm/include/asm/arch-octeontx/atf_part.h      |   27 +
 .../include/asm/arch-octeontx/cavm-csrs-mio_emm.h  | 1165 +++
 arch/arm/include/asm/arch-octeontx/clock.h         |  230 +
 arch/arm/include/asm/arch-octeontx/fdt-helper.h    |   37 +
 arch/arm/include/asm/arch-octeontx/octeontx.h      |   40 +
 arch/arm/include/asm/arch-octeontx/octeontx_fdt.h  |   12 +
 arch/arm/include/asm/arch-octeontx/octeontx_mmc.h  |  211 +
 arch/arm/include/asm/arch-octeontx/octeontx_smi.h  |   14 +
 arch/arm/include/asm/arch-octeontx/octeontx_svc.h  |   27 +
 arch/arm/include/asm/arch-octeontx/octeontx_vnic.h |   22 +
 arch/arm/include/asm/arch-octeontx/octeontx_xcv.h  |  256 +
 arch/arm/include/asm/arch-octeontx2/atf.h          |   20 +
 arch/arm/include/asm/arch-octeontx2/cavium_mmc.h   | 1815 ++++
 .../include/asm/arch-octeontx2/cavm-csrs-mio_emm.h |    1 +
 arch/arm/include/asm/arch-octeontx2/clock.h        |  231 +
 arch/arm/include/asm/arch-octeontx2/fdt-helper.h   |   38 +
 arch/arm/include/asm/arch-octeontx2/octeontx2.h    |   66 +
 .../arm/include/asm/arch-octeontx2/octeontx2_fdt.h |   13 +
 .../arm/include/asm/arch-octeontx2/octeontx2_svc.h |   37 +
 arch/arm/include/asm/arch-octeontx2/octeontx_mmc.h |    1 +
 arch/arm/include/asm/gpio.h                        |    2 +-
 arch/arm/include/asm/io.h                          |    9 +
 arch/arm/include/asm/system.h                      |   35 +
 arch/arm/lib/interrupts_64.c                       |   10 +
 arch/arm/mach-mvebu/Kconfig                        |   31 +-
 arch/arm/mach-mvebu/Makefile                       |    2 -
 arch/arm/mach-mvebu/arm64-common.c                 |   51 +-
 arch/arm/mach-mvebu/armada3700/Makefile            |    1 +
 arch/arm/mach-mvebu/armada3700/clock.c             |  244 +
 arch/arm/mach-mvebu/armada3700/cpu.c               |   88 +-
 arch/arm/mach-mvebu/armada8k/Makefile              |    2 +
 arch/arm/mach-mvebu/armada8k/clock.c               |   53 +
 arch/arm/mach-mvebu/armada8k/cpu.c                 |  143 +-
 arch/arm/mach-mvebu/armada8k/soc.c                 |  314 +
 arch/arm/mach-mvebu/cpu.c                          |   53 +-
 arch/arm/mach-mvebu/efuse.c                        |  264 -
 arch/arm/mach-mvebu/include/mach/clock.h           |   23 +
 arch/arm/mach-mvebu/include/mach/cpu.h             |    3 +-
 arch/arm/mach-mvebu/include/mach/efuse.h           |   69 -
 arch/arm/mach-mvebu/include/mach/fw_info.h         |   19 +
 arch/arm/mach-mvebu/include/mach/soc.h             |   31 +
 arch/arm/mach-mvebu/sata.c                         |   54 -
 arch/arm/mach-mvebu/serdes/a38x/sys_env_lib.c      |   24 +
 arch/arm/mach-octeontx/Kconfig                     |   19 +
 arch/arm/mach-octeontx/Makefile                    |    9 +
 arch/arm/mach-octeontx/clock.c                     |   34 +
 arch/arm/mach-octeontx/cpu.c                       |   54 +
 arch/arm/mach-octeontx/fdt-helper.c                |   72 +
 arch/arm/mach-octeontx/lowlevel_init.S             |   36 +
 arch/arm/mach-octeontx2/Kconfig                    |   29 +
 arch/arm/mach-octeontx2/Makefile                   |    9 +
 arch/arm/mach-octeontx2/clock.c                    |   34 +
 arch/arm/mach-octeontx2/config.mk                  |    4 +
 arch/arm/mach-octeontx2/cpu.c                      |   60 +
 arch/arm/mach-octeontx2/fdt-helper.c               |   72 +
 arch/arm/mach-octeontx2/lowlevel_init.S            |   34 +
 board/Marvell/common/Kconfig                       |   22 +
 board/Marvell/common/Makefile                      |    9 +
 board/Marvell/common/cfg_eeprom.c                  |  386 +
 board/Marvell/common/sar.c                         |  516 ++
 board/Marvell/mvebu_armada-37xx/board.c            |  103 +-
 board/Marvell/mvebu_armada-8k/board.c              |  158 +-
 board/Marvell/octeontx/Kconfig                     |   18 +
 board/Marvell/octeontx/MAINTAINERS                 |    5 +
 board/Marvell/octeontx/Makefile                    |    9 +
 board/Marvell/octeontx/atf.c                       |   42 +
 board/Marvell/octeontx/fdt.c                       |  208 +
 board/Marvell/octeontx/octeontx.c                  |  272 +
 board/Marvell/octeontx2/Kconfig                    |   17 +
 board/Marvell/octeontx2/MAINTAINERS                |    6 +
 board/Marvell/octeontx2/Makefile                   |    9 +
 board/Marvell/octeontx2/atf.c                      |  119 +
 board/Marvell/octeontx2/fdt.c                      |   69 +
 board/Marvell/octeontx2/octeontx2.c                |  387 +
 board/Marvell/octeontx2_cn913x/MAINTAINERS         |    4 +
 board/Marvell/octeontx2_cn913x/Makefile            |    8 +
 board/Marvell/octeontx2_cn913x/board.c             |   67 +
 board/cavium/thunderx/Kconfig                      |   27 -
 board/cavium/thunderx/MAINTAINERS                  |    6 -
 board/cavium/thunderx/Makefile                     |    8 -
 board/cavium/thunderx/atf.c                        |  312 -
 board/cavium/thunderx/thunderx.c                   |  129 -
 board/raspberrypi/rpi/rpi.c                        |   10 +
 cmd/Kconfig                                        |   24 +
 cmd/Makefile                                       |    7 +-
 cmd/bootimgup.c                                    |  549 ++
 cmd/bootm.c                                        |    1 +
 cmd/elf.c                                          |  109 +-
 cmd/fdt.c                                          |    3 +-
 cmd/marvell/Kconfig                                |   26 +
 cmd/marvell/Makefile                               |   10 +
 cmd/marvell/eth_cmds.c                             |  120 +
 cmd/marvell/mdio_dbg.c                             |   83 +
 cmd/marvell/octeontx2_cmds.c                       |   22 +
 cmd/mem.c                                          |   95 +
 cmd/mii.c                                          |   20 +
 cmd/mmc.c                                          |    4 +-
 cmd/mtdparts.c                                     |    2 +-
 cmd/mvebu/Kconfig                                  |  119 +-
 cmd/mvebu/Makefile                                 |   10 +
 cmd/mvebu/avs.c                                    |  102 +
 cmd/mvebu/bubt.c                                   |   89 +-
 cmd/mvebu/hw_info.c                                |  297 +
 cmd/mvebu/map.c                                    |  254 +
 cmd/mvebu/mv_fw_info.c                             |   78 +
 cmd/mvebu/mv_get_counters.c                        |  184 +
 cmd/mvebu/pxa3xx_nand_oem.c                        |  587 ++
 cmd/mvebu/rx_training.c                            |   57 +
 cmd/mvebu/sar.c                                    |  108 +
 cmd/mvebu/thermal.c                                |   47 +
 cmd/nvedit.c                                       |   14 +
 cmd/nvme.c                                         |    1 -
 cmd/scsi.c                                         |   16 +
 common/Kconfig                                     |    7 +
 common/board_f.c                                   |    6 +-
 common/board_r.c                                   |   18 +-
 common/bootm.c                                     |    2 +-
 common/ddr_spd.c                                   |   34 +
 common/fdt_support.c                               |    2 +
 common/spl/Kconfig                                 |   12 +-
 common/usb_hub.c                                   |    3 +-
 configs/chromebook_link64_defconfig                |    2 +-
 configs/clearfog_defconfig                         |    2 +-
 configs/controlcenterdc_defconfig                  |    3 +
 configs/db-88f6720_defconfig                       |    2 +-
 configs/db-88f6820-amc_defconfig                   |    3 +-
 configs/db-88f6820-gp_defconfig                    |   19 +-
 configs/db-mv784mp-gp_defconfig                    |    2 +-
 configs/ds414_defconfig                            |    1 +
 configs/mvebu_db-88f3720_defconfig                 |   19 +-
 configs/mvebu_db_armada8k_defconfig                | 1201 ++-
 configs/mvebu_db_cn91xx_defconfig                  |   95 +
 configs/mvebu_espressobin-88f3720_defconfig        |   22 +-
 configs/mvebu_mcbin-88f8040_defconfig              |   19 +-
 configs/mvebu_ocp-88f8040_defconfig                |   70 +
 configs/mvebu_ucpe-88f8040_defconfig               |  104 +
 configs/octeontx2_95xx_defconfig                   |   96 +
 configs/octeontx2_96xx_defconfig                   |  126 +
 configs/octeontx2_98xx_defconfig                   |  121 +
 configs/octeontx2_loki_defconfig                   |   94 +
 configs/octeontx_81xx_defconfig                    |  127 +
 configs/octeontx_83xx_defconfig                    |  124 +
 configs/qemu-x86_64_defconfig                      |    2 +-
 configs/theadorable_debug_defconfig                |    2 +
 configs/thunderx_88xx_defconfig                    |   29 -
 configs/turris_omnia_defconfig                     |    3 +-
 doc/device-tree-bindings/mdio/marvell-mdio.txt     |   18 +
 doc/device-tree-bindings/mdio/mdio-bus.txt         |   54 +
 doc/device-tree-bindings/mmc/xenon-mmc.txt         |   46 +
 doc/device-tree-bindings/net/ethernet.txt          |    4 +-
 doc/device-tree-bindings/phy/mvebu_comphy.txt      |   69 +
 .../pinctrl/marvell,armada-37xx-pinctrl.txt        |  186 +
 .../pinctrl/marvell,mvebu-pinctrl.txt              |   16 +-
 doc/device-tree-bindings/regulator/regulator.txt   |    1 +
 doc/device-tree-bindings/rtc/marvell-rtc.txt       |   23 +
 doc/device-tree-bindings/spi/mvebu-spi.txt         |   73 +
 doc/device-tree-bindings/thermal/mvebu-thermal.txt |   63 +
 doc/device-tree-bindings/usb/marvell.ehci-usb.txt  |   22 +
 doc/device-tree-bindings/usb/marvell.xhci-usb.txt  |    3 +
 doc/mvebu/a3700/armada-3700-db-setup.txt           |   76 +
 doc/mvebu/a7k-a8k/armada3900-db-setup.txt          |  128 +
 doc/mvebu/a7k-a8k/armada70x0-db-setup.txt          |  229 +
 doc/mvebu/a7k-a8k/armada80x0-db-setup.txt          |  307 +
 doc/mvebu/build.txt                                |  210 +
 doc/mvebu/linux_boot.txt                           |   43 +
 doc/mvebu/porting_guide.txt                        |  128 +
 doc/mvebu/trusted_boot.txt                         |  530 ++
 doc/mvebu/uart_boot.txt                            |  117 +
 doc/mvebu/uboot_cmd.txt                            |  366 +
 drivers/Kconfig                                    |    4 +
 drivers/Makefile                                   |   12 +-
 drivers/ata/Kconfig                                |    9 +
 drivers/ata/Makefile                               |    1 +
 drivers/ata/ahci-pci.c                             |   13 +-
 drivers/ata/ahci.c                                 |  134 +-
 drivers/ata/ahci_mvebu.c                           |   59 +
 drivers/ata/dwc_ahsata.c                           |  275 +
 drivers/block/Kconfig                              |    7 +
 drivers/block/blk-uclass.c                         |    1 -
 drivers/core/device.c                              |    8 +
 drivers/core/ofnode.c                              |   36 +
 drivers/ddr/marvell/a38x/ddr3_init.c               |   24 -
 drivers/fuse/Kconfig                               |   24 +
 drivers/fuse/Makefile                              |    4 +
 drivers/fuse/fuse-mvebu-hd.c                       |  111 +
 drivers/fuse/fuse-mvebu-init.c                     |   33 +
 drivers/fuse/fuse-mvebu-ld.c                       |  111 +
 drivers/fuse/fuse-mvebu.c                          |  268 +
 drivers/gpio/Kconfig                               |   19 +
 drivers/gpio/Makefile                              |    2 +
 drivers/gpio/i2c_gpio.c                            |  236 +
 drivers/gpio/octeontx_gpio.c                       |  220 +
 drivers/gpio/pca953x_gpio.c                        |    4 +-
 drivers/i2c/Kconfig                                |    7 +
 drivers/i2c/Makefile                               |    2 +
 drivers/i2c/i2c-uclass.c                           |    3 +
 drivers/i2c/mv_i2c.c                               |   29 +-
 drivers/i2c/mvtwsi.c                               |    6 +-
 drivers/i2c/octeontx_i2c.c                         |  962 ++
 drivers/mdio/Kconfig                               |   23 +
 drivers/mdio/Makefile                              |    7 +
 drivers/mdio/mdio-uclass.c                         |  119 +
 drivers/mdio/mvmdio.c                              |  237 +
 drivers/misc/Makefile                              |    1 +
 drivers/misc/mvebu_sar/Makefile                    |   13 +
 drivers/misc/mvebu_sar/ap806_sar.c                 |  249 +
 drivers/misc/mvebu_sar/ap807_sar.c                 |  230 +
 drivers/misc/mvebu_sar/cp110_sar.c                 |  236 +
 drivers/misc/mvebu_sar/sar-uclass.c                |  146 +
 drivers/mmc/Kconfig                                |   43 +-
 drivers/mmc/Makefile                               |    3 +-
 drivers/mmc/fsl_esdhc.c                            |    2 +-
 drivers/mmc/meson_gx_mmc.c                         |    2 +-
 drivers/mmc/mmc-uclass.c                           |   15 +-
 drivers/mmc/mmc.c                                  |  365 +-
 drivers/mmc/mmc_legacy.c                           |   23 +-
 drivers/mmc/octeontx_hsmmc.c                       | 3281 +++++++
 drivers/mmc/octeontx_hsmmc.h                       |  189 +
 drivers/mmc/sdhci.c                                |   41 +-
 drivers/mmc/xenon_sdhci.c                          |  415 +-
 drivers/mtd/nand/Kconfig                           |    6 +
 drivers/mtd/nand/Makefile                          |    2 +
 drivers/mtd/nand/octeontx_bch.c                    |  433 +
 drivers/mtd/nand/octeontx_bch.h                    |  143 +
 drivers/mtd/nand/octeontx_bch_regs.h               |  169 +
 drivers/mtd/nand/octeontx_nand.c                   | 2276 +++++
 drivers/mtd/nand/pxa3xx_nand.c                     |  552 +-
 drivers/mtd/nand/pxa3xx_nand.h                     |  106 +
 drivers/mtd/spi/Kconfig                            |   21 +-
 drivers/mtd/spi/sf.c                               |   88 +-
 drivers/mtd/spi/sf_dataflash.c                     |  119 +-
 drivers/mtd/spi/sf_internal.h                      |   44 +-
 drivers/mtd/spi/spi_flash.c                        |  314 +-
 drivers/mtd/spi/spi_flash_ids.c                    |    2 +
 drivers/net/Kconfig                                |   31 +
 drivers/net/Makefile                               |    4 +
 drivers/net/e1000.c                                |   28 +-
 drivers/net/e1000_spi.c                            |    4 +-
 drivers/net/mvneta.c                               |   17 +-
 drivers/net/mvpp2.c                                |  469 +-
 drivers/net/octeontx/Makefile                      |   10 +
 drivers/net/octeontx/nic.h                         |  518 ++
 drivers/net/octeontx/nic_main.c                    |  798 ++
 drivers/net/octeontx/nic_reg.h                     |  251 +
 drivers/net/octeontx/nicvf_main.c                  |  582 ++
 drivers/net/octeontx/nicvf_queues.c                | 1144 +++
 drivers/net/octeontx/nicvf_queues.h                |  368 +
 drivers/net/octeontx/octeontx_bgx.c                | 1497 +++
 drivers/net/octeontx/octeontx_bgx.h                |  252 +
 drivers/net/octeontx/octeontx_smi.c                |  382 +
 drivers/net/octeontx/octeontx_xcv.c                |  171 +
 drivers/net/octeontx/q_struct.h                    |  698 ++
 drivers/net/octeontx2/Makefile                     |   11 +
 drivers/net/octeontx2/cavm-csrs-cgx.h              | 7715 ++++++++++++++++
 drivers/net/octeontx2/cavm-csrs-lmt.h              |   61 +
 drivers/net/octeontx2/cavm-csrs-nix.h              | 9556 ++++++++++++++++++++
 drivers/net/octeontx2/cavm-csrs-npa.h              | 2294 +++++
 drivers/net/octeontx2/cavm-csrs-npc.h              | 1608 ++++
 drivers/net/octeontx2/cavm-csrs-rvu.h              | 2243 +++++
 drivers/net/octeontx2/cgx.c                        |  335 +
 drivers/net/octeontx2/cgx.h                        |  104 +
 drivers/net/octeontx2/cgx_intf.c                   |  358 +
 drivers/net/octeontx2/cgx_intf.h                   |  352 +
 drivers/net/octeontx2/lmt.h                        |   52 +
 drivers/net/octeontx2/nix.c                        |  852 ++
 drivers/net/octeontx2/nix.h                        |  334 +
 drivers/net/octeontx2/nix_af.c                     | 1114 +++
 drivers/net/octeontx2/npc.c                        |  400 +
 drivers/net/octeontx2/npc.h                        |   93 +
 drivers/net/octeontx2/npc_profile.h                | 3354 +++++++
 drivers/net/octeontx2/npc_reg.h                    |  639 ++
 drivers/net/octeontx2/rvu.h                        |  132 +
 drivers/net/octeontx2/rvu_af.c                     |  180 +
 drivers/net/octeontx2/rvu_common.c                 |   76 +
 drivers/net/octeontx2/rvu_pf.c                     |  129 +
 drivers/net/phy/Kconfig                            |    9 +
 drivers/net/phy/Makefile                           |    2 +
 drivers/net/phy/marvell.c                          |  275 +-
 drivers/net/phy/mv88e6xxx.c                        |  604 ++
 drivers/net/phy/mv88e6xxx.h                        |  394 +
 drivers/net/phy/mvebu_fw_download.c                |  559 ++
 drivers/net/phy/phy.c                              |    2 +-
 drivers/nvme/nvme.c                                |   24 +-
 drivers/pci/Kconfig                                |   27 +
 drivers/pci/Makefile                               |    2 +
 drivers/pci/pci-aardvark.c                         |  698 ++
 drivers/pci/pci-uclass.c                           |  527 +-
 drivers/pci/pci.c                                  |   22 +-
 drivers/pci/pci_auto.c                             |    4 +-
 drivers/pci/pci_auto_old.c                         |  119 +-
 drivers/pci/pci_mvebu.c                            |  486 +-
 drivers/pci/pci_octeontx_ecam.c                    |  550 ++
 drivers/phy/marvell/Makefile                       |    1 -
 drivers/phy/marvell/comphy.h                       |  154 -
 drivers/phy/marvell/comphy_a3700.c                 |  743 +-
 drivers/phy/marvell/comphy_a3700.h                 |  186 +-
 drivers/phy/marvell/comphy_core.c                  |   87 +-
 drivers/phy/marvell/comphy_cp110.c                 | 1805 +---
 drivers/phy/marvell/comphy_hpipe.h                 |  655 --
 drivers/phy/marvell/comphy_mux.c                   |  125 -
 drivers/phy/marvell/comphy_priv.h                  |  111 +
 drivers/phy/marvell/utmi_phy.h                     |   29 +-
 drivers/pinctrl/mvebu/pinctrl-armada-37xx.c        |   52 +-
 drivers/pinctrl/mvebu/pinctrl-mvebu.c              |   72 +-
 drivers/power/regulator/regulator-uclass.c         |   38 +
 drivers/rtc/Kconfig                                |   16 +
 drivers/rtc/Makefile                               |    1 +
 drivers/rtc/ds1337.c                               |  200 +-
 drivers/rtc/marvell_rtc.c                          |  184 +
 drivers/rtc/marvell_rtc.h                          |   54 +
 drivers/scsi/scsi.c                                |    1 +
 drivers/serial/Kconfig                             |   17 +
 drivers/serial/Makefile                            |    1 +
 drivers/serial/ns16550.c                           |    2 +-
 drivers/serial/serial_octeontx_bootcmd.c           |  300 +
 drivers/serial/serial_pl01x.c                      |    3 +
 drivers/spi/Kconfig                                |    6 +
 drivers/spi/Makefile                               |    1 +
 drivers/spi/kirkwood_spi.c                         |  172 +-
 drivers/spi/mvebu_a3700_spi.c                      |  413 +-
 drivers/spi/octeontx_spi.c                         |  675 ++
 drivers/spi/spi-uclass.c                           |   45 +
 drivers/spi/spi.c                                  |    1 +
 drivers/thermal/Kconfig                            |   31 +
 drivers/thermal/Makefile                           |    3 +
 drivers/thermal/mvebu_ext_thermal_28nm.c           |   95 +
 drivers/thermal/mvebu_thermal_28nm.c               |   85 +
 drivers/thermal/mvebu_thermal_core.c               |  145 +
 drivers/usb/eth/usb_ether.c                        |    1 +
 drivers/usb/host/ehci-marvell.c                    |   45 +-
 drivers/usb/host/xhci-mem.c                        |   10 +
 drivers/usb/host/xhci-mvebu.c                      |   43 +-
 drivers/usb/host/xhci-pci.c                        |    7 +-
 drivers/usb/host/xhci-ring.c                       |   23 +
 drivers/usb/host/xhci.c                            |   17 +-
 drivers/usb/host/xhci.h                            |   10 +
 env/common.c                                       |   12 +
 env/mmc.c                                          |   17 +-
 env/sf.c                                           |   26 +-
 examples/standalone/stubs.c                        |   11 +
 fs/ext4/ext4_common.c                              |   41 +-
 fs/ext4/ext4_write.c                               |    2 +-
 fs/ext4/ext4fs.c                                   |    5 +-
 include/ahci.h                                     |    7 +-
 include/cavium/atf.h                               |   22 -
 include/cavium/atf_part.h                          |   26 -
 include/cavium/thunderx_svc.h                      |   67 -
 include/common.h                                   |    4 +
 include/configs/armada8k.h                         |  131 +
 include/configs/clearfog.h                         |    1 -
 include/configs/controlcenterdc.h                  |    3 -
 include/configs/db-88f6820-amc.h                   |    1 -
 include/configs/db-88f6820-gp.h                    |   13 +-
 include/configs/db-mv784mp-gp.h                    |    1 -
 include/configs/ds414.h                            |    1 -
 include/configs/mv-common.h                        |   57 +
 include/configs/mvebu_armada-37xx.h                |  100 +-
 include/configs/mvebu_armada-8k.h                  |   93 +-
 include/configs/mvebu_armada-common.h              |  178 +
 include/configs/octeontx2_95xx.h                   |  111 +
 include/configs/octeontx2_96xx.h                   |  123 +
 include/configs/octeontx2_98xx.h                   |  122 +
 include/configs/octeontx2_cn913x.h                 |   37 +
 include/configs/octeontx2_loki.h                   |  110 +
 include/configs/octeontx_81xx.h                    |  128 +
 include/configs/octeontx_83xx.h                    |  127 +
 include/configs/theadorable.h                      |    7 -
 include/configs/thunderx_88xx.h                    |   76 -
 include/configs/turris_omnia.h                     |    1 -
 include/ddr_spd.h                                  |    2 +
 include/dm/device-internal.h                       |    4 +
 include/dm/ofnode.h                                |   13 +
 include/dm/uclass-id.h                             |    2 +
 include/dt-bindings/comphy/comphy_data.h           |   80 +-
 include/elf.h                                      |   55 +
 include/environment.h                              |    5 +
 include/ext4fs.h                                   |    4 +-
 include/fdtdec.h                                   |   16 +-
 include/linux/ethtool.h                            |    3 +-
 include/linux/sizes.h                              |    4 +
 include/mdio.h                                     |   62 +
 include/miiphy.h                                   |    4 +
 include/mmc.h                                      |   46 +-
 include/mvebu/cfg_eeprom.h                         |   95 +
 include/mvebu/comphy.h                             |   13 +
 include/mvebu/fuse-mvebu.h                         |   55 +
 include/mvebu/mvebu_chip_sar.h                     |   75 +
 include/mvebu/sar.h                                |   60 +
 include/mvebu/var.h                                |   31 +
 include/net.h                                      |    4 +
 include/pci.h                                      |  303 +-
 include/pci_ids.h                                  |    3 +
 include/phy.h                                      |   19 +-
 include/power/regulator.h                          |   23 +
 include/sar-uclass.h                               |   27 +
 include/scsi.h                                     |   20 +
 include/sdhci.h                                    |    4 +
 include/spi.h                                      |  170 +
 include/spi_flash.h                                |    7 +
 lib/Makefile                                       |    1 +
 lib/fdtdec.c                                       |   24 +-
 lib/ssp.c                                          |   10 +
 localversion                                       |    1 +
 net/Kconfig                                        |    4 +
 net/bootp.c                                        |    9 +
 net/eth-uclass.c                                   |    7 +-
 net/eth_legacy.c                                   |    3 +
 scripts/checkpatch.pl                              |  831 +-
 scripts/ci/baseline.txt                            |    7 +
 scripts/ci/compile.sh                              |  242 +
 scripts/ci/pack.sh                                 |   25 +
 scripts/ci/pack_source.sh                          |   42 +
 scripts/ci/supported_builds.txt                    |   77 +
 scripts/config                                     |  225 +
 scripts/config_whitelist.txt                       |    1 -
 scripts/const_structs.checkpatch                   |   66 +-
 scripts/spelling.txt                               |  159 +
 503 files changed, 87382 insertions(+), 8547 deletions(-)
 create mode 100644 arch/arm/dts/armada-3720-ddr3-db-v1-A.dts
 create mode 100644 arch/arm/dts/armada-3720-ddr3-db-v1-B.dts
 create mode 100644 arch/arm/dts/armada-3720-ddr3-db-v1-C.dts
 create mode 100644 arch/arm/dts/armada-3720-ddr3-db-v2-B.dts
 create mode 100644 arch/arm/dts/armada-3720-ddr3-db-v2-C.dts
 create mode 100644 arch/arm/dts/armada-3720-ddr4-db-v1-A.dts
 create mode 100644 arch/arm/dts/armada-3720-ddr4-db-v1-B.dts
 create mode 100644 arch/arm/dts/armada-3720-ddr4-db-v3-A.dts
 create mode 100644 arch/arm/dts/armada-3720-ddr4-db-v3-B.dts
 create mode 100644 arch/arm/dts/armada-3720-ddr4-db-v3-C.dts
 create mode 100644 arch/arm/dts/armada-3720-espressobin-emmc.dts
 create mode 100644 arch/arm/dts/armada-3900-db.dtsi
 create mode 100644 arch/arm/dts/armada-3900-vd-A.dts
 create mode 100644 arch/arm/dts/armada-3900-vd-B.dts
 create mode 100644 arch/arm/dts/armada-3900.dtsi
 create mode 100644 arch/arm/dts/armada-7020-amc.dts
 create mode 100644 arch/arm/dts/armada-7020-comexp.dts
 create mode 100644 arch/arm/dts/armada-7040-db-B.dts
 create mode 100644 arch/arm/dts/armada-7040-db-C.dts
 create mode 100644 arch/arm/dts/armada-7040-db-D.dts
 create mode 100644 arch/arm/dts/armada-7040-db-E.dts
 delete mode 100644 arch/arm/dts/armada-7040-db-nand.dts
 create mode 100644 arch/arm/dts/armada-7040-dev-info.dtsi
 create mode 100644 arch/arm/dts/armada-7040-pcac.dts
 delete mode 100644 arch/arm/dts/armada-7040.dtsi
 create mode 100644 arch/arm/dts/armada-70x0-db.dtsi
 create mode 100644 arch/arm/dts/armada-70x0.dtsi
 create mode 100644 arch/arm/dts/armada-8040-db-B.dts
 create mode 100644 arch/arm/dts/armada-8040-db-C.dts
 create mode 100644 arch/arm/dts/armada-8040-db-D.dts
 create mode 100644 arch/arm/dts/armada-8040-db-E.dts
 create mode 100644 arch/arm/dts/armada-8040-db-F.dts
 create mode 100644 arch/arm/dts/armada-8040-db-G.dts
 create mode 100644 arch/arm/dts/armada-8040-db-H.dts
 create mode 100644 arch/arm/dts/armada-8040-dev-info.dtsi
 create mode 100644 arch/arm/dts/armada-8040-mcbin-single-shot.dts
 create mode 100644 arch/arm/dts/armada-8040-ocp.dts
 create mode 100644 arch/arm/dts/armada-8040-ucpe.dts
 create mode 100644 arch/arm/dts/armada-80x0-db.dtsi
 create mode 100644 arch/arm/dts/armada-8k.dtsi
 delete mode 100644 arch/arm/dts/armada-ap806-quad.dtsi
 create mode 100644 arch/arm/dts/armada-ap807.dtsi
 create mode 100644 arch/arm/dts/armada-ap80x-quad.dtsi
 create mode 100644 arch/arm/dts/armada-ap80x.dtsi
 create mode 100644 arch/arm/dts/armada-common.dtsi
 delete mode 100644 arch/arm/dts/armada-cp110-master.dtsi
 delete mode 100644 arch/arm/dts/armada-cp110-slave.dtsi
 create mode 100644 arch/arm/dts/armada-cp110.dtsi
 create mode 100644 arch/arm/dts/cn9130-crb-A.dts
 create mode 100644 arch/arm/dts/cn9130-crb-B.dts
 create mode 100644 arch/arm/dts/cn9130-crb.dtsi
 create mode 100644 arch/arm/dts/cn9130-db-A.dts
 create mode 100644 arch/arm/dts/cn9130-db-B.dts
 create mode 100644 arch/arm/dts/cn9130-db-dev-info.dtsi
 create mode 100644 arch/arm/dts/cn9130-db.dtsi
 create mode 100644 arch/arm/dts/cn9130.dtsi
 create mode 100644 arch/arm/dts/cn9131-db-A.dts
 create mode 100644 arch/arm/dts/cn9131-db-B.dts
 create mode 100644 arch/arm/dts/cn9131-db.dtsi
 create mode 100644 arch/arm/dts/cn9132-db-A.dts
 create mode 100644 arch/arm/dts/cn9132-db-B.dts
 create mode 100644 arch/arm/dts/cn9132-db.dtsi
 delete mode 100644 arch/arm/dts/thunderx-88xx.dts
 delete mode 100644 arch/arm/dts/thunderx-88xx.dtsi
 create mode 100644 arch/arm/include/asm/arch-mvebu/thermal.h
 create mode 100644 arch/arm/include/asm/arch-octeontx/atf.h
 create mode 100644 arch/arm/include/asm/arch-octeontx/atf_part.h
 create mode 100644 arch/arm/include/asm/arch-octeontx/cavm-csrs-mio_emm.h
 create mode 100644 arch/arm/include/asm/arch-octeontx/clock.h
 create mode 100644 arch/arm/include/asm/arch-octeontx/fdt-helper.h
 create mode 100644 arch/arm/include/asm/arch-octeontx/octeontx.h
 create mode 100644 arch/arm/include/asm/arch-octeontx/octeontx_fdt.h
 create mode 100644 arch/arm/include/asm/arch-octeontx/octeontx_mmc.h
 create mode 100644 arch/arm/include/asm/arch-octeontx/octeontx_smi.h
 create mode 100644 arch/arm/include/asm/arch-octeontx/octeontx_svc.h
 create mode 100644 arch/arm/include/asm/arch-octeontx/octeontx_vnic.h
 create mode 100644 arch/arm/include/asm/arch-octeontx/octeontx_xcv.h
 create mode 100644 arch/arm/include/asm/arch-octeontx2/atf.h
 create mode 100644 arch/arm/include/asm/arch-octeontx2/cavium_mmc.h
 create mode 120000 arch/arm/include/asm/arch-octeontx2/cavm-csrs-mio_emm.h
 create mode 100644 arch/arm/include/asm/arch-octeontx2/clock.h
 create mode 100644 arch/arm/include/asm/arch-octeontx2/fdt-helper.h
 create mode 100644 arch/arm/include/asm/arch-octeontx2/octeontx2.h
 create mode 100644 arch/arm/include/asm/arch-octeontx2/octeontx2_fdt.h
 create mode 100644 arch/arm/include/asm/arch-octeontx2/octeontx2_svc.h
 create mode 120000 arch/arm/include/asm/arch-octeontx2/octeontx_mmc.h
 create mode 100644 arch/arm/mach-mvebu/armada3700/clock.c
 create mode 100644 arch/arm/mach-mvebu/armada8k/clock.c
 create mode 100644 arch/arm/mach-mvebu/armada8k/soc.c
 delete mode 100644 arch/arm/mach-mvebu/efuse.c
 create mode 100644 arch/arm/mach-mvebu/include/mach/clock.h
 delete mode 100644 arch/arm/mach-mvebu/include/mach/efuse.h
 create mode 100644 arch/arm/mach-mvebu/include/mach/fw_info.h
 delete mode 100644 arch/arm/mach-mvebu/sata.c
 create mode 100644 arch/arm/mach-octeontx/Kconfig
 create mode 100644 arch/arm/mach-octeontx/Makefile
 create mode 100644 arch/arm/mach-octeontx/clock.c
 create mode 100644 arch/arm/mach-octeontx/cpu.c
 create mode 100644 arch/arm/mach-octeontx/fdt-helper.c
 create mode 100644 arch/arm/mach-octeontx/lowlevel_init.S
 create mode 100644 arch/arm/mach-octeontx2/Kconfig
 create mode 100644 arch/arm/mach-octeontx2/Makefile
 create mode 100644 arch/arm/mach-octeontx2/clock.c
 create mode 100644 arch/arm/mach-octeontx2/config.mk
 create mode 100644 arch/arm/mach-octeontx2/cpu.c
 create mode 100644 arch/arm/mach-octeontx2/fdt-helper.c
 create mode 100644 arch/arm/mach-octeontx2/lowlevel_init.S
 create mode 100644 board/Marvell/common/Kconfig
 create mode 100644 board/Marvell/common/Makefile
 create mode 100644 board/Marvell/common/cfg_eeprom.c
 create mode 100644 board/Marvell/common/sar.c
 create mode 100644 board/Marvell/octeontx/Kconfig
 create mode 100644 board/Marvell/octeontx/MAINTAINERS
 create mode 100644 board/Marvell/octeontx/Makefile
 create mode 100644 board/Marvell/octeontx/atf.c
 create mode 100644 board/Marvell/octeontx/fdt.c
 create mode 100644 board/Marvell/octeontx/octeontx.c
 create mode 100644 board/Marvell/octeontx2/Kconfig
 create mode 100644 board/Marvell/octeontx2/MAINTAINERS
 create mode 100644 board/Marvell/octeontx2/Makefile
 create mode 100644 board/Marvell/octeontx2/atf.c
 create mode 100644 board/Marvell/octeontx2/fdt.c
 create mode 100644 board/Marvell/octeontx2/octeontx2.c
 create mode 100644 board/Marvell/octeontx2_cn913x/MAINTAINERS
 create mode 100644 board/Marvell/octeontx2_cn913x/Makefile
 create mode 100644 board/Marvell/octeontx2_cn913x/board.c
 delete mode 100644 board/cavium/thunderx/Kconfig
 delete mode 100644 board/cavium/thunderx/MAINTAINERS
 delete mode 100644 board/cavium/thunderx/Makefile
 delete mode 100644 board/cavium/thunderx/atf.c
 delete mode 100644 board/cavium/thunderx/thunderx.c
 create mode 100644 cmd/bootimgup.c
 create mode 100644 cmd/marvell/Kconfig
 create mode 100644 cmd/marvell/Makefile
 create mode 100644 cmd/marvell/eth_cmds.c
 create mode 100644 cmd/marvell/mdio_dbg.c
 create mode 100644 cmd/marvell/octeontx2_cmds.c
 create mode 100644 cmd/mvebu/avs.c
 create mode 100644 cmd/mvebu/hw_info.c
 create mode 100644 cmd/mvebu/map.c
 create mode 100644 cmd/mvebu/mv_fw_info.c
 create mode 100644 cmd/mvebu/mv_get_counters.c
 create mode 100644 cmd/mvebu/pxa3xx_nand_oem.c
 create mode 100644 cmd/mvebu/rx_training.c
 create mode 100644 cmd/mvebu/sar.c
 create mode 100644 cmd/mvebu/thermal.c
 create mode 100644 configs/mvebu_db_cn91xx_defconfig
 create mode 100644 configs/mvebu_ocp-88f8040_defconfig
 create mode 100644 configs/mvebu_ucpe-88f8040_defconfig
 create mode 100644 configs/octeontx2_95xx_defconfig
 create mode 100644 configs/octeontx2_96xx_defconfig
 create mode 100644 configs/octeontx2_98xx_defconfig
 create mode 100644 configs/octeontx2_loki_defconfig
 create mode 100644 configs/octeontx_81xx_defconfig
 create mode 100644 configs/octeontx_83xx_defconfig
 delete mode 100644 configs/thunderx_88xx_defconfig
 create mode 100644 doc/device-tree-bindings/mdio/marvell-mdio.txt
 create mode 100644 doc/device-tree-bindings/mdio/mdio-bus.txt
 create mode 100644 doc/device-tree-bindings/mmc/xenon-mmc.txt
 create mode 100644 doc/device-tree-bindings/phy/mvebu_comphy.txt
 create mode 100644 doc/device-tree-bindings/pinctrl/marvell,armada-37xx-pinctrl.txt
 create mode 100644 doc/device-tree-bindings/rtc/marvell-rtc.txt
 create mode 100644 doc/device-tree-bindings/spi/mvebu-spi.txt
 create mode 100644 doc/device-tree-bindings/thermal/mvebu-thermal.txt
 create mode 100644 doc/device-tree-bindings/usb/marvell.ehci-usb.txt
 create mode 100644 doc/mvebu/a3700/armada-3700-db-setup.txt
 create mode 100644 doc/mvebu/a7k-a8k/armada3900-db-setup.txt
 create mode 100644 doc/mvebu/a7k-a8k/armada70x0-db-setup.txt
 create mode 100644 doc/mvebu/a7k-a8k/armada80x0-db-setup.txt
 create mode 100644 doc/mvebu/build.txt
 create mode 100644 doc/mvebu/linux_boot.txt
 create mode 100644 doc/mvebu/porting_guide.txt
 create mode 100644 doc/mvebu/trusted_boot.txt
 create mode 100644 doc/mvebu/uart_boot.txt
 create mode 100644 doc/mvebu/uboot_cmd.txt
 create mode 100644 drivers/ata/ahci_mvebu.c
 create mode 100644 drivers/fuse/Kconfig
 create mode 100644 drivers/fuse/Makefile
 create mode 100644 drivers/fuse/fuse-mvebu-hd.c
 create mode 100644 drivers/fuse/fuse-mvebu-init.c
 create mode 100644 drivers/fuse/fuse-mvebu-ld.c
 create mode 100644 drivers/fuse/fuse-mvebu.c
 create mode 100644 drivers/gpio/i2c_gpio.c
 create mode 100644 drivers/gpio/octeontx_gpio.c
 create mode 100644 drivers/i2c/octeontx_i2c.c
 create mode 100644 drivers/mdio/Kconfig
 create mode 100644 drivers/mdio/Makefile
 create mode 100644 drivers/mdio/mdio-uclass.c
 create mode 100644 drivers/mdio/mvmdio.c
 create mode 100644 drivers/misc/mvebu_sar/Makefile
 create mode 100644 drivers/misc/mvebu_sar/ap806_sar.c
 create mode 100644 drivers/misc/mvebu_sar/ap807_sar.c
 create mode 100644 drivers/misc/mvebu_sar/cp110_sar.c
 create mode 100644 drivers/misc/mvebu_sar/sar-uclass.c
 create mode 100644 drivers/mmc/octeontx_hsmmc.c
 create mode 100644 drivers/mmc/octeontx_hsmmc.h
 create mode 100644 drivers/mtd/nand/octeontx_bch.c
 create mode 100644 drivers/mtd/nand/octeontx_bch.h
 create mode 100644 drivers/mtd/nand/octeontx_bch_regs.h
 create mode 100644 drivers/mtd/nand/octeontx_nand.c
 create mode 100644 drivers/net/octeontx/Makefile
 create mode 100644 drivers/net/octeontx/nic.h
 create mode 100644 drivers/net/octeontx/nic_main.c
 create mode 100644 drivers/net/octeontx/nic_reg.h
 create mode 100644 drivers/net/octeontx/nicvf_main.c
 create mode 100644 drivers/net/octeontx/nicvf_queues.c
 create mode 100644 drivers/net/octeontx/nicvf_queues.h
 create mode 100644 drivers/net/octeontx/octeontx_bgx.c
 create mode 100644 drivers/net/octeontx/octeontx_bgx.h
 create mode 100644 drivers/net/octeontx/octeontx_smi.c
 create mode 100644 drivers/net/octeontx/octeontx_xcv.c
 create mode 100644 drivers/net/octeontx/q_struct.h
 create mode 100644 drivers/net/octeontx2/Makefile
 create mode 100644 drivers/net/octeontx2/cavm-csrs-cgx.h
 create mode 100644 drivers/net/octeontx2/cavm-csrs-lmt.h
 create mode 100644 drivers/net/octeontx2/cavm-csrs-nix.h
 create mode 100644 drivers/net/octeontx2/cavm-csrs-npa.h
 create mode 100644 drivers/net/octeontx2/cavm-csrs-npc.h
 create mode 100644 drivers/net/octeontx2/cavm-csrs-rvu.h
 create mode 100644 drivers/net/octeontx2/cgx.c
 create mode 100644 drivers/net/octeontx2/cgx.h
 create mode 100644 drivers/net/octeontx2/cgx_intf.c
 create mode 100644 drivers/net/octeontx2/cgx_intf.h
 create mode 100644 drivers/net/octeontx2/lmt.h
 create mode 100644 drivers/net/octeontx2/nix.c
 create mode 100644 drivers/net/octeontx2/nix.h
 create mode 100644 drivers/net/octeontx2/nix_af.c
 create mode 100644 drivers/net/octeontx2/npc.c
 create mode 100644 drivers/net/octeontx2/npc.h
 create mode 100644 drivers/net/octeontx2/npc_profile.h
 create mode 100644 drivers/net/octeontx2/npc_reg.h
 create mode 100644 drivers/net/octeontx2/rvu.h
 create mode 100644 drivers/net/octeontx2/rvu_af.c
 create mode 100644 drivers/net/octeontx2/rvu_common.c
 create mode 100644 drivers/net/octeontx2/rvu_pf.c
 create mode 100644 drivers/net/phy/mv88e6xxx.c
 create mode 100644 drivers/net/phy/mv88e6xxx.h
 create mode 100644 drivers/net/phy/mvebu_fw_download.c
 create mode 100644 drivers/pci/pci-aardvark.c
 create mode 100644 drivers/pci/pci_octeontx_ecam.c
 delete mode 100644 drivers/phy/marvell/comphy.h
 delete mode 100644 drivers/phy/marvell/comphy_hpipe.h
 delete mode 100644 drivers/phy/marvell/comphy_mux.c
 create mode 100644 drivers/phy/marvell/comphy_priv.h
 create mode 100644 drivers/rtc/marvell_rtc.c
 create mode 100644 drivers/rtc/marvell_rtc.h
 create mode 100644 drivers/serial/serial_octeontx_bootcmd.c
 create mode 100755 drivers/spi/octeontx_spi.c
 create mode 100644 drivers/thermal/mvebu_ext_thermal_28nm.c
 create mode 100644 drivers/thermal/mvebu_thermal_28nm.c
 create mode 100644 drivers/thermal/mvebu_thermal_core.c
 delete mode 100644 include/cavium/atf.h
 delete mode 100644 include/cavium/atf_part.h
 delete mode 100644 include/cavium/thunderx_svc.h
 create mode 100644 include/configs/armada8k.h
 create mode 100644 include/configs/mvebu_armada-common.h
 create mode 100644 include/configs/octeontx2_95xx.h
 create mode 100644 include/configs/octeontx2_96xx.h
 create mode 100644 include/configs/octeontx2_98xx.h
 create mode 100644 include/configs/octeontx2_cn913x.h
 create mode 100644 include/configs/octeontx2_loki.h
 create mode 100644 include/configs/octeontx_81xx.h
 create mode 100644 include/configs/octeontx_83xx.h
 delete mode 100644 include/configs/thunderx_88xx.h
 create mode 100644 include/mdio.h
 create mode 100644 include/mvebu/cfg_eeprom.h
 create mode 100644 include/mvebu/comphy.h
 create mode 100644 include/mvebu/fuse-mvebu.h
 create mode 100644 include/mvebu/mvebu_chip_sar.h
 create mode 100644 include/mvebu/sar.h
 create mode 100644 include/mvebu/var.h
 create mode 100644 include/sar-uclass.h
 create mode 100644 lib/ssp.c
 create mode 100644 localversion
 create mode 100644 scripts/ci/baseline.txt
 create mode 100755 scripts/ci/compile.sh
 create mode 100755 scripts/ci/pack.sh
 create mode 100755 scripts/ci/pack_source.sh
 create mode 100644 scripts/ci/supported_builds.txt
 create mode 100755 scripts/config

diff --git a/MAINTAINERS b/MAINTAINERS
index d5059f6..e69a693 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -104,6 +104,22 @@ F:	drivers/video/bcm2835.c
 F:	include/dm/platform_data/serial_bcm283x_mu.h
 F:	drivers/pinctrl/broadcom/
 
+ARM OCTEONTX
+M:	Aaron Williams <aaron.williams@cavium.com>
+M:	Suneel Garapati <sgarapati@caviumnetworks.com>
+S:	Maintained
+F:	arch/arm/mach-octeontx/
+F:	arch/arm/include/asm/arch-octeontx/
+F:	board/Marvell/octeontx/
+
+ARM OCTEONTX2
+M:	Aaron Williams <aaron.williams@cavium.com>
+M:	Suneel Garapati <sgarapati@caviumnetworks.com>
+S:	Maintained
+F:	arch/arm/mach-octeontx2/
+F:	arch/arm/include/asm/arch-octeontx2/
+F:	board/Marvell/octeontx2/
+
 ARM FREESCALE IMX
 M:	Stefano Babic <sbabic@denx.de>
 M:	Fabio Estevam <fabio.estevam@nxp.com>
diff --git a/Makefile b/Makefile
index 6b2aac6..34cad17 100644
--- a/Makefile
+++ b/Makefile
@@ -591,10 +591,14 @@ else
 KBUILD_CFLAGS	+= -O2
 endif
 
-KBUILD_CFLAGS += $(call cc-option,-fno-stack-protector)
+KBUILD_CFLAGS += $(call cc-option,-fstack-protector-strong)
+
+ifdef BUILD_TAG
+KBUILD_CFLAGS += -DBUILD_TAG='"$(BUILD_TAG)"'
+endif
+
 KBUILD_CFLAGS += $(call cc-option,-fno-delete-null-pointer-checks)
 
-KBUILD_CFLAGS	+= -g
 # $(KBUILD_AFLAGS) sets -g, which causes gcc to pass a suitable -g<format>
 # option to the assembler.
 KBUILD_AFLAGS	+= -g
@@ -664,7 +668,6 @@ libs-$(CONFIG_CMD_UBI) += drivers/mtd/ubi/
 libs-y += drivers/mtd/spi/
 libs-y += drivers/net/
 libs-y += drivers/net/phy/
-libs-y += drivers/pci/
 libs-y += drivers/power/ \
 	drivers/power/domain/ \
 	drivers/power/fuel_gauge/ \
diff --git a/README b/README
index 5cf90a4..549c4ad 100644
--- a/README
+++ b/README
@@ -1531,6 +1531,7 @@ The following options need to be configured:
 		CONFIG_BOOTP_BOOTFILESIZE
 		CONFIG_BOOTP_SEND_HOSTNAME
 		CONFIG_BOOTP_NTPSERVER
+		CONFIG_BOOTP_TFTP_SERVERIP
 		CONFIG_BOOTP_TIMEOFFSET
 		CONFIG_BOOTP_VENDOREX
 		CONFIG_BOOTP_MAY_FAIL
@@ -1551,6 +1552,12 @@ The following options need to be configured:
 		of the "hostname" environment variable is passed as
 		option 12 to the DHCP server.
 
+		CONFIG_BOOTP_TFTP_SERVERIP - Some DHCP servers can send
+		the IP address of the TFTP server.  By setting this,
+		the DHCP client will automatically set the serverip
+		based on the response from the DHCP server via option
+		150.
+
 		CONFIG_BOOTP_DHCP_REQUEST_DELAY
 
 		A 32bit value in microseconds for a delay between
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 2c52ff0..014d18b 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -332,7 +332,7 @@ config SPL_USE_ARCH_MEMSET
 
 config ARM64_SUPPORT_AARCH32
 	bool "ARM64 system support AArch32 execution state"
-	default y if ARM64 && !TARGET_THUNDERX_88XX
+	default y if ARM64 && !TARGET_OCTEONTX_88XX
 	help
 	  This ARM64 system supports AArch32 execution state.
 
@@ -379,6 +379,7 @@ config ARCH_MVEBU
 	select DM_SERIAL
 	select DM_SPI
 	select DM_SPI_FLASH
+	select DM_MDIO
 
 config TARGET_DEVKIT3250
 	bool "Support devkit3250"
@@ -1176,12 +1177,21 @@ config ARCH_ROCKCHIP
 	imply ADC
 	imply SARADC_ROCKCHIP
 
-config TARGET_THUNDERX_88XX
-	bool "Support ThunderX 88xx"
+config ARCH_OCTEONTX
+	bool "Support OcteonTX SoCs"
+	select DM
 	select ARM64
 	select OF_CONTROL
+	select BOARD_LATE_INIT
+	select SYS_CACHE_SHIFT_7
+
+config ARCH_OCTEONTX2
+	bool "Support OcteonTX2 SoCs"
+	select DM
+	select ARM64
+	select OF_CONTROL
+	select BOARD_LATE_INIT
 	select SYS_CACHE_SHIFT_7
-	select PL01X_SERIAL
 
 config ARCH_ASPEED
 	bool "Support Aspeed SoCs"
@@ -1220,6 +1230,10 @@ source "arch/arm/mach-kirkwood/Kconfig"
 
 source "arch/arm/mach-mvebu/Kconfig"
 
+source "arch/arm/mach-octeontx/Kconfig"
+
+source "arch/arm/mach-octeontx2/Kconfig"
+
 source "arch/arm/cpu/armv7/ls102xa/Kconfig"
 
 source "arch/arm/mach-imx/mx2/Kconfig"
@@ -1282,6 +1296,8 @@ source "board/bosch/shc/Kconfig"
 source "board/CarMediaLab/flea3/Kconfig"
 source "board/Marvell/aspenite/Kconfig"
 source "board/Marvell/gplugd/Kconfig"
+source "board/Marvell/octeontx/Kconfig"
+source "board/Marvell/octeontx2/Kconfig"
 source "board/armadeus/apf27/Kconfig"
 source "board/armltd/vexpress/Kconfig"
 source "board/armltd/vexpress64/Kconfig"
@@ -1290,7 +1306,6 @@ source "board/broadcom/bcm28155_ap/Kconfig"
 source "board/broadcom/bcmcygnus/Kconfig"
 source "board/broadcom/bcmnsp/Kconfig"
 source "board/broadcom/bcmns2/Kconfig"
-source "board/cavium/thunderx/Kconfig"
 source "board/cirrus/edb93xx/Kconfig"
 source "board/eets/pdu001/Kconfig"
 source "board/freescale/ls2080a/Kconfig"
@@ -1335,6 +1350,7 @@ source "board/vscom/baltos/Kconfig"
 source "board/woodburn/Kconfig"
 source "board/work-microwave/work_92105/Kconfig"
 source "board/zipitz2/Kconfig"
+source "board/Marvell/common/Kconfig"
 
 source "arch/arm/Kconfig.debug"
 
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index 5881fdc..dae0b30 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -42,6 +42,8 @@ tune-$(CONFIG_CPU_ARM1136)	=
 tune-$(CONFIG_CPU_ARM1176)	=
 tune-$(CONFIG_CPU_V7)		=
 tune-$(CONFIG_ARM64)		=
+tune-$(CONFIG_OCTEONTX)		=
+tune-$(CONFIG_OCTEONTX2)	=
 
 # Evaluate tune cc-option calls now
 tune-y := $(tune-y)
@@ -73,6 +75,8 @@ machine-$(CONFIG_ARCH_RMOBILE)		+= rmobile
 machine-$(CONFIG_ARCH_ROCKCHIP)		+= rockchip
 machine-$(CONFIG_STM32)			+= stm32
 machine-$(CONFIG_TEGRA)			+= tegra
+machine-$(CONFIG_ARCH_OCTEONTX)		+= octeontx
+machine-$(CONFIG_ARCH_OCTEONTX2)	+= octeontx2
 machine-$(CONFIG_ARCH_UNIPHIER)		+= uniphier
 machine-$(CONFIG_ARCH_ZYNQ)		+= zynq
 
diff --git a/arch/arm/cpu/armv8/cache_v8.c b/arch/arm/cpu/armv8/cache_v8.c
index 6548f3c..ee36833 100644
--- a/arch/arm/cpu/armv8/cache_v8.c
+++ b/arch/arm/cpu/armv8/cache_v8.c
@@ -11,7 +11,7 @@
 #include <common.h>
 #include <asm/system.h>
 #include <asm/armv8/mmu.h>
-
+#undef DEBUG_CACHE
 DECLARE_GLOBAL_DATA_PTR;
 
 #ifndef CONFIG_SYS_DCACHE_OFF
@@ -108,9 +108,9 @@ static u64 *find_pte(u64 addr, int level)
 	u64 idx;
 	u64 va_bits;
 	int i;
-
+#ifdef DEBUG_CACHE
 	debug("addr=%llx level=%d\n", addr, level);
-
+#endif
 	get_tcr(0, NULL, &va_bits);
 	if (va_bits < 39)
 		start_level = 1;
@@ -123,8 +123,9 @@ static u64 *find_pte(u64 addr, int level)
 	for (i = start_level; i < 4; i++) {
 		idx = (addr >> level2shift(i)) & 0x1FF;
 		pte += idx;
+#ifdef DEBUG_CACHE
 		debug("idx=%llx PTE %p at level %d: %llx\n", idx, pte, i, *pte);
-
+#endif
 		/* Found it */
 		if (i == level)
 			return pte;
@@ -163,7 +164,9 @@ static u64 *create_table(void)
 static void set_pte_table(u64 *pte, u64 *table)
 {
 	/* Point *pte to the new table */
+#ifdef DEBUG_CACHE
 	debug("Setting %p to addr=%p\n", pte, table);
+#endif
 	*pte = PTE_TYPE_TABLE | (ulong)table;
 }
 
@@ -182,8 +185,9 @@ static void split_block(u64 *pte, int level)
 		      "mem_map.", pte, old_pte);
 
 	new_table = create_table();
+#ifdef DEBUG_CACHE
 	debug("Splitting pte %p (%llx) into %p\n", pte, old_pte, new_table);
-
+#endif
 	for (i = 0; i < MAX_PTE_ENTRIES; i++) {
 		new_table[i] = old_pte | (i << levelshift);
 
@@ -191,7 +195,9 @@ static void split_block(u64 *pte, int level)
 		if ((level + 1) == 3)
 			new_table[i] |= PTE_TYPE_TABLE;
 
+#ifdef DEBUG_CACHE
 		debug("Setting new_table[%lld] = %llx\n", i, new_table[i]);
+#endif
 	}
 
 	/* Set the new table into effect */
@@ -213,7 +219,9 @@ static void add_map(struct mm_region *map)
 	while (size) {
 		pte = find_pte(virt, 0);
 		if (pte && (pte_type(pte) == PTE_TYPE_FAULT)) {
+#ifdef DEBUG_CACHE
 			debug("Creating table for virt 0x%llx\n", virt);
+#endif
 			new_table = create_table();
 			set_pte_table(pte, new_table);
 		}
@@ -224,12 +232,16 @@ static void add_map(struct mm_region *map)
 				panic("pte not found\n");
 
 			blocksize = 1ULL << level2shift(level);
+#ifdef DEBUG_CACHE
 			debug("Checking if pte fits for virt=%llx size=%llx blocksize=%llx\n",
 			      virt, size, blocksize);
+#endif
 			if (size >= blocksize && !(virt & (blocksize - 1))) {
 				/* Page fits, create block PTE */
+#ifdef DEBUG_CACHE
 				debug("Setting PTE %p to block virt=%llx\n",
 				      pte, virt);
+#endif
 				if (level == 3)
 					*pte = phys | attrs | PTE_TYPE_PAGE;
 				else
@@ -240,13 +252,17 @@ static void add_map(struct mm_region *map)
 				break;
 			} else if (pte_type(pte) == PTE_TYPE_FAULT) {
 				/* Page doesn't fit, create subpages */
+#ifdef DEBUG_CACHE
 				debug("Creating subtable for virt 0x%llx blksize=%llx\n",
 				      virt, blocksize);
+#endif
 				new_table = create_table();
 				set_pte_table(pte, new_table);
 			} else if (pte_type(pte) == PTE_TYPE_BLOCK) {
+#ifdef DEBUG_CACHE
 				debug("Split block into subtable for virt 0x%llx blksize=0x%llx\n",
 				      virt, blocksize);
+#endif
 				split_block(pte, level);
 			}
 		}
@@ -434,14 +450,16 @@ void invalidate_dcache_all(void)
  */
 inline void flush_dcache_all(void)
 {
-	int ret;
+	int __maybe_unused ret;
 
 	__asm_flush_dcache_all();
 	ret = __asm_flush_l3_dcache();
+#ifdef DEBUG_CACHE
 	if (ret)
 		debug("flushing dcache returns 0x%x\n", ret);
 	else
 		debug("flushing dcache successfully.\n");
+#endif
 }
 
 /*
@@ -520,14 +538,16 @@ static u64 set_one_region(u64 start, u64 size, u64 attrs, bool flag, int level)
 			*pte &= ~PMD_ATTRINDX_MASK;
 			*pte |= attrs & PMD_ATTRINDX_MASK;
 		}
+#ifdef DEBUG_CACHE
 		debug("Set attrs=%llx pte=%p level=%d\n", attrs, pte, level);
-
+#endif
 		return levelsize;
 	}
 
 	/* Unaligned or doesn't fit, maybe split block into table */
+#ifdef DEBUG_CACHE
 	debug("addr=%llx level=%d pte=%p (%llx)\n", start, level, pte, *pte);
-
+#endif
 	/* Maybe we need to split the block into a table */
 	if (pte_type(pte) == PTE_TYPE_BLOCK)
 		split_block(pte, level);
@@ -548,8 +568,9 @@ void mmu_set_region_dcache_behaviour(phys_addr_t start, size_t size,
 	u64 real_start = start;
 	u64 real_size = size;
 
+#ifdef DEBUG_CACHE
 	debug("start=%lx size=%lx\n", (ulong)start, (ulong)size);
-
+#endif
 	if (!gd->arch.tlb_emerg)
 		panic("Emergency page table not setup.");
 
diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index 20a4c37..d65974d 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -88,20 +88,53 @@ dtb-$(CONFIG_TEGRA) += tegra20-harmony.dtb \
 
 dtb-$(CONFIG_ARCH_MVEBU) +=			\
 	armada-3720-db.dtb			\
+	armada-3720-ddr3-db-v2-B.dtb		\
+	armada-3720-ddr3-db-v2-C.dtb		\
+	armada-3720-ddr3-db-v1-A.dtb		\
+	armada-3720-ddr3-db-v1-B.dtb		\
+	armada-3720-ddr3-db-v1-C.dtb		\
+	armada-3720-ddr4-db-v3-A.dtb		\
+	armada-3720-ddr4-db-v3-B.dtb		\
+	armada-3720-ddr4-db-v3-C.dtb		\
+	armada-3720-ddr4-db-v1-A.dtb		\
+	armada-3720-ddr4-db-v1-B.dtb		\
 	armada-3720-espressobin.dtb		\
+	armada-3720-espressobin-emmc.dtb	\
 	armada-375-db.dtb			\
 	armada-388-clearfog.dtb			\
 	armada-388-gp.dtb			\
 	armada-385-amc.dtb			\
+	armada-3900-vd-A.dtb			\
+	armada-3900-vd-B.dtb			\
+	armada-7020-amc.dtb			\
+	armada-7020-comexp.dtb                  \
+	armada-7040-pcac.dtb	                \
 	armada-7040-db.dtb			\
-	armada-7040-db-nand.dtb			\
+	armada-7040-db-B.dtb			\
+	armada-7040-db-C.dtb                    \
+	armada-7040-db-D.dtb			\
+	armada-7040-db-E.dtb			\
 	armada-8040-db.dtb			\
+	armada-8040-db-B.dtb			\
+	armada-8040-db-C.dtb			\
+	armada-8040-db-D.dtb			\
+	armada-8040-db-E.dtb			\
+	armada-8040-db-F.dtb			\
+	armada-8040-db-G.dtb			\
+	armada-8040-db-H.dtb			\
 	armada-8040-mcbin.dtb			\
+	armada-8040-mcbin-single-shot.dtb	\
+	armada-8040-ocp.dtb			\
+	armada-8040-ucpe.dtb			\
 	armada-xp-gp.dtb			\
 	armada-xp-maxbcm.dtb			\
 	armada-xp-synology-ds414.dtb		\
 	armada-xp-theadorable.dtb		\
-	armada-38x-controlcenterdc.dtb
+	armada-38x-controlcenterdc.dtb		\
+	cn9130-db-A.dtb				\
+	cn9130-db-B.dtb				\
+	cn9131-db-A.dtb				\
+	cn9131-db-B.dtb
 
 dtb-$(CONFIG_ARCH_UNIPHIER_LD11) += \
 	uniphier-ld11-global.dtb \
@@ -169,7 +202,7 @@ dtb-$(CONFIG_AM43XX) += am437x-gp-evm.dtb am437x-sk-evm.dtb	\
 	am43x-epos-evm.dtb \
 	am437x-idk-evm.dtb
 dtb-$(CONFIG_TI816X) += dm8168-evm.dtb
-dtb-$(CONFIG_THUNDERX) += thunderx-88xx.dtb
+dtb-$(CONFIG_OCTEONTX) += octeontx-88xx.dtb
 
 dtb-$(CONFIG_ARCH_SOCFPGA) +=				\
 	socfpga_arria10_socdk_sdmmc.dtb			\
diff --git a/arch/arm/dts/armada-3720-db.dts b/arch/arm/dts/armada-3720-db.dts
index 5f06252..e5cb132 100644
--- a/arch/arm/dts/armada-3720-db.dts
+++ b/arch/arm/dts/armada-3720-db.dts
@@ -49,8 +49,10 @@
 #include "armada-372x.dtsi"
 
 / {
-	model = "Marvell Armada 3720 Development Board DB-88F3720-DDR3";
-	compatible = "marvell,armada-3720-db", "marvell,armada3720", "marvell,armada3710";
+	model = "Marvell Armada 3720 Development Board DB-88F3720-DDR3-V2";
+	compatible = "marvell,armada-3720-db-v2",
+		     "marvell,armada3720",
+		     "marvell,armada3710";
 
 	chosen {
 		stdout-path = "serial0:115200n8";
@@ -66,23 +68,68 @@
 		device_type = "memory";
 		reg = <0x00000000 0x00000000 0x00000000 0x20000000>;
 	};
+
+	reg_usb3_vbus: usb3_vbus@0 {
+		compatible = "regulator-fixed";
+		regulator-name = "usb3-vbus";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		shutdown-delay-us = <1000000>;
+		gpio = <&expander0 1 GPIO_ACTIVE_HIGH>;
+	};
+
+	reg_usb2_vbus: usb2_vbus@0 {
+		compatible = "regulator-fixed";
+		regulator-name = "usb2-vbus";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		shutdown-delay-us = <1000000>;
+		gpio = <&expander0 0 GPIO_ACTIVE_HIGH>;
+	};
+
+	vcc_sd_reg0: regulator@0 {
+		compatible = "regulator-gpio";
+		regulator-name = "vcc_sd0";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-type = "voltage";
+		states = <1800000 0x1
+				  3300000 0x0>;
+		gpios = <&gpiosb 23 GPIO_ACTIVE_HIGH>;
+	};
+
+	vcc_sd_reg1: regulator@1 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_sd1";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		shutdown-delay-us = <1000000>;
+		gpio = <&expander0 4 GPIO_ACTIVE_HIGH>;
+	};
 };
 
+
 &comphy {
 	phy0 {
-		phy-type = <PHY_TYPE_PEX0>;
-		phy-speed = <PHY_SPEED_2_5G>;
+		phy-type = <COMPHY_TYPE_USB3>;
+		phy-speed = <COMPHY_SPEED_5G>;
 	};
 
 	phy1 {
-		phy-type = <PHY_TYPE_USB3_HOST0>;
-		phy-speed = <PHY_SPEED_5G>;
+		phy-type = <COMPHY_TYPE_PEX0>;
+		phy-speed = <COMPHY_SPEED_2_5G>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+		phy-speed = <COMPHY_SPEED_6G>;
+		phy-invert = <COMPHY_POLARITY_NO_INVERT>;
 	};
 };
 
 &eth0 {
 	pinctrl-names = "default";
-	pinctrl-0 = <&rgmii_pins>;
+	pinctrl-0 = <&rgmii_pins>, <&smi_pins>;
 	status = "okay";
 	phy-mode = "rgmii";
 };
@@ -91,8 +138,18 @@
 	pinctrl-names = "default";
 	pinctrl-0 = <&i2c1_pins>;
 	status = "okay";
+
+	#address-cells = <1>;
+	#size-cells = <0>;
+	expander0: pca953x@22 {
+		compatible = "nxp,pca9555";
+                #gpio-cells = <2>;
+		reg = <0x22>;
+		status = "okay";
+	};
 };
 
+
 /* CON3 */
 &sata {
 	status = "okay";
@@ -100,6 +157,10 @@
 
 &sdhci0 {
 	bus-width = <4>;
+	vqmmc-supply = <&vcc_sd_reg0>;
+	vmmc-supply = <&vcc_sd_reg1>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdio_pins>;
 	status = "okay";
 };
 
@@ -109,6 +170,8 @@
 	mmc-ddr-1_8v;
 	mmc-hs400-1_8v;
 	marvell,pad-type = "fixed-1-8v";
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc_pins>;
 	status = "okay";
 
 	#address-cells = <1>;
@@ -143,10 +206,20 @@
 
 /* CON29 */
 &usb2 {
+	vbus-supply = <&reg_usb2_vbus>;
 	status = "okay";
 };
 
 /* CON31 */
 &usb3 {
+	vbus-supply = <&reg_usb3_vbus>;
+	status = "okay";
+};
+
+/* CON17 */
+&pcie0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pcie_pins>;
+	reset-gpio = <&gpiosb 3 GPIO_ACTIVE_HIGH>;
 	status = "okay";
 };
diff --git a/arch/arm/dts/armada-3720-ddr3-db-v1-A.dts b/arch/arm/dts/armada-3720-ddr3-db-v1-A.dts
new file mode 100644
index 0000000..4fe02d0
--- /dev/null
+++ b/arch/arm/dts/armada-3720-ddr3-db-v1-A.dts
@@ -0,0 +1,43 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "armada-3720-db.dts"
+
+/* detail board setup:
+ * Pcie Jumper slot	:	DB-88F3720-PCIe-mPCIe-Jumper
+ * SGMII module slot	:	DB-88F3720-SerDes-Jumper
+ * RGMII module slot	:	DB-88F3720-PHY module
+ * eMMC slot		:	DB-88F3720-eMMC_NAND module
+ * SDIO slot		:	DB-88F3720-SDcard module
+ *
+ * PHY0 (USB3/SGMII1)	:	USB3
+ * PHY1 (PCIe/SGMII0)	:	PCIe (WiFi via mini_PCIe module)
+ * PHY2 (SATA)		:	SATA
+ * RGMII-0		:	Ethernet via PHY (1 Lane)
+ * USB2 Port 0		:	USB2 as part USB3
+ * USB2 Port 1		:	USB2 Host
+ * eMMC*		:	eMMC NAND,
+				connected to SD / eMMC Host 1 in North Bridge
+ * SDIO*		:	SD card,
+				connected to SDIO Host 0 in South Bridge
+ */
+
+/ {
+	model = "Marvell Armada 3720 Development Board DB-88F3720-DDR3-V1";
+	compatible = "marvell,armada-3720-db-v1",
+		     "marvell,armada3720",
+		     "marvell,armada3710";
+
+	soc {
+		internal-regs {
+			comphy: comphy@18300 {
+				phy2 {
+					phy-invert =
+						<COMPHY_POLARITY_TXD_INVERT>;
+				};
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/armada-3720-ddr3-db-v1-B.dts b/arch/arm/dts/armada-3720-ddr3-db-v1-B.dts
new file mode 100644
index 0000000..11122f9
--- /dev/null
+++ b/arch/arm/dts/armada-3720-ddr3-db-v1-B.dts
@@ -0,0 +1,55 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "armada-3720-ddr3-db-v1-A.dts"
+
+/* detail board setup:
+ * Pcie Jumper slot	:	DB-88F3720-PCIe-mPCIe-Jumper
+ * SGMII module slot	:	DB-88F3720-SerDes-Jumper
+ * RGMII module slot	:	DB-88F3720-PHY module
+ * eMMC slot		:	DB-88F3720-eMMC_NAND module
+ * SDIO slot		:	DB-88F3720-SDcard module
+ *
+ * PHY0 (USB3/SGMII1)	:	SGMII1_Ethernet via PHY (1 Lane)
+ * PHY1 (PCIe/SGMII0)	:	PCIe (WiFi via mini_PCIe module)
+ * PHY2 (SATA)		:	SATA
+ * RGMII		:	Ethernet via PHY (1 Lane)
+ * USB2 Port 0		:	USB2 only
+ * USB2 Port 1		:	USB2 Host
+ * eMMC*		:	eMMC NAND,
+				connected to SD / eMMC Host 1 in North Bridge
+ * SDIO*		:	SD card,
+				connected to SDIO Host 0 in South Bridge
+ */
+
+/ {
+	model = "Marvell Armada 3720 Development Board DB-88F3720-DDR3-V1-B";
+	compatible = "marvell,armada-3720-db-v1",
+		     "marvell,armada3720",
+		     "marvell,armada3710";
+
+	soc {
+		internal-regs {
+			comphy: comphy@18300 {
+				phy0 {
+					phy-type = <COMPHY_TYPE_SGMII1>;
+					phy-speed = <COMPHY_SPEED_1_25G>;
+				};
+			};
+			mdio@32004 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				ethphy1: ethernet-phy@1 {
+					reg = <1>;
+				};
+			};
+			eth1: neta@40000 {
+				status = "okay";
+				phy-mode = "sgmii";
+				phy = <&ethphy1>;
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/armada-3720-ddr3-db-v1-C.dts b/arch/arm/dts/armada-3720-ddr3-db-v1-C.dts
new file mode 100644
index 0000000..e17d5c2
--- /dev/null
+++ b/arch/arm/dts/armada-3720-ddr3-db-v1-C.dts
@@ -0,0 +1,62 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "armada-3720-ddr3-db-v1-A.dts"
+
+/* detail board setup:
+ * Pcie Jumper slot	:	DB-88F3720-PCIe-mPCIe-Jumper
+ * SGMII module slot	:	DB-88F3720-SerDes-Jumper
+ * RGMII module slot	:	DB-88F3720-PHY module
+ * eMMC slot		:	DB-88F3720-eMMC_NAND module
+ * SDIO slot		:	DB-88F3720-SDcard module
+ *
+ * PHY0 (USB3/SGMII1)	:	SGMII1_Ethernet via SFP2.5G (1 Lane)
+ * PHY1 (PCIe/SGMII0)	:	PCIe (WiFi via mini_PCIe module)
+ * PHY2 (SATA)		:	SATA
+ * RGMII		:	Ethernet via PHY (1 Lane)
+ * USB2 Port 0		:	USB2 only
+ * USB2 Port 1		:	USB2 Host
+ * eMMC*		:	eMMC NAND,
+				connected to SD / eMMC Host 1 in North Bridge
+ * SDIO*		:	SD card,
+				connected to SDIO Host 0 in South Bridge
+ */
+
+/ {
+	model = "Marvell Armada 3720 Development Board DB-88F3720-DDR3-V1-C";
+	compatible = "marvell,armada-3720-db-v1",
+		     "marvell,armada3720",
+		     "marvell,armada3710";
+
+	soc {
+		internal-regs {
+			comphy: comphy@18300 {
+				phy0 {
+					phy-type = <COMPHY_TYPE_SGMII1>;
+					phy-speed = <COMPHY_SPEED_3_125G>;
+				};
+			};
+			eth1: neta@40000 {
+				status = "okay";
+				phy-mode = "sgmii";
+				fixed-link {
+					/* Here "speed" is set to 1000, GBE MAC
+					 * is running in 1G mode, but the
+					 * actuall PHY speed may be 1 Gbps or
+					 * 2.5 Gbps, it's up to the
+					 * corresponding SERDES speed in comphy
+					 * node.
+					 * If SERDES speed is set to 3.125G, it
+					 * implies sgmii 2.5 Gbps;
+					 * if SERDES speed is set to 1.25G, it
+					 * implies sgmii 1 Gbps.
+					 */
+					speed = <1000>;
+					full-duplex;
+				};
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/armada-3720-ddr3-db-v2-B.dts b/arch/arm/dts/armada-3720-ddr3-db-v2-B.dts
new file mode 100644
index 0000000..6f16c82
--- /dev/null
+++ b/arch/arm/dts/armada-3720-ddr3-db-v2-B.dts
@@ -0,0 +1,55 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "armada-3720-db.dts"
+
+/* detail board setup:
+ * Pcie Jumper slot	:	DB-88F3720-PCIe-mPCIe-Jumper
+ * SGMII module slot	:	DB-88F3720-SerDes-Jumper
+ * RGMII module slot	:	DB-88F3720-PHY module
+ * eMMC slot		:	DB-88F3720-eMMC_NAND module
+ * SDIO slot		:	DB-88F3720-SDcard module
+ *
+ * PHY0 (USB3/SGMII1)	:	SGMII1_Ethernet via PHY (1 Lane)
+ * PHY1 (PCIe/SGMII0)	:	PCIe (WiFi via mini_PCIe module)
+ * PHY2 (SATA)		:	SATA
+ * RGMII		:	Ethernet via PHY (1 Lane)
+ * USB2 Port 0		:	USB2 only
+ * USB2 Port 1		:	USB2 Host
+ * eMMC*		:	eMMC NAND,
+				connected to SD / eMMC Host 1 in North Bridge
+ * SDIO*		:	SD card,
+				connected to SDIO Host 0 in South Bridge
+ */
+
+/ {
+	model = "Marvell Armada 3720 Development Board DB-88F3720-DDR3-V2-B";
+	compatible = "marvell,armada-3720-db-v2",
+		     "marvell,armada3720",
+		     "marvell,armada3710";
+
+	soc {
+		internal-regs {
+			comphy: comphy@18300 {
+				phy0 {
+					phy-type = <COMPHY_TYPE_SGMII1>;
+					phy-speed = <COMPHY_SPEED_1_25G>;
+				};
+			};
+			mdio@32004 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				ethphy1: ethernet-phy@1 {
+					reg = <1>;
+				};
+			};
+			eth1: neta@40000 {
+				status = "okay";
+				phy-mode = "sgmii";
+				phy = <&ethphy1>;
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/armada-3720-ddr3-db-v2-C.dts b/arch/arm/dts/armada-3720-ddr3-db-v2-C.dts
new file mode 100644
index 0000000..3b5b764
--- /dev/null
+++ b/arch/arm/dts/armada-3720-ddr3-db-v2-C.dts
@@ -0,0 +1,62 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "armada-3720-db.dts"
+
+/* detail board setup:
+ * Pcie Jumper slot	:	DB-88F3720-PCIe-mPCIe-Jumper
+ * SGMII module slot	:	DB-88F3720-SerDes-Jumper
+ * RGMII module slot	:	DB-88F3720-PHY module
+ * eMMC slot		:	DB-88F3720-eMMC_NAND module
+ * SDIO slot		:	DB-88F3720-SDcard module
+ *
+ * PHY0 (USB3/SGMII1)	:	SGMII1_Ethernet via SFP2.5G (1 Lane)
+ * PHY1 (PCIe/SGMII0)	:	PCIe (WiFi via mini_PCIe module)
+ * PHY2 (SATA)		:	SATA
+ * RGMII		:	Ethernet via PHY (1 Lane)
+ * USB2 Port 0		:	USB2 only
+ * USB2 Port 1		:	USB2 Host
+ * eMMC*		:	eMMC NAND,
+				connected to SD / eMMC Host 1 in North Bridge
+ * SDIO*		:	SD card,
+				connected to SDIO Host 0 in South Bridge
+*/
+
+/ {
+	model = "Marvell Armada 3720 Development Board DB-88F3720-DDR3-V2-C";
+	compatible = "marvell,armada-3720-db-v2",
+		     "marvell,armada3720",
+		     "marvell,armada3710";
+
+	soc {
+		internal-regs {
+			comphy: comphy@18300 {
+				phy0 {
+					phy-type = <COMPHY_TYPE_SGMII1>;
+					phy-speed = <COMPHY_SPEED_3_125G>;
+				};
+			};
+			eth1: neta@40000 {
+				status = "okay";
+				phy-mode = "sgmii";
+				fixed-link {
+					/* Here "speed" is set to 1000, GBE MAC
+					 * is running in 1G mode, but the
+					 * actuall PHY speed may be 1 Gbps or
+					 * 2.5 Gbps, it's up to the
+					 * corresponding SERDES speed in comphy
+					 * node.
+					 * If SERDES speed is set to 3.125G, it
+					 * implies sgmii 2.5 Gbps;
+					 * if SERDES speed is set to 1.25G, it
+					 * implies sgmii 1 Gbps.
+					 */
+					speed = <1000>;
+					full-duplex;
+				};
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/armada-3720-ddr4-db-v1-A.dts b/arch/arm/dts/armada-3720-ddr4-db-v1-A.dts
new file mode 100644
index 0000000..7654569
--- /dev/null
+++ b/arch/arm/dts/armada-3720-ddr4-db-v1-A.dts
@@ -0,0 +1,47 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "armada-3720-ddr3-db-v1-A.dts"
+
+/* detail board setup:
+ * Pcie Jumper slot	:	DB-88F3720-PCIe-mPCIe-Jumper
+ * SGMII module slot	:	DB-88F3720-SerDes-Jumper
+ * RGMII module slot	:	DB-88F3720-PHY module
+ * eMMC slot		:	DB-88F3720-eMMC_NAND module
+ * SDIO slot		:	DB-88F3720-SDcard module
+ *
+ * PHY0 (USB3/SGMII1)	:	USB3
+ * PHY1 (PCIe/SGMII0)	:	PCIe (WiFi via mini_PCIe module)
+ * PHY2 (SATA)		:	SATA
+ * RGMII-0		:	Ethernet via PHY (1 Lane)
+ * USB2 Port 0		:	USB2 as part USB3
+ * USB2 Port 1		:	USB2 Host
+ * eMMC*		:	eMMC NAND,
+				connected to SD / eMMC Host 1 in North Bridge
+ * SDIO*		:	SD card,
+				connected to SDIO Host 0 in South Bridge
+ */
+
+/ {
+	model = "Marvell Armada 3720 Development Board DB-88F3720-DDR4-V1";
+	compatible = "marvell,armada-3720-db-v2",
+		     "marvell,armada3720",
+		     "marvell,armada3710";
+
+	soc {
+		internal-regs {
+			comphy: comphy@18300 {
+				phy2 {
+					phy-invert =
+						<COMPHY_POLARITY_NO_INVERT>;
+				};
+			};
+		};
+	};
+
+	vcc_sd_reg0: regulator@0 {
+		gpios = <&gpiosb 22 GPIO_ACTIVE_HIGH>;
+	};
+};
diff --git a/arch/arm/dts/armada-3720-ddr4-db-v1-B.dts b/arch/arm/dts/armada-3720-ddr4-db-v1-B.dts
new file mode 100644
index 0000000..2e73878
--- /dev/null
+++ b/arch/arm/dts/armada-3720-ddr4-db-v1-B.dts
@@ -0,0 +1,56 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "armada-3720-ddr4-db-v1-A.dts"
+
+/* detail board setup:
+ * Pcie Jumper slot	:	DB-88F3720-PCIe-mPCIe-Jumper
+ * SGMII module slot	:	DB-88F3720-SerDes-Jumper
+ * RGMII module slot	:	DB-88F3720-PHY module
+ * eMMC slot		:	DB-88F3720-eMMC_NAND module
+ * SDIO slot		:	DB-88F3720-SDcard module
+ *
+ * PHY0 (USB3/SGMII1)	:	SGMII1
+ * PHY1 (PCIe/SGMII0)	:	PCIe (WiFi via mini_PCIe module)
+ * PHY2 (SATA)		:	SATA
+ * RGMII-0		:	Ethernet via PHY (1 Lane)
+ * USB2 Port 0		:	USB2 as part USB3
+ * USB2 Port 1		:	USB2 Host
+ * eMMC*		:	eMMC NAND,
+				connected to SD / eMMC Host 1 in North Bridge
+ * SDIO*		:	SD card,
+				connected to SDIO Host 0 in South Bridge
+ */
+
+/ {
+	model = "Marvell Armada 3720 Development Board DB-88F3720-DDR4-V1-B";
+	compatible = "marvell,armada-3720-db-v2",
+		     "marvell,armada3720",
+		     "marvell,armada3710";
+
+	soc {
+		internal-regs {
+			comphy: comphy@18300 {
+				phy0 {
+					phy-type = <COMPHY_TYPE_SGMII1>;
+					phy-speed = <COMPHY_SPEED_1_25G>;
+				};
+			};
+			mdio@32004 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				ethphy1: ethernet-phy@1 {
+					reg = <1>;
+				};
+			};
+			eth1: neta@40000 {
+				status = "okay";
+				phy-mode = "sgmii";
+				phy = <&ethphy1>;
+			};
+		};
+	};
+
+};
diff --git a/arch/arm/dts/armada-3720-ddr4-db-v3-A.dts b/arch/arm/dts/armada-3720-ddr4-db-v3-A.dts
new file mode 100644
index 0000000..a956ec6
--- /dev/null
+++ b/arch/arm/dts/armada-3720-ddr4-db-v3-A.dts
@@ -0,0 +1,33 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "armada-3720-db.dts"
+
+/* detail board setup:
+ * Pcie Jumper slot	:	DB-88F3720-PCIe-mPCIe-Jumper
+ * SGMII module slot	:	DB-88F3720-SerDes-Jumper
+ * RGMII module slot	:	DB-88F3720-PHY module
+ * eMMC slot		:	DB-88F3720-eMMC_NAND module
+ * SDIO slot		:	DB-88F3720-SDcard module
+ *
+ * PHY0 (USB3/SGMII1)	:	USB3
+ * PHY1 (PCIe/SGMII0)	:	PCIe (WiFi via mini_PCIe module)
+ * PHY2 (SATA)		:	SATA
+ * RGMII-0		:	Ethernet via PHY (1 Lane)
+ * USB2 Port 0		:	USB2 as part USB3
+ * USB2 Port 1		:	USB2 Host
+ * eMMC*		:	eMMC NAND,
+				connected to SD / eMMC Host 1 in North Bridge
+ * SDIO*		:	SD card,
+				connected to SDIO Host 0 in South Bridge
+ */
+
+/ {
+	model = "Marvell Armada 3720 Development Board DB-88F3720-DDR4-V3";
+	compatible = "marvell,armada-3720-db-v3",
+		     "marvell,armada3720",
+		     "marvell,armada3710";
+
+};
diff --git a/arch/arm/dts/armada-3720-ddr4-db-v3-B.dts b/arch/arm/dts/armada-3720-ddr4-db-v3-B.dts
new file mode 100644
index 0000000..85530f7
--- /dev/null
+++ b/arch/arm/dts/armada-3720-ddr4-db-v3-B.dts
@@ -0,0 +1,56 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "armada-3720-ddr4-db-v3-A.dts"
+
+/* detail board setup:
+ * Pcie Jumper slot	:	DB-88F3720-PCIe-mPCIe-Jumper
+ * SGMII module slot	:	DB-88F3720-SerDes-Jumper
+ * RGMII module slot	:	DB-88F3720-PHY module
+ * eMMC slot		:	DB-88F3720-eMMC_NAND module
+ * SDIO slot		:	DB-88F3720-SDcard module
+ *
+ * PHY0 (USB3/SGMII1)	:	SGMII1
+ * PHY1 (PCIe/SGMII0)	:	PCIe (WiFi via mini_PCIe module)
+ * PHY2 (SATA)		:	SATA
+ * RGMII-0		:	Ethernet via PHY (1 Lane)
+ * USB2 Port 0		:	USB2 as part USB3
+ * USB2 Port 1		:	USB2 Host
+ * eMMC*		:	eMMC NAND,
+				connected to SD / eMMC Host 1 in North Bridge
+ * SDIO*		:	SD card,
+				connected to SDIO Host 0 in South Bridge
+ */
+
+/ {
+	model = "Marvell Armada 3720 Development Board DB-88F3720-DDR4-V3-B";
+	compatible = "marvell,armada-3720-db-v3",
+		     "marvell,armada3720",
+		     "marvell,armada3710";
+
+	soc {
+		internal-regs {
+			comphy: comphy@18300 {
+				phy0 {
+					phy-type = <COMPHY_TYPE_SGMII1>;
+					phy-speed = <COMPHY_SPEED_1_25G>;
+				};
+			};
+			mdio@32004 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				ethphy1: ethernet-phy@1 {
+					reg = <1>;
+				};
+			};
+			eth1: neta@40000 {
+				status = "okay";
+				phy-mode = "sgmii";
+				phy = <&ethphy1>;
+			};
+		};
+	};
+
+};
diff --git a/arch/arm/dts/armada-3720-ddr4-db-v3-C.dts b/arch/arm/dts/armada-3720-ddr4-db-v3-C.dts
new file mode 100644
index 0000000..1fa8b54
--- /dev/null
+++ b/arch/arm/dts/armada-3720-ddr4-db-v3-C.dts
@@ -0,0 +1,63 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "armada-3720-ddr4-db-v3-A.dts"
+
+/* detail board setup:
+ * Pcie Jumper slot	:	DB-88F3720-PCIe-mPCIe-Jumper
+ * SGMII module slot	:	DB-88F3720-SerDes-Jumper
+ * RGMII module slot	:	DB-88F3720-PHY module
+ * eMMC slot		:	DB-88F3720-eMMC_NAND module
+ * SDIO slot		:	DB-88F3720-SDcard module
+ *
+ * PHY0 (USB3/SGMII1)	:	SGMII1 via SFP2.5G (1 Lane)
+ * PHY1 (PCIe/SGMII0)	:	PCIe (WiFi via mini_PCIe module)
+ * PHY2 (SATA)		:	SATA
+ * RGMII-0		:	Ethernet via PHY (1 Lane)
+ * USB2 Port 0		:	USB2 as part USB3
+ * USB2 Port 1		:	USB2 Host
+ * eMMC*		:	eMMC NAND,
+				connected to SD / eMMC Host 1 in North Bridge
+ * SDIO*		:	SD card,
+				connected to SDIO Host 0 in South Bridge
+ */
+
+/ {
+	model = "Marvell Armada 3720 Development Board DB-88F3720-DDR4-V3-C";
+	compatible = "marvell,armada-3720-db-v3",
+		     "marvell,armada3720",
+		     "marvell,armada3710";
+
+	soc {
+		internal-regs {
+			comphy: comphy@18300 {
+				phy0 {
+					phy-type = <COMPHY_TYPE_SGMII1>;
+					phy-speed = <COMPHY_SPEED_3_125G>;
+				};
+			};
+			eth1: neta@40000 {
+				status = "okay";
+				phy-mode = "sgmii";
+				fixed-link {
+					/* Here "speed" is set to 1000, GBE MAC
+					 * is running in 1G mode, but the
+					 * actuall PHY speed may be 1 Gbps or
+					 * 2.5 Gbps, it's up to the
+					 * corresponding SERDES speed in comphy
+					 * node.
+					 * If SERDES speed is set to 3.125G, it
+					 * implies sgmii 2.5 Gbps;
+					 * if SERDES speed is set to 1.25G, it
+					 * implies sgmii 1 Gbps.
+					 */
+					speed = <1000>;
+					full-duplex;
+				};
+			};
+		};
+	};
+
+};
diff --git a/arch/arm/dts/armada-3720-espressobin-emmc.dts b/arch/arm/dts/armada-3720-espressobin-emmc.dts
new file mode 100644
index 0000000..0dd59af
--- /dev/null
+++ b/arch/arm/dts/armada-3720-espressobin-emmc.dts
@@ -0,0 +1,19 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "armada-3720-espressobin.dts"
+
+/ {
+	model = "Marvell Armada 3720 Community Board ESPRESSOBin (eMMC)";
+	compatible = "marvell,armada-3720-espressobin",
+		     "marvell,armada-3720-espressobin-emmc",
+		     "marvell,armada3720", "marvell,armada3710";
+
+};
+
+/* U11 */
+&sdhci1 {
+	status = "okay";
+};
diff --git a/arch/arm/dts/armada-3720-espressobin.dts b/arch/arm/dts/armada-3720-espressobin.dts
index aa6587a..2ab039c 100644
--- a/arch/arm/dts/armada-3720-espressobin.dts
+++ b/arch/arm/dts/armada-3720-espressobin.dts
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Device Tree file for Marvell Armada 3720 community board
  * (ESPRESSOBin)
@@ -5,53 +6,15 @@
  *
  * Gregory CLEMENT <gregory.clement@free-electrons.com>
  * Konstantin Porotchkin <kostap@marvell.com>
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPL or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This file is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This file is distributed in the hope that it will be useful
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED , WITHOUT WARRANTY OF ANY KIND
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
  */
-
 /dts-v1/;
 
 #include "armada-372x.dtsi"
 
 / {
 	model = "Marvell Armada 3720 Community Board ESPRESSOBin";
-	compatible = "marvell,armada-3720-espressobin", "marvell,armada3720", "marvell,armada3710";
+	compatible = "marvell,armada-3720-espressobin",
+		     "marvell,armada3720", "marvell,armada3710";
 
 	chosen {
 		stdout-path = "serial0:115200n8";
@@ -67,30 +30,59 @@
 		device_type = "memory";
 		reg = <0x00000000 0x00000000 0x00000000 0x20000000>;
 	};
+
+	vcc_sd_reg0: regulator@0 {
+		compatible = "regulator-gpio";
+		regulator-name = "vcc_sd0";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-type = "voltage";
+		states = <1800000 0x1
+			  3300000 0x0>;
+		gpios = <&gpionb 4 GPIO_ACTIVE_HIGH>;
+	};
+
+	mdio@32004 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		status = "okay";
+
+		mvswitch: switch@000000{
+			compatible = "marvell,mv88e6xxx";
+			status = "okay";
+			phy-addr = <1>;
+			cpu-port = <0x0>;
+			port-mask = <0xf>;
+		};
+	};
 };
 
 &comphy {
 	max-lanes = <3>;
 	phy0 {
-		phy-type = <PHY_TYPE_PEX0>;
-		phy-speed = <PHY_SPEED_2_5G>;
+		phy-type = <COMPHY_TYPE_USB3>;
+		phy-speed = <COMPHY_SPEED_5G>;
 	};
 
 	phy1 {
-		phy-type = <PHY_TYPE_USB3_HOST0>;
-		phy-speed = <PHY_SPEED_5G>;
+		phy-type = <COMPHY_TYPE_PEX0>;
+		phy-speed = <COMPHY_SPEED_2_5G>;
 	};
 
 	phy2 {
-		phy-type = <PHY_TYPE_SATA0>;
-		phy-speed = <PHY_SPEED_5G>;
+		phy-type = <COMPHY_TYPE_SATA0>;
+		phy-speed = <COMPHY_SPEED_6G>;
 	};
 };
 
 &eth0 {
 	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&rgmii_pins>, <&smi_pins>;
 	phy-mode = "rgmii";
 	phy_addr = <0x1>;
+	phy = <&mvswitch>;
+
 	fixed-link {
 		speed = <1000>;
 		full-duplex;
@@ -98,6 +90,8 @@
 };
 
 &i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c1_pins>;
 	status = "okay";
 };
 
@@ -106,8 +100,38 @@
 	status = "okay";
 };
 
+/* J1 */
+&sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdio_pins>;
+	bus-width = <4>;
+	vqmmc-supply = <&vcc_sd_reg0>;
+	status = "okay";
+};
+
+/* U11 */
+&sdhci1 {
+	non-removable;
+	bus-width = <8>;
+	mmc-ddr-1_8v;
+	mmc-hs400-1_8v;
+	marvell,pad-type = "fixed-1-8v";
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc_pins>;
+	status = "disabled";
+
+	#address-cells = <1>;
+	#size-cells = <0>;
+	mmccard: mmccard@0 {
+		compatible = "mmc-card";
+		reg = <0>;
+	};
+};
+
 &spi0 {
 	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi_quad_pins>;
 
 	spi-flash@0 {
 		#address-cells = <1>;
@@ -121,6 +145,8 @@
 
 /* Exported on the micro USB connector CON32 through an FTDI */
 &uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart1_pins>;
 	status = "okay";
 };
 
@@ -133,3 +159,10 @@
 &usb3 {
 	status = "okay";
 };
+
+&pcie0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pcie_pins>;
+	reset-gpio = <&gpiosb 3 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+};
diff --git a/arch/arm/dts/armada-375-db.dts b/arch/arm/dts/armada-375-db.dts
index 343349b..7571bac 100644
--- a/arch/arm/dts/armada-375-db.dts
+++ b/arch/arm/dts/armada-375-db.dts
@@ -171,6 +171,8 @@
 			};
 
 			mdio {
+				status = "okay";
+
 				phy0: ethernet-phy@0 {
 					reg = <0>;
 				};
diff --git a/arch/arm/dts/armada-37xx.dtsi b/arch/arm/dts/armada-37xx.dtsi
index 6902342..bf9cf7d 100644
--- a/arch/arm/dts/armada-37xx.dtsi
+++ b/arch/arm/dts/armada-37xx.dtsi
@@ -46,6 +46,7 @@
 
 #include <dt-bindings/interrupt-controller/arm-gic.h>
 #include <dt-bindings/comphy/comphy_data.h>
+#include <dt-bindings/gpio/gpio.h>
 
 / {
 	model = "Marvell Armada 37xx SoC";
@@ -154,6 +155,11 @@
 					groups = "uart2";
 					function = "uart";
 				};
+
+				mmc_pins: mmc-pins {
+					groups = "emmc_nb";
+					function = "emmc";
+				};
 			};
 
 			pinctrl_sb: pinctrl-sb@18800 {
@@ -162,7 +168,7 @@
 				reg = <0x18800 0x100>, <0x18C00 0x20>;
 				gpiosb: gpiosb {
 					#gpio-cells = <2>;
-					gpio-ranges = <&pinctrl_sb 0 0 29>;
+					gpio-ranges = <&pinctrl_sb 0 0 30>;
 					gpio-controller;
 					interrupts =
 					<GIC_SPI 160 IRQ_TYPE_LEVEL_HIGH>,
@@ -177,6 +183,20 @@
 					function = "mii";
 				};
 
+				smi_pins: smi-pins {
+					groups = "smi";
+					function = "smi";
+				};
+
+				sdio_pins: sdio-pins {
+					groups = "sdio_sb";
+					function = "sdio";
+				};
+
+				pcie_pins: pcie-pins {
+					groups = "pcie1";
+					function = "gpio";
+				};
 			};
 
 			usb3: usb@58000 {
@@ -266,27 +286,29 @@
 				status = "disabled";
 			};
 
-			pinctl0: pinctl@13830 { /* north bridge */
-				compatible = "marvell,armada-3700-pinctl";
-				bank-name = "armada-3700-nb";
-				reg = <0x13830 0x4>;
-				pin-count = <36>;
-			};
-
-			pinctl1: pinctl@18830 { /* south bridge */
-				compatible = "marvell,armada-3700-pinctl";
-				bank-name = "armada-3700-sb";
-				reg = <0x18830 0x4>;
-				pin-count = <30>;
-			};
-
 			comphy: comphy@18300 {
 				compatible = "marvell,mvebu-comphy", "marvell,comphy-armada-3700";
 				reg = <0x18300 0x28>,
 				      <0x1f300 0x3d000>;
-				mux-bitcount = <1>;
-				max-lanes = <2>;
+				mux-bitcount = <4>;
+				max-lanes = <3>;
 			};
 		};
+
+		pcie0: pcie@d0070000 {
+			compatible = "marvell,armada-37xx-pcie";
+			reg = <0 0xd0070000 0 0x20000>;
+			#address-cells = <3>;
+			#size-cells = <2>;
+			device_type = "pci";
+			num-lanes = <1>;
+			status = "disabled";
+
+			bus-range = <0 0xff>;
+			ranges = <0x82000000 0 0xe8000000
+				 0 0xe8000000 0 0x1000000 /* Port 0 MEM */
+				 0x81000000 0 0xe9000000
+				 0 0xe9000000 0 0x10000>; /* Port 0 IO*/
+		};
 	};
 };
diff --git a/arch/arm/dts/armada-388-gp.dts b/arch/arm/dts/armada-388-gp.dts
index 7bc878f..d3c31b5 100644
--- a/arch/arm/dts/armada-388-gp.dts
+++ b/arch/arm/dts/armada-388-gp.dts
@@ -55,6 +55,7 @@
 		ethernet0 = &eth0;
 		ethernet1 = &eth1;
 		spi0 = &spi0;
+		fuse0 = &efuse;
 	};
 
 	memory {
@@ -232,6 +233,11 @@
 				vcc-supply = <&reg_usb3_vbus>;
 				status = "okay";
 			};
+
+			efuse@f9000 {
+				status = "okay";
+			};
+
 		};
 
 		pcie-controller {
diff --git a/arch/arm/dts/armada-38x.dtsi b/arch/arm/dts/armada-38x.dtsi
index 5e5a158..cd6c405 100644
--- a/arch/arm/dts/armada-38x.dtsi
+++ b/arch/arm/dts/armada-38x.dtsi
@@ -594,6 +594,14 @@
 				clocks = <&gateclk 10>;
 				status = "disabled";
 			};
+
+			efuse: efuse@f9000 {
+				compatible = "marvell,mvebu-fuse-hd";
+				reg = <0xe4008 0x4>;
+				otp-mem = <0xf9000>;
+				rows-count = <64>;
+				status = "disabled";
+			};
 		};
 	};
 
diff --git a/arch/arm/dts/armada-3900-db.dtsi b/arch/arm/dts/armada-3900-db.dtsi
new file mode 100644
index 0000000..0ddfa65
--- /dev/null
+++ b/arch/arm/dts/armada-3900-db.dtsi
@@ -0,0 +1,235 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "armada-3900.dtsi" /* include SoC device tree */
+
+/ {
+	model = "DB-ARMADA-3900";
+	compatible = "marvell,armada7040", "marvell,armada-ap806-quad",
+		     "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &ap_spi0;
+		fuse0 = &ap_hd_efuse0;	/* banks 0-63 RW */
+		fuse1 = &ap_ld_efuse0;	/* bank 64 RO */
+		fuse2 = &ap_ld_efuse1;	/* bank 65 RW */
+		fuse3 = &cp0_ld_efuse0;	/* bank 66 RO */
+		fuse4 = &cp0_ld_efuse1;	/* bank 67 RW */
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+
+	cp0 {
+		config-space {
+			cp0_reg_usb3_vbus0: cp0_usb3_vbus@0 {
+				compatible = "regulator-fixed";
+				pinctrl-names = "default";
+				pinctrl-0 = <&cp0_xhci0_vbus_pins>;
+				regulator-name = "cp0-xhci0-vbus";
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5000000>;
+				startup-delay-us = <100000>;
+				enable-active-high;
+				regulator-force-boot-off;
+				gpio = <&cp0_gpio1 12 GPIO_ACTIVE_HIGH>;
+			};
+
+			cp0_reg_usb3_vbus1: cp0_usb3_vbus@1 {
+				compatible = "regulator-fixed";
+				pinctrl-names = "default";
+				pinctrl-0 = <&cp0_xhci1_vbus_pins>;
+				regulator-name = "cp0-xhci1-vbus";
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5000000>;
+				startup-delay-us = <100000>;
+				enable-active-high;
+				regulator-force-boot-off;
+				gpio = <&cp0_gpio1 13 GPIO_ACTIVE_HIGH>;
+			};
+		};
+	};
+};
+
+/*
+ * AP related configuration
+ */
+&ap_pinctl {
+		/* MPP Bus:
+		 * SPI   [0-3]
+		 * I2C   [4-5]
+		 * UART0 [11,19]
+		 */
+		/*   0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 3 3 3 3 3 3 0 0 0 0
+		     0 3 0 0 0 0 0 0 0 3 >;
+};
+
+&ap_spi0 {
+	status = "okay";
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
+/*
+ * CP related configuration
+ */
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_nand {
+	nand-ecc-strength = <8>;
+};
+
+&cp0_pinctl {
+	cp0_xhci0_vbus_pins: cp0-xhci0-vbus-pins {
+		marvell,pins = <44>;
+		marvell,function = <0>;
+	};
+
+	cp0_xhci1_vbus_pins: cp0-xhci1-vbus-pins {
+		marvell,pins = <45>;
+		marvell,function = <0>;
+	};
+
+	cp0_mochi_reset_pins: cp0-mochi-reset-pins {
+		marvell,pins = <56>;
+		marvell,function = <0>;
+	};
+
+	cp0_mochi_enable_pins: cp0-mochi-enable-pins {
+		marvell,pins = <57>;
+		marvell,function = <0>;
+	};
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_utmi1 {
+	status = "okay";
+};
+
+&cp0_usb3_0 {
+	status = "okay";
+	vbus-supply = <&cp0_reg_usb3_vbus0>;
+	vbus-disable-delay = <500>;
+};
+
+&cp0_usb3_1 {
+	status = "okay";
+	vbus-supply = <&cp0_reg_usb3_vbus1>;
+	vbus-disable-delay = <500>;
+};
+
+&cp0_pcie0 {
+	status = "okay";
+	ranges =
+		/* downstream I/O */
+		<0x81000000 0 0xf7000000 0  0xf7000000 0 0x10000
+		/* non-prefetchable memory */
+		0x82000000 0 0xf6000000 0  0xf6000000 0 0xf00000>;
+};
+
+&cp0_pcie2 {
+	status = "okay";
+	ranges =
+		/* downstream I/O */
+		<0x81000000 0 0xf7020000 0  0xf7020000 0 0x10000
+		/* non-prefetchable memory */
+		0x82000000 0 0xf8000000 0  0xf8000000 0 0xf00000>;
+};
+
+&cp0_comphy {
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+		phy-speed = <COMPHY_SPEED_5G>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+		phy-speed = <COMPHY_SPEED_5G>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_SGMII0>;
+		phy-speed = <COMPHY_SPEED_1_25G>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_SGMII1>;
+		phy-speed = <COMPHY_SPEED_1_25G>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+		phy-speed = <COMPHY_SPEED_5G>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+		phy-speed = <COMPHY_SPEED_5G>;
+	};
+};
+
+&cp0_xmdio {
+	status = "okay";
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sgmii";
+	phy = <&phy0>;
+};
+
+&cp0_eth1 {
+	status = "okay";
+	phy-mode = "sgmii";
+	phy = <&phy1>;
+};
+
diff --git a/arch/arm/dts/armada-3900-vd-A.dts b/arch/arm/dts/armada-3900-vd-A.dts
new file mode 100644
index 0000000..52c3808
--- /dev/null
+++ b/arch/arm/dts/armada-3900-vd-A.dts
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include "armada-3900-db.dtsi"
+
+/ {
+	model = "Marvell Armada 3900 Validation Development board (CP NOR) setup(A)";
+	compatible = "marvell,armada3900-vd", "marvell,armada7040",
+		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
+
+	aliases {
+		i2c1 = &ap_i2c0;
+	};
+};
+
+/*
+ * AP related configuration
+ */
+&ap_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ap_i2c0_pins>;
+	status = "okay";
+};
+
+/*
+ * CP related configuration
+ */
+&cp0_pinctl {
+		/* MPP Bus:
+		 *   NAND	[13,15-27]
+		 *   SMI	[32,34]
+		 *   XSMI	[35-36]
+		 *   I2C0	[37-38]
+		 *   USB	[44-45]
+		 *   UART1	[46-47,49,58]
+		 *   IHB	[56-57]
+		 *   UART0	[59-62]
+		 */
+		/*   0   1   2   3   4   5   6   7   8   9 */
+	pin-func = < 0   0   0   0   0   0   0   0   0   0
+		     0   0   0   2   0   1   1   1   1   1
+		     1   1   1   1   1   1   1   1   0   0
+		     0   0   7   0   7   7   7   2   2   0
+		     0   0   0   0   0   0   7   7   0   7
+		     0   0   0   0   0   0   0   0   7   7
+		     7   7   7>;
+};
+
+&cp0_nand {
+	status = "okay";
+};
+
+&cp0_comphy {
+
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_USB3_HOST0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_5_15625G>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_UNCONNECTED>;
+		/delete-property/phy-speed;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI1>;
+		phy-speed = <COMPHY_SPEED_5_15625G>;
+	};
+};
+
+&cp0_xmdio {
+	status = "okay";
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi";
+	phy = <&phy0>;
+};
+
+&cp0_eth1 {
+	status = "okay";
+	phy-mode = "sfi";
+	phy = <&phy1>;
+};
diff --git a/arch/arm/dts/armada-3900-vd-B.dts b/arch/arm/dts/armada-3900-vd-B.dts
new file mode 100644
index 0000000..7c51076
--- /dev/null
+++ b/arch/arm/dts/armada-3900-vd-B.dts
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include "armada-3900-db.dtsi"
+
+/ {
+	model = "Marvell Armada 3900 Validation Development board(CP NOR) setup(B)";
+	compatible = "marvell,armada3900-vd", "marvell,armada7040",
+		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
+
+	aliases {
+		i2c1 = &ap_i2c0;
+	};
+};
+
+/*
+ * AP related configuration
+ */
+&ap_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ap_i2c0_pins>;
+	status = "okay";
+};
+
+/*
+ * CP related configuration
+ */
+&cp0_pinctl {
+		/* MPP Bus:
+		 *   NAND	[13,15-27]
+		 *   SMI	[32,34]
+		 *   XSMI	[35-36]
+		 *   I2C0	[37-38]
+		 *   USB	[44-45]
+		 *   UART1	[46-47,49,58]
+		 *   IHB	[56-57]
+		 *   UART0	[59-62]
+		 */
+		/*   0   1   2   3   4   5   6   7   8   9 */
+	pin-func = < 0   0   0   0   0   0   0   0   0   0
+		     0   0   0   2   0   1   1   1   1   1
+		     1   1   1   1   1   1   1   1   0   0
+		     0   0   7   0   7   7   7   2   2   0
+		     0   0   0   0   0   0   7   7   0   7
+		     0   0   0   0   0   0   0   0   7   7
+		     7   7   7>;
+};
+
+&cp0_nand {
+	status = "okay";
+};
+
+&cp0_comphy {
+
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+		/delete-property/phy-speed;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_USB3_HOST0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_5_15625G>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_UNCONNECTED>;
+		/delete-property/phy-speed;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_SGMII1>;
+		phy-speed = <COMPHY_SPEED_1_25G>;
+	};
+};
+
+&cp0_xmdio {
+	status = "okay";
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi";
+	phy = <&phy0>;
+};
+
+&cp0_eth1 {
+	status = "okay";
+	phy-mode = "sgmii";
+	phy = <&phy1>;
+};
diff --git a/arch/arm/dts/armada-3900.dtsi b/arch/arm/dts/armada-3900.dtsi
new file mode 100644
index 0000000..65a23c1
--- /dev/null
+++ b/arch/arm/dts/armada-3900.dtsi
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+/*
+ * Device Tree file for the Armada 70x0 SoC, made of an AP806 Quad and
+ * one CP110.
+ */
+
+#include <dt-bindings/gpio/gpio.h>
+#include "armada-common.dtsi"
+#include "armada-8k.dtsi"
+#include "armada-ap807.dtsi"
+#include "armada-ap80x-quad.dtsi"
+
+/* CP110-0 Settings */
+#define CP110_NAME				cp0
+#define CP110_NUM				0
+
+#include "armada-cp110.dtsi"
+
+#undef CP110_NAME
+#undef CP110_NUM
+
+/ {
+	model = "Marvell Armada 3900";
+	compatible = "marvell,armada70x0", "marvell,armada-ap806-quad",
+		     "marvell,armada-ap806";
+};
+
+&cp0_pinctl {
+	compatible = "marvell,mvebu-pinctrl", "marvell,armada-8k-cpm-pinctrl";
+	bank-name ="cp0-110";
+
+	cp0_i2c0_pins: cp0-i2c-pins-0 {
+		marvell,pins = < 37 38 >;
+		marvell,function = <2>;
+	};
+	cp0_i2c1_pins: cp0-i2c-pins-1 {
+		marvell,pins = < 35 36 >;
+		marvell,function = <2>;
+	};
+	cp0_ge1_rgmii_pins: cp0-ge-rgmii-pins-0 {
+		marvell,pins = < 0 1 2 3 4 5 6 7 8 9 10 11>;
+		marvell,function = <3>;
+	};
+	cp0_ge2_rgmii_pins: cp0-ge-rgmii-pins-1 {
+		marvell,pins = < 44 45 46 47 48 49 50 51
+				52 53 54 55 >;
+		marvell,function = <1>;
+	};
+	cp0_pca0_pins: cp0-pca0_pins {
+		marvell,pins = <62>;
+		marvell,function = <0>;
+	};
+	cp0_sdhci_pins: cp0-sdhi-pins-0 {
+		marvell,pins = < 56 57 58 59 60 61 >;
+		marvell,function = <14>;
+	};
+	cp0_spi0_pins: cp0-spi-pins-0 {
+		marvell,pins = < 13 14 15 16 >;
+		marvell,function = <3>;
+	};
+};
diff --git a/arch/arm/dts/armada-7020-amc.dts b/arch/arm/dts/armada-7020-amc.dts
new file mode 100644
index 0000000..b0682e7
--- /dev/null
+++ b/arch/arm/dts/armada-7020-amc.dts
@@ -0,0 +1,212 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for Marvell Armada 7020 AMC board
+ * Boot device: NAND
+ */
+
+#include "armada-70x0.dtsi"
+
+/ {
+	model = "Marvell Armada 7020 AMC";
+	compatible = "marvell,armada7020-amc", "marvell,armada7020",
+		     "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		i2c1 = &cp0_mss_i2c0;
+		i2c2 = &ap_i2c0;
+		spi0 = &ap_spi0;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>; /* 2GB */
+	};
+
+	simple-bus {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reg_smi0: reg_smi {
+			compatible = "regulator-fixed";
+			regulator-name = "reg-smi";
+			/*
+			 * set GPIO[31] to 0 to connect SMI to main switch
+			 * board
+			 */
+			gpio = <&cp0_gpio0 31 GPIO_ACTIVE_HIGH>;
+		};
+
+		reg_i2c0: reg_i2c {
+			compatible = "regulator-fixed";
+			regulator-name = "reg-i2c";
+			enable-active-high;
+			 /*
+			  * set GPIO[44] to 1 to connect ap_i2c0 to main switch
+			  * board
+			  */
+			gpio = <&cp0_gpio1 12 GPIO_ACTIVE_HIGH>;
+		};
+	};
+};
+
+&ap_pinctl {
+	   /* MPP Bus:
+	    * SPI  [0-3]
+	    * I2C  [4-5]
+	    * UART0 [11,19]
+	    */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 3 3 3 3 3 3 0 0 0 0
+		     0 3 0 0 0 0 0 0 0 3 >;
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&ap_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ap_i2c0_pins>;
+	enable_gpios = <&reg_i2c0>;
+	status = "okay";
+};
+
+&ap_spi0 {
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <0x1>;
+		#size-cells = <0x1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0x0>;
+		spi-max-frequency = <108000000>;
+	};
+};
+
+&cp0_nand {
+	status = "okay";
+};
+
+&cp0_pcie0 {
+	num-lanes = <4>;
+	ranges =
+		/* downstream I/O */
+		<0x81000000 0 0xfa000000 0  0xfa000000 0 0x10000
+		/* non-prefetchable memory */
+		0x82000000 0 0xf6000000 0  0xf6000000 0 0x4000000>;
+
+	status = "okay";
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_mss_i2c0 {
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_pinctl {
+		/* MPP Bus:
+		 * RGMII [0-11]
+		 * Device Bus [13-27]
+		 * SATA1 [28]
+		 * UART0 [29-30]
+		 * SMI	 [32,34]
+		 * XSMI  [35-36]
+		 * I2C0	 [37-38]
+		 * I2C1	 [50-51]
+		 * SD	 [49, 55-61]
+		 */
+		/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 3    3    3    3    3    3    3    3    3    3
+		     3    3    0    2    3    1    1    1    1    1
+		     1    1    1    1    1    1    1    1    9    0xA
+		     0xA  0    7    0    7    7    7    2    2    0xFF
+		     0xFF 0xFF 0xFF 0xFF 0    0    0    0    0    0xA
+		     2    2    0    0    0    0xB  0xE  0xE  0xE  0xE
+		     0xE  0xE  0>;
+};
+
+&cp0_sata0 {
+	status = "okay";
+};
+
+&cp0_comphy {
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+};
+
+&cp0_usb3_0 {
+	status = "okay";
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_sdhci0 {
+	status = "okay";
+	bus-width = <4>;
+	no-1-8-v;
+	non-removable;
+};
+
+&cp0_mdio {
+	status = "okay";
+	enable_gpios = <&reg_smi0>;
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi";
+};
+
+&cp0_eth1 {
+	status = "okay";
+	phy = <&phy1>;
+	phy-mode = "rgmii-id";
+};
diff --git a/arch/arm/dts/armada-7020-comexp.dts b/arch/arm/dts/armada-7020-comexp.dts
new file mode 100644
index 0000000..6f5c9b2
--- /dev/null
+++ b/arch/arm/dts/armada-7020-comexp.dts
@@ -0,0 +1,199 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for Marvell Armada 7020 COMEXPRESS board
+ * Boot device: NAND
+ */
+
+#include "armada-70x0.dtsi"
+
+/ {
+	model = "Marvell Armada-7020 COMEXPRESS board setup";
+	compatible = "marvell,armada7020-comexp", "marvell,armada702",
+		     "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		i2c1 = &cp0_mss_i2c0;
+		i2c2 = &ap_i2c0;
+		spi0 = &ap_spi0;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>; /* 2GB */
+	};
+
+	simple-bus {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reg_smi0: reg_smi {
+			compatible = "regulator-fixed";
+			regulator-name = "reg-smi";
+			/*
+			 * set GPIO[31] to 0 to connect SMI to main switch
+			 * board
+			 */
+			gpio = <&cp0_gpio0 31 GPIO_ACTIVE_HIGH>;
+		};
+
+		reg_i2c0: reg_i2c {
+			compatible = "regulator-fixed";
+			regulator-name = "reg-i2c";
+			enable-active-high;
+			 /*
+			  * set GPIO[44] to 1 to connect ap_i2c0 to main switch
+			  * board
+			  */
+			gpio = <&cp0_gpio1 12 GPIO_ACTIVE_HIGH>;
+		};
+	};
+};
+
+&ap_pinctl {
+	   /* MPP Bus:
+	    * SPI  [0-3]
+	    * I2C  [4-5]
+	    * UART0 [11,19]
+	    */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 3 3 3 3 3 3 0 0 0 0
+		     0 3 0 0 0 0 0 0 0 3 >;
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&ap_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ap_i2c0_pins>;
+	enable_gpios = <&reg_i2c0>;
+	status = "okay";
+};
+
+&cp0_pinctl {
+		/* MPP Bus:
+		 * RGMII [0-11]
+		 * Device Bus [13-27]
+		 * SATA1 [28]
+		 * UART0 [29-30]
+		 * SMI	 [32,34]
+		 * XSMI  [35-36]
+		 * I2C0	 [37-38]
+		 * I2C1	 [50-51]
+		 * SD	 [55-61]
+		 */
+		/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 3    3    3    3    3    3    3    3    3    3
+		     3    3    0    2    0    1    1    1    1    1
+		     1    1    1    1    1    1    1    1    9    0xA
+		     0xA  0    7    0    7    7    7    2    2    0
+		     0    0    0    0    0    0    0    0    0    0
+		     2    2    0    0    0    0xB  0xE  0xE  0xE  0xE
+		     0xE  0xE  0>;
+};
+
+&cp0_comphy {
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+};
+
+&cp0_nand {
+	/* MT29F8G08ABACAWP, ID=0xd32c, ONFI, page:4KB-224B, 8bit ECC,
+	 * 1GByte total.
+	 */
+	status = "okay";
+	nand-enable-arbiter;
+	num-cs = <1>;
+	nand-ecc-strength = <8>;
+	nand-ecc-step-size = <512>;
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_mss_i2c0 {
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_sata0 {
+	status = "okay";
+};
+
+&cp0_sdhci0 {
+	status = "okay";
+	bus-width = <4>;
+	no-1-8-v;
+	non-removable;
+};
+
+&cp0_mdio {
+	status = "okay";
+	enable_gpios = <&reg_smi0>;
+	phy1: ethernet-phy@1 {
+		reg = <0x10>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi";
+};
+
+&cp0_eth1 {
+	status = "okay";
+	phy = <&phy1>;
+	phy-mode = "rgmii-id";
+};
+
+&cp0_pcie0 {
+	num-lanes = <4>;
+	ranges =
+		/* downstream I/O */
+		<0x81000000 0 0xfa000000 0  0xfa000000 0 0x10000
+		/* non-prefetchable memory */
+		0x82000000 0 0xf6000000 0  0xf6000000 0 0x4000000>;
+
+	status = "okay";
+};
diff --git a/arch/arm/dts/armada-7040-db-B.dts b/arch/arm/dts/armada-7040-db-B.dts
new file mode 100644
index 0000000..4795231
--- /dev/null
+++ b/arch/arm/dts/armada-7040-db-B.dts
@@ -0,0 +1,221 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for Marvell Armada 7040 Development board platform
+ * Boot device: SPI NOR, 0x32 (SW3)
+ */
+
+#include "armada-70x0-db.dtsi"
+
+/ {
+	model = "Marvell Armada 7040 Development Board DB-88FA7040 setup(B)";
+	compatible = "marvell,armada7040-db", "marvell,armada7040",
+		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp0_spi1;
+		fuse0 = &ap_hd_efuse0;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+};
+
+&ap_pinctl {
+	   /* MPP Bus:
+	    * SDIO  [0-5]
+	    * UART0 [11,19]
+	    */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 0 0 0 0
+		     0 3 0 0 0 0 0 0 0 3 >;
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_pcie2 {
+	status = "okay";
+};
+
+&cp0_pcie0 {
+	status = "okay";
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_pinctl {
+		/* MPP Bus:
+		 * RGMII1 [0-11]
+		 * SPI    [13-16]
+		 * SATA1  [28]
+		 * UART0  [29-30]
+		 * SMI	  [32,34]
+		 * XSMI   [35-36]
+		 * I2C	  [37-38]
+		 * RGMII2 [44-55]
+		 * SD	  [56-61]
+		 * GPIO   [62]
+		 */
+		/*   0   1   2   3   4   5   6   7   8   9 */
+	pin-func = < 3   3   3   3   3   3   3   3   3   3
+		     3   3   0   3   3   3   3   0   0   0
+		     0   0   0   0   0   0   0   0   9   0xA
+		     0xA 0   7   0   7   7   7   2   2   0
+		     0   0   0   0   1   1   1   1   1   1
+		     1   1   1   1   1   1   0xE 0xE 0xE 0xE
+		     0xE 0xE 0>;
+};
+
+&cp0_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_spi0_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>,		/* CS1 */
+	      <0 0xffffffff>,		/* CS2 */
+	      <0 0xffffffff>;		/* CS3 */
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <0x1>;
+		#size-cells = <0x1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0x0>;
+		spi-max-frequency = <108000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0x0 0x200000>;
+			};
+
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xe00000>;
+			};
+		};
+	};
+};
+
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_usb3_1 {
+	status = "okay";
+};
+
+&cp0_comphy {
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_utmi1 {
+	status = "okay";
+};
+
+&ap_sdhci0 {
+	status = "okay";
+	bus-width = <4>;
+	no-1-8-v;
+	non-removable;
+};
+
+&cp0_sdhci0 {
+	status = "okay";
+	bus-width = <4>;
+	no-1-8-v;
+	non-removable;
+};
+
+&cp0_mdio {
+	status = "okay";
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth1 {
+	status = "okay";
+	phy = <&phy0>;
+	phy-mode = "rgmii-id";
+};
+
+&cp0_eth2 {
+	status = "okay";
+	phy = <&phy1>;
+	phy-mode = "rgmii-id";
+};
diff --git a/arch/arm/dts/armada-7040-db-C.dts b/arch/arm/dts/armada-7040-db-C.dts
new file mode 100644
index 0000000..ec4e114
--- /dev/null
+++ b/arch/arm/dts/armada-7040-db-C.dts
@@ -0,0 +1,222 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for Marvell Armada 7040 Development board platform
+ * Boot device: SPI NOR, 0x32 (SW3)
+ */
+
+#include "armada-70x0-db.dtsi"
+
+/ {
+	model = "Marvell Armada 7040 Development Board DB-88FA7040 setup(C)";
+	compatible = "marvell,armada7040-db", "marvell,armada7040",
+		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp0_spi1;
+		fuse0 = &ap_hd_efuse0;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+};
+
+&ap_pinctl {
+	   /* MPP Bus:
+	    * SDIO  [0-5]
+	    * UART0 [11,19]
+	    */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 0 0 0 0
+		     0 3 0 0 0 0 0 0 0 3 >;
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_pcie0 {
+	status = "okay";
+};
+
+&cp0_pcie2 {
+	status = "okay";
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_pinctl {
+		/* MPP Bus:
+		 * TDM	  [0-5]
+		 * SPI0	  [6-11]
+		 * SPI1   [13-16]
+		 * SATA1  [28]
+		 * UART0  [29-30]
+		 * SMI	  [32,34]
+		 * XSMI   [35-36]
+		 * I2C	  [37-38]
+		 * RGMII1 [44-55]
+		 * SD	  [56-61]
+		 * GPIO   [62]
+		 */
+		/*   0   1   2   3   4   5   6   7   8   9 */
+	pin-func = < 4   4   4   4   4   4   4   4   4   4
+		     4   4   0   3   3   3   3   0   0   0
+		     0   0   0   0   0   0   0   0   9   0xA
+		     0xA 0   7   0   7   7   7   2   2   0
+		     0   0   0   0   1   1   1   1   1   1
+		     1   1   1   1   1   1   0xE 0xE 0xE 0xE
+		     0xE 0xE 0>;
+};
+
+&cp0_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_spi0_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>,		/* CS1 */
+	      <0 0xffffffff>,		/* CS2 */
+	      <0 0xffffffff>;		/* CS3 */
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <0x1>;
+		#size-cells = <0x1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0x0>;
+		spi-max-frequency = <108000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0x0 0x200000>;
+			};
+
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xe00000>;
+			};
+		};
+	};
+};
+
+&cp0_sata0 {
+	status = "okay";
+};
+
+&cp0_usb3_0 {
+	status = "okay";
+};
+
+&cp0_usb3_1 {
+	status = "okay";
+};
+
+&cp0_comphy {
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_utmi1 {
+	status = "okay";
+};
+
+&ap_sdhci0 {
+	status = "okay";
+	bus-width = <4>;
+	no-1-8-v;
+	non-removable;
+};
+
+&cp0_sdhci0 {
+	status = "okay";
+	bus-width = <4>;
+	no-1-8-v;
+	non-removable;
+};
+
+&cp0_mdio {
+	status = "okay";
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-2 */
+};
+
+&cp0_eth2 {
+	status = "okay";
+	phy = <&phy1>;
+	phy-mode = "rgmii-id";
+};
diff --git a/arch/arm/dts/armada-7040-db-D.dts b/arch/arm/dts/armada-7040-db-D.dts
new file mode 100644
index 0000000..95d8e06
--- /dev/null
+++ b/arch/arm/dts/armada-7040-db-D.dts
@@ -0,0 +1,201 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for Marvell Armada 7040 Development board platform
+ * Boot device: SPI NOR, 0x32 (SW3)
+ */
+
+#include "armada-70x0-db.dtsi"
+
+/ {
+	model = "Marvell Armada 7040 Development Board DB-88FA7040 setup(D)";
+	compatible = "marvell,armada7040-db", "marvell,armada7040",
+		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp0_spi1;
+		fuse0 = &ap_hd_efuse0;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+
+	cp0_sar {
+		boot_mode {
+			default = <0xe>;
+		};
+	};
+};
+
+&ap_pinctl {
+	   /* MPP Bus:
+	    * SDIO  [0-5]
+	    * UART0 [11,19]
+	    */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 0 0 0 0
+		     0 3 0 0 0 0 0 0 0 3 >;
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_pcie0 {
+	status = "okay";
+};
+
+&cp0_pcie2 {
+	status = "okay";
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_pinctl {
+		/* MPP Bus:
+		 * AUDIO   [0-5]
+		 * SS_PWDN [12]
+		 * NF_RBn  [13]
+		 * DEV_BUS [14-27]
+		 * SATA1   [28]
+		 * UART0   [29-30]
+		 * MSS_VTT [31]
+		 * SMI	   [32,34]
+		 * XSMI    [35-36]
+		 * I2C	   [37-38]
+		 * RGMII1  [44-55]
+		 * SD	   [56-61]
+		 * GPIO    [62]
+		 */
+		/*   0   1   2   3   4   5   6   7   8   9 */
+	pin-func = < 2   2   2   2   2   2   0   0   0   0
+		     0   0   0   2   0   1   1   1   1   1
+		     1   1   1   1   1   1   1   1   9   0xA
+		     0xA 0   7   0   7   7   7   2   2   0
+		     0   0   0   0   1   1   1   1   1   1
+		     1   1   1   1   1   1    0xE 0xE 0xE 0xE
+		     0xE 0xE 0>;
+};
+
+&cp0_nand {
+	status = "okay";
+};
+
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_sata0 {
+	status = "okay";
+};
+
+&cp0_usb3_1 {
+	status = "okay";
+};
+
+&cp0_comphy {
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_USB3_DEVICE>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+&cp0_utmi0 {
+	utmi-port = <UTMI_PHY_TO_USB3_DEVICE0>;
+	status = "okay";
+};
+
+&cp0_utmi1 {
+	status = "okay";
+};
+
+&ap_sdhci0 {
+	status = "okay";
+	bus-width = <4>;
+	no-1-8-v;
+	non-removable;
+};
+
+&cp0_sdhci0 {
+	status = "okay";
+	bus-width = <4>;
+	no-1-8-v;
+	non-removable;
+};
+
+&cp0_mdio {
+	status = "okay";
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-2 */
+};
+
+&cp0_eth2 {
+	status = "okay";
+	phy = <&phy1>;
+	phy-mode = "rgmii-id";
+};
diff --git a/arch/arm/dts/armada-7040-db-E.dts b/arch/arm/dts/armada-7040-db-E.dts
new file mode 100644
index 0000000..871734f
--- /dev/null
+++ b/arch/arm/dts/armada-7040-db-E.dts
@@ -0,0 +1,233 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for Marvell Armada 7040 Development board platform
+ * Boot device: SPI NOR, 0x32 (SW3)
+ */
+
+#include "armada-70x0-db.dtsi"
+
+/ {
+	model = "Marvell Armada 7040 Development Board DB-88FA7040 setup(E)";
+	compatible = "marvell,armada7040-db", "marvell,armada7040",
+		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp0_spi1;
+		fuse0 = &ap_hd_efuse0;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+};
+
+&ap_spi0 {
+	status = "okay";
+};
+
+&ap_i2c0 {
+	status = "okay";
+};
+
+&ap_pinctl {
+	   /* MPP Bus:
+	    * SPI0 [0-3]
+	    * I2C0 [4-5]
+	    * UART0 [11,19]
+	    */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 3 3 3 3 3 3 0 0 0 0
+		     0 3 0 0 0 0 0 0 0 3 >;
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_pcie0 {
+	status = "okay";
+};
+
+&cp0_pcie2 {
+	status = "okay";
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_i2c1 {
+	status = "okay";
+};
+
+&cp0_pinctl {
+		/* MPP Bus:
+		 * RGMII0 [0-11]
+		 * SPI1   [13-16]
+		 * SATA1  [28]
+		 * UART0  [29-30]
+		 * SMI	  [32,34]
+		 * I2C1   [35-36]
+		 * I2C0   [37-38]
+		 * UART1  [47-49]
+		 * UART0  [50-51]
+		 * SD	  [56-61]
+		 * GPIO   [62]
+		 */
+		/*   0   1   2   3   4   5   6   7   8   9 */
+	pin-func = < 3   3   3   3   3   3   3   3   3   3
+		     3   3   0   3   3   3   3   0   0   0
+		     0   0   0   0   0   0   0   0   9   0xA
+		     0xA 0   7   0   7   2   2   2   2   0
+		     0   0   0   0   1   1   1   7   1   7
+		     6   6   1   1   0xA 1   0xE 0xE 0xE 0xE
+		     0xE 0xE 0>;
+};
+
+&cp0_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_spi0_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>,		/* CS1 */
+	      <0 0xffffffff>,		/* CS2 */
+	      <0 0xffffffff>;		/* CS3 */
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <0x1>;
+		#size-cells = <0x1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0x0>;
+		spi-max-frequency = <108000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0x0 0x200000>;
+			};
+
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xe00000>;
+			};
+		};
+	};
+};
+
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_sata0 {
+	status = "okay";
+};
+
+&cp0_usb3_0 {
+	status = "okay";
+};
+
+&cp0_usb3_1 {
+	status = "okay";
+};
+
+&cp0_comphy {
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_SGMII0>;
+		phy-speed = <COMPHY_SPEED_1_25G>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_utmi1 {
+	status = "okay";
+};
+
+&cp0_sdhci0 {
+	status = "okay";
+	bus-width = <4>;
+	no-1-8-v;
+	non-removable;
+};
+
+&cp0_mdio {
+	status = "okay";
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sgmii"; /* lane-2 */
+};
+
+&cp0_eth1 {
+	status = "okay";
+	phy = <&phy0>;
+	phy-mode = "rgmii-id"; /* lane-0 */
+};
diff --git a/arch/arm/dts/armada-7040-db-nand.dts b/arch/arm/dts/armada-7040-db-nand.dts
deleted file mode 100644
index 3a9df21..0000000
--- a/arch/arm/dts/armada-7040-db-nand.dts
+++ /dev/null
@@ -1,223 +0,0 @@
-/*
- * Copyright (C) 2017 Marvell Technology Group Ltd.
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPLv2 or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This library is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This library is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively,
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use,
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/*
- * Device Tree file for Marvell Armada 7040 Development board platform
- * Boot device: NAND, 0xE (SW3)
- */
-
-#include "armada-7040.dtsi"
-
-/ {
-	model = "Marvell Armada 7040 DB board with NAND";
-	compatible = "marvell,armada7040-db-nand", "marvell,armada7040-db",
-		     "marvell,armada7040", "marvell,armada-ap806-quad",
-		     "marvell,armada-ap806";
-
-	chosen {
-		stdout-path = "serial0:115200n8";
-	};
-
-	aliases {
-		i2c0 = &cpm_i2c0;
-		spi0 = &cpm_spi1;
-	};
-
-	memory@00000000 {
-		device_type = "memory";
-		reg = <0x0 0x0 0x0 0x80000000>;
-	};
-};
-
-&ap_pinctl {
-	   /* MPP Bus:
-	    * SDIO  [0-5]
-	    * UART0 [11,19]
-	    */
-		  /* 0   1   2   3   4   5   6   7   8   9 */
-	pin-func = < 0x1 0x1 0x1 0x1 0x1 0x1 0x0 0x0 0x0 0x0
-		     0x0 0x3 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x3 >;
-};
-
-&uart0 {
-	status = "okay";
-};
-
-
-&cpm_pcie2 {
-	status = "okay";
-};
-
-&cpm_i2c0 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&cpm_i2c0_pins>;
-	status = "okay";
-	clock-frequency = <100000>;
-};
-
-&cpm_pinctl {
-		/* MPP Bus:
-		 * AUDIO   [0-5]
-                 * GBE     [6-11]
-		 * SS_PWDN [12]
-		 * NF_RBn  [13]
-                 * GPIO    [14]
-		 * DEV_BUS [15-27]
-		 * SATA1   [28]
-		 * UART0   [29-30]
-		 * MSS_VTT_EN [31]
-		 * SMI	   [32,34]
-		 * XSMI    [35-36]
-		 * I2C	   [37-38]
-		 * RGMII1  [44-55]
-		 * SD	   [56-61]
-		 * GPIO    [62]
-		 */
-		 /*   0   1   2   3   4   5   6   7   8   9 */
-	 pin-func = < 0x2 0x2 0x2 0x2 0x2 0x2 0x3 0x3 0x3 0x3
-		      0x3 0x3 0x0 0x2 0x0 0x1 0x1 0x1 0x1 0x1
-		      0x1 0x1 0x1 0x1 0x1 0x1 0x1 0x1 0x9 0xa
-		      0xa 0x0 0x7 0x0 0x7 0x7 0x7 0x2 0x2 0x0
-		      0x0 0x0 0x0 0x0 0x1 0x1 0x1 0x1 0x1 0x1
-		      0x1 0x1 0x1 0x1 0x1 0x1 0xe 0xe 0xe 0xe
-		      0xe 0xe 0x0>;
-};
-
-&cpm_spi1 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&cpm_spi0_pins>;
-	status = "disabled";
-
-	spi-flash@0 {
-		#address-cells = <0x1>;
-		#size-cells = <0x1>;
-		compatible = "jedec,spi-nor";
-		reg = <0x0>;
-		spi-max-frequency = <20000000>;
-
-		partitions {
-			compatible = "fixed-partitions";
-			#address-cells = <1>;
-			#size-cells = <1>;
-
-			partition@0 {
-				label = "U-Boot";
-				reg = <0x0 0x200000>;
-			};
-
-			partition@400000 {
-				label = "Filesystem";
-				reg = <0x200000 0xe00000>;
-			};
-		};
-	};
-};
-
-&cpm_sata0 {
-	status = "okay";
-};
-
-&cpm_usb3_0 {
-	status = "okay";
-};
-
-&cpm_usb3_1 {
-	status = "okay";
-};
-
-&cpm_comphy {
-	phy0 {
-		phy-type = <PHY_TYPE_SGMII2>;
-		phy-speed = <PHY_SPEED_3_125G>;
-	};
-
-	phy1 {
-		phy-type = <PHY_TYPE_USB3_HOST0>;
-		phy-speed = <PHY_SPEED_5G>;
-	};
-
-	phy2 {
-		phy-type = <PHY_TYPE_SGMII0>;
-		phy-speed = <PHY_SPEED_1_25G>;
-	};
-
-	phy3 {
-		phy-type = <PHY_TYPE_SATA1>;
-		phy-speed = <PHY_SPEED_5G>;
-	};
-
-	phy4 {
-		phy-type = <PHY_TYPE_USB3_HOST1>;
-		phy-speed = <PHY_SPEED_5G>;
-	};
-
-	phy5 {
-		phy-type = <PHY_TYPE_PEX2>;
-		phy-speed = <PHY_SPEED_5G>;
-	};
-};
-
-&cpm_nand {
-	status = "okay";
-};
-
-&cpm_utmi0 {
-	status = "okay";
-};
-
-&cpm_utmi1 {
-	status = "okay";
-};
-
-&ap_sdhci0 {
-	status = "okay";
-	bus-width = <4>;
-	no-1-8-v;
-	non-removable;
-};
-
-&cpm_sdhci0 {
-	status = "okay";
-	bus-width = <4>;
-	no-1-8-v;
-	non-removable;
-};
diff --git a/arch/arm/dts/armada-7040-db.dts b/arch/arm/dts/armada-7040-db.dts
index cfd2b4b..170b855 100644
--- a/arch/arm/dts/armada-7040-db.dts
+++ b/arch/arm/dts/armada-7040-db.dts
@@ -45,10 +45,10 @@
  * Boot device: SPI NOR, 0x32 (SW3)
  */
 
-#include "armada-7040.dtsi"
+#include "armada-70x0-db.dtsi"
 
 / {
-	model = "Marvell Armada 7040 DB board";
+	model = "Marvell Armada 7040 Development Board DB-88FA7040";
 	compatible = "marvell,armada7040-db", "marvell,armada7040",
 		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
 
@@ -57,8 +57,13 @@
 	};
 
 	aliases {
-		i2c0 = &cpm_i2c0;
-		spi0 = &cpm_spi1;
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp0_spi1;
+		fuse0 = &ap_hd_efuse0;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
 	};
 
 	memory@00000000 {
@@ -81,51 +86,67 @@
 	status = "okay";
 };
 
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
 
-&cpm_pcie2 {
+&cp0_pcie2 {
 	status = "okay";
 };
 
-&cpm_i2c0 {
+&cp0_i2c0 {
 	pinctrl-names = "default";
-	pinctrl-0 = <&cpm_i2c0_pins>;
+	pinctrl-0 = <&cp0_i2c0_pins>;
 	status = "okay";
 	clock-frequency = <100000>;
 };
 
-&cpm_pinctl {
+&cp0_pinctl {
 		/* MPP Bus:
-		 * TDM	 [0-11]
 		 * SPI   [13-16]
 		 * SATA1 [28]
 		 * UART0 [29-30]
 		 * SMI	 [32,34]
 		 * XSMI  [35-36]
 		 * I2C	 [37-38]
-		 * RGMII1[44-55]
-		 * SD	 [56-62]
+		 * RGMII [44-55]
+		 * SD	 [56-61]
+		 * GPIO  [62]
 		 */
 		/*   0   1   2   3   4   5   6   7   8   9 */
-	pin-func = < 4   4   4   4   4   4   4   4   4   4
-		     4   4   0   3   3   3   3   0   0   0
+	pin-func = < 0   0   0   0   0   0   0   0   0   0
+		     0   0   0   3   3   3   3   0   0   0
 		     0   0   0   0   0   0   0   0   9   0xA
 		     0xA 0   7   0   7   7   7   2   2   0
 		     0   0   0   0   1   1   1   1   1   1
 		     1   1   1   1   1   1   0xE 0xE 0xE 0xE
-		     0xE 0xE 0xE >;
+		     0xE 0xE 0>;
 };
 
-&cpm_spi1 {
+&cp0_spi1 {
 	pinctrl-names = "default";
-	pinctrl-0 = <&cpm_spi0_pins>;
+	pinctrl-0 = <&cp0_spi0_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>,		/* CS1 */
+	      <0 0xffffffff>,		/* CS2 */
+	      <0 0xffffffff>;		/* CS3 */
 	status = "okay";
 
 	spi-flash@0 {
 		#address-cells = <0x1>;
 		#size-cells = <0x1>;
-		compatible = "jedec,spi-nor";
+		compatible = "jedec,spi-nor", "spi-flash";
 		reg = <0x0>;
-		spi-max-frequency = <20000000>;
+		spi-max-frequency = <108000000>;
 
 		partitions {
 			compatible = "fixed-partitions";
@@ -145,54 +166,59 @@
 	};
 };
 
-&cpm_sata0 {
+&cp0_ld_efuse0 {
 	status = "okay";
 };
 
-&cpm_usb3_0 {
+&cp0_ld_efuse1 {
 	status = "okay";
 };
 
-&cpm_usb3_1 {
+&cp0_sata0 {
 	status = "okay";
 };
 
-&cpm_comphy {
+&cp0_usb3_0 {
+	status = "okay";
+};
+
+&cp0_usb3_1 {
+	status = "okay";
+};
+
+&cp0_comphy {
 	phy0 {
-		phy-type = <PHY_TYPE_SGMII1>;
-		phy-speed = <PHY_SPEED_1_25G>;
+		phy-type = <COMPHY_TYPE_SGMII1>;
+		phy-speed = <COMPHY_SPEED_1_25G>;
 	};
 
 	phy1 {
-		phy-type = <PHY_TYPE_USB3_HOST0>;
-		phy-speed = <PHY_SPEED_5G>;
+		phy-type = <COMPHY_TYPE_USB3_HOST0>;
 	};
 
 	phy2 {
-		phy-type = <PHY_TYPE_SFI>;
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
 	};
 
 	phy3 {
-		phy-type = <PHY_TYPE_SATA1>;
-		phy-speed = <PHY_SPEED_5G>;
+		phy-type = <COMPHY_TYPE_SATA1>;
 	};
 
 	phy4 {
-		phy-type = <PHY_TYPE_USB3_HOST1>;
-		phy-speed = <PHY_SPEED_5G>;
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
 	};
 
 	phy5 {
-		phy-type = <PHY_TYPE_PEX2>;
-		phy-speed = <PHY_SPEED_5G>;
+		phy-type = <COMPHY_TYPE_PEX2>;
 	};
 };
 
-&cpm_utmi0 {
+&cp0_utmi0 {
 	status = "okay";
 };
 
-&cpm_utmi1 {
+&cp0_utmi1 {
 	status = "okay";
 };
 
@@ -203,14 +229,15 @@
 	non-removable;
 };
 
-&cpm_sdhci0 {
+&cp0_sdhci0 {
 	status = "okay";
 	bus-width = <4>;
 	no-1-8-v;
 	non-removable;
 };
 
-&cpm_mdio {
+&cp0_mdio {
+	status = "okay";
 	phy0: ethernet-phy@0 {
 		reg = <0>;
 	};
@@ -219,22 +246,22 @@
 	};
 };
 
-&cpm_ethernet {
+&cp0_ethernet {
 	status = "okay";
 };
 
-&cpm_eth0 {
+&cp0_eth0 {
 	status = "okay";
 	phy-mode = "sfi"; /* lane-2 */
 };
 
-&cpm_eth1 {
+&cp0_eth1 {
 	status = "okay";
 	phy = <&phy0>;
-	phy-mode = "sgmii";
+	phy-mode = "sgmii"; /* lane-0 */
 };
 
-&cpm_eth2 {
+&cp0_eth2 {
 	status = "okay";
 	phy = <&phy1>;
 	phy-mode = "rgmii-id";
diff --git a/arch/arm/dts/armada-7040-dev-info.dtsi b/arch/arm/dts/armada-7040-dev-info.dtsi
new file mode 100644
index 0000000..42b63f0
--- /dev/null
+++ b/arch/arm/dts/armada-7040-dev-info.dtsi
@@ -0,0 +1,73 @@
+/*
+ * ***************************************************************************
+ * Copyright (C) 2017 Marvell International Ltd.
+ * ***************************************************************************
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * ***************************************************************************
+ */
+
+/ {
+	/* This should go only into devel boards */
+	compatible = "marvell,cp110";
+	sar {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		sar_fields {
+			compatible = "marvell,sample-at-reset";
+			reg = <0x4c 0x4e>;
+			chip_count = <2>;
+			bit_width = <5>;
+
+			freq {
+				key = "freq";
+				description = "CPU/DDR frequencies";
+				start-bit = <0>;
+				bit-length = <3>;
+				option-cnt = <7>;
+				options = "0x0", "1600/800 Mhz",
+					  "0x2", "1000/650 Mhz",
+					  "0x3", "1200/800 Mhz",
+					  "0x4", "1400/800 Mhz",
+					  "0x5", "600/800 Mhz",
+					  "0x6", "800/800 Mhz",
+					  "0x7", "1000/800 Mhz";
+				default = <0x3>;
+				status = "okay";
+			};
+			boot_mode {
+				key = "boot_mode";
+				description = "Boot mode options";
+				start-bit = <4>;
+				bit-length = <6>;
+				option-cnt = <14>;
+				options = "0xE", "NAND IHB BW-8bit, PS-4KB, ECC-4bit",
+					  "0xF", "NAND IHB BW-8bit, PS-4KB, ECC-8bit",
+					  "0x28", "AP_SD",
+					  "0x29", "CP_SD",
+					  "0x2A", "AP_EMMC",
+					  "0x2B", "CP_EMMC",
+					  "0x30", "AP_SPI 24bits",
+					  "0x31", "AP SPI BR-Disabled 24bits",
+					  "0x32", "CP_SPI_1 24bits",
+					  "0x33", "CP_SPI_1 32bits",
+					  "0x34", "CP_SPI_0 24bits",
+					  "0x35", "CP_SPI_0 32bits",
+					  "0x36", "CP_SPI_1 BR-Disabled 24bits",
+					  "0x37", "CP_SPI_1 BR-Disabled 32bits";
+				default = <0x32>;
+				status = "okay";
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/armada-7040-pcac.dts b/arch/arm/dts/armada-7040-pcac.dts
new file mode 100644
index 0000000..3b429a5
--- /dev/null
+++ b/arch/arm/dts/armada-7040-pcac.dts
@@ -0,0 +1,222 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for Marvell Armada 7040 Development board platform
+ * Boot device: SPI NOR, 0x32 (SW3)
+ */
+
+#include "armada-70x0-db.dtsi"
+
+/ {
+	model = "Marvell Armada 7040 Development Board DB-88FA7040-PCAC";
+	compatible = "marvell, armada7040-pcac", "marvell,armada7040",
+		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp0_spi1;
+		fuse0 = &ap_hd_efuse0;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+
+	simple-bus {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reg_usb3h1_current_limiter: usb3-current-limiter1 {
+			compatible = "regulator-fixed";
+			pinctrl-names = "default";
+			pinctrl-0 = <&cp0_xhci_vbus_pins>;
+			regulator-name = "reg-usb3h1-current-limiter";
+			regulator-min-microvolt = <900000>;
+			regulator-max-microvolt = <900000>;
+			regulator-force-boot-off;
+			gpio = <&cp0_gpio1 14 GPIO_ACTIVE_HIGH>; /* GPIO[46] */
+		};
+	};
+};
+
+&ap_pinctl {
+	   /* MPP Bus:
+	    * SDIO  [0-10]
+	    * UART0 [11,19]
+	    */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 1 1 1 1
+		     1 3 0 0 0 0 0 0 0 3 >;
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_pinctl {
+		/* MPP Bus:
+		 * RGMII0[0-11]
+		 * SPI   [13-16]
+		 * SATA1 [28]
+		 * UART0 [29-30]
+		 * PCI_RST [31]
+		 * SMI	 [32,34]
+		 * XSMI  [35-36]
+		 * I2C	 [37-38]
+		 * UART1 [40-41]
+		 * USB CURRENT-LIMIT	[46]
+		 * UART2 [50-51]
+		 */
+		/*   0   1   2   3   4   5   6   7   8   9 */
+	pin-func = < 3   3   3   3   3   3   3   3   3   3
+		     3   3   0   3   3   3   3   0   0   0
+		     0   0   0   0   0   0   0   0   9   0xA
+		     0xA 6   7   0   7   0   0   2   2   0
+		     0   0   0   0   0   0   0   7   0   7
+		     6   6   0   0   0   0   0   0   0   0
+		     0   0   0>;
+
+	cp0_xhci_vbus_pins: cp0-xhci-vbus-pins {
+		marvell,pins = < 46 >;
+		marvell,function = <0>;
+	};
+};
+
+&cp0_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_spi0_pins>;
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <0x1>;
+		#size-cells = <0x1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0x0>;
+		spi-max-frequency = <108000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0x0 0x200000>;
+			};
+
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xe00000>;
+			};
+		};
+	};
+};
+
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_sata0 {
+	status = "okay";
+};
+
+&cp0_usb3_1 {
+	vbus-supply = <&reg_usb3h1_current_limiter>;
+	status = "okay";
+};
+
+&cp0_comphy {
+	phy0 {
+		phy-type = <COMPHY_TYPE_IGNORE>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_IGNORE>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_IGNORE>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_IGNORE>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+};
+
+&ap_sdhci0 {
+
+	status = "okay";
+	bus-width = <4>;
+	no-1-8-v;
+	non-removable;
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_mdio {
+	status = "okay";
+	phy0: ethernet-phy@0 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-4*/
+};
+
+&cp0_eth1 {
+	status = "okay";
+	phy = <&phy0>;
+	phy-mode = "rgmii-id"; /* rgmii-0*/
+};
diff --git a/arch/arm/dts/armada-7040.dtsi b/arch/arm/dts/armada-7040.dtsi
deleted file mode 100644
index b5be0c4..0000000
--- a/arch/arm/dts/armada-7040.dtsi
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (C) 2016 Marvell Technology Group Ltd.
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPLv2 or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This library is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This library is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively,
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use,
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/*
- * Device Tree file for the Armada 7040 SoC, made of an AP806 Quad and
- * one CP110.
- */
-
-#include <dt-bindings/gpio/gpio.h>
-#include "armada-ap806-quad.dtsi"
-#include "armada-cp110-master.dtsi"
-
-/ {
-	model = "Marvell Armada 7040";
-	compatible = "marvell,armada7040", "marvell,armada-ap806-quad",
-		     "marvell,armada-ap806";
-};
diff --git a/arch/arm/dts/armada-70x0-db.dtsi b/arch/arm/dts/armada-70x0-db.dtsi
new file mode 100644
index 0000000..02db647
--- /dev/null
+++ b/arch/arm/dts/armada-70x0-db.dtsi
@@ -0,0 +1,90 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "armada-70x0.dtsi" /* include SoC device tree */
+#include "armada-7040-dev-info.dtsi"
+
+#define CP110_NUM				0
+#define SPI_DIRECT_BASE				(0xf9000000)
+
+/ {
+	model = "DB-ARMADA-70x0";
+	compatible = "marvell,armada-70x0-db", "marvell,armada-70x0";
+
+	cp0 {
+		config-space {
+			ranges = <0x0 U64_TO_U32_H(CP110_BASE) U64_TO_U32_L(CP110_BASE) 0x2000000>,			/* internal regs */
+				 <0x2000000 U64_TO_U32_H(SPI_DIRECT_BASE) U64_TO_U32_L(SPI_DIRECT_BASE) 0x1000000>;	/* SPI1-DEV0 */
+			i2c@701000 {
+				expander0: pca953x@21 {
+					compatible = "nxp,pca9555";
+					#gpio-cells = <2>;
+					reg = <0x21>;
+					status = "okay";
+				};
+			};
+
+			sdhci@780000 {
+				vqmmc-supply = <&cp0_reg_sd_vccq>;
+			};
+
+			cp0_reg_usb3_vbus0:cp0_usb3_vbus@0 {
+				compatible = "regulator-fixed";
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5000000>;
+				startup-delay-us = <100000>;
+				regulator-force-boot-off;
+				gpio = <&expander0 0 GPIO_ACTIVE_HIGH>;
+			};
+
+			cp0_reg_usb3_vbus1: cp0_usb3_vbus@1 {
+				compatible = "regulator-fixed";
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5000000>;
+				startup-delay-us = <100000>;
+				regulator-force-boot-off;
+				gpio = <&expander0 1 GPIO_ACTIVE_HIGH>;
+			};
+
+			cp0_reg_usb3_current_limiter0:cp0_usb3_current_limiter@0 {
+				compatible = "regulator-fixed";
+				regulator-min-microamp = <900000>;
+				regulator-max-microamp = <900000>;
+				regulator-force-boot-off;
+				gpio = <&expander0 4 GPIO_ACTIVE_HIGH>;
+			};
+
+			cp0_reg_usb3_current_limiter1: cp0_usb3_current_limiter@1 {
+				compatible = "regulator-fixed";
+				regulator-min-microamp = <900000>;
+				regulator-max-microamp = <900000>;
+				regulator-force-boot-off;
+				gpio = <&expander0 5 GPIO_ACTIVE_HIGH>;
+			};
+
+			cp0_usb3_0: usb3@500000 {
+				vbus-supply = <&cp0_reg_usb3_vbus0>;
+				current-limiter = <&cp0_reg_usb3_current_limiter0>;
+				vbus-disable-delay = <500>;
+			};
+
+			cp0_usb3_1: usb3@510000 {
+				vbus-supply = <&cp0_reg_usb3_vbus1>;
+				current-limiter = <&cp0_reg_usb3_current_limiter1>;
+				vbus-disable-delay = <500>;
+			};
+
+			cp0_reg_sd_vccq: cp0_sd_vccq@0 {
+				compatible = "regulator-gpio";
+				regulator-name = "cp0_sd_vcc";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				gpios = <&expander0 15 GPIO_ACTIVE_HIGH>;
+				states = <1800000 0x1
+					  3300000 0x0>;
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/armada-70x0.dtsi b/arch/arm/dts/armada-70x0.dtsi
new file mode 100644
index 0000000..d6b9cab
--- /dev/null
+++ b/arch/arm/dts/armada-70x0.dtsi
@@ -0,0 +1,69 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for the Armada 7040 SoC, made of an AP806 Quad and
+ * one CP110.
+ */
+
+#include <dt-bindings/gpio/gpio.h>
+#include "armada-common.dtsi"
+#include "armada-8k.dtsi"
+#include "armada-ap806.dtsi"
+#include "armada-ap80x-quad.dtsi"
+
+/* CP110-0 Settings */
+#define CP110_NAME				cp0
+#define CP110_NUM				0
+
+#include "armada-cp110.dtsi"
+
+#undef CP110_NAME
+#undef CP110_NUM
+
+/ {
+	model = "Marvell Armada 7040";
+	compatible = "marvell,armada7040", "marvell,armada-ap806-quad",
+		     "marvell,armada-ap806";
+};
+
+&cp0_rtc {
+	status = "okay";
+};
+
+&cp0_pinctl {
+	compatible = "marvell,mvebu-pinctrl", "marvell,armada-7k-pinctrl";
+	bank-name ="cp0-110";
+
+	cp0_i2c0_pins: cp0-i2c-pins-0 {
+		marvell,pins = < 37 38 >;
+		marvell,function = <2>;
+	};
+	cp0_i2c1_pins: cp0-i2c-pins-1 {
+		marvell,pins = < 35 36 >;
+		marvell,function = <2>;
+	};
+	cp0_ge1_rgmii_pins: cp0-ge-rgmii-pins-0 {
+		marvell,pins = < 0 1 2 3 4 5 6 7 8 9 10 11>;
+		marvell,function = <3>;
+	};
+	cp0_ge2_rgmii_pins: cp0-ge-rgmii-pins-1 {
+		marvell,pins = < 44 45 46 47 48 49 50 51
+				52 53 54 55 >;
+		marvell,function = <1>;
+	};
+	cp0_pca0_pins: cp0-pca0_pins {
+		marvell,pins = <62>;
+		marvell,function = <0>;
+	};
+	cp0_sdhci_pins: cp0-sdhi-pins-0 {
+		marvell,pins = < 56 57 58 59 60 61 >;
+		marvell,function = <14>;
+	};
+	cp0_spi0_pins: cp0-spi-pins-0 {
+		marvell,pins = < 13 14 15 16 >;
+		marvell,function = <3>;
+	};
+};
diff --git a/arch/arm/dts/armada-8020.dtsi b/arch/arm/dts/armada-8020.dtsi
index 048e5cf..3f33e78 100644
--- a/arch/arm/dts/armada-8020.dtsi
+++ b/arch/arm/dts/armada-8020.dtsi
@@ -45,12 +45,82 @@
  * two CP110.
  */
 
+#include <dt-bindings/gpio/gpio.h>
+#include "armada-common.dtsi"
 #include "armada-ap806-dual.dtsi"
-#include "armada-cp110-master.dtsi"
-#include "armada-cp110-slave.dtsi"
+
+#define CP110_NAME		cp0
+#define CP110_BASE              0xf2000000
+#define CP110_PCIE_MEM_BASE     0xf6000000
+#define CP110_PCIE_MEM_OFFSET	0x1000000
+
+#include "armada-cp110.dtsi"
+
+#undef CP110_NAME
+#undef CP110_BASE
+#undef CP110_PCIE_MEM_BASE
+
+#define CP110_NAME		cp1
+#define CP110_BASE              0xf4000000
+#define CP110_PCIE_MEM_BASE     0xfa000000
+
+#include "armada-cp110.dtsi"
+
+#undef CP110_NAME
+#undef CP110_BASE
+#undef CP110_PCIE_MEM_BASE
 
 / {
 	model = "Marvell Armada 8020";
 	compatible = "marvell,armada8020", "marvell,armada-ap806-dual",
 		     "marvell,armada-ap806";
 };
+
+&cp0_pinctl {
+	compatible = "marvell,mvebu-pinctrl", "marvell,armada-8k-cpm-pinctrl";
+	bank-name ="cp0-110";
+
+	cp0_i2c0_pins: cp0-i2c-pins-0 {
+		marvell,pins = < 37 38 >;
+		marvell,function = <2>;
+	};
+	cp0_i2c1_pins: cp0-i2c-pins-1 {
+		marvell,pins = < 35 36 >;
+		marvell,function = <2>;
+	};
+	cp0_ge1_rgmii_pins: cp0-ge-rgmii-pins-0 {
+		marvell,pins = < 0 1 2 3 4 5 6 7 8 9 10 11>;
+		marvell,function = <3>;
+	};
+	cp0_ge2_rgmii_pins: cp0-ge-rgmii-pins-1 {
+		marvell,pins = < 44 45 46 47 48 49 50 51
+				52 53 54 55 >;
+		marvell,function = <1>;
+	};
+	cp0_pca0_pins: cp0-pca0_pins {
+		marvell,pins = <62>;
+		marvell,function = <0>;
+	};
+	cp0_sdhci_pins: cp0-sdhi-pins-0 {
+		marvell,pins = < 56 57 58 59 60 61 >;
+		marvell,function = <14>;
+	};
+	cp0_spi0_pins: cp0-spi-pins-0 {
+		marvell,pins = < 13 14 15 16 >;
+		marvell,function = <3>;
+	};
+};
+
+&cp1_pinctl {
+	compatible = "marvell,mvebu-pinctrl", "marvell,armada-8k-cps-pinctrl";
+	bank-name ="cp1-110";
+
+	cp1_ge1_rgmii_pins: cp1-ge-rgmii-pins-0 {
+		marvell,pins = < 0 1 2 3 4 5 6 7 8 9 10 11 >;
+		marvell,function = <3>;
+	};
+	cp1_spi1_pins: cp1-spi-pins-1 {
+		marvell,pins = < 13 14 15 16 >;
+		marvell,function = <3>;
+	};
+};
diff --git a/arch/arm/dts/armada-8040-db-B.dts b/arch/arm/dts/armada-8040-db-B.dts
new file mode 100644
index 0000000..74f9fc2
--- /dev/null
+++ b/arch/arm/dts/armada-8040-db-B.dts
@@ -0,0 +1,339 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for Marvell Armada 8040 Development board platform
+ */
+
+#include "armada-80x0-db.dtsi"
+
+/ {
+	model = "Marvell Armada 8040 Development Board DB-88F8040 setup(B)";
+	compatible = "marvell,armada8040-db", "marvell,armada8040",
+		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp1_spi1;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+		fuse5 = &cp1_ld_efuse0;
+		fuse6 = &cp1_ld_efuse1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+};
+
+/* Accessible over the mini-USB CON9 connector on the main board */
+&uart0 {
+	status = "okay";
+};
+
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
+&ap_pinctl {
+	/* MPP Bus:
+	 * SDIO  [0-10]
+	 * UART0 [11,19]
+	 */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 1 1 1 1
+		     1 3 0 0 0 0 0 0 0 3 >;
+};
+
+&ap_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ap_emmc_pins>;
+	bus-width = <8>;
+	status = "okay";
+};
+
+&cp0_pinctl {
+	/* MPP Bus:
+	 *	[0-31]	= 0xff: Keep default CP0_shared_pins
+	 *	[11]	CLKOUT_MPP_11 (out)
+	 *	[23]	LINK_RD_IN_CP2CP (in)
+	 *	[25]	CLKOUT_MPP_25 (out)
+	 *	[29]	AVS_FB_IN_CP2CP (in)
+	 *	[32,34]	GE_MDIO/MDC
+	 *	[33]	GPIO: GE_INT#/push button/Wake
+	 *	[35]	MSS_GPIO[3]: MSS_PWDN
+	 *	[36]	MSS_GPIO[5]: MSS_VTT_EN
+	 *	[37-38]	I2C0
+	 *	[39]	PTP_CLK
+	 *	[40-41]	SATA[0/1]_PRESENT_ACTIVEn
+	 *	[42-43]	XG_MDC/XG_MDIO (XSMI)
+	 *	[44-55]	RGMII1
+	 *	[56-62]	SD
+	 */
+	/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0x7  0x0  0x7  0xa  0xa  0x2  0x2  0x5
+		     0x9  0x9  0x8  0x8  0x1  0x1  0x1  0x1  0x1  0x1
+		     0x1  0x1  0x1  0x1  0x1  0x1  0xe  0xe  0xe  0xe
+		     0xe  0xe  0xe>;
+};
+
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0-3: PCIe0 (x4)
+	 *	Lane 4: USB3_HOST1
+	 *	Lane 5: PCIe2 (x1)
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+/* CON6 on CP0 expansion */
+&cp0_pcie0 {
+	status = "okay";
+};
+
+&cp0_pcie1 {
+	status = "disabled";
+};
+
+/* CON5 on CP0 expansion */
+&cp0_pcie2 {
+	status = "okay";
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+/* CON9 on CP0 expansion */
+&cp0_usb3_0 {
+	status = "okay";
+};
+
+/* CON10 on CP0 expansion */
+&cp0_usb3_1 {
+	status = "okay";
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_utmi1 {
+	status = "okay";
+};
+
+&cp0_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_sdhci_pins>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+&cp0_mdio {
+	status = "okay";
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth2 {
+	status = "okay";
+	phy = <&phy1>;
+	phy-mode = "rgmii-id";
+};
+
+&cp1_pinctl {
+	/* MPP Bus:
+	 *	[0-11]	RGMII0
+	 *	[13-16]	SPI1
+	 *	[27,31]	GE_MDIO/MDC
+	 *	[28]	SATA1_PRESENT_ACTIVEn
+	 *	[29-30]	UART0
+	 *	[32-62]	= 0xff: Keep default CP1_shared_pins
+	 */
+	/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0x3  0x3  0x3  0x3  0x3  0x3  0x3  0x3  0x3  0x3
+		     0x3  0x3  0x3  0x3  0x3  0x3  0x3  0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0x8  0x9  0xa
+		     0xA  0x8  0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff>;
+};
+
+&cp1_ld_efuse0 {
+	status = "okay";
+};
+
+&cp1_ld_efuse1 {
+	status = "okay";
+};
+
+&cp1_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0: PCIe0 (x1)
+	 *	Lane 1: USB3_HOST0
+	 *	Lane 2: SFI0 (10G)
+	 *	Lane 3: SATA1
+	 *	Lane 4: PCIe1 (x1)
+	 *	Lane 5: PCIe2 (x1)
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_USB3_HOST0>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_PEX1>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+/* CON6 on CP1 expansion */
+&cp1_pcie0 {
+	status = "okay";
+};
+
+&cp1_pcie1 {
+	status = "okay";
+};
+
+/* CON5 on CP1 expansion */
+&cp1_pcie2 {
+	status = "okay";
+};
+
+&cp1_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp1_spi1_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>;		/* CS1 */
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0>;
+		spi-max-frequency = <108000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0 0x200000>;
+			};
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xce0000>;
+			};
+		};
+	};
+};
+
+/* CON4 on CP1 expansion */
+&cp1_sata0 {
+	status = "okay";
+};
+
+/* CON9 on CP1 expansion */
+&cp1_usb3_0 {
+	status = "okay";
+};
+
+&cp1_utmi0 {
+	status = "okay";
+};
+
+&cp1_mdio {
+	status = "okay";
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+};
+
+&cp1_ethernet {
+	status = "okay";
+};
+
+&cp1_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-2 */
+};
+
+&cp1_eth1 {
+	status = "okay";
+	phy = <&phy0>;
+	phy-mode = "rgmii-id";
+};
diff --git a/arch/arm/dts/armada-8040-db-C.dts b/arch/arm/dts/armada-8040-db-C.dts
new file mode 100644
index 0000000..a3977c9
--- /dev/null
+++ b/arch/arm/dts/armada-8040-db-C.dts
@@ -0,0 +1,334 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for Marvell Armada 8040 Development board platform
+ */
+
+#include "armada-80x0-db.dtsi"
+
+/ {
+	model = "Marvell Armada 8040 Development Board DB-88F8040 setup(C)";
+	compatible = "marvell,armada8040-db", "marvell,armada8040",
+		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp1_spi1;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+		fuse5 = &cp1_ld_efuse0;
+		fuse6 = &cp1_ld_efuse1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+};
+
+/* Accessible over the mini-USB CON9 connector on the main board */
+&uart0 {
+	status = "okay";
+};
+
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
+&ap_pinctl {
+	/* MPP Bus:
+	 * SDIO  [0-10]
+	 * UART0 [11,19]
+	 */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 1 1 1 1
+		     1 3 0 0 0 0 0 0 0 3 >;
+};
+
+&ap_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ap_emmc_pins>;
+	bus-width = <8>;
+	status = "okay";
+};
+
+&cp0_pinctl {
+	/* MPP Bus:
+	 *	[0-31]	= 0xff: Keep default CP0_shared_pins
+	 *	[11]	CLKOUT_MPP_11 (out)
+	 *	[23]	LINK_RD_IN_CP2CP (in)
+	 *	[25]	CLKOUT_MPP_25 (out)
+	 *	[29]	AVS_FB_IN_CP2CP (in)
+	 *	[32,34]	GE_MDIO/MDC
+	 *	[33]	GPIO: GE_INT#/push button/Wake
+	 *	[35]	MSS_GPIO[3]: MSS_PWDN
+	 *	[36]	MSS_GPIO[5]: MSS_VTT_EN
+	 *	[37-38]	I2C0
+	 *	[39]	PTP_CLK
+	 *	[40-41]	SATA[0/1]_PRESENT_ACTIVEn
+	 *	[42-43]	XG_MDC/XG_MDIO (XSMI)
+	 *	[44-55]	RGMII1
+	 *	[56-62]	SD
+	 */
+	/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0x7  0x0  0x7  0xa  0xa  0x2  0x2  0x5
+		     0x9  0x9  0x8  0x8  0x1  0x1  0x1  0x1  0x1  0x1
+		     0x1  0x1  0x1  0x1  0x1  0x1  0xe  0xe  0xe  0xe
+		     0xe  0xe  0xe>;
+};
+
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0: PCIe0 (x1)
+	 *	Lane 1: SATA0
+	 *	Lane 2: SFI (10G)
+	 *	Lane 3: SATA1
+	 *	Lane 4: USB3_HOST1
+	 *	Lane 5: PCIe2 (x1)
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+/* CON6 on CP0 expansion */
+&cp0_pcie0 {
+	status = "okay";
+};
+
+&cp0_pcie1 {
+	status = "disabled";
+};
+
+/* CON5 on CP0 expansion */
+&cp0_pcie2 {
+	status = "okay";
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+/* CON4 on CP0 expansion */
+&cp0_sata0 {
+	status = "okay";
+};
+
+/* CON9 on CP0 expansion */
+&cp0_usb3_0 {
+	status = "okay";
+};
+
+/* CON10 on CP0 expansion */
+&cp0_usb3_1 {
+	status = "okay";
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_utmi1 {
+	status = "okay";
+};
+
+&cp0_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_sdhci_pins>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+&cp0_mdio {
+	status = "okay";
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-2 */
+};
+
+&cp0_eth2 {
+	status = "okay";
+	phy = <&phy1>;
+	phy-mode = "rgmii-id";
+};
+
+&cp1_pinctl {
+	/* MPP Bus:
+	 *	[0-11] TDM
+	 *	[13-16] SPI1
+	 *	[27-28] SATA[0/1]_PRESENT_ACTIVEn
+	 *	[29-30] UART0
+	 *	[32-62] = 0xff: Keep default CP1_shared_pins
+	 */
+	/*	     0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0x4  0x4  0x4  0x4  0x4  0x4  0x4  0x4  0x4  0x4
+		     0x4  0x4  0x3  0x3  0x3  0x3  0x3  0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0x9  0x9  0xA
+		     0xA  0x0  0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff>;
+};
+
+&cp1_ld_efuse0 {
+	status = "okay";
+};
+
+&cp1_ld_efuse1 {
+	status = "okay";
+};
+
+&cp1_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0: PCIe0 (x1)
+	 *	Lane 1: SATA0
+	 *	Lane 2: SFI (10G)
+	 *	Lane 3: SATA1
+	 *	Lane 4: PCIe1 (x1)
+	 *	Lane 5: PCIe2 (x1)
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_PEX1>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+/* CON6 on CP1 expansion */
+&cp1_pcie0 {
+	status = "okay";
+};
+
+&cp1_pcie1 {
+	status = "okay";
+};
+
+/* CON5 on CP1 expansion */
+&cp1_pcie2 {
+	status = "okay";
+};
+
+&cp1_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp1_spi1_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>;		/* CS1 */
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0>;
+		spi-max-frequency = <108000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0 0x200000>;
+			};
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xce0000>;
+			};
+		};
+	};
+};
+
+/* CON4 on CP1 expansion */
+&cp1_sata0 {
+	status = "okay";
+};
+
+/* CON9 on CP1 expansion */
+&cp1_usb3_0 {
+	status = "okay";
+};
+
+&cp1_utmi0 {
+	status = "okay";
+};
+
+&cp1_ethernet {
+	status = "okay";
+};
+
+&cp1_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-2 */
+};
diff --git a/arch/arm/dts/armada-8040-db-D.dts b/arch/arm/dts/armada-8040-db-D.dts
new file mode 100644
index 0000000..82679f6
--- /dev/null
+++ b/arch/arm/dts/armada-8040-db-D.dts
@@ -0,0 +1,316 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for Marvell Armada 8040 Development board platform
+ */
+
+#include "armada-80x0-db.dtsi"
+
+/ {
+	model = "Marvell Armada 8040 Development Board DB-88F8040 setup(D)";
+	compatible = "marvell,armada8040-db", "marvell,armada8040",
+		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp1_spi1;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+		fuse5 = &cp1_ld_efuse0;
+		fuse6 = &cp1_ld_efuse1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+
+	cp0_sar {
+		boot_mode {
+			default = <0xe>;
+		};
+	};
+};
+
+/* Accessible over the mini-USB CON9 connector on the main board */
+&uart0 {
+	status = "okay";
+};
+
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
+&ap_pinctl {
+	/* MPP Bus:
+	 * SDIO  [0-10]
+	 * UART0 [11,19]
+	 */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 1 1 1 1
+		     1 3 0 0 0 0 0 0 0 3 >;
+};
+
+&ap_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ap_emmc_pins>;
+	bus-width = <8>;
+	status = "okay";
+};
+
+&cp0_pinctl {
+	/* MPP Bus:
+	 *	[0-31]	= 0xff: Keep default CP0_shared_pins
+	 *	[11]	CLKOUT_MPP_11 (out)
+	 *	[23]	LINK_RD_IN_CP2CP (in)
+	 *	[25]	CLKOUT_MPP_25 (out)
+	 *	[29]	AVS_FB_IN_CP2CP (in)
+	 *	[32,34]	GE_MDIO/MDC
+	 *	[33]	GPIO: GE_INT#/push button/Wake
+	 *	[35]	MSS_GPIO[3]: MSS_PWDN
+	 *	[36]	MSS_GPIO[5]: MSS_VTT_EN
+	 *	[37-38]	I2C0
+	 *	[39]	PTP_CLK
+	 *	[40-41]	SATA[0/1]_PRESENT_ACTIVEn
+	 *	[42-43]	XG_MDC/XG_MDIO (XSMI)
+	 *	[44-55]	RGMII1
+	 *	[56-62]	SD
+	 */
+	/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0x7  0x0  0x7  0xa  0xa  0x2  0x2  0x5
+		     0x9  0x9  0x8  0x8  0x1  0x1  0x1  0x1  0x1  0x1
+		     0x1  0x1  0x1  0x1  0x1  0x1  0xe  0xe  0xe  0xe
+		     0xe  0xe  0xe>;
+};
+
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0: PCIe0 (x1)
+	 *	Lane 1: SATA0
+	 *	Lane 2: SFI (10G)
+	 *	Lane 3: SATA1
+	 *	Lane 4: USB3_HOST1
+	 *	Lane 5: PCIe2 (x1)
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+/* CON6 on CP0 expansion */
+&cp0_pcie0 {
+	status = "okay";
+};
+
+&cp0_pcie1 {
+	status = "disabled";
+};
+
+/* CON5 on CP0 expansion */
+&cp0_pcie2 {
+	status = "okay";
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+/* CON4 on CP0 expansion */
+&cp0_sata0 {
+	status = "okay";
+};
+
+/* CON9 on CP0 expansion */
+&cp0_usb3_0 {
+	status = "okay";
+};
+
+/* CON10 on CP0 expansion */
+&cp0_usb3_1 {
+	status = "okay";
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_utmi1 {
+	status = "okay";
+};
+
+&cp0_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_sdhci_pins>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+&cp0_mdio {
+	status = "okay";
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-2 */
+};
+
+&cp0_eth2 {
+	status = "okay";
+	phy = <&phy1>;
+	phy-mode = "rgmii-id";
+};
+
+&cp1_pinctl {
+	/* MPP Bus:
+	 *	[0-11]  DEV_AD
+	 *	[12,13] ND_RBn
+	 *	[14-27] DEV_AD
+	 *	[28]    SATA1_PRESENT_ACTIVEn
+	 *	[29-30] UART0
+	 *	[32-62] = 0xff: Keep default CP1_shared_pins
+	 */
+	/*	     0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0x1  0x1  0x1  0x1  0x1  0x1  0x1  0x1  0x1  0x1
+		     0x1  0x1  0x2  0x2  0x1  0x1  0x1  0x1  0x1  0x1
+		     0x1  0x1  0x1  0x1  0x1  0x1  0x1  0x1  0x9  0xA
+		     0xA  0x0  0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff>;
+};
+
+&cp1_ld_efuse0 {
+	status = "okay";
+};
+
+&cp1_ld_efuse1 {
+	status = "okay";
+};
+
+&cp1_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0: PCIe0 (x1)
+	 *	Lane 1: SATA0
+	 *	Lane 2: SGMII0 (1.25G)
+	 *	Lane 3: SATA1
+	 *	Lane 4: PCIe1 (x1)
+	 *	Lane 5: PCIe2 (x1)
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_SGMII0>;
+		phy-speed = <COMPHY_SPEED_1_25G>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_PEX1>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+/* CON6 on CP1 expansion */
+&cp1_pcie0 {
+	status = "okay";
+};
+
+&cp1_pcie1 {
+	status = "okay";
+};
+
+/* CON5 on CP1 expansion */
+&cp1_pcie2 {
+	status = "okay";
+};
+
+/* CON4 on CP1 expansion */
+&cp1_sata0 {
+	status = "okay";
+};
+
+/* CON9 on CP1 expansion */
+&cp1_usb3_0 {
+	status = "okay";
+};
+
+&cp1_utmi0 {
+	status = "okay";
+};
+
+&cp1_nand {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp1_nand_pins &cp1_nand_rb>;
+
+	status = "okay";
+};
+
+&cp1_ethernet {
+	status = "okay";
+};
+
+&cp1_eth0 {
+	status = "okay";
+	phy-mode = "sgmii"; /* lane-2 */
+};
diff --git a/arch/arm/dts/armada-8040-db-E.dts b/arch/arm/dts/armada-8040-db-E.dts
new file mode 100644
index 0000000..22d4617
--- /dev/null
+++ b/arch/arm/dts/armada-8040-db-E.dts
@@ -0,0 +1,331 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for Marvell Armada 8040 Development board platform
+ */
+
+#include "armada-80x0-db.dtsi"
+
+/ {
+	model = "Marvell Armada 8040 Development Board DB-88F8040 setup(E)";
+	compatible = "marvell,armada8040-db", "marvell,armada8040",
+		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp1_spi1;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+		fuse5 = &cp1_ld_efuse0;
+		fuse6 = &cp1_ld_efuse1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+};
+
+/* Accessible over the mini-USB CON9 connector on the main board */
+&uart0 {
+	status = "okay";
+};
+
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
+&ap_pinctl {
+	/* MPP Bus:
+	 * SPI0  [0-3]
+	 * UART0 [11,19]
+	 */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 3 3 3 3 0 0 0 0 0 0
+		     0 3 0 0 0 0 0 0 0 3 >;
+};
+
+&ap_spi0 {
+	status = "okay";
+};
+
+&cp0_pinctl {
+	/* MPP Bus:
+	 *	[0-31]	= 0xff: Keep default CP0_shared_pins
+	 *	[11]	CLKOUT_MPP_11 (out)
+	 *	[23]	LINK_RD_IN_CP2CP (in)
+	 *	[25]	CLKOUT_MPP_25 (out)
+	 *	[29]	AVS_FB_IN_CP2CP (in)
+	 *	[32,34] GE_MDIO/MDC
+	 *	[33]    GPIO: GE_INT#/push button/Wake
+	 *	[35]    MSS_GPIO[3]: MSS_PWDN
+	 *	[36]    MSS_GPIO[5]: MSS_VTT_EN
+	 *	[35-36] I2C1
+	 *	[37-38] I2C0
+	 *	[39]	PTP_CLK
+	 *	[40-41] SATA[0/1]_PRESENT_ACTIVEn
+	 *	[42-43] XG_MDC/XG_MDIO (XSMI)
+	 *	[47,49] UART1
+	 *	[50-51] UART2
+	 *	[54]	SDIO_HW_RST
+	 *	[56-62] SD
+	 */
+	/*	     0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0x0  0xff 0x2  0x2  0x2  0x2  0x5
+		     0x9  0x9  0x8  0x8  0xff 0xff 0xff 0x7  0xff 0x7
+		     0x6  0x6  0xff 0xff 0xa  0xff 0xe  0xe  0xe  0xe
+		     0xe  0xe  0xe>;
+};
+
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0: PCIe0 (x1)
+	 *	Lane 1: SATA0
+	 *	Lane 2: SFI (10G)
+	 *	Lane 3: SATA1
+	 *	Lane 4: USB3_HOST1
+	 *	Lane 5: PCIe2 (x1)
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+/* CON6 on CP0 expansion */
+&cp0_pcie0 {
+	status = "okay";
+};
+
+/* CON5 on CP0 expansion */
+&cp0_pcie2 {
+	status = "okay";
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+/* CON4 on CP0 expansion */
+&cp0_sata0 {
+	status = "okay";
+};
+
+/* CON9 on CP0 expansion */
+&cp0_usb3_0 {
+	status = "okay";
+};
+
+/* CON10 on CP0 expansion */
+&cp0_usb3_1 {
+	status = "okay";
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_utmi1 {
+	status = "okay";
+};
+
+&cp0_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_sdhci_pins>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-2 */
+};
+
+&cp1_pinctl {
+	/* MPP Bus:
+	 *	[0-11]	RGMII0
+	 *	[13-16]	SPI1
+	 *	[27,31]	GE_MDIO/MDC
+	 *	[28]	SATA1_PRESENT_ACTIVEn
+	 *	[29-30]	UART0
+	 *	[32-62]	= 0xff: Keep default CP1_shared_pins
+	 */
+	/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0x3  0x3  0x3  0x3  0x3  0x3  0x3  0x3  0x3  0x3
+		     0x3  0x3  0x3  0x3  0x3  0x3  0x3  0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0x8  0x9  0xa
+		     0xA  0x8  0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff>;
+};
+
+&cp1_ld_efuse0 {
+	status = "okay";
+};
+
+&cp1_ld_efuse1 {
+	status = "okay";
+};
+
+&cp1_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0: PCIe0 (x1)
+	 *	Lane 1: SATA0
+	 *	Lane 2: SGMII (3.125G)
+	 *	Lane 3: SATA1
+	 *	Lane 4: PCIe1 (x1)
+	 *	Lane 5: PCIe2 (x1)
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_SGMII0>;
+		phy-speed = <COMPHY_SPEED_3_125G>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_PEX1>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+/* CON6 on CP1 expansion */
+&cp1_pcie0 {
+	status = "okay";
+};
+
+&cp1_pcie1 {
+	status = "okay";
+};
+
+/* CON5 on CP1 expansion */
+&cp1_pcie2 {
+	status = "okay";
+};
+
+&cp1_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp1_spi1_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>;		/* CS1 */
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0>;
+		spi-max-frequency = <108000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0 0x200000>;
+			};
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xce0000>;
+			};
+		};
+	};
+};
+
+/* CON4 on CP1 expansion */
+&cp1_sata0 {
+	status = "disabled";
+};
+
+/* CON9 on CP1 expansion */
+&cp1_usb3_0 {
+	status = "okay";
+};
+
+&cp1_utmi0 {
+	status = "okay";
+};
+
+&cp1_mdio {
+	status = "okay";
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+};
+
+&cp1_ethernet {
+	status = "okay";
+};
+
+&cp1_eth0 {
+	status = "okay";
+	phy-mode = "sgmii"; /* lane-2 */
+};
+
+&cp1_eth1 {
+	status = "okay";
+	phy = <&phy0>;
+	phy-mode = "rgmii-id";
+};
diff --git a/arch/arm/dts/armada-8040-db-F.dts b/arch/arm/dts/armada-8040-db-F.dts
new file mode 100644
index 0000000..6d3596e
--- /dev/null
+++ b/arch/arm/dts/armada-8040-db-F.dts
@@ -0,0 +1,395 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for Marvell Armada 8040 Development board platform
+ */
+
+#include "armada-8040.dtsi"
+
+/ {
+	model = "Marvell Armada 8040 Development Board DB-88F8040 setup(F)";
+	compatible = "marvell,armada8040-db", "marvell,armada8040",
+		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp1_spi1;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+		fuse5 = &cp1_ld_efuse0;
+		fuse6 = &cp1_ld_efuse1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+
+	cp0_reg_usb3_vbus0:cp0_usb3_vbus@0 {
+		compatible = "regulator-fixed";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		startup-delay-us = <100000>;
+		regulator-force-boot-off;
+		gpio = <&expander0 0 GPIO_ACTIVE_HIGH>;
+	};
+
+	cp0_reg_usb3_vbus1: cp0_usb3_vbus@1 {
+		compatible = "regulator-fixed";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		startup-delay-us = <100000>;
+		regulator-force-boot-off;
+		gpio = <&expander0 1 GPIO_ACTIVE_HIGH>;
+	};
+
+	/* even though this node used for enable/disable cp1 usb vbus-supply,
+	 * we use "cp0" prefix since the expander is connected to cp0.
+	 */
+	cp0_reg_usb3_vbus2: cp0_usb3_vbus@2 {
+		compatible = "regulator-fixed";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		startup-delay-us = <100000>;
+		regulator-force-boot-off;
+		gpio = <&expander1 0 GPIO_ACTIVE_HIGH>;
+	};
+};
+
+/* Accessible over the mini-USB CON9 connector on the main board */
+&uart0 {
+	status = "okay";
+};
+
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
+&ap_pinctl {
+	/* MPP Bus:
+	 * SDIO  [0-10]
+	 * UART0 [11,19]
+	 */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 1 1 1 1
+		     1 3 0 0 0 0 0 0 0 3 >;
+};
+
+&ap_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ap_emmc_pins>;
+	bus-width = <8>;
+	status = "okay";
+};
+
+&cp0_pinctl {
+	/* MPP Bus:
+	 *	[0-31]	= 0xff: Keep default CP0_shared_pins
+	 *	[11]	CLKOUT_MPP_11 (out)
+	 *	[23]	LINK_RD_IN_CP2CP (in)
+	 *	[25]	CLKOUT_MPP_25 (out)
+	 *	[29]	AVS_FB_IN_CP2CP (in)
+	 *	[32,34]	GE_MDIO/MDC
+	 *	[33]	GPIO: GE_INT#/push button/Wake
+	 *	[35]	MSS_GPIO[3]: MSS_PWDN
+	 *	[36]	MSS_GPIO[5]: MSS_VTT_EN
+	 *	[37-38]	I2C0
+	 *	[39]	PTP_CLK
+	 *	[40-41]	SATA[0/1]_PRESENT_ACTIVEn
+	 *	[42-43]	XG_MDC/XG_MDIO (XSMI)
+	 *	[44-55]	RGMII1
+	 *	[56-62]	SD
+	 */
+		/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0x7  0x0  0x7  0xa  0xa  0x2  0x2  0x5
+		     0x9  0x9  0x8  0x8  0x1  0x1  0x1  0x1  0x1  0x1
+		     0x1  0x1  0x1  0x1  0x1  0x1  0xe  0xe  0xe  0xe
+		     0xe  0xe  0xe>;
+};
+
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0: PCIe0 (x1)
+	 *	Lane 1: SATA0
+	 *	Lane 2: SFI (10G)
+	 *	Lane 3: SATA1
+	 *	Lane 4: USB3_HOST1
+	 *	Lane 5: PCIe2 (x1)
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_AP>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+/* CON6 on CP0 expansion */
+&cp0_pcie0 {
+	status = "okay";
+};
+
+&cp0_pcie1 {
+	status = "disabled";
+};
+
+/* CON5 on CP0 expansion */
+&cp0_pcie2 {
+	status = "okay";
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+	expander0: pca953x@21 {
+		compatible = "nxp,pca9555";
+		#gpio-cells = <2>;
+		reg = <0x21>;
+		status = "okay";
+	};
+	expander1: pca953x@25 {
+		compatible = "nxp,pca9555";
+		#gpio-cells = <2>;
+		reg = <0x25>;
+		status = "okay";
+	};
+};
+
+/* CON4 on CP0 expansion */
+&cp0_sata0 {
+	status = "okay";
+};
+
+/* CON9 on CP0 expansion */
+&cp0_usb3_0 {
+	vbus-supply = <&cp0_reg_usb3_vbus0>;
+	vbus-disable-delay = <500>;
+	status = "okay";
+};
+
+/* CON10 on CP0 expansion */
+&cp0_usb3_1 {
+	vbus-supply = <&cp0_reg_usb3_vbus1>;
+	vbus-disable-delay = <500>;
+	status = "okay";
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_utmi1 {
+	status = "okay";
+};
+
+&cp0_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_sdhci_pins>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+&cp0_mdio {
+	status = "okay";
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "ap"; /* lane-2: left for auto-neg */
+};
+
+&cp0_eth2 {
+	status = "okay";
+	phy = <&phy1>;
+	phy-mode = "rgmii-id";
+};
+
+&cp1_pinctl {
+	/* MPP Bus:
+	 *	[0-11]	RGMII0
+	 *	[13-16]	SPI1
+	 *	[27,31]	GE_MDIO/MDC
+	 *	[28]	SATA1_PRESENT_ACTIVEn
+	 *	[29-30]	UART0
+	 *	[32-62]	= 0xff: Keep default CP1_shared_pins
+	 */
+		/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0x3  0x3  0x3  0x3  0x3  0x3  0x3  0x3  0x3  0x3
+		     0x3  0x3  0x3  0x3  0x3  0x3  0x3  0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0x8  0x9  0xa
+		     0xA  0x8  0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff>;
+};
+
+&cp1_ld_efuse0 {
+	status = "okay";
+};
+
+&cp1_ld_efuse1 {
+	status = "okay";
+};
+
+&cp1_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0: PCIe0 (x1)
+	 *	Lane 1: SATA0
+	 *	Lane 2: SFI (10G)
+	 *	Lane 3: SATA1
+	 *	Lane 4: PCIe1 (x1)
+	 *	Lane 5: PCIe2 (x1)
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_PEX1>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+/* CON6 on CP1 expansion */
+&cp1_pcie0 {
+	status = "okay";
+};
+
+&cp1_pcie1 {
+	status = "okay";
+};
+
+/* CON5 on CP1 expansion */
+&cp1_pcie2 {
+	status = "okay";
+};
+
+&cp1_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp1_spi1_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>;		/* CS1 */
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0>;
+		spi-max-frequency = <108000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0 0x200000>;
+			};
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xce0000>;
+			};
+		};
+	};
+};
+
+/* CON4 on CP1 expansion */
+&cp1_sata0 {
+	status = "okay";
+};
+
+/* CON9 on CP1 expansion */
+&cp1_usb3_0 {
+	vbus-supply = <&cp0_reg_usb3_vbus2>;
+	vbus-disable-delay = <500>;
+	status = "okay";
+};
+
+&cp1_utmi0 {
+	status = "okay";
+};
+
+&cp1_mdio {
+	status = "okay";
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+};
+
+&cp1_ethernet {
+	status = "okay";
+};
+
+&cp1_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-2 */
+};
+
+&cp1_eth1 {
+	status = "okay";
+	phy = <&phy0>;
+	phy-mode = "rgmii-id";
+};
diff --git a/arch/arm/dts/armada-8040-db-G.dts b/arch/arm/dts/armada-8040-db-G.dts
new file mode 100644
index 0000000..964c71d
--- /dev/null
+++ b/arch/arm/dts/armada-8040-db-G.dts
@@ -0,0 +1,344 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for Marvell Armada 8040 Development board platform
+ */
+
+#include "armada-80x0-db.dtsi"
+
+/ {
+	model = "Marvell Armada 8040 Development Board DB-88F8040 setup(G)";
+	compatible = "marvell,armada8040-db", "marvell,armada8040",
+		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp1_spi1;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+		fuse5 = &cp1_ld_efuse0;
+		fuse6 = &cp1_ld_efuse1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+};
+
+/* Accessible over the mini-USB CON9 connector on the main board */
+&uart0 {
+	status = "okay";
+};
+
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
+&ap_pinctl {
+	/* MPP Bus:
+	 * SDIO  [0-10]
+	 * UART0 [11,19]
+	 */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 1 1 1 1
+		     1 3 0 0 0 0 0 0 0 3 >;
+};
+
+&ap_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ap_emmc_pins>;
+	bus-width = <8>;
+	status = "okay";
+};
+
+&cp0_pinctl {
+	/* MPP Bus:
+	 *	[0-31]	= 0xff: Keep default CP0_shared_pins
+	 *	[11]	CLKOUT_MPP_11 (out)
+	 *	[23]	LINK_RD_IN_CP2CP (in)
+	 *	[25]	CLKOUT_MPP_25 (out)
+	 *	[29]	AVS_FB_IN_CP2CP (in)
+	 *	[32,34]	GE_MDIO/MDC
+	 *	[33]	GPIO: GE_INT#/push button/Wake
+	 *	[35]	MSS_GPIO[3]: MSS_PWDN
+	 *	[36]	MSS_GPIO[5]: MSS_VTT_EN
+	 *	[37-38]	I2C0
+	 *	[39]	PTP_CLK
+	 *	[40-41]	SATA[0/1]_PRESENT_ACTIVEn
+	 *	[42-43]	XG_MDC/XG_MDIO (XSMI)
+	 *	[44-55]	RGMII1
+	 *	[56-62]	SD
+	 */
+	/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0x7  0x0  0x7  0xa  0xa  0x2  0x2  0x5
+		     0x9  0x9  0x8  0x8  0x1  0x1  0x1  0x1  0x1  0x1
+		     0x1  0x1  0x1  0x1  0x1  0x1  0xe  0xe  0xe  0xe
+		     0xe  0xe  0xe>;
+};
+
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0-3: PCIe0 (x4)
+	 *	Lane 4: USB3_HOST1
+	 *	Lane 5: PCIe2 (x1)
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+/* CON6 on CP0 expansion */
+&cp0_pcie0 {
+	status = "okay";
+};
+
+&cp0_pcie1 {
+	status = "disabled";
+};
+
+/* CON5 on CP0 expansion */
+&cp0_pcie2 {
+	status = "okay";
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+/* CON9 on CP0 expansion */
+&cp0_usb3_0 {
+	status = "okay";
+};
+
+/* CON10 on CP0 expansion */
+&cp0_usb3_1 {
+	status = "okay";
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_utmi1 {
+	status = "okay";
+};
+
+&cp0_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_sdhci_pins>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+&cp0_mdio {
+	status = "okay";
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth2 {
+	status = "okay";
+	phy = <&phy1>;
+	phy-mode = "rgmii-id";
+};
+
+&cp1_pinctl {
+	/* MPP Bus:
+	 *	[0-11]	RGMII0
+	 *	[13-16]	SPI1
+	 *	[27,31]	GE_MDIO/MDC
+	 *	[28]	SATA1_PRESENT_ACTIVEn
+	 *	[29-30]	UART0
+	 *	[32-62]	= 0xff: Keep default CP1_shared_pins
+	 */
+	/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0x3  0x3  0x3  0x3  0x3  0x3  0x3  0x3  0x3  0x3
+		     0x3  0x3  0x3  0x3  0x3  0x3  0x3  0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0x8  0x9  0xa
+		     0xA  0x8  0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff>;
+};
+
+&cp1_ld_efuse0 {
+	status = "okay";
+};
+
+&cp1_ld_efuse1 {
+	status = "okay";
+};
+
+&cp1_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0-3: PCIe0 (x4)
+	 *	Lane 4: USB3_HOST1
+	 *	Lane 5: PCIe2 (x1)
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+/* CON6 on CP1 expansion */
+&cp1_pcie0 {
+	status = "okay";
+};
+
+&cp1_pcie1 {
+	status = "disabled";
+};
+
+/* CON5 on CP1 expansion */
+&cp1_pcie2 {
+	status = "okay";
+};
+
+&cp1_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp1_spi1_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>;		/* CS1 */
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0>;
+		spi-max-frequency = <108000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0 0x200000>;
+			};
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xce0000>;
+			};
+		};
+	};
+};
+
+/* CON9 on CP1 expansion */
+&cp1_usb3_0 {
+	status = "okay";
+};
+
+/* CON10 on CP0 expansion */
+&cp1_usb3_1 {
+	status = "okay";
+};
+
+&cp1_utmi0 {
+	status = "okay";
+};
+
+&cp1_utmi1 {
+	status = "okay";
+};
+
+&cp1_mdio {
+	status = "okay";
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+};
+
+&cp1_ethernet {
+	status = "okay";
+};
+
+&cp1_eth0 {
+	status = "disabled";
+	phy-mode = "sfi"; /* lane-2 */
+};
+
+&cp1_eth1 {
+	status = "okay";
+	phy = <&phy0>;
+	phy-mode = "rgmii-id";
+};
diff --git a/arch/arm/dts/armada-8040-db-H.dts b/arch/arm/dts/armada-8040-db-H.dts
new file mode 100644
index 0000000..d8b78cd
--- /dev/null
+++ b/arch/arm/dts/armada-8040-db-H.dts
@@ -0,0 +1,351 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/*
+ * Device Tree file for Marvell Armada 8040 Development board platform
+ */
+
+#include "armada-80x0-db.dtsi"
+
+/ {
+	model = "Marvell Armada 8040 Development Board DB-88F8040 setup(H)";
+	compatible = "marvell,armada8040-db", "marvell,armada8040",
+		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp1_spi1;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+		fuse5 = &cp1_ld_efuse0;
+		fuse6 = &cp1_ld_efuse1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+};
+
+/* Accessible over the mini-USB CON9 connector on the main board */
+&uart0 {
+	status = "okay";
+};
+
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
+&ap_pinctl {
+	/* MPP Bus:
+	 * SDIO  [0-10]
+	 * UART0 [11,19]
+	 */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 1 1 1 1
+		     1 3 0 0 0 0 0 0 0 3 >;
+};
+
+&ap_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ap_emmc_pins>;
+	bus-width = <8>;
+	status = "okay";
+};
+
+&cp0_pinctl {
+	/* MPP Bus:
+	 *	[0-31]	= 0xff: Keep default CP0_shared_pins
+	 *	[11]	CLKOUT_MPP_11 (out)
+	 *	[23]	LINK_RD_IN_CP2CP (in)
+	 *	[25]	CLKOUT_MPP_25 (out)
+	 *	[29]	AVS_FB_IN_CP2CP (in)
+	 *	[32,34]	GE_MDIO/MDC
+	 *	[33]	GPIO: GE_INT#/push button/Wake
+	 *	[35]	MSS_GPIO[3]: MSS_PWDN
+	 *	[36]	MSS_GPIO[5]: MSS_VTT_EN
+	 *	[37-38]	I2C0
+	 *	[39]	PTP_CLK
+	 *	[40-41]	SATA[0/1]_PRESENT_ACTIVEn
+	 *	[42-43]	XG_MDC/XG_MDIO (XSMI)
+	 *	[44-55]	RGMII1
+	 *	[56-62]	SD
+	 */
+	/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0x7  0x0  0x7  0xa  0xa  0x2  0x2  0x5
+		     0x9  0x9  0x8  0x8  0x1  0x1  0x1  0x1  0x1  0x1
+		     0x1  0x1  0x1  0x1  0x1  0x1  0xe  0xe  0xe  0xe
+		     0xe  0xe  0xe>;
+};
+
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0-3: PCIe0 (x4)
+	 *	Lane 4: SFI0 (10G)
+	 *	Lane 5: PCIe2 (x1)
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI1>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+/* CON6 on CP0 expansion */
+&cp0_pcie0 {
+	status = "okay";
+};
+
+&cp0_pcie1 {
+	status = "disabled";
+};
+
+/* CON5 on CP0 expansion */
+&cp0_pcie2 {
+	status = "okay";
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+/* CON9 on CP0 expansion */
+&cp0_usb3_0 {
+	status = "okay";
+};
+
+/* CON10 on CP0 expansion */
+&cp0_usb3_1 {
+	status = "okay";
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_utmi1 {
+	status = "okay";
+};
+
+&cp0_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_sdhci_pins>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+&cp0_mdio {
+	status = "okay";
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-4 */
+};
+
+&cp0_eth2 {
+	status = "okay";
+	phy = <&phy1>;
+	phy-mode = "rgmii-id";
+};
+
+&cp1_pinctl {
+	/* MPP Bus:
+	 *	[0-11]	RGMII0
+	 *	[13-16]	SPI1
+	 *	[27,31]	GE_MDIO/MDC
+	 *	[28]	SATA1_PRESENT_ACTIVEn
+	 *	[29-30]	UART0
+	 *	[32-62]	= 0xff: Keep default CP1_shared_pins
+	 */
+	/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0x3  0x3  0x3  0x3  0x3  0x3  0x3  0x3  0x3  0x3
+		     0x3  0x3  0x3  0x3  0x3  0x3  0x3  0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0x8  0x9  0xa
+		     0xA  0x8  0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff>;
+};
+
+&cp1_ld_efuse0 {
+	status = "okay";
+};
+
+&cp1_ld_efuse1 {
+	status = "okay";
+};
+
+&cp1_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0-3: PCIe0 (x4)
+	 *	Lane 4: SFI0 (10G)
+	 *	Lane 5: PCIe2 (x1)
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI1>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+/* CON6 on CP1 expansion */
+&cp1_pcie0 {
+	status = "okay";
+};
+
+&cp1_pcie1 {
+	status = "disabled";
+};
+
+/* CON5 on CP1 expansion */
+&cp1_pcie2 {
+	status = "okay";
+};
+
+&cp1_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp1_spi1_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>;		/* CS1 */
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0>;
+		spi-max-frequency = <108000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0 0x200000>;
+			};
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xce0000>;
+			};
+		};
+	};
+};
+
+/* CON9 on CP1 expansion */
+&cp1_usb3_0 {
+	status = "okay";
+};
+
+/* CON10 on CP0 expansion */
+&cp1_usb3_1 {
+	status = "okay";
+};
+
+&cp1_utmi0 {
+	status = "okay";
+};
+
+&cp1_utmi1 {
+	status = "okay";
+};
+
+&cp1_mdio {
+	status = "okay";
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+};
+
+&cp1_ethernet {
+	status = "okay";
+};
+
+&cp1_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-4 */
+};
+
+&cp1_eth1 {
+	status = "okay";
+	phy = <&phy0>;
+	phy-mode = "rgmii-id";
+};
diff --git a/arch/arm/dts/armada-8040-db.dts b/arch/arm/dts/armada-8040-db.dts
index fa58995..9c54862 100644
--- a/arch/arm/dts/armada-8040-db.dts
+++ b/arch/arm/dts/armada-8040-db.dts
@@ -44,10 +44,10 @@
  * Device Tree file for Marvell Armada 8040 Development board platform
  */
 
-#include "armada-8040.dtsi"
+#include "armada-80x0-db.dtsi"
 
 / {
-	model = "Marvell Armada 8040 DB board";
+	model = "Marvell Armada 8040 Development Board DB-88F8040";
 	compatible = "marvell,armada8040-db", "marvell,armada8040",
 		     "marvell,armada-ap806-quad", "marvell,armada-ap806";
 
@@ -56,8 +56,14 @@
 	};
 
 	aliases {
-		i2c0 = &cpm_i2c0;
-		spi0 = &cps_spi1;
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp1_spi1;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+		fuse5 = &cp1_ld_efuse0;
+		fuse6 = &cp1_ld_efuse1;
 	};
 
 	memory@00000000 {
@@ -71,6 +77,18 @@
 	status = "okay";
 };
 
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
 &ap_pinctl {
 	/* MPP Bus:
 	 * SDIO  [0-10]
@@ -81,7 +99,14 @@
 		     1 3 0 0 0 0 0 0 0 3 >;
 };
 
-&cpm_pinctl {
+&ap_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ap_emmc_pins>;
+	bus-width = <8>;
+	status = "okay";
+};
+
+&cp0_pinctl {
 	/* MPP Bus:
 	 *	[0-31]	= 0xff: Keep default CP0_shared_pins
 	 *	[11]	CLKOUT_MPP_11 (out)
@@ -109,7 +134,15 @@
 		     0xe  0xe  0xe>;
 };
 
-&cpm_comphy {
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_comphy {
 	/* Serdes Configuration:
 	 *	Lane 0: PCIe0 (x1)
 	 *	Lane 1: SATA0
@@ -119,70 +152,78 @@
 	 *	Lane 5: PCIe2 (x1)
 	 */
 	phy0 {
-		phy-type = <PHY_TYPE_PEX0>;
+		phy-type = <COMPHY_TYPE_PEX0>;
 	};
 	phy1 {
-		phy-type = <PHY_TYPE_SATA0>;
+		phy-type = <COMPHY_TYPE_SATA0>;
 	};
 	phy2 {
-		phy-type = <PHY_TYPE_SFI>;
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
 	};
 	phy3 {
-		phy-type = <PHY_TYPE_SATA1>;
+		phy-type = <COMPHY_TYPE_SATA1>;
 	};
 	phy4 {
-		phy-type = <PHY_TYPE_USB3_HOST1>;
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
 	};
 	phy5 {
-		phy-type = <PHY_TYPE_PEX2>;
+		phy-type = <COMPHY_TYPE_PEX2>;
 	};
 };
 
 /* CON6 on CP0 expansion */
-&cpm_pcie0 {
+&cp0_pcie0 {
 	status = "okay";
 };
 
-&cpm_pcie1 {
+&cp0_pcie1 {
 	status = "disabled";
 };
 
 /* CON5 on CP0 expansion */
-&cpm_pcie2 {
+&cp0_pcie2 {
 	status = "okay";
 };
 
-&cpm_i2c0 {
+&cp0_i2c0 {
 	pinctrl-names = "default";
-	pinctrl-0 = <&cpm_i2c0_pins>;
+	pinctrl-0 = <&cp0_i2c0_pins>;
 	status = "okay";
 	clock-frequency = <100000>;
 };
 
 /* CON4 on CP0 expansion */
-&cpm_sata0 {
+&cp0_sata0 {
 	status = "okay";
 };
 
 /* CON9 on CP0 expansion */
-&cpm_usb3_0 {
+&cp0_usb3_0 {
 	status = "okay";
 };
 
 /* CON10 on CP0 expansion */
-&cpm_usb3_1 {
+&cp0_usb3_1 {
 	status = "okay";
 };
 
-&cpm_utmi0 {
+&cp0_utmi0 {
 	status = "okay";
 };
 
-&cpm_utmi1 {
+&cp0_utmi1 {
 	status = "okay";
 };
 
-&cps_pinctl {
+&cp0_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_sdhci_pins>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+&cp1_pinctl {
 	/* MPP Bus:
 	 *	[0-11]	RGMII0
 	 *	[13-16]	SPI1
@@ -201,7 +242,15 @@
 		     0xff 0xff 0xff>;
 };
 
-&cps_comphy {
+&cp1_ld_efuse0 {
+	status = "okay";
+};
+
+&cp1_ld_efuse1 {
+	status = "okay";
+};
+
+&cp1_comphy {
 	/* Serdes Configuration:
 	 *	Lane 0: PCIe0 (x1)
 	 *	Lane 1: SATA0
@@ -211,50 +260,54 @@
 	 *	Lane 5: PCIe2 (x1)
 	 */
 	phy0 {
-		phy-type = <PHY_TYPE_PEX0>;
+		phy-type = <COMPHY_TYPE_PEX0>;
 	};
 	phy1 {
-		phy-type = <PHY_TYPE_SATA0>;
+		phy-type = <COMPHY_TYPE_SATA0>;
 	};
 	phy2 {
-		phy-type = <PHY_TYPE_SFI>;
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
 	};
 	phy3 {
-		phy-type = <PHY_TYPE_SATA1>;
+		phy-type = <COMPHY_TYPE_SATA1>;
 	};
 	phy4 {
-		phy-type = <PHY_TYPE_PEX1>;
+		phy-type = <COMPHY_TYPE_PEX1>;
 	};
 	phy5 {
-		phy-type = <PHY_TYPE_PEX2>;
+		phy-type = <COMPHY_TYPE_PEX2>;
 	};
 };
 
 /* CON6 on CP1 expansion */
-&cps_pcie0 {
+&cp1_pcie0 {
 	status = "okay";
 };
 
-&cps_pcie1 {
+&cp1_pcie1 {
 	status = "okay";
 };
 
 /* CON5 on CP1 expansion */
-&cps_pcie2 {
+&cp1_pcie2 {
 	status = "okay";
 };
 
-&cps_spi1 {
+&cp1_spi1 {
 	pinctrl-names = "default";
-	pinctrl-0 = <&cps_spi1_pins>;
+	pinctrl-0 = <&cp1_spi1_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>;		/* CS1 */
 	status = "okay";
 
 	spi-flash@0 {
 		#address-cells = <1>;
 		#size-cells = <1>;
-		compatible = "jedec,spi-nor";
+		compatible = "jedec,spi-nor", "spi-flash";
 		reg = <0>;
-		spi-max-frequency = <10000000>;
+		spi-max-frequency = <108000000>;
 
 		partitions {
 			compatible = "fixed-partitions";
@@ -274,36 +327,59 @@
 };
 
 /* CON4 on CP1 expansion */
-&cps_sata0 {
+&cp1_sata0 {
 	status = "okay";
 };
 
 /* CON9 on CP1 expansion */
-&cps_usb3_0 {
+&cp1_usb3_0 {
 	status = "okay";
 };
 
-/* CON10 on CP1 expansion */
-&cps_usb3_1 {
+&cp1_utmi0 {
 	status = "okay";
 };
 
-&cps_utmi0 {
+&cp0_mdio {
 	status = "okay";
-};
-
-&cpm_mdio {
 	phy1: ethernet-phy@1 {
 		reg = <1>;
 	};
 };
 
-&cpm_ethernet {
+&cp1_mdio {
+	status = "okay";
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp1_ethernet {
+	status = "okay";
+};
+
+&cp0_eth0 {
 	status = "okay";
+	phy-mode = "sfi"; /* lane-2 */
 };
 
-&cpm_eth2 {
+&cp0_eth2 {
 	status = "okay";
 	phy = <&phy1>;
 	phy-mode = "rgmii-id";
 };
+
+&cp1_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-2 */
+};
+
+&cp1_eth1 {
+	status = "okay";
+	phy = <&phy0>;
+	phy-mode = "rgmii-id";
+};
diff --git a/arch/arm/dts/armada-8040-dev-info.dtsi b/arch/arm/dts/armada-8040-dev-info.dtsi
new file mode 100644
index 0000000..a8a51f2
--- /dev/null
+++ b/arch/arm/dts/armada-8040-dev-info.dtsi
@@ -0,0 +1,64 @@
+/*
+ * ***************************************************************************
+ * Copyright (C) 2017 Marvell International Ltd.
+ * ***************************************************************************
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * ***************************************************************************
+ */
+
+/ {
+	/* This should go only into devel boards */
+	compatible = "marvell,cp110";
+	sar {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		sar_fields {
+
+			compatible = "marvell,sample-at-reset";
+			reg = <0x4c 0x4e>;
+			chip_count = <2>;
+			bit_width = <5>;
+
+			freq {
+				key = "freq";
+				description = "CPU/DDR and PIDI frequencies";
+				start-bit = <0>;
+				bit-length = <4>;
+				option-cnt = <4>;
+				options = "0x1", "CPU/DDR = 0x1:  2000/1050 Mhz, PIDI = 0: 1Ghz",
+					  "0x3", "CPU/DDR = 0x3:  1800/1050 Mhz, PIDI = 0: 1Ghz",
+					  "0x4", "CPU/DDR = 0x4:  1600/1050 Mhz, PIDI = 0: 1Ghz",
+					  "0xe", "CPU/DDR = 0x34: 1300/800 Mhz,  PIDI = 1: 500Mhz";
+				default = <0x1>;
+				status = "okay";
+			};
+			boot_mode {
+				key = "boot_mode";
+				description = "Boot mode options";
+				start-bit = <4>;
+				bit-length = <6>;
+				option-cnt = <7>;
+				options = "0xE", "CP1_NAND IHB BW-8bit, PS-4KB, ECC-4bit\t(supported configuration: D)",
+					  "0xF", "CP1_NAND IHB BW-8bit, PS-4KB, ECC-8bit\t(supported configuration: D)",
+					  "0x29", "CP0_SD\t\t\t\t\t(supported configurations: C, D and E)",
+					  "0x2A", "AP_EMMC\t\t\t\t\t(supported configurations: A, B, C and D)",
+					  "0x2B", "CP0_EMMC\t\t\t\t\t(supported configurations: A and B)",
+					  "0x30", "AP_SPI 24bits\t\t\t\t(supported configurations: E and A0)",
+					  "0x32", "CP1_SPI_1 24bits\t\t\t\t(supported configurations: A, B, C and E)";
+				default = <0x32>;
+				status = "okay";
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/armada-8040-mcbin-single-shot.dts b/arch/arm/dts/armada-8040-mcbin-single-shot.dts
new file mode 100644
index 0000000..44135da
--- /dev/null
+++ b/arch/arm/dts/armada-8040-mcbin-single-shot.dts
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include "armada-8040-mcbin.dts"
+
+/{
+	model = "Marvell 8040 MACHIATOBin SingleShot";
+	compatible = "marvell,armada8040-mcbin-single-shot",
+		     "marvell,armada8040-mcbin",
+		     "marvell,armada8040";
+};
+
+/* 10G SFI/copper */
+&cp0_eth0 {
+	/delete-property/phy;
+};
+
+/* 10G SFI/copper */
+&cp1_eth0 {
+	/delete-property/phy;
+};
+
+/delete-node/ &sfi_phy0;
+/delete-node/ &sfi_phy8;
diff --git a/arch/arm/dts/armada-8040-mcbin.dts b/arch/arm/dts/armada-8040-mcbin.dts
index 991ddc0..db0570e 100644
--- a/arch/arm/dts/armada-8040-mcbin.dts
+++ b/arch/arm/dts/armada-8040-mcbin.dts
@@ -5,10 +5,10 @@
  * https://spdx.org/licenses
  */
 
-#include "armada-8040.dtsi" /* include SoC device tree */
+#include "armada-80x0-db.dtsi" /* include SoC device tree */
 
 / {
-	model = "MACCHIATOBin-8040";
+	model = "Marvell Armada 8040 MACCHIATOBin";
 	compatible = "marvell,armada8040-mcbin",
 		     "marvell,armada8040";
 
@@ -17,12 +17,18 @@
 	};
 
 	aliases {
-		i2c0 = &cpm_i2c0;
-		i2c1 = &cpm_i2c1;
-		spi0 = &cps_spi1;
+		i2c0 = &cp0_i2c0;
+		i2c1 = &cp0_i2c1;
+		spi0 = &cp1_spi1;
 		gpio0 = &ap_gpio0;
-		gpio1 = &cpm_gpio0;
-		gpio2 = &cpm_gpio1;
+		gpio1 = &cp0_gpio0;
+		gpio2 = &cp0_gpio1;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+		fuse5 = &cp1_ld_efuse0;
+		fuse6 = &cp1_ld_efuse1;
 	};
 
 	memory@00000000 {
@@ -38,15 +44,13 @@
 		reg_usb3h0_vbus: usb3-vbus0 {
 			compatible = "regulator-fixed";
 			pinctrl-names = "default";
-			pinctrl-0 = <&cpm_xhci_vbus_pins>;
+			pinctrl-0 = <&cp0_xhci_vbus_pins>;
 			regulator-name = "reg-usb3h0-vbus";
 			regulator-min-microvolt = <5000000>;
 			regulator-max-microvolt = <5000000>;
-			startup-delay-us = <500000>;
-			enable-active-high;
-			regulator-always-on;
-			regulator-boot-on;
-			gpio = <&cpm_gpio1 15 GPIO_ACTIVE_HIGH>; /* GPIO[47] */
+			startup-delay-us = <300000>;
+			regulator-force-boot-off;
+			gpio = <&cp0_gpio1 15 GPIO_ACTIVE_HIGH>; /* GPIO[47] */
 		};
 	};
 };
@@ -56,6 +60,18 @@
 	status = "okay";
 };
 
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
 &ap_pinctl {
 	/*
 	 * MPP Bus:
@@ -71,11 +87,11 @@
 &ap_sdhci0 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&ap_emmc_pins>;
-	bus-width= <8>;
+	bus-width = <8>;
 	status = "okay";
 };
 
-&cpm_pinctl {
+&cp0_pinctl {
 	/*
 	 * MPP Bus:
 	 * [0-31] = 0xff: Keep default CP0_shared_pins:
@@ -110,53 +126,69 @@
 		     0    0    0    0    0    0    0xe  0xe  0xe  0xe
 		     0xe  0xe  0 >;
 
-	cpm_xhci_vbus_pins: cpm-xhci-vbus-pins {
+	cp0_xhci_vbus_pins: cp0-xhci-vbus-pins {
 		marvell,pins = < 47 >;
 		marvell,function = <0>;
 	};
 
-	cpm_pcie_reset_pins: cpm-pcie-reset-pins {
+	cp0_pcie_reset_pins: cp0-pcie-reset-pins {
 		marvell,pins = < 52 >;
 		marvell,function = <0>;
 	};
 };
 
 /* uSD slot */
-&cpm_sdhci0 {
+&cp0_sdhci0 {
 	pinctrl-names = "default";
-	pinctrl-0 = <&cpm_sdhci_pins>;
+	pinctrl-0 = <&cp0_sdhci_pins>;
 	bus-width= <4>;
 	status = "okay";
 };
 
 /* PCIe x4 */
-&cpm_pcie0 {
+&cp0_pcie0 {
 	num-lanes = <4>;
 	pinctrl-names = "default";
-	pinctrl-0 = <&cpm_pcie_reset_pins>;
-	marvell,reset-gpio = <&cpm_gpio1 20 GPIO_ACTIVE_HIGH>; /* GPIO[52] */
+	pinctrl-0 = <&cp0_pcie_reset_pins>;
+	marvell,reset-gpio = <&cp0_gpio1 20 GPIO_ACTIVE_HIGH>; /* GPIO[52] */
 	status = "okay";
 };
 
-&cpm_i2c0 {
+&cp0_i2c0 {
 	pinctrl-names = "default";
-	pinctrl-0 = <&cpm_i2c0_pins>;
+	pinctrl-0 = <&cp0_i2c0_pins>;
 	status = "okay";
 	clock-frequency = <100000>;
 };
 
-&cpm_i2c1 {
+&cp0_i2c1 {
 	pinctrl-names = "default";
-	pinctrl-0 = <&cpm_i2c1_pins>;
+	pinctrl-0 = <&cp0_i2c1_pins>;
 	status = "okay";
 	clock-frequency = <100000>;
 };
 
-&cpm_sata0 {
+&cp0_sata0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
 	status = "okay";
 };
 
-&cpm_comphy {
+/* uSD slot */
+&cp0_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_sdhci_pins>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+&cp0_comphy {
 	/*
 	 * CP0 Serdes Configuration:
 	 * Lane 0: PCIe0 (x4)
@@ -167,39 +199,73 @@
 	 * Lane 5: SATA1
 	 */
 	phy0 {
-		phy-type = <PHY_TYPE_PEX0>;
+		phy-type = <COMPHY_TYPE_PEX0>;
 	};
 	phy1 {
-		phy-type = <PHY_TYPE_PEX0>;
+		phy-type = <COMPHY_TYPE_PEX0>;
 	};
 	phy2 {
-		phy-type = <PHY_TYPE_PEX0>;
+		phy-type = <COMPHY_TYPE_PEX0>;
 	};
 	phy3 {
-		phy-type = <PHY_TYPE_PEX0>;
+		phy-type = <COMPHY_TYPE_PEX0>;
 	};
 	phy4 {
-		phy-type = <PHY_TYPE_SFI>;
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
 	};
 	phy5 {
-		phy-type = <PHY_TYPE_SATA1>;
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+};
+
+&cp0_mdio {
+	status = "okay";
+	ge_phy0: ethernet-phy@0 {
+		reg = <0>;
 	};
 };
 
-&cps_sata0 {
+&cp0_xmdio {
 	status = "okay";
+	sfi_phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+
+	sfi_phy8: ethernet-phy@8 {
+		reg = <8>;
+	};
 };
 
-&cps_usb3_0 {
+&cp0_ethernet {
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+/* 10G SFI/copper */
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi";
+	phy = <&sfi_phy0>;
+	phy-reset-gpios = <&cp1_gpio0 31 GPIO_ACTIVE_HIGH>;
+	marvell,sfp-tx-disable-gpio = <&cp1_gpio0 29 GPIO_ACTIVE_HIGH>;
+};
+
+&cp1_sata0 {
+	status = "okay";
+};
+
+&cp1_usb3_0 {
 	vbus-supply = <&reg_usb3h0_vbus>;
+	/delete-property/ current-limiter;
 	status = "okay";
 };
 
-&cps_utmi0 {
+&cp1_utmi0 {
 	status = "okay";
 };
 
-&cps_pinctl {
+&cp1_pinctl {
 	/*
 	 * MPP Bus:
 	 * [0-5] TDM
@@ -232,17 +298,20 @@
 		     0xff 0xff 0xff>;
 };
 
-&cps_spi1 {
+&cp1_spi1 {
 	pinctrl-names = "default";
-	pinctrl-0 = <&cps_spi1_pins>;
+	pinctrl-0 = <&cp1_spi1_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>;		/* CS1 */
 	status = "okay";
 
 	spi-flash@0 {
 		#address-cells = <1>;
 		#size-cells = <1>;
-		compatible = "jedec,spi-nor";
+		compatible = "jedec,spi-nor", "spi-flash";
 		reg = <0>;
-		spi-max-frequency = <10000000>;
+		spi-max-frequency = <108000000>;
 
 		partitions {
 			compatible = "fixed-partitions";
@@ -261,7 +330,15 @@
 	};
 };
 
-&cps_comphy {
+&cp1_ld_efuse0 {
+	status = "okay";
+};
+
+&cp1_ld_efuse1 {
+	status = "okay";
+};
+
+&cp1_comphy {
 	/*
 	 * CP1 Serdes Configuration:
 	 * Lane 0: SGMII1
@@ -272,22 +349,52 @@
 	 * Lane 5: SGMII3
 	 */
 	phy0 {
-		phy-type = <PHY_TYPE_SGMII1>;
-		phy-speed = <PHY_SPEED_1_25G>;
+		phy-type = <COMPHY_TYPE_SGMII1>;
+		phy-speed = <COMPHY_SPEED_1_25G>;
 	};
 	phy1 {
-		phy-type = <PHY_TYPE_SATA0>;
+		phy-type = <COMPHY_TYPE_SATA0>;
 	};
 	phy2 {
-		phy-type = <PHY_TYPE_USB3_HOST0>;
+		phy-type = <COMPHY_TYPE_USB3_HOST0>;
 	};
 	phy3 {
-		phy-type = <PHY_TYPE_SATA1>;
+		phy-type = <COMPHY_TYPE_SATA1>;
 	};
 	phy4 {
-		phy-type = <PHY_TYPE_SFI>;
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
 	};
 	phy5 {
-		phy-type = <PHY_TYPE_SGMII3>;
+		phy-type = <COMPHY_TYPE_SGMII2>;
+		phy-speed = <COMPHY_SPEED_3_125G>;
 	};
 };
+
+&cp1_ethernet {
+	status = "okay";
+};
+
+/* 10G SFI/copper */
+&cp1_eth0 {
+	status = "okay";
+	phy-mode = "sfi";
+	phy = <&sfi_phy8>;
+	phy-reset-gpios = <&cp1_gpio0 9 GPIO_ACTIVE_HIGH>;
+	marvell,sfp-tx-disable-gpio = <&cp1_gpio0 10 GPIO_ACTIVE_HIGH>;
+};
+
+/* 1G SFI */
+&cp1_eth1 {
+	status = "okay";
+	phy-mode = "sgmii";
+	phy = <&ge_phy0>;
+};
+
+/* 2.5G copper */
+&cp1_eth2 {
+	status = "okay";
+	phy-mode = "sgmii";
+	phy-speed = <2500>;
+	marvell,sfp-tx-disable-gpio = <&cp1_gpio0 24 GPIO_ACTIVE_HIGH>;
+};
diff --git a/arch/arm/dts/armada-8040-ocp.dts b/arch/arm/dts/armada-8040-ocp.dts
new file mode 100644
index 0000000..460f2d4
--- /dev/null
+++ b/arch/arm/dts/armada-8040-ocp.dts
@@ -0,0 +1,318 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "armada-8040.dtsi" /* include SoC device tree */
+
+/ {
+	model = "OCP-8K";	/* PCB model */
+	compatible = "marvell,armada8040-ocp",
+		     "marvell,armada8040";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		i2c1 = &cp0_i2c1;
+		spi0 = &cp1_spi1;
+		gpio0 = &ap_gpio0;
+		gpio1 = &cp0_gpio0;
+		gpio2 = &cp0_gpio1;
+		fuse1 = &ap_ld_efuse0;
+		fuse2 = &ap_ld_efuse1;
+		fuse3 = &cp0_ld_efuse0;
+		fuse4 = &cp0_ld_efuse1;
+		fuse5 = &cp1_ld_efuse0;
+		fuse6 = &cp1_ld_efuse1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+
+	simple-bus {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reg_usb3h0_vbus: usb3-vbus0 {
+			compatible = "regulator-fixed";
+			pinctrl-names = "default";
+			pinctrl-0 = <&cp0_xhci_vbus_pins>;
+			regulator-name = "reg-usb3h0-vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			startup-delay-us = <300000>;
+			shutdown-delay-us = <500000>;
+			regulator-force-boot-off;
+			gpio = <&cp0_gpio1 15 GPIO_ACTIVE_HIGH>; /* GPIO[47] */
+		};
+	};
+};
+
+/*
+ * Accessible over the front panel micro USB connector CON9 or the
+ * three pin header (default unsoldered) J27 where the pinout is as follows -
+ * 1-GND, 2-8040 SoC RX, 3-8040 SoC TX.
+ */
+&uart0 {
+	status = "okay";
+};
+
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
+&ap_pinctl {
+	/*
+	 * MPP Bus:
+	 * eMMC [0-10]
+	 * UART0 [11,19]
+	 */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 1 1 1 1
+		     1 3 2 0 0 0 0 0 0 3 >;
+};
+
+/* on-board eMMC */
+&ap_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ap_emmc_pins>;
+	bus-width = <8>;
+	no-1-8-v;
+	non-removable;
+	status = "okay";
+};
+
+&cp0_pinctl {
+/*
+ * [0-32] = 0xff: Keep default CP1_shared_pins
+ * [32..34] Front panel LEDs (active low)
+ * [35-38] CP0 I2C1 and I2C0
+ * [39] MSS_GPIO
+ * [40-41] NC
+ * [42] LED
+ * [43] Mask system reset (active high)
+ * [47] USB VBUS EN GPIO
+ * [48-49] NC
+ * [50,51] CP0 MSS I2C
+ * [52-61] NC
+ * [62] CP1 SFI SFP FAULT
+ */
+		  /*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0    0    0    2    2    2    2    0
+		     7    7    0    0    0    0    0    0    0xff 0xff
+		     0    0    0    0    0    0    0xe  0xe  0xe  0xe
+		     0xe  0xe  0 >;
+
+	cp0_xhci_vbus_pins: cp0-xhci-vbus-pins {
+		marvell,pins = < 47 >;
+		marvell,function = <0>;
+	};
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_i2c1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c1_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_comphy {
+	/*
+	 * CP0 Serdes Configuration:
+	 * PCIex4 is connected to CP0
+	 * Lane 0: IGNORE (x4)
+	 * Lane 1: IGNORE (x4)
+	 * Lane 2: IGNORE (x4)
+	 * Lane 3: IGNORE (x4)
+	 * Lane 4: SFI (10G)
+	 * Lane 5: UNCONNECTED
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_IGNORE>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_IGNORE>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_IGNORE>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_IGNORE>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_UNCONNECTED>;
+	};
+};
+
+&cp0_ethernet {
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+/* 10G SFI/copper */
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi";
+	marvell,sfp-tx-disable-gpio = <&cp1_gpio0 24 GPIO_ACTIVE_HIGH>;
+};
+
+&cp1_utmi0 {
+	status = "okay";
+};
+
+&cp1_usb3_0 {
+	vbus-supply = <&reg_usb3h0_vbus>;
+	status = "okay";
+};
+
+&cp1_pinctl {
+	/*
+	 * MPP Bus:
+	 * [0-5] NC
+	 * [6,7] UART0
+	 * [8]   CP1 10G SFP LOS
+	 * [9]   NC
+	 * [10]  CP1 10G SFP TX Disable
+	 * [11]  CP1 10G SFP Mode
+	 * [12]  SPI1 CS1n
+	 * [13]  SPI1 MISO (TDM and SPI ROM shared)
+	 * [14]  SPI1 CS0n
+	 * [15]  SPI1 MOSI (TDM and SPI ROM shared)
+	 * [16]  SPI1 CLK (TDM and SPI ROM shared)
+	 * [17-23] NC
+	 * [24]  CP0_10G_SFP_TX_DISABLE
+	 * [25]  NC
+	 * [26]  CP0 10G SFP TX Fault
+	 * [27]  CP0 10G SFP Mode
+	 * [28]  CP0 10G SFP LOS
+	 * [29]  MSS_TWSI_SDA - NOTE: set as gpio, to be used
+	 *                            when MSS is used for power cooling
+	 * [30]  MSS_TWSI_SDA - NOTE: set as gpio, to be used
+	 *                            when MSS is used for power cooling
+	 * [31]  USB Over current indication
+	 * [32-62] = 0xff: Keep default CP0_shared_pins:
+	 */
+		/*     0    1    2    3    4    5    6    7    8    9 */
+	pin-func = <  0xff 0xff 0xff 0xff 0xff 0xff 0x8  0x8  0    0xff
+		      0    0    3    3    3    3    3    0xff 0xff 0xff
+		      0xff 0xff 0xff 0xff 0    0xff 0    0    0    0
+		      0    0    0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		      0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		      0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		      0xff 0xff 0xff>;
+};
+
+&cp1_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp1_spi1_pins>;
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0>;
+		spi-max-frequency = <108000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0 0x200000>;
+			};
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xce0000>;
+			};
+		};
+	};
+};
+
+&cp1_ld_efuse0 {
+	status = "okay";
+};
+
+&cp1_ld_efuse1 {
+	status = "okay";
+};
+
+&cp1_comphy {
+	/* check if PCI is here, else none
+	 * CP1 Serdes Configuration:
+	 * Lane 0: UNCONNECTED
+	 * Lane 1: UNCONNECTED
+	 * Lane 2: UNCONNECTED
+	 * Lane 3: UNCONNECTED
+	 * Lane 4: SFI (10G)
+	 * Lane 5: UNCONNECTED
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_UNCONNECTED>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_UNCONNECTED>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_UNCONNECTED>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_UNCONNECTED>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_UNCONNECTED>;
+	};
+};
+
+&cp1_ethernet {
+	status = "okay";
+};
+
+/* 10G SFI/copper */
+&cp1_eth0 {
+	status = "okay";
+	phy-mode = "sfi";
+	marvell,sfp-tx-disable-gpio = <&cp1_gpio0 10 GPIO_ACTIVE_HIGH>;
+};
diff --git a/arch/arm/dts/armada-8040-ucpe.dts b/arch/arm/dts/armada-8040-ucpe.dts
new file mode 100644
index 0000000..a040288
--- /dev/null
+++ b/arch/arm/dts/armada-8040-ucpe.dts
@@ -0,0 +1,383 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include "armada-8040.dtsi" /* include SoC device tree */
+
+/ {
+	model = "Marvell Armada 8040 uCPE";
+	compatible = "marvell,armada-8040-ucpe",
+		     "marvell,armada8040";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		i2c1 = &cp0_i2c1;
+		spi0 = &cp1_spi1;
+		gpio0 = &ap_gpio0;
+		gpio1 = &cp0_gpio0;
+		gpio2 = &cp0_gpio1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+
+	simple-bus {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cp0_reg_usb3h0_vbus: usb3-right-port-vbus {
+			compatible = "regulator-fixed";
+			pinctrl-names = "default";
+			pinctrl-0 = <&cp0_xhci_vbus_pins0>;
+			regulator-name = "cp0_reg-usb3h0-vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			startup-delay-us = <300000>;
+			shutdown-delay-us = <500000>;
+			gpio = <&cp0_gpio1 10 GPIO_ACTIVE_LOW>; /* GPIO[42] */
+		};
+
+		cp0_reg_usb3h1_vbus: usb3-left-port-vbus {
+			compatible = "regulator-fixed";
+			pinctrl-names = "default";
+			pinctrl-0 = <&cp0_xhci_vbus_pins1>;
+			regulator-name = "cp0_reg-usb3h1-vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			startup-delay-us = <300000>;
+			shutdown-delay-us = <500000>;
+			gpio = <&cp0_gpio1 11 GPIO_ACTIVE_LOW>; /* GPIO[43] */
+		};
+	};
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&ap_pinctl {
+	/*
+	 * MPP Bus:
+	 * AP_SD_CLK    [0]
+	 * AP_SD_CMD    [1]
+	 * AP_SD_D[0~7] [2-10]
+	 * UART0        [11,19]
+	 * AP_SD_HW_RST [12]
+	 */
+		  /* 0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 1 1 1 1
+		     1 3 2 0 0 0 0 0 0 3 >;
+};
+
+/* on-board eMMC, KLM8G1GEME-B041 */
+&ap_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ap_emmc_pins>;
+	bus-width = <8>;
+	status = "okay";
+};
+
+&cp0_pinctl {
+	/*
+	 * MPP Bus:
+	 * [0-31] = 0xff: Keep default CP0_shared_pins:
+	 * [32] CP1_PCIE1_CLKREQn
+	 * [33] 10_SFP_LED
+	 * [34] CP1_PCIE0_CLKREQn
+	 * [35-36] CP0 I2C1
+	 * [37-38] CP0 I2C0
+	 * [39] PWM IC enable
+	 * [40,41] CP0 SMI
+	 * [42] USB3 PWR EN Port1
+	 * [43] USB3 PWR EN Port2
+	 * [44] CP0_PCIe0_clk_en
+	 * [45] CP0 PCIe0 and PCIe1 RSTOUTn
+	 * [46] CP0_PCIe0_waken
+	 * [47] CP0_PCIe1_waken
+	 * [48] CP0_PCIe1_clk_en / SFP 1G LED SW4
+	 * [49] CP0 PCIe0 wifi disable
+	 * [50-51] CP0_UA2
+	 * [52] TP31 --> CP0_LED_CLK ?
+	 * [53] TP32 --> CP0_LED_STB ?
+	 * [54] CP0 LED data
+	 * [55] Micro SD card detect
+	 * [56-61] Micro SD
+	 * [62] CP0 PCIe1 wifi disable
+	 */
+		/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0    0x9  0x0  0x9  0x2  0x2  0x2  0x2  0x0
+		     0x8  0x8  0x0  0x0  0x0  0x9  0x0  0x0  0x0  0x0
+		     0x6  0x6  0x8  0x8  0x0  0x0  0xe  0xe  0xe  0xe
+		     0xe  0xe  0x0 >;
+
+	cp0_xhci_vbus_pins0: cpm-xhci-vbus-pins {
+		marvell,pins = < 42 >;
+		marvell,function = <0>;
+	};
+
+	cp0_xhci_vbus_pins1: cpm-xhci-vbus-pins {
+		marvell,pins = < 43 >;
+		marvell,function = <0>;
+	};
+};
+
+&cp0_pcie0 {
+	status = "okay";
+	reset-gpios = <&cp0_gpio1 13 GPIO_ACTIVE_HIGH>;
+	gpio = <&cp0_gpio1 12 GPIO_ACTIVE_HIGH>; /* MPP[44] clock enable*/
+};
+
+&cp0_pcie1 {
+	status = "okay";
+	reset-gpios = <&cp0_gpio1 13 GPIO_ACTIVE_HIGH>;
+	gpio = <&cp0_gpio1 16 GPIO_ACTIVE_HIGH>; /* MPP[48] clock enable*/
+};
+
+&cp0_pcie2 {
+	status = "disabled";
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_i2c1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c1_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+/* uSD slot */
+&cp0_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_sdhci_pins>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+&cp0_usb3_0 {
+	status = "okay";
+	/* MPP[42] for USB3 port0 vbus on/off*/
+	vbus-supply = <&cp0_reg_usb3h0_vbus>;
+};
+
+&cp0_usb3_1 {
+	status = "okay";
+	/* MPP[43] for USB3 port0 vbus on/off*/
+	vbus-supply = <&cp0_reg_usb3h1_vbus>;
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_utmi1 {
+	status = "okay";
+};
+
+&cp0_comphy {
+	/*
+	 * CP0 Serdes Configuration:
+	 * Lane 0: PCIE0
+	 * Lane 1: USB3 HOST0
+	 * Lane 2: SFI
+	 * Lane 3: USB3 HOST1
+	 * Lane 4: PCIE1
+	 * Lane 5: NC
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_USB3_HOST0>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_PEX1>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_UNCONNECTED>;
+	};
+};
+
+&cp0_mdio {
+	status = "okay";
+
+	mvswitch: switch@0{
+		compatible = "marvell,mv88e6xxx";
+		status = "okay";
+		phy-addr = <0x0>;
+		cpu-port = <0xa>;
+		port-mask = <0x7FF>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+/* 10G SFI/copper */
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi";
+};
+
+&cp1_sata0 {
+	status = "okay";
+	gpio = <&cp1_gpio0 17 GPIO_ACTIVE_LOW>;
+};
+
+&cp1_usb3_0 {
+	status = "okay";
+};
+
+&cp1_utmi0 {
+	status = "okay";
+};
+
+&cp1_pinctl {
+	/*
+	 * MPP Bus:
+	 * [0-5] TDM
+	 * [6,7] CP1_UART 0
+	 * [8]   CP1 10G SFP LOS
+	 * [9]   CP1 10G TX FAULT
+	 * [10]  CP1 10G SFP TX Disable
+	 * [11]  CP1 10G SFP Mode
+	 * [12]  SPI1 CS1n
+	 * [13]  SPI1 MISO (TDM and SPI ROM shared)
+	 * [14]  SPI1 CS0n
+	 * [15]  SPI1 MOSI (TDM and SPI ROM shared)
+	 * [16]  SPI1 CLK (TDM and SPI ROM shared)
+	 * [17]  SSD DEV SLEEP (pull down to wake up SSD)
+	 * [18]  FAN PWM
+	 * [19]  PWM Sense
+	 * [20]  SFP 1G LED SW1
+	 * [21]  SFP 1G LED SW2
+	 * [22]  USB3 Port1 PWR overcurrent ?
+	 * [23]  USB3 Port2 PWR overcurrent ?
+	 * [24]  TP33
+	 * [25-28] LTE
+	 * [29]  PCA9535 int
+	 * [30]  E6390 int
+	 * [31]  E6390 RESETn
+	 * [32-62] = 0xff: Keep default CP1_shared_pins:
+	 */
+		/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0x4  0x4  0x4  0x4  0x4  0x4  0x8  0x8  0x0  0x0
+		     0x0  0x0  0x3  0x3  0x3  0x3  0x3  0x0  0x0  0x0
+		     0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0
+		     0x0  0x0  0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff
+		     0xff 0xff 0xff>;
+};
+
+&cp1_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp1_spi1_pins>;
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <10000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0 0x200000>;
+			};
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xce0000>;
+			};
+		};
+	};
+};
+
+&cp1_comphy {
+	/*
+	 * CP1 Serdes Configuration:
+	 * Lane 0: SATA 1
+	 * Lane 1: SATA 0
+	 * Lane 2: USB HOST 0
+	 * Lane 3: HS-SGMII
+	 * Lane 4: RXAUI0
+	 * Lane 5: RXAUI1
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_USB3_HOST0>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_SGMII1>;
+		phy-speed = <COMPHY_SPEED_3_125G>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_RXAUI0>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_RXAUI1>;
+	};
+};
+
+&cp1_ethernet {
+	status = "okay";
+};
+
+/* 10G RXAUI to E6390X port9 - CP1 SRDS[4:5] */
+&cp1_eth0 {
+	status = "disabled";
+	phy-mode = "rxaui";
+};
+
+/* 2.5G SGMii to E6390X port10 - CP1 SRDS[3] */
+&cp1_eth1 {
+	status = "okay";
+	phy-mode = "sgmii";
+	phy-speed = <2500>;
+	phy = <&mvswitch>;
+	marvell,sfp-tx-disable-gpio = <&cp1_gpio0 24 GPIO_ACTIVE_HIGH>;
+	fixed-link {
+		speed = <2500>;
+		full-duplex;
+	};
+};
+
+&cp1_eth2 {
+	status = "disabled";
+};
diff --git a/arch/arm/dts/armada-8040.dtsi b/arch/arm/dts/armada-8040.dtsi
index 96cc112..9d701c4 100644
--- a/arch/arm/dts/armada-8040.dtsi
+++ b/arch/arm/dts/armada-8040.dtsi
@@ -46,12 +46,96 @@
  */
 
 #include <dt-bindings/gpio/gpio.h>
-#include "armada-ap806-quad.dtsi"
-#include "armada-cp110-master.dtsi"
-#include "armada-cp110-slave.dtsi"
+#include "armada-common.dtsi"
+#include "armada-8k.dtsi"
+#include "armada-ap806.dtsi"
+#include "armada-ap80x-quad.dtsi"
+
+/* CP110-0 Settings */
+#define CP110_NAME				cp0
+#define CP110_NUM				0
+
+#include "armada-cp110.dtsi"
+
+#undef CP110_NAME
+#undef CP110_NUM
+
+/* CP110-1 Settings */
+#define CP110_NAME				cp1
+#define CP110_NUM				1
+
+#include "armada-cp110.dtsi"
+
+#undef CP110_NAME
+#undef CP110_NUM
 
 / {
 	model = "Marvell Armada 8040";
 	compatible = "marvell,armada8040", "marvell,armada-ap806-quad",
 		     "marvell,armada-ap806";
 };
+
+&cp0_rtc {
+	status = "okay";
+};
+
+&cp0_pinctl {
+	compatible = "marvell,mvebu-pinctrl", "marvell,armada-8k-cpm-pinctrl";
+	bank-name ="cp0-110";
+
+	cp0_i2c0_pins: cp0-i2c-pins-0 {
+		marvell,pins = < 37 38 >;
+		marvell,function = <2>;
+	};
+	cp0_i2c1_pins: cp0-i2c-pins-1 {
+		marvell,pins = < 35 36 >;
+		marvell,function = <2>;
+	};
+	cp0_ge1_rgmii_pins: cp0-ge-rgmii-pins-0 {
+		marvell,pins = < 0 1 2 3 4 5 6 7 8 9 10 11>;
+		marvell,function = <3>;
+	};
+	cp0_ge2_rgmii_pins: cp0-ge-rgmii-pins-1 {
+		marvell,pins = < 44 45 46 47 48 49 50 51
+				52 53 54 55 >;
+		marvell,function = <1>;
+	};
+	cp0_pca0_pins: cp0-pca0_pins {
+		marvell,pins = <62>;
+		marvell,function = <0>;
+	};
+	cp0_sdhci_pins: cp0-sdhi-pins-0 {
+		marvell,pins = < 56 57 58 59 60 61 >;
+		marvell,function = <14>;
+	};
+	cp0_spi0_pins: cp0-spi-pins-0 {
+		marvell,pins = < 13 14 15 16 >;
+		marvell,function = <3>;
+	};
+};
+
+&cp1_pinctl {
+	compatible = "marvell,mvebu-pinctrl", "marvell,armada-8k-cps-pinctrl";
+	bank-name ="cp1-110";
+
+	cp1_ge1_rgmii_pins: cp1-ge-rgmii-pins-0 {
+		marvell,pins = < 0 1 2 3 4 5 6 7 8 9 10 11 >;
+		marvell,function = <3>;
+	};
+	cp1_spi1_pins: cp1-spi-pins-1 {
+		marvell,pins = < 13 14 15 16 >;
+		marvell,function = <3>;
+	};
+
+	cp1_nand_pins: cp1-nand-pins {
+		marvell,pins = < 0  1  2  3  4  5  6  7  8
+				 9  10 11 14 15 16 17 18 19
+				 20 21 22 23 24 25 26 27 >;
+		marvell,function = <1>;
+	};
+
+	cp1_nand_rb: cp1-nand-rb {
+		marvell,pins = < 12 13 >;
+		marvell,function = <2>;
+	};
+};
diff --git a/arch/arm/dts/armada-80x0-db.dtsi b/arch/arm/dts/armada-80x0-db.dtsi
new file mode 100644
index 0000000..fe074e0
--- /dev/null
+++ b/arch/arm/dts/armada-80x0-db.dtsi
@@ -0,0 +1,143 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "armada-8040.dtsi" /* include SoC device tree */
+#include "armada-8040-dev-info.dtsi"
+
+/ {
+	compatible = "marvell,armada-80x0-db", "marvell,armada-8040";
+	model = "DB-ARMADA-80x0";
+
+	cp0 {
+		config-space {
+			i2c@701000 {
+				expander0: pca953x@21 {
+					compatible = "nxp,pca9555";
+					#gpio-cells = <2>;
+					reg = <0x21>;
+					status = "okay";
+				};
+				expander1: pca953x@25 {
+					compatible = "nxp,pca9555";
+					#gpio-cells = <2>;
+					reg = <0x25>;
+					status = "okay";
+				};
+			};
+
+			sdhci@780000 {
+				vqmmc-supply = <&cp0_reg_sd_vccq>;
+			};
+
+			cp0_reg_usb3_vbus0:cp0_usb3_vbus@0 {
+				compatible = "regulator-fixed";
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5000000>;
+				startup-delay-us = <100000>;
+				regulator-force-boot-off;
+				gpio = <&expander0 0 GPIO_ACTIVE_HIGH>;
+			};
+
+			cp0_reg_usb3_vbus1: cp0_usb3_vbus@1 {
+				compatible = "regulator-fixed";
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5000000>;
+				startup-delay-us = <100000>;
+				regulator-force-boot-off;
+				gpio = <&expander0 1 GPIO_ACTIVE_HIGH>;
+			};
+
+			cp0_reg_usb3_current_limiter0:cp0_usb3_current_limiter@0 {
+				compatible = "regulator-fixed";
+				regulator-min-microamp = <900000>;
+				regulator-max-microamp = <900000>;
+				regulator-force-boot-off;
+				gpio = <&expander0 4 GPIO_ACTIVE_HIGH>;
+			};
+
+			cp0_reg_usb3_current_limiter1: cp0_usb3_current_limiter@1 {
+				compatible = "regulator-fixed";
+				regulator-min-microamp = <900000>;
+				regulator-max-microamp = <900000>;
+				regulator-force-boot-off;
+				gpio = <&expander0 5 GPIO_ACTIVE_HIGH>;
+			};
+			/*
+			 * Even though this node used for enable/disable
+			 * cp1 usb vbus-supply, we use "cp0" prefix since
+			 * the expander is connected to cp0.
+			 */
+			cp0_reg_usb3_vbus2: cp0_usb3_vbus@2 {
+				compatible = "regulator-fixed";
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5000000>;
+				startup-delay-us = <100000>;
+				regulator-force-boot-off;
+				gpio = <&expander1 0 GPIO_ACTIVE_HIGH>;
+			};
+
+			cp0_reg_usb3_vbus3: cp0_usb3_vbus@3 {
+				compatible = "regulator-fixed";
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5000000>;
+				startup-delay-us = <100000>;
+				regulator-force-boot-off;
+				gpio = <&expander1 1 GPIO_ACTIVE_HIGH>;
+			};
+
+			cp0_reg_usb3_current_limiter2: cp0_usb3_current_limiter@2 {
+				compatible = "regulator-fixed";
+				regulator-min-microamp = <900000>;
+				regulator-max-microamp = <900000>;
+				regulator-force-boot-off;
+				gpio = <&expander1 4 GPIO_ACTIVE_HIGH>;
+			};
+
+			cp0_usb3_0: usb3@500000 {
+				vbus-supply = <&cp0_reg_usb3_vbus0>;
+				current-limiter = <&cp0_reg_usb3_current_limiter0>;
+				vbus-disable-delay = <500>;
+			};
+			cp0_usb3_1: usb3@510000 {
+				vbus-supply = <&cp0_reg_usb3_vbus1>;
+				current-limiter = <&cp0_reg_usb3_current_limiter1>;
+				vbus-disable-delay = <500>;
+			};
+
+			cp0_reg_sd_vccq: cp0_sd_vccq@0 {
+				compatible = "regulator-gpio";
+				regulator-name = "cp0_sd_vcc";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				gpios = <&expander0 15 GPIO_ACTIVE_HIGH>;
+				states = <1800000 0x1
+					  3300000 0x0>;
+			};
+		};
+	};
+
+#define CP110_NUM				1
+#define SPI_DIRECT_BASE				(0xf9000000)
+
+	cp1 {
+		config-space {
+			ranges = <0x0 U64_TO_U32_H(CP110_BASE) U64_TO_U32_L(CP110_BASE) 0x2000000>,			/* internal regs */
+				 <0x2000000 U64_TO_U32_H(SPI_DIRECT_BASE) U64_TO_U32_L(SPI_DIRECT_BASE) 0x1000000>;	/* SPI1-DEV0 */
+
+			cp1_usb3_0: usb3@500000 {
+				vbus-supply = <&cp0_reg_usb3_vbus2>;
+				current-limiter = <&cp0_reg_usb3_current_limiter2>;
+				vbus-disable-delay = <500>;
+			};
+
+			cp1_usb3_1: usb3@510000 {
+				vbus-supply = <&cp0_reg_usb3_vbus3>;
+				vbus-disable-delay = <500>;
+			};
+
+		};
+	};
+#undef CP110_NUM
+};
diff --git a/arch/arm/dts/armada-8k.dtsi b/arch/arm/dts/armada-8k.dtsi
new file mode 100644
index 0000000..923466d
--- /dev/null
+++ b/arch/arm/dts/armada-8k.dtsi
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+/* Common definitions used by Armada 8K DTs */
+
+/* This defines used to calculate the base address of each CP */
+#define CP110_BASE_OFFSET			(0xf2000000)
+#define CP110_SPACE_SIZE			(0x02000000)
+#define CP110_BASE				(CP110_BASE_OFFSET + \
+	((CP110_NUM % 2) * CP110_SPACE_SIZE))
+
+#define CP110_PCIE_MEM_SIZE(iface)	(0xf00000)
+#define CP110_PCIEx_CPU_MEM_BASE(iface)		\
+	(0xf6000000 + (CP110_NUM % 2) * 0x4000000 + (iface) *  0x1000000)
+#define CP110_PCIEx_BUS_MEM_BASE(iface)		\
+		(CP110_PCIEx_CPU_MEM_BASE(iface))
+#define CP110_PCIE_BUS_MEM_CFG			(0x82000000)
+
diff --git a/arch/arm/dts/armada-ap806-quad.dtsi b/arch/arm/dts/armada-ap806-quad.dtsi
deleted file mode 100644
index ba43a43..0000000
--- a/arch/arm/dts/armada-ap806-quad.dtsi
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright (C) 2016 Marvell Technology Group Ltd.
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPLv2 or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This library is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This library is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively,
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use,
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/*
- * Device Tree file for Marvell Armada AP806.
- */
-
-#include "armada-ap806.dtsi"
-
-/ {
-	model = "Marvell Armada AP806 Quad";
-	compatible = "marvell,armada-ap806-quad", "marvell,armada-ap806";
-
-	cpus {
-		#address-cells = <1>;
-		#size-cells = <0>;
-
-		cpu@000 {
-			device_type = "cpu";
-			compatible = "arm,cortex-a72", "arm,armv8";
-			reg = <0x000>;
-			enable-method = "psci";
-		};
-		cpu@001 {
-			device_type = "cpu";
-			compatible = "arm,cortex-a72", "arm,armv8";
-			reg = <0x001>;
-			enable-method = "psci";
-		};
-		cpu@100 {
-			device_type = "cpu";
-			compatible = "arm,cortex-a72", "arm,armv8";
-			reg = <0x100>;
-			enable-method = "psci";
-		};
-		cpu@101 {
-			device_type = "cpu";
-			compatible = "arm,cortex-a72", "arm,armv8";
-			reg = <0x101>;
-			enable-method = "psci";
-		};
-	};
-};
diff --git a/arch/arm/dts/armada-ap806.dtsi b/arch/arm/dts/armada-ap806.dtsi
index e0d3016..6a8eced 100644
--- a/arch/arm/dts/armada-ap806.dtsi
+++ b/arch/arm/dts/armada-ap806.dtsi
@@ -44,220 +44,32 @@
  * Device Tree file for Marvell Armada AP806.
  */
 
-#include <dt-bindings/interrupt-controller/arm-gic.h>
+/* AP806 Settings */
+#define AP_NAME				ap806
 
-/dts-v1/;
+#include "armada-ap80x.dtsi"
 
 / {
 	model = "Marvell Armada AP806";
-	compatible = "marvell,armada-ap806";
-	#address-cells = <2>;
-	#size-cells = <2>;
-
-	aliases {
-		serial0 = &uart0;
-		serial1 = &uart1;
-	};
-
-	psci {
-		compatible = "arm,psci-0.2";
-		method = "smc";
-	};
-
-	ap806 {
-		#address-cells = <2>;
-		#size-cells = <2>;
-		compatible = "simple-bus";
-		interrupt-parent = <&gic>;
-		ranges;
 
+	AP_NAME {
 		config-space {
-			#address-cells = <1>;
-			#size-cells = <1>;
-			compatible = "simple-bus";
-			ranges = <0x0 0x0 0xf0000000 0x1000000>;
-
-			gic: interrupt-controller@210000 {
-				compatible = "arm,gic-400";
-				#interrupt-cells = <3>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-				ranges;
-				interrupt-controller;
-				interrupts = <GIC_PPI 9 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_HIGH)>;
-				reg = <0x210000 0x10000>,
-				      <0x220000 0x20000>,
-				      <0x240000 0x20000>,
-				      <0x260000 0x20000>;
-
-				gic_v2m0: v2m@280000 {
-					compatible = "arm,gic-v2m-frame";
-					msi-controller;
-					reg = <0x280000 0x1000>;
-					arm,msi-base-spi = <160>;
-					arm,msi-num-spis = <32>;
-				};
-				gic_v2m1: v2m@290000 {
-					compatible = "arm,gic-v2m-frame";
-					msi-controller;
-					reg = <0x290000 0x1000>;
-					arm,msi-base-spi = <192>;
-					arm,msi-num-spis = <32>;
-				};
-				gic_v2m2: v2m@2a0000 {
-					compatible = "arm,gic-v2m-frame";
-					msi-controller;
-					reg = <0x2a0000 0x1000>;
-					arm,msi-base-spi = <224>;
-					arm,msi-num-spis = <32>;
-				};
-				gic_v2m3: v2m@2b0000 {
-					compatible = "arm,gic-v2m-frame";
-					msi-controller;
-					reg = <0x2b0000 0x1000>;
-					arm,msi-base-spi = <256>;
-					arm,msi-num-spis = <32>;
-				};
-			};
-
-			timer {
-				compatible = "arm,armv8-timer";
-				interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_EDGE_RISING)>,
-					     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_EDGE_RISING)>,
-					     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_EDGE_RISING)>,
-					     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_EDGE_RISING)>;
-			};
-
-			odmi: odmi@300000 {
-				compatible = "marvell,odmi-controller";
-				interrupt-controller;
-				msi-controller;
-				marvell,odmi-frames = <4>;
-				reg = <0x300000 0x4000>,
-				      <0x304000 0x4000>,
-				      <0x308000 0x4000>,
-				      <0x30C000 0x4000>;
-				marvell,spi-base = <128>, <136>, <144>, <152>;
-			};
-
-			ap_pinctl: ap-pinctl@6F4000 {
-				compatible = "marvell,armada-ap806-pinctrl";
-				bank-name ="apn-806";
-				reg = <0x6F4000 0x10>;
-				pin-count = <20>;
-				max-func = <3>;
-
-				ap_i2c0_pins: i2c-pins-0 {
-					marvell,pins = < 4 5 >;
-					marvell,function = <3>;
-				};
-				ap_emmc_pins: emmc-pins-0 {
-					marvell,pins = < 0 1 2 3 4 5 6 7
-							 8 9 10 >;
-					marvell,function = <1>;
-				};
-			};
-
-			ap_gpio0: gpio@6F5040 {
-				compatible = "marvell,orion-gpio";
-				reg = <0x6F5040 0x40>;
-				ngpios = <20>;
-				gpio-controller;
-				#gpio-cells = <2>;
-			};
-
-			xor@400000 {
-				compatible = "marvell,mv-xor-v2";
-				reg = <0x400000 0x1000>,
-				      <0x410000 0x1000>;
-				msi-parent = <&gic_v2m0>;
-				dma-coherent;
-			};
-
-			xor@420000 {
-				compatible = "marvell,mv-xor-v2";
-				reg = <0x420000 0x1000>,
-				      <0x430000 0x1000>;
-				msi-parent = <&gic_v2m0>;
-				dma-coherent;
-			};
-
-			xor@440000 {
-				compatible = "marvell,mv-xor-v2";
-				reg = <0x440000 0x1000>,
-				      <0x450000 0x1000>;
-				msi-parent = <&gic_v2m0>;
-				dma-coherent;
-			};
-
-			xor@460000 {
-				compatible = "marvell,mv-xor-v2";
-				reg = <0x460000 0x1000>,
-				      <0x470000 0x1000>;
-				msi-parent = <&gic_v2m0>;
-				dma-coherent;
-			};
-
-			spi0: spi@510600 {
-				compatible = "marvell,armada-380-spi";
-				reg = <0x510600 0x50>;
-				#address-cells = <1>;
-				#size-cells = <0>;
-				cell-index = <0>;
-				interrupts = <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>;
-				clocks = <&ap_syscon 3>;
-				status = "disabled";
-			};
-
-			i2c0: i2c@511000 {
-				compatible = "marvell,mv78230-i2c";
-				reg = <0x511000 0x20>;
-				#address-cells = <1>;
-				#size-cells = <0>;
-				interrupts = <GIC_SPI 20 IRQ_TYPE_LEVEL_HIGH>;
-				timeout-ms = <1000>;
-				clocks = <&ap_syscon 3>;
-				status = "disabled";
-			};
-
-			uart0: serial@512000 {
-				compatible = "snps,dw-apb-uart";
-				reg = <0x512000 0x100>;
-				reg-shift = <2>;
-				interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>;
-				reg-io-width = <1>;
-				clocks = <&ap_syscon 3>;
-				status = "disabled";
-				clock-frequency = <200000000>;
-			};
-
-			uart1: serial@512100 {
-				compatible = "snps,dw-apb-uart";
-				reg = <0x512100 0x100>;
-				reg-shift = <2>;
-				interrupts = <GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
-				reg-io-width = <1>;
-				clocks = <&ap_syscon 3>;
-				status = "disabled";
-
-			};
-
-			ap_sdhci0: sdhci@6e0000 {
-				compatible = "marvell,armada-8k-sdhci";
-				reg = <0x6e0000 0x300>;
-				interrupts = <GIC_SPI 16 IRQ_TYPE_LEVEL_HIGH>;
-				dma-coherent;
-				status = "disabled";
+			sar-reg {
+				compatible = "marvell,sample-at-reset-common",
+					     "marvell,sample-at-reset-ap806";
+				reg = <0x6F8200 0x8>;
+				sar-driver = "ap806_sar";
+				sar-name = "ap806_sar";
+				status = "okay";
 			};
 
-			ap_syscon: system-controller@6f4000 {
-				compatible = "marvell,ap806-system-controller",
-					     "syscon";
-				#clock-cells = <1>;
-				clock-output-names = "ap-cpu-cluster-0",
-						     "ap-cpu-cluster-1",
-						     "ap-fixed", "ap-mss";
-				reg = <0x6f4000 0x1000>;
+			thermal: thermal@6f8084 {
+				compatible = "marvell,mvebu-thermal", "marvell,thermal-ext-sensor";
+				reg = <0x6f8084 0x12>;
+				gain = <425>;
+				offset = <153400>;
+				divisor = <1000>;
+				status = "okay";
 			};
 		};
 	};
diff --git a/arch/arm/dts/armada-ap807.dtsi b/arch/arm/dts/armada-ap807.dtsi
new file mode 100644
index 0000000..5bd9f99
--- /dev/null
+++ b/arch/arm/dts/armada-ap807.dtsi
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+/*
+ * Device Tree file for Marvell Armada AP807.
+ */
+
+/* AP807 Settings */
+#define AP_NAME				ap807
+
+#include "armada-ap80x.dtsi"
+
+/ {
+	model = "Marvell Armada AP807";
+
+	AP_NAME {
+		config-space {
+			sar-reg {
+				compatible = "marvell,sample-at-reset-common",
+					     "marvell,sample-at-reset-ap807";
+				reg = <0x6F8200 0x8>;
+				sar-driver = "ap807_sar";
+				sar-name = "ap807_sar";
+				status = "okay";
+			};
+
+			thermal: thermal@6f8084 {
+				compatible = "marvell,mvebu-thermal",
+					     "marvell,thermal-ext-sensor";
+				reg = <0x6f8084 0x12>;
+				gain = <394>;
+				offset = <128900>;
+				divisor = <1000>;
+				status = "okay";
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/armada-ap80x-quad.dtsi b/arch/arm/dts/armada-ap80x-quad.dtsi
new file mode 100644
index 0000000..95ffe9a
--- /dev/null
+++ b/arch/arm/dts/armada-ap80x-quad.dtsi
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+/*
+ * Device Tree file for Marvell Armada AP806/AP807.
+ */
+
+/ {
+	model = "Marvell Armada AP80X Quad";
+	compatible = "marvell,armada-ap806-quad", "marvell,armada-ap806";
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu@000 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a72", "arm,armv8";
+			reg = <0x000>;
+			enable-method = "psci";
+		};
+		cpu@001 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a72", "arm,armv8";
+			reg = <0x001>;
+			enable-method = "psci";
+		};
+		cpu@100 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a72", "arm,armv8";
+			reg = <0x100>;
+			enable-method = "psci";
+		};
+		cpu@101 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a72", "arm,armv8";
+			reg = <0x101>;
+			enable-method = "psci";
+		};
+	};
+};
diff --git a/arch/arm/dts/armada-ap80x.dtsi b/arch/arm/dts/armada-ap80x.dtsi
new file mode 100644
index 0000000..348e965
--- /dev/null
+++ b/arch/arm/dts/armada-ap80x.dtsi
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+/*
+ * Device Tree file for Marvell Armada AP806/AP807.
+ */
+
+/dts-v1/;
+/ {
+	compatible = "marvell,armada-ap806";
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	aliases {
+		serial0 = &uart0;
+		serial1 = &uart1;
+	};
+
+	psci {
+		compatible = "arm,psci-0.2";
+		method = "smc";
+	};
+
+	AP_NAME {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		compatible = "simple-bus";
+		ranges;
+
+		config-space {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "simple-bus";
+			ranges = <0x0 0x0 0xf0000000 0x1000000>;
+
+			ap_pinctl: ap-pinctl@6F4000 {
+				compatible = "marvell,ap806-pinctrl";
+				bank-name ="apn-806";
+				reg = <0x6F4000 0x10>;
+				pin-count = <20>;
+				max-func = <3>;
+
+				ap_i2c0_pins: i2c-pins-0 {
+					marvell,pins = < 4 5 >;
+					marvell,function = <3>;
+				};
+				ap_emmc_pins: emmc-pins-0 {
+					marvell,pins = < 0 1 2 3 4 5 6 7
+							 8 9 10 12 >;
+					marvell,function = <1>;
+				};
+			};
+
+			ap_gpio0: gpio@6F5040 {
+				compatible = "marvell,orion-gpio";
+				reg = <0x6F5040 0x40>;
+				ngpios = <20>;
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			ap_spi0: spi@510600 {
+				compatible = "marvell,armada-380-spi";
+				reg = <0x510600 0x50>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				cell-index = <0>;
+				spi-max-frequency = <50000000>;
+				status = "disabled";
+			};
+
+			ap_i2c0: i2c@511000 {
+				compatible = "marvell,mv78230-i2c";
+				reg = <0x511000 0x20>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				timeout-ms = <1000>;
+				status = "disabled";
+			};
+
+			uart0: serial@512000 {
+				compatible = "snps,dw-apb-uart";
+				reg = <0x512000 0x100>;
+				reg-shift = <2>;
+				reg-io-width = <1>;
+				status = "disabled";
+				clock-frequency = <200000000>;
+			};
+
+			uart1: serial@512100 {
+				compatible = "snps,dw-apb-uart";
+				reg = <0x512100 0x100>;
+				reg-shift = <2>;
+				reg-io-width = <1>;
+				status = "disabled";
+
+			};
+
+			ap_sdhci0: sdhci@6e0000 {
+				compatible = "marvell,armada-8k-sdhci";
+				reg = <0x6e0000 0x300>;
+				dma-coherent;
+				status = "disabled";
+			};
+
+			ap_ld_efuse0: efuse-0@6F8F00 {
+				compatible = "marvell,mvebu-fuse-ld-user";
+				reg = <0x6F8008 0x4>;
+				otp-mem = <0x6F8F00>;
+				status = "disabled";
+			};
+
+			ap_ld_efuse1: efuse-1@6F8F00 {
+				compatible = "marvell,mvebu-fuse-ld-prop";
+				reg = <0x6F8008 0x4>;
+				otp-mem = <0x6F8F00>;
+				status = "disabled";
+			};
+
+			ap_hd_efuse0: efuse@6F9000  {
+				compatible = "marvell,mvebu-fuse-hd";
+				reg = <0x6F8008 0x4>;
+				otp-mem = <0x6F9000>;
+				rows-count = <64>;
+				status = "disabled";
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/armada-common.dtsi b/arch/arm/dts/armada-common.dtsi
new file mode 100644
index 0000000..34bd7e3
--- /dev/null
+++ b/arch/arm/dts/armada-common.dtsi
@@ -0,0 +1,30 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/* Common definitions used by Armada 7K/8K DTs */
+#define PASTER(x, y)		x ## _ ## y
+#define EVALUATOR(x, y)		PASTER(x, y)
+
+/* This define used to create die label:
+ * For example:
+ * CP110 master:
+ *     CP110_LABEL(spi0) -> cp0_spi0
+ * CP110 slave:
+ *     CP110_LABEL(usb0) -> cp1_usb0
+ */
+#define CP110_LABEL(name)	EVALUATOR(CP110_NAME, name)
+
+#define APPEND_NX(A, B)		A ##-## B
+#define APPEND(A, B)		APPEND_NX(A, B)
+
+#define STRINGIZE_NX(x)		#x
+#define STRINGIZE(x)		STRINGIZE_NX(x)
+
+/* Same idea here, but this define convert the name to string:
+ * For example:
+ * master: CP110_STRING_LABEL(ppv2) -> "cp0-ppv2"
+ * slave: CP110_STRING_LABEL(ppv2) -> "cp1-ppv2"
+ */
+#define CP110_STRING_LABEL(name)	STRINGIZE(APPEND(CP110_NAME, name))
diff --git a/arch/arm/dts/armada-cp110-master.dtsi b/arch/arm/dts/armada-cp110-master.dtsi
deleted file mode 100644
index 8c336f2..0000000
--- a/arch/arm/dts/armada-cp110-master.dtsi
+++ /dev/null
@@ -1,369 +0,0 @@
-/*
- * Copyright (C) 2016 Marvell Technology Group Ltd.
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPLv2 or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This library is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This library is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively,
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use,
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/*
- * Device Tree file for Marvell Armada CP110 Master.
- */
-
-#include <dt-bindings/comphy/comphy_data.h>
-
-/ {
-	cp110-master {
-		#address-cells = <2>;
-		#size-cells = <2>;
-		compatible = "simple-bus";
-		interrupt-parent = <&gic>;
-		ranges;
-
-		config-space {
-			#address-cells = <1>;
-			#size-cells = <1>;
-			compatible = "simple-bus";
-			interrupt-parent = <&gic>;
-			ranges = <0x0 0x0 0xf2000000 0x2000000>;
-
-			cpm_ethernet: ethernet@0 {
-				compatible = "marvell,armada-7k-pp22";
-				reg = <0x0 0x100000>, <0x129000 0xb000>;
-				clocks = <&cpm_syscon0 1 3>, <&cpm_syscon0 1 9>, <&cpm_syscon0 1 5>;
-				clock-names = "pp_clk", "gop_clk", "mg_clk";
-				status = "disabled";
-				dma-coherent;
-
-				cpm_eth0: eth0 {
-					interrupts = <GIC_SPI 37 IRQ_TYPE_LEVEL_HIGH>;
-					port-id = <0>;
-					gop-port-id = <0>;
-					status = "disabled";
-				};
-
-				cpm_eth1: eth1 {
-					interrupts = <GIC_SPI 38 IRQ_TYPE_LEVEL_HIGH>;
-					port-id = <1>;
-					gop-port-id = <2>;
-					status = "disabled";
-				};
-
-				cpm_eth2: eth2 {
-					interrupts = <GIC_SPI 39 IRQ_TYPE_LEVEL_HIGH>;
-					port-id = <2>;
-					gop-port-id = <3>;
-					status = "disabled";
-				};
-			};
-
-			cpm_mdio: mdio@12a200 {
-				#address-cells = <1>;
-				#size-cells = <0>;
-				compatible = "marvell,orion-mdio";
-				reg = <0x12a200 0x10>;
-			};
-
-			cpm_syscon0: system-controller@440000 {
-				compatible = "marvell,cp110-system-controller0",
-					     "syscon";
-				reg = <0x440000 0x1000>;
-				#clock-cells = <2>;
-				core-clock-output-names =
-					"cpm-apll", "cpm-ppv2-core", "cpm-eip",
-					"cpm-core", "cpm-nand-core";
-				gate-clock-output-names =
-					"cpm-audio", "cpm-communit", "cpm-nand",
-					"cpm-ppv2", "cpm-sdio", "cpm-mg-domain",
-					"cpm-mg-core", "cpm-xor1", "cpm-xor0",
-					"cpm-gop-dp", "none", "cpm-pcie_x10",
-					"cpm-pcie_x11", "cpm-pcie_x4", "cpm-pcie-xor",
-					"cpm-sata", "cpm-sata-usb", "cpm-main",
-					"cpm-sd-mmc", "none", "none",
-					"cpm-slow-io", "cpm-usb3h0", "cpm-usb3h1",
-					"cpm-usb3dev", "cpm-eip150", "cpm-eip197";
-			};
-
-			cpm_pinctl: cpm-pinctl@440000 {
-				compatible = "marvell,mvebu-pinctrl",
-					     "marvell,a70x0-pinctrl",
-					     "marvell,a80x0-cp0-pinctrl";
-				bank-name ="cp0-110";
-				reg = <0x440000 0x20>;
-				pin-count = <63>;
-				max-func = <0xf>;
-
-				cpm_i2c0_pins: cpm-i2c-pins-0 {
-					marvell,pins = < 37 38 >;
-					marvell,function = <2>;
-				};
-				cpm_i2c1_pins: cpm-i2c-pins-1 {
-					marvell,pins = < 35 36 >;
-					marvell,function = <2>;
-				};
-				cpm_ge2_rgmii_pins: cpm-ge-rgmii-pins-0 {
-					marvell,pins = < 44 45 46 47 48 49 50 51
-							 52 53 54 55 >;
-					marvell,function = <1>;
-				};
-				pca0_pins: cpm-pca0_pins {
-					marvell,pins = <62>;
-					marvell,function = <0>;
-				};
-				cpm_sdhci_pins: cpm-sdhi-pins-0 {
-					marvell,pins = < 56 57 58 59 60 61 >;
-					marvell,function = <14>;
-				};
-				cpm_spi0_pins: cpm-spi-pins-0 {
-					marvell,pins = < 13 14 15 16 >;
-					marvell,function = <3>;
-				};
-			};
-
-			cpm_gpio0: gpio@440100 {
-				compatible = "marvell,orion-gpio";
-				reg = <0x440100 0x40>;
-				ngpios = <32>;
-				gpiobase = <20>;
-				gpio-controller;
-				#gpio-cells = <2>;
-			};
-
-			cpm_gpio1: gpio@440140 {
-				compatible = "marvell,orion-gpio";
-				reg = <0x440140 0x40>;
-				ngpios = <31>;
-				gpiobase = <52>;
-				gpio-controller;
-				#gpio-cells = <2>;
-			};
-
-			cpm_sata0: sata@540000 {
-				compatible = "marvell,armada-8k-ahci";
-				reg = <0x540000 0x30000>;
-				interrupts = <GIC_SPI 63 IRQ_TYPE_LEVEL_HIGH>;
-				clocks = <&cpm_syscon0 1 15>;
-				status = "disabled";
-			};
-
-			cpm_usb3_0: usb3@500000 {
-				compatible = "marvell,armada-8k-xhci",
-					     "generic-xhci";
-				reg = <0x500000 0x4000>;
-				dma-coherent;
-				interrupts = <GIC_SPI 62 IRQ_TYPE_LEVEL_HIGH>;
-				clocks = <&cpm_syscon0 1 22>;
-				status = "disabled";
-			};
-
-			cpm_usb3_1: usb3@510000 {
-				compatible = "marvell,armada-8k-xhci",
-					     "generic-xhci";
-				reg = <0x510000 0x4000>;
-				dma-coherent;
-				interrupts = <GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>;
-				clocks = <&cpm_syscon0 1 23>;
-				status = "disabled";
-			};
-
-			cpm_spi0: spi@700600 {
-				compatible = "marvell,armada-380-spi";
-				reg = <0x700600 0x50>;
-				#address-cells = <0x1>;
-				#size-cells = <0x0>;
-				cell-index = <1>;
-				clocks = <&cpm_syscon0 0 3>;
-				status = "disabled";
-			};
-
-			cpm_spi1: spi@700680 {
-				compatible = "marvell,armada-380-spi";
-				reg = <0x700680 0x50>;
-				#address-cells = <1>;
-				#size-cells = <0>;
-				cell-index = <2>;
-				clocks = <&cpm_syscon0 1 21>;
-				status = "disabled";
-			};
-
-			cpm_i2c0: i2c@701000 {
-				compatible = "marvell,mv78230-i2c";
-				reg = <0x701000 0x20>;
-				#address-cells = <1>;
-				#size-cells = <0>;
-				interrupts = <GIC_SPI 86 IRQ_TYPE_LEVEL_HIGH>;
-				clocks = <&cpm_syscon0 1 21>;
-				status = "disabled";
-			};
-
-			cpm_i2c1: i2c@701100 {
-				compatible = "marvell,mv78230-i2c";
-				reg = <0x701100 0x20>;
-				#address-cells = <1>;
-				#size-cells = <0>;
-				interrupts = <GIC_SPI 87 IRQ_TYPE_LEVEL_HIGH>;
-				clocks = <&cpm_syscon0 1 21>;
-				status = "disabled";
-			};
-
-			cpm_comphy: comphy@441000 {
-				compatible = "marvell,mvebu-comphy", "marvell,comphy-cp110";
-				reg = <0x441000 0x8>,
-				      <0x120000 0x8>;
-				mux-bitcount = <4>;
-				max-lanes = <6>;
-			};
-
-			cpm_utmi0: utmi@580000 {
-				compatible = "marvell,mvebu-utmi-2.6.0";
-				reg = <0x580000 0x1000>,	/* utmi-unit */
-				      <0x440420 0x4>,		/* usb-cfg */
-				      <0x440440 0x4>;		/* utmi-cfg */
-				utmi-port = <UTMI_PHY_TO_USB3_HOST0>;
-				status = "disabled";
-			};
-
-			cpm_utmi1: utmi@581000 {
-				compatible = "marvell,mvebu-utmi-2.6.0";
-				reg = <0x581000 0x1000>,	/* utmi-unit */
-				      <0x440420 0x4>,		/* usb-cfg */
-				      <0x440444 0x4>;		/* utmi-cfg */
-				utmi-port = <UTMI_PHY_TO_USB3_HOST1>;
-				status = "disabled";
-			};
-
-			cpm_sdhci0: sdhci@780000 {
-				compatible = "marvell,armada-8k-sdhci";
-				reg = <0x780000 0x300>;
-				interrupts = <GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>;
-				dma-coherent;
-				status = "disabled";
-			};
-
-			cpm_nand: nand@720000 {
-				compatible = "marvell,mvebu-pxa3xx-nand";
-				reg = <0x720000 0x100>;
-				#address-cells = <1>;
-
-				clocks = <&cpm_syscon0 1 2>;
-				nand-enable-arbiter;
-				num-cs = <1>;
-				nand-ecc-strength = <4>;
-				nand-ecc-step-size = <512>;
-				status = "disabled";
-			};
-
-		};
-
-		cpm_pcie0: pcie@f2600000 {
-			compatible = "marvell,armada8k-pcie", "snps,dw-pcie";
-			reg = <0 0xf2600000 0 0x10000>,
-			      <0 0xf6f00000 0 0x80000>;
-			reg-names = "ctrl", "config";
-			#address-cells = <3>;
-			#size-cells = <2>;
-			#interrupt-cells = <1>;
-			device_type = "pci";
-			dma-coherent;
-
-			bus-range = <0 0xff>;
-			ranges =
-				/* downstream I/O */
-				<0x81000000 0 0xf9000000 0  0xf9000000 0 0x10000
-				/* non-prefetchable memory */
-				0x82000000 0 0xf6000000 0  0xf6000000 0 0xf00000>;
-			interrupt-map-mask = <0 0 0 0>;
-			interrupt-map = <0 0 0 0 &gic 0 GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>;
-			interrupts = <GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>;
-			num-lanes = <1>;
-			clocks = <&cpm_syscon0 1 13>;
-			status = "disabled";
-		};
-
-		cpm_pcie1: pcie@f2620000 {
-			compatible = "marvell,armada8k-pcie", "snps,dw-pcie";
-			reg = <0 0xf2620000 0 0x10000>,
-			      <0 0xf7f00000 0 0x80000>;
-			reg-names = "ctrl", "config";
-			#address-cells = <3>;
-			#size-cells = <2>;
-			#interrupt-cells = <1>;
-			device_type = "pci";
-			dma-coherent;
-
-			bus-range = <0 0xff>;
-			ranges =
-				/* downstream I/O */
-				<0x81000000 0 0xf9010000 0  0xf9010000 0 0x10000
-				/* non-prefetchable memory */
-				0x82000000 0 0xf7000000 0  0xf7000000 0 0xf00000>;
-			interrupt-map-mask = <0 0 0 0>;
-			interrupt-map = <0 0 0 0 &gic 0 GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>;
-			interrupts = <GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>;
-
-			num-lanes = <1>;
-			clocks = <&cpm_syscon0 1 11>;
-			status = "disabled";
-		};
-
-		cpm_pcie2: pcie@f2640000 {
-			compatible = "marvell,armada8k-pcie", "snps,dw-pcie";
-			reg = <0 0xf2640000 0 0x10000>,
-			      <0 0xf8f00000 0 0x80000>;
-			reg-names = "ctrl", "config";
-			#address-cells = <3>;
-			#size-cells = <2>;
-			#interrupt-cells = <1>;
-			device_type = "pci";
-			dma-coherent;
-
-			bus-range = <0 0xff>;
-			ranges =
-				/* downstream I/O */
-				<0x81000000 0 0xf9020000 0  0xf9020000 0 0x10000
-				/* non-prefetchable memory */
-				0x82000000 0 0xf8000000 0  0xf8000000 0 0xf00000>;
-			interrupt-map-mask = <0 0 0 0>;
-			interrupt-map = <0 0 0 0 &gic 0 GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
-			interrupts = <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
-
-			num-lanes = <1>;
-			clocks = <&cpm_syscon0 1 12>;
-			status = "disabled";
-		};
-	};
-};
diff --git a/arch/arm/dts/armada-cp110-slave.dtsi b/arch/arm/dts/armada-cp110-slave.dtsi
deleted file mode 100644
index 0cdb3d3..0000000
--- a/arch/arm/dts/armada-cp110-slave.dtsi
+++ /dev/null
@@ -1,342 +0,0 @@
-/*
- * Copyright (C) 2016 Marvell Technology Group Ltd.
- *
- * This file is dual-licensed: you can use it either under the terms
- * of the GPLv2 or the X11 license, at your option. Note that this dual
- * licensing only applies to this file, and not this project as a
- * whole.
- *
- *  a) This library is free software; you can redistribute it and/or
- *     modify it under the terms of the GNU General Public License as
- *     published by the Free Software Foundation; either version 2 of the
- *     License, or (at your option) any later version.
- *
- *     This library is distributed in the hope that it will be useful,
- *     but WITHOUT ANY WARRANTY; without even the implied warranty of
- *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *     GNU General Public License for more details.
- *
- * Or, alternatively,
- *
- *  b) Permission is hereby granted, free of charge, to any person
- *     obtaining a copy of this software and associated documentation
- *     files (the "Software"), to deal in the Software without
- *     restriction, including without limitation the rights to use,
- *     copy, modify, merge, publish, distribute, sublicense, and/or
- *     sell copies of the Software, and to permit persons to whom the
- *     Software is furnished to do so, subject to the following
- *     conditions:
- *
- *     The above copyright notice and this permission notice shall be
- *     included in all copies or substantial portions of the Software.
- *
- *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- *     OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/*
- * Device Tree file for Marvell Armada CP110 Slave.
- */
-
-#include <dt-bindings/comphy/comphy_data.h>
-
-/ {
-	cp110-slave {
-		#address-cells = <2>;
-		#size-cells = <2>;
-		compatible = "simple-bus";
-		interrupt-parent = <&gic>;
-		ranges;
-
-		config-space {
-			#address-cells = <1>;
-			#size-cells = <1>;
-			compatible = "simple-bus";
-			interrupt-parent = <&gic>;
-			ranges = <0x0 0x0 0xf4000000 0x2000000>;
-
-			cps_ethernet: ethernet@0 {
-				compatible = "marvell,armada-7k-pp22";
-				reg = <0x0 0x100000>, <0x129000 0xb000>;
-				clocks = <&cps_syscon0 1 3>, <&cps_syscon0 1 9>, <&cps_syscon0 1 5>;
-				clock-names = "pp_clk", "gop_clk", "mg_clk";
-				status = "disabled";
-				dma-coherent;
-
-				cps_eth0: eth0 {
-					interrupts = <GIC_SPI 261 IRQ_TYPE_LEVEL_HIGH>;
-					port-id = <0>;
-					gop-port-id = <0>;
-					status = "disabled";
-				};
-
-				cps_eth1: eth1 {
-					interrupts = <GIC_SPI 262 IRQ_TYPE_LEVEL_HIGH>;
-					port-id = <1>;
-					gop-port-id = <2>;
-					status = "disabled";
-				};
-
-				cps_eth2: eth2 {
-					interrupts = <GIC_SPI 263 IRQ_TYPE_LEVEL_HIGH>;
-					port-id = <2>;
-					gop-port-id = <3>;
-					status = "disabled";
-				};
-			};
-
-			cps_mdio: mdio@12a200 {
-				#address-cells = <1>;
-				#size-cells = <0>;
-				compatible = "marvell,orion-mdio";
-				reg = <0x12a200 0x10>;
-			};
-
-			cps_syscon0: system-controller@440000 {
-				compatible = "marvell,cp110-system-controller0",
-					     "syscon";
-				reg = <0x440000 0x1000>;
-				#clock-cells = <2>;
-				core-clock-output-names =
-					"cps-apll", "cps-ppv2-core", "cps-eip",
-					"cps-core", "cps-nand-core";
-				gate-clock-output-names =
-					"cps-audio", "cps-communit", "cps-nand",
-					"cps-ppv2", "cps-sdio", "cps-mg-domain",
-					"cps-mg-core", "cps-xor1", "cps-xor0",
-					"cps-gop-dp", "none", "cps-pcie_x10",
-					"cps-pcie_x11", "cps-pcie_x4", "cps-pcie-xor",
-					"cps-sata", "cps-sata-usb", "cps-main",
-					"cps-sd-mmc", "none", "none",
-					"cps-slow-io", "cps-usb3h0", "cps-usb3h1",
-					"cps-usb3dev", "cps-eip150", "cps-eip197";
-			};
-
-			cps_pinctl: cps-pinctl@440000 {
-				compatible = "marvell,mvebu-pinctrl",
-					     "marvell,a80x0-cp1-pinctrl";
-				bank-name ="cp1-110";
-				reg = <0x440000 0x20>;
-				pin-count = <63>;
-				max-func = <0xf>;
-
-				cps_ge1_rgmii_pins: cps-ge-rgmii-pins-0 {
-					marvell,pins = < 0  1  2  3  4  5  6  7
-							 8  9  10 11 >;
-					marvell,function = <3>;
-				};
-				cps_spi1_pins: cps-spi-pins-1 {
-					marvell,pins = < 13 14 15 16 >;
-					marvell,function = <3>;
-				};
-			};
-
-			cps_gpio0: gpio@440100 {
-				compatible = "marvell,orion-gpio";
-				reg = <0x440100 0x40>;
-				ngpios = <32>;
-				gpiobase = <20>;
-				gpio-controller;
-				#gpio-cells = <2>;
-			};
-
-			cps_gpio1: gpio@440140 {
-				compatible = "marvell,orion-gpio";
-				reg = <0x440140 0x40>;
-				ngpios = <31>;
-				gpiobase = <52>;
-				gpio-controller;
-				#gpio-cells = <2>;
-			};
-
-			cps_sata0: sata@540000 {
-				compatible = "marvell,armada-8k-ahci";
-				reg = <0x540000 0x30000>;
-				interrupts = <GIC_SPI 287 IRQ_TYPE_LEVEL_HIGH>;
-				clocks = <&cps_syscon0 1 15>;
-				status = "disabled";
-			};
-
-			cps_usb3_0: usb3@500000 {
-				compatible = "marvell,armada-8k-xhci",
-					     "generic-xhci";
-				reg = <0x500000 0x4000>;
-				dma-coherent;
-				interrupts = <GIC_SPI 286 IRQ_TYPE_LEVEL_HIGH>;
-				clocks = <&cps_syscon0 1 22>;
-				status = "disabled";
-			};
-
-			cps_usb3_1: usb3@510000 {
-				compatible = "marvell,armada-8k-xhci",
-					     "generic-xhci";
-				reg = <0x510000 0x4000>;
-				dma-coherent;
-				interrupts = <GIC_SPI 285 IRQ_TYPE_LEVEL_HIGH>;
-				clocks = <&cps_syscon0 1 23>;
-				status = "disabled";
-			};
-
-			cps_xor0: xor@6a0000 {
-				compatible = "marvell,armada-7k-xor", "marvell,xor-v2";
-				reg = <0x6a0000 0x1000>,
-				      <0x6b0000 0x1000>;
-				dma-coherent;
-				msi-parent = <&gic_v2m0>;
-				clocks = <&cps_syscon0 1 8>;
-			};
-
-			cps_xor1: xor@6c0000 {
-				compatible = "marvell,armada-7k-xor", "marvell,xor-v2";
-				reg = <0x6c0000 0x1000>,
-				      <0x6d0000 0x1000>;
-				dma-coherent;
-				msi-parent = <&gic_v2m0>;
-				clocks = <&cps_syscon0 1 7>;
-			};
-
-			cps_spi0: spi@700600 {
-				compatible = "marvell,armada-380-spi";
-				reg = <0x700600 0x50>;
-				#address-cells = <0x1>;
-				#size-cells = <0x0>;
-				cell-index = <1>;
-				clocks = <&cps_syscon0 0 3>;
-				status = "disabled";
-			};
-
-			cps_spi1: spi@700680 {
-				compatible = "marvell,armada-380-spi";
-				reg = <0x700680 0x50>;
-				#address-cells = <1>;
-				#size-cells = <0>;
-				cell-index = <2>;
-				clocks = <&cps_syscon0 1 21>;
-				status = "disabled";
-			};
-
-			cps_i2c0: i2c@701000 {
-				compatible = "marvell,mv78230-i2c";
-				reg = <0x701000 0x20>;
-				#address-cells = <1>;
-				#size-cells = <0>;
-				interrupts = <GIC_SPI 310 IRQ_TYPE_LEVEL_HIGH>;
-				clocks = <&cps_syscon0 1 21>;
-				status = "disabled";
-			};
-
-			cps_i2c1: i2c@701100 {
-				compatible = "marvell,mv78230-i2c";
-				reg = <0x701100 0x20>;
-				#address-cells = <1>;
-				#size-cells = <0>;
-				interrupts = <GIC_SPI 311 IRQ_TYPE_LEVEL_HIGH>;
-				clocks = <&cps_syscon0 1 21>;
-				status = "disabled";
-			};
-
-			cps_comphy: comphy@441000 {
-				compatible = "marvell,mvebu-comphy", "marvell,comphy-cp110";
-				reg = <0x441000 0x8>,
-				      <0x120000 0x8>;
-				mux-bitcount = <4>;
-				max-lanes = <6>;
-			};
-
-			cps_utmi0: utmi@580000 {
-				compatible = "marvell,mvebu-utmi-2.6.0";
-				reg = <0x580000 0x1000>,	/* utmi-unit */
-				      <0x440420 0x4>,		/* usb-cfg */
-				      <0x440440 0x4>;		/* utmi-cfg */
-				utmi-port = <UTMI_PHY_TO_USB3_HOST0>;
-				status = "disabled";
-			};
-		};
-
-		cps_pcie0: pcie@f4600000 {
-			compatible = "marvell,armada8k-pcie", "snps,dw-pcie";
-			reg = <0 0xf4600000 0 0x10000>,
-			      <0 0xfaf00000 0 0x80000>;
-			reg-names = "ctrl", "config";
-			#address-cells = <3>;
-			#size-cells = <2>;
-			#interrupt-cells = <1>;
-			device_type = "pci";
-			dma-coherent;
-			msi-parent = <&gic_v2m0>;
-
-			bus-range = <0 0xff>;
-			ranges =
-				/* downstream I/O */
-				<0x81000000 0 0xfd000000 0  0xfd000000 0 0x10000
-				/* non-prefetchable memory */
-				0x82000000 0 0xfa000000 0  0xfa000000 0 0xf00000>;
-			interrupt-map-mask = <0 0 0 0>;
-			interrupt-map = <0 0 0 0 &gic 0 GIC_SPI 256 IRQ_TYPE_LEVEL_HIGH>;
-			interrupts = <GIC_SPI 256 IRQ_TYPE_LEVEL_HIGH>;
-			num-lanes = <1>;
-			clocks = <&cps_syscon0 1 13>;
-			status = "disabled";
-		};
-
-		cps_pcie1: pcie@f4620000 {
-			compatible = "marvell,armada8k-pcie", "snps,dw-pcie";
-			reg = <0 0xf4620000 0 0x10000>,
-			      <0 0xfbf00000 0 0x80000>;
-			reg-names = "ctrl", "config";
-			#address-cells = <3>;
-			#size-cells = <2>;
-			#interrupt-cells = <1>;
-			device_type = "pci";
-			dma-coherent;
-			msi-parent = <&gic_v2m0>;
-
-			bus-range = <0 0xff>;
-			ranges =
-				/* downstream I/O */
-				<0x81000000 0 0xfd010000 0  0xfd010000 0 0x10000
-				/* non-prefetchable memory */
-				0x82000000 0 0xfb000000 0  0xfb000000 0 0xf00000>;
-			interrupt-map-mask = <0 0 0 0>;
-			interrupt-map = <0 0 0 0 &gic 0 GIC_SPI 258 IRQ_TYPE_LEVEL_HIGH>;
-			interrupts = <GIC_SPI 258 IRQ_TYPE_LEVEL_HIGH>;
-
-			num-lanes = <1>;
-			clocks = <&cps_syscon0 1 11>;
-			status = "disabled";
-		};
-
-		cps_pcie2: pcie@f4640000 {
-			compatible = "marvell,armada8k-pcie", "snps,dw-pcie";
-			reg = <0 0xf4640000 0 0x10000>,
-			      <0 0xfcf00000 0 0x80000>;
-			reg-names = "ctrl", "config";
-			#address-cells = <3>;
-			#size-cells = <2>;
-			#interrupt-cells = <1>;
-			device_type = "pci";
-			dma-coherent;
-			msi-parent = <&gic_v2m0>;
-
-			bus-range = <0 0xff>;
-			ranges =
-				/* downstream I/O */
-				<0x81000000 0 0xfd020000 0  0xfd020000 0 0x10000
-				/* non-prefetchable memory */
-				0x82000000 0 0xfc000000 0  0xfc000000 0 0xf00000>;
-			interrupt-map-mask = <0 0 0 0>;
-			interrupt-map = <0 0 0 0 &gic 0 GIC_SPI 257 IRQ_TYPE_LEVEL_HIGH>;
-			interrupts = <GIC_SPI 257 IRQ_TYPE_LEVEL_HIGH>;
-
-			num-lanes = <1>;
-			clocks = <&cps_syscon0 1 12>;
-			status = "disabled";
-		};
-	};
-};
diff --git a/arch/arm/dts/armada-cp110.dtsi b/arch/arm/dts/armada-cp110.dtsi
new file mode 100644
index 0000000..c92c8d4
--- /dev/null
+++ b/arch/arm/dts/armada-cp110.dtsi
@@ -0,0 +1,329 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/*
+ * Generic Device Tree describing Marvell Armada CP-110 device
+ */
+#include <dt-bindings/comphy/comphy_data.h>
+
+#define U64_TO_U32_H(addr)		(((addr) >> 32) & 0xffffffff)
+#define U64_TO_U32_L(addr)		((addr) & 0xffffffff)
+
+#define CP110_PCIEx_REG0_BASE(iface)	\
+	(CP110_BASE + 0x600000 + (iface) * 0x20000)
+#define CP110_PCIEx_REG1_BASE(iface)	\
+	(CP110_PCIEx_CPU_MEM_BASE(iface) + CP110_PCIE_MEM_SIZE(iface))
+/ {
+	CP110_NAME {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		compatible = "simple-bus";
+		ranges;
+
+		config-space {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "simple-bus";
+			ranges = <0x0 U64_TO_U32_H(CP110_BASE) U64_TO_U32_L(CP110_BASE) 0x2000000>;
+
+			CP110_LABEL(mdio): mdio@12a200 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "marvell,orion-mdio";
+				reg = <0x12a200 0x10>;
+				mdio-name = CP110_STRING_LABEL(mdio);
+				status = "disabled";
+			};
+
+			CP110_LABEL(xmdio): mdio@12a600 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "marvell,xmdio";
+				reg = <0x12a600 0x200>;
+				mdio-name = CP110_STRING_LABEL(xmdio);
+				status = "disabled";
+			};
+
+			CP110_LABEL(sar-reg) {
+				compatible = "marvell,sample-at-reset-common",
+					     "marvell,sample-at-reset-cp110";
+				reg = <0x400200 0x8>;
+				sar-driver = "cp110_sar";
+				sar-name = CP110_STRING_LABEL(sar);
+				status = "okay";
+			};
+
+			CP110_LABEL(ld_efuse0): CP110_LABEL(efuse0)@400F00 {
+				compatible = "marvell,mvebu-fuse-ld-user";
+				reg = <0x400008 0x4>;
+				otp-mem = <0x400F00>;
+				status = "disabled";
+			};
+
+			CP110_LABEL(ld_efuse1): CP110_LABEL(efuse1)@400F00 {
+				compatible = "marvell,mvebu-fuse-ld-prop";
+				reg = <0x400008 0x4>;
+				otp-mem = <0x400F00>;
+				status = "disabled";
+			};
+
+			CP110_LABEL(pinctl): pinctl@440000 {
+				compatible = "marvell,mvebu-pinctrl";
+				reg = <0x440000 0x20>;
+				pin-count = <63>;
+				max-func = <0xf>;
+			};
+
+			CP110_LABEL(gpio0): gpio@440100 {
+				compatible = "marvell,orion-gpio";
+				reg = <0x440100 0x40>;
+				ngpios = <32>;
+				gpiobase = <20>;
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			CP110_LABEL(thermal): thermal@400070 {
+				compatible = "marvell,mvebu-thermal", "marvell,thermal-sensor";
+				reg = <0x400070 0x12>;
+				gain = <4761>;
+				offset = <2791000>;
+				divisor = <10000>;
+				status = "okay";
+			};
+
+			CP110_LABEL(gpio1): gpio@440140 {
+				compatible = "marvell,orion-gpio";
+				reg = <0x440140 0x40>;
+				ngpios = <31>;
+				gpiobase = <52>;
+				gpio-controller;
+				#gpio-cells = <2>;
+			};
+
+			CP110_LABEL(sata0): sata@540000 {
+				compatible = "marvell,armada-8k-ahci";
+				reg = <0x540000 0x30000>;
+				status = "disabled";
+			};
+
+			CP110_LABEL(usb3_0): usb3@500000 {
+				compatible = "marvell,armada-8k-xhci",
+					     "generic-xhci";
+				reg = <0x500000 0x4000>;
+				dma-coherent;
+				status = "disabled";
+			};
+
+			CP110_LABEL(usb3_1): usb3@510000 {
+				compatible = "marvell,armada-8k-xhci",
+					     "generic-xhci";
+				reg = <0x510000 0x4000>;
+				dma-coherent;
+				status = "disabled";
+			};
+
+			CP110_LABEL(spi0): spi@700600 {
+				compatible = "marvell,armada-380-spi";
+				reg = <0x700600 0x50>;
+				#address-cells = <0x1>;
+				#size-cells = <0x0>;
+				cell-index = <1>;
+				spi-max-frequency = <50000000>;
+				status = "disabled";
+			};
+
+			CP110_LABEL(spi1): spi@700680 {
+				compatible = "marvell,armada-380-spi";
+				reg = <0x700680 0x50>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				cell-index = <2>;
+				spi-max-frequency = <50000000>;
+				status = "disabled";
+			};
+
+			CP110_LABEL(i2c0): i2c@701000 {
+				compatible = "marvell,mv78230-i2c";
+				reg = <0x701000 0x20>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				status = "disabled";
+			};
+
+			CP110_LABEL(i2c1): i2c@701100 {
+				compatible = "marvell,mv78230-i2c";
+				reg = <0x701100 0x20>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				status = "disabled";
+			};
+
+			CP110_LABEL(mss_i2c0): i2c@211000 {
+				compatible = "marvell,mv78230-i2c";
+				reg = <0x211000 0x20>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				status = "disabled";
+			};
+
+			CP110_LABEL(comphy): comphy@441000 {
+				compatible = "marvell,mvebu-comphy", "marvell,comphy-cp110";
+				reg = <0x441000 0x8>,
+				      <0x120000 0x8>;
+				mux-bitcount = <4>;
+				max-lanes = <6>;
+			};
+
+			CP110_LABEL(utmi): utmi@580000 {
+				compatible = "marvell,mvebu-utmi";
+				reg = <0x580000 0xc>; /* utmi-common-pll */
+				#address-cells = <1>;
+				#size-cells = <1>;
+				CP110_LABEL(utmi0): utmi@58000c {
+					compatible = "marvell,mvebu-utmi-2.6.0";
+					reg = <0x58000c 0x100>,/* utmi-unit */
+					      <0x440420 0x4>,	/* usb-cfg */
+					      <0x440440 0x4>;	/* utmi-cfg */
+					utmi-port = <UTMI_PHY_TO_USB3_HOST0>;
+					status = "disabled";
+				};
+
+				CP110_LABEL(utmi1): utmi@58100c {
+					compatible = "marvell,mvebu-utmi-2.6.0";
+					reg = <0x58100c 0x100>,/* utmi-unit */
+					      <0x440420 0x4>,	/* usb-cfg */
+					      <0x440444 0x4>;	/* utmi-cfg */
+					utmi-port = <UTMI_PHY_TO_USB3_HOST1>;
+					status = "disabled";
+				};
+			};
+
+			CP110_LABEL(sdhci0): sdhci@780000 {
+				compatible = "marvell,armada-8k-sdhci";
+				reg = <0x780000 0x300>;
+				dma-coherent;
+				status = "disabled";
+			};
+
+			CP110_LABEL(nand): nand@720000 {
+				compatible = "marvell,mvebu-pxa3xx-nand";
+				reg = <0x720000 0x100>,
+				      <0x440700 0x20>,
+				      <0x440208 0x20>;
+				reg-names = "ctrl_base",
+					    "flash_clock",
+					    "dev_mux";
+				#address-cells = <1>;
+
+				nand-enable-arbiter;
+				num-cs = <1>;
+				nand-ecc-strength = <8>;
+				nand-ecc-step-size = <512>;
+				status = "disabled";
+			};
+
+			CP110_LABEL(rtc): rtc-reg@284000 {
+				compatible = "marvell,armada-8k-rtc";
+				reg = <0x284000 104>;
+				status = "disabled";
+			};
+
+			CP110_LABEL(ethernet): ethernet@0 {
+				compatible = "marvell,armada-7k-pp22";
+				reg = <0x0 0x100000>, <0x129000 0xb000>;
+				status = "disabled";
+				dma-coherent;
+
+				CP110_LABEL(eth0): eth0 {
+					port-id = <0>;
+					gop-port-id = <0>;
+					status = "disabled";
+				};
+
+				CP110_LABEL(eth1): eth1 {
+					port-id = <1>;
+					gop-port-id = <2>;
+					status = "disabled";
+				};
+
+				CP110_LABEL(eth2): eth2 {
+					port-id = <2>;
+					gop-port-id = <3>;
+					status = "disabled";
+				};
+			};
+		};
+
+		CP110_LABEL(pcie0): pcie0@600000 {
+			compatible = "marvell,armada8k-pcie", "snps,dw-pcie";
+			reg =
+			   <U64_TO_U32_H(CP110_PCIEx_REG0_BASE(0)) U64_TO_U32_L(CP110_PCIEx_REG0_BASE(0)) 0 0x10000>,
+			   /* Last 512KB of mem space */
+			   <U64_TO_U32_H(CP110_PCIEx_REG1_BASE(0)) U64_TO_U32_L(CP110_PCIEx_REG1_BASE(0)) 0 0x80000>;
+			reg-names = "ctrl", "config";
+			#address-cells = <3>;
+			#size-cells = <2>;
+			device_type = "pci";
+			dma-coherent;
+
+			bus-range = <0 0xff>;
+			ranges =
+				/* non-prefetchable memory */
+				<CP110_PCIE_BUS_MEM_CFG U64_TO_U32_H(CP110_PCIEx_BUS_MEM_BASE(0))
+				U64_TO_U32_L(CP110_PCIEx_BUS_MEM_BASE(0)) U64_TO_U32_H(CP110_PCIEx_CPU_MEM_BASE(0))
+				U64_TO_U32_L(CP110_PCIEx_CPU_MEM_BASE(0))
+				U64_TO_U32_H(CP110_PCIE_MEM_SIZE(0)) U64_TO_U32_L(CP110_PCIE_MEM_SIZE(0))>;
+			num-lanes = <1>;
+			status = "disabled";
+		};
+
+		CP110_LABEL(pcie1): pcie1@620000 {
+			compatible = "marvell,armada8k-pcie", "snps,dw-pcie";
+			reg =
+			   <U64_TO_U32_H(CP110_PCIEx_REG0_BASE(1)) U64_TO_U32_L(CP110_PCIEx_REG0_BASE(1)) 0 0x10000>,
+			   /* Last 512KB of mem space */
+			   <U64_TO_U32_H(CP110_PCIEx_REG1_BASE(1)) U64_TO_U32_L(CP110_PCIEx_REG1_BASE(1)) 0 0x80000>;
+			reg-names = "ctrl", "config";
+			#address-cells = <3>;
+			#size-cells = <2>;
+			device_type = "pci";
+			dma-coherent;
+
+			bus-range = <0 0xff>;
+			ranges =
+				/* non-prefetchable memory */
+				<CP110_PCIE_BUS_MEM_CFG U64_TO_U32_H(CP110_PCIEx_BUS_MEM_BASE(1))
+				U64_TO_U32_L(CP110_PCIEx_BUS_MEM_BASE(1)) U64_TO_U32_H(CP110_PCIEx_CPU_MEM_BASE(1))
+				U64_TO_U32_L(CP110_PCIEx_CPU_MEM_BASE(1)) U64_TO_U32_H(CP110_PCIE_MEM_SIZE(1))
+				U64_TO_U32_L(CP110_PCIE_MEM_SIZE(1))>;
+			num-lanes = <1>;
+			status = "disabled";
+		};
+
+		CP110_LABEL(pcie2): pcie2@640000 {
+			compatible = "marvell,armada8k-pcie", "snps,dw-pcie";
+			reg =
+			   <U64_TO_U32_H(CP110_PCIEx_REG0_BASE(2)) U64_TO_U32_L(CP110_PCIEx_REG0_BASE(2)) 0 0x10000>,
+			   /* Last 64KB of mem space */
+			   <U64_TO_U32_H(CP110_PCIEx_REG1_BASE(2)) U64_TO_U32_L(CP110_PCIEx_REG1_BASE(2)) 0 0x80000>;
+			reg-names = "ctrl", "config";
+			#address-cells = <3>;
+			#size-cells = <2>;
+			device_type = "pci";
+			dma-coherent;
+
+			bus-range = <0 0xff>;
+			ranges =
+				/* non-prefetchable memory */
+				<CP110_PCIE_BUS_MEM_CFG U64_TO_U32_H(CP110_PCIEx_BUS_MEM_BASE(2))
+				U64_TO_U32_L(CP110_PCIEx_BUS_MEM_BASE(2)) U64_TO_U32_H(CP110_PCIEx_CPU_MEM_BASE(2))
+				U64_TO_U32_L(CP110_PCIEx_CPU_MEM_BASE(2)) U64_TO_U32_H(CP110_PCIE_MEM_SIZE(2))
+				U64_TO_U32_L(CP110_PCIE_MEM_SIZE(2))>;
+			num-lanes = <1>;
+			status = "disabled";
+		};
+	};
+};
diff --git a/arch/arm/dts/cn9130-crb-A.dts b/arch/arm/dts/cn9130-crb-A.dts
new file mode 100644
index 0000000..e3fd227
--- /dev/null
+++ b/arch/arm/dts/cn9130-crb-A.dts
@@ -0,0 +1,57 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ */
+
+#include "cn9130-crb.dtsi"
+
+/ {
+	model = "CN9130-CRB-A";
+	compatible = "marvell,cn9130-crb-A",
+		"marvell,cn9130",
+		"marvell,armada-ap806-quad",
+		"marvell,armada-ap806";
+};
+
+&cp0_comphy {
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_SGMII2>;
+		phy-speed = <COMPHY_SPEED_3_125G>;
+	};
+};
+
+&cp0_pcie0 {
+	num-lanes = <4>;
+		/* non-prefetchable memory */
+	ranges =<0x82000000 0 0xc0000000 0 0xc0000000 0 0x2000000>;
+	status = "okay";
+};
+
+&cp0_usb3_0 {
+	status = "okay";
+};
+
+&cp0_usb3_1 {
+	status = "okay";
+};
diff --git a/arch/arm/dts/cn9130-crb-B.dts b/arch/arm/dts/cn9130-crb-B.dts
new file mode 100644
index 0000000..52204d5
--- /dev/null
+++ b/arch/arm/dts/cn9130-crb-B.dts
@@ -0,0 +1,61 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ */
+
+#include "cn9130-crb.dtsi"
+
+/ {
+	model = "CN9130-CRB-B";
+	compatible = "marvell,cn9130-crb-B",
+		"marvell,cn9130",
+		"marvell,armada-ap806-quad",
+		"marvell,armada-ap806";
+};
+
+&cp0_comphy {
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_USB3_HOST0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_SGMII2>;
+		phy-speed = <COMPHY_SPEED_3_125G>;
+	};
+};
+
+&cp0_sata0 {
+	status = "okay";
+};
+
+&cp0_pcie0 {
+	num-lanes = <1>;
+		/* non-prefetchable memory */
+	ranges =<0x82000000 0 0xc0000000 0 0xc0000000 0 0x2000000>;
+	status = "okay";
+};
+
+&cp0_usb3_0 {
+	status = "okay";
+};
+
+&cp0_usb3_1 {
+	status = "okay";
+};
diff --git a/arch/arm/dts/cn9130-crb.dtsi b/arch/arm/dts/cn9130-crb.dtsi
new file mode 100644
index 0000000..c892811
--- /dev/null
+++ b/arch/arm/dts/cn9130-crb.dtsi
@@ -0,0 +1,229 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ */
+
+#include "cn9130.dtsi" /* include SoC device tree */
+
+/ {
+	model = "CN9130-CRB";
+	compatible = "marvell,cn9130-crb",
+		"marvell,cn9130",
+		"marvell,armada-ap806-quad",
+		"marvell,armada-ap806";
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp0_spi1;
+		gpio0 = &ap_gpio0;
+		gpio1 = &cp0_gpio0;
+		gpio2 = &cp0_gpio1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+
+	cp0 {
+		config-space {
+			sdhci@780000 {
+				vqmmc-supply = <&cp0_reg_sd_vccq>;
+				vmmc-supply = <&cp0_reg_sd_vcc>;
+			};
+			cp0_reg_sd_vccq: cp0_sd_vccq@0 {
+				compatible = "regulator-gpio";
+				regulator-name = "cp0_sd_vccq";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				gpios = <&cp0_gpio1 18 GPIO_ACTIVE_HIGH>;
+				states = <1800000 0x1
+					  3300000 0x0>;
+			};
+			cp0_reg_sd_vcc: cp0_sd_vcc@0 {
+				compatible = "regulator-fixed";
+				regulator-name = "cp0_sd_vcc";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				gpio = <&cp0_gpio1 22 GPIO_ACTIVE_HIGH>;
+				enable-active-high;
+				regulator-always-on;
+			};
+		};
+	};
+};
+
+&uart0 {
+	status = "okay";
+};
+
+/*
+ * AP related configuration
+ */
+&ap_pinctl {
+	/* MPP Bus:
+	 * SDIO  [0-10, 12]
+	 * UART0 [11,19]
+	 */
+		/*   0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 1 1 1 1
+		     1 3 1 0 0 0 0 0 0 3 >;
+};
+
+/* on-board eMMC - U6 */
+&ap_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ap_emmc_pins>;
+	bus-width = <8>;
+	status = "okay";
+};
+
+/*
+ * CP related configuration
+ */
+&cp0_pinctl {
+	/* MPP Bus:
+	 *	[0-11]	RGMII1
+	 *	[12-26]	GPIO
+	 *	[27-30]	SPI1
+	 *	[31]	GPIO
+	 *	[32]	GPIO
+	 *	[33]	SD_PWR_OFF
+	 *	[34]	CP_PCIE0_CLKREQn
+	 *	[35-38]	I2C1 I2C0
+	 *	[39]	GPIO
+	 *	[40-43]	SMI/XSMI
+	 *	[44-46]	GPIO
+	 *	[47]	UART1_TX
+	 *	[48]	GPIO
+	 *	[49]	SD_HST_18_EN
+	 *	[50]	GPIO
+	 *	[51]	SD_PWR_0
+	 *	[52]	PCIE_RSTn
+	 *	[53]	UART1_RX
+	 *	[54]	GPIO
+	 *	[55]	SD_DT
+	 *	[56-61]	SDIO
+	 */
+		/*   0   1   2   3   4   5   6   7   8   9 */
+	pin-func = < 3   3   3   3   3   3   3   3   3   3
+		     3   3   0   0   0   0   0   0   0   0
+		     0   0   0   0   0   0   0   2   2   2
+		     2   0   0   6   9   2   2   2   2   0
+		     8   8   8   8   0   0   0   7   0   0xa
+		     0   0xa 9   7   0   0xb 0xe 0xe 0xe 0xe
+		     0xe 0xe 0xe>;
+};
+
+&cp0_pinctl {
+	cp0_spi1_pins_crb: cp0-spi-pins-crb {
+		marvell,pins = < 27 28 29 30 >;
+		marvell,function = <2>;
+	};
+};
+
+/*
+ * CP0
+ */
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_i2c1 {
+	status = "okay";
+};
+
+&cp0_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_sdhci_pins>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+&cp0_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_spi1_pins_crb>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>,		/* CS1 */
+	      <0 0xffffffff>,		/* CS2 */
+	      <0 0xffffffff>;		/* CS3 */
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <0x1>;
+		#size-cells = <0x1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0x0>;
+		/* On-board MUX does not allow higher frequencies */
+		spi-max-frequency = <40000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0x0 0x200000>;
+			};
+
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xe00000>;
+			};
+		};
+	};
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_utmi1 {
+	status = "okay";
+};
+
+&cp0_mdio {
+	status = "okay";
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+	switch6: ethernet-switch@6 {
+		reg = <6>;
+	};
+};
+
+&cp0_xmdio {
+	status = "okay";
+	nbaset_phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi";
+};
+
+&cp0_eth1 {
+	status = "okay";
+	phy = <&phy0>;
+	phy-mode = "rgmii-id";
+};
+
+&cp0_eth2 {
+	status = "okay";
+	phy = <&nbaset_phy0>;
+	phy-mode = "sgmii";
+};
diff --git a/arch/arm/dts/cn9130-db-A.dts b/arch/arm/dts/cn9130-db-A.dts
new file mode 100644
index 0000000..a285592
--- /dev/null
+++ b/arch/arm/dts/cn9130-db-A.dts
@@ -0,0 +1,222 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include "cn9130-db.dtsi"
+
+/ {
+	model = "Marvell CN9130 development board (CP NOR) setup(A)";
+	compatible = "marvell,cn9130-db", "marvell,cn91xx", "marvell,cn9030-vd",
+		     "marvell,cn9030", "marvell,armada-ap806-quad",
+		     "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp0_spi1;
+		gpio0 = &ap_gpio0;
+		gpio1 = &cp0_gpio0;
+		gpio2 = &cp0_gpio1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+};
+
+&uart0 {
+	status = "okay";
+};
+
+/*
+ * AP related configuration
+ */
+&ap_pinctl {
+	/* MPP Bus:
+	 * SDIO  [0-10, 12]
+	 * UART0 [11,19]
+	 */
+		/*   0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 1 1 1 1
+		     1 3 1 0 0 0 0 0 0 3 >;
+};
+
+/* on-board eMMC - U9 */
+&ap_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ap_emmc_pins>;
+	bus-width = <8>;
+	status = "okay";
+};
+
+/*
+ * CP related configuration
+ */
+&cp0_pinctl {
+	/* MPP Bus:
+	 *	[0-11]	RGMII1
+	 *	[12]	GPIO GE-IN
+	 *	[13-16]	SPI1
+	 *	[17-27]	NAND
+	 *	[28]	MSS_GPIO[5] XXX:(mode nr from a3900)
+	 *	[29-30]	SATA
+	 *	[31]	MSS_GPIO[4] XXX:(mode nr from a3900)
+	 *	[32,34]	SMI
+	 *	[33]	SDIO
+	 *	[35-36]	I2C1
+	 *	[37-38]	I2C0
+	 *	[39-43]	SDIOctrl
+	 *	[44-55]	RGMII2
+	 *	[56-62]	SDIO
+	 */
+
+		/*   0   1   2   3   4   5   6   7   8   9 */
+	pin-func = < 3   3   3   3   3   3   3   3   3   3
+		     3   3   0   3   3   3   3   1   1   1
+		     1   1   1   1   1   1   1   1   3   9
+		     9   3   7   6   7   2   2   2   2   1
+		     1   1   1   1   1   1   1   1   1   1
+		     1   1   1   1   1   1   0xe 0xe 0xe 0xe
+		     0xe 0xe 0xe>;
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_i2c1 {
+	status = "okay";
+};
+
+/* CON 28 */
+&cp0_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_sdhci_pins>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+/* U54 */
+&cp0_nand {
+	status = "disabled";
+};
+
+/* U55 */
+&cp0_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_spi0_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>,		/* CS1 */
+	      <0 0xffffffff>,		/* CS2 */
+	      <0 0xffffffff>;		/* CS3 */
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <0x1>;
+		#size-cells = <0x1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0x0>;
+		/* On-board MUX does not allow higher frequencies */
+		spi-max-frequency = <40000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0x0 0x200000>;
+			};
+
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xe00000>;
+			};
+		};
+	};
+};
+
+&cp0_comphy {
+
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+};
+
+/* SLM-1521-V2, CON6 */
+&cp0_pcie0 {
+	num-lanes = <4>;
+	status = "okay";
+};
+
+&cp0_mdio {
+	status = "okay";
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+/* SLM-1521-V2, CON9 */
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi";
+};
+
+/* CON56 */
+&cp0_eth1 {
+	status = "okay";
+	phy = <&phy0>;
+	phy-mode = "rgmii-id";
+};
+
+/* CON57 */
+&cp0_eth2 {
+	status = "okay";
+	phy = <&phy1>;
+	phy-mode = "rgmii-id";
+};
+
+/* SLM-1521-V2, CON2 */
+&cp0_sata0 {
+	status = "okay";
+};
diff --git a/arch/arm/dts/cn9130-db-B.dts b/arch/arm/dts/cn9130-db-B.dts
new file mode 100644
index 0000000..a00c0fa
--- /dev/null
+++ b/arch/arm/dts/cn9130-db-B.dts
@@ -0,0 +1,234 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include "cn9130-db.dtsi"
+
+/ {
+	model = "Marvell CN9130 development board (CP NOR) setup(A)";
+	compatible = "marvell,cn9130-db", "marvell,cn91xx", "marvell,cn9030-vd",
+		     "marvell,cn9030", "marvell,armada-ap806-quad",
+		     "marvell,armada-ap806";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		i2c0 = &cp0_i2c0;
+		spi0 = &cp0_spi1;
+		gpio0 = &ap_gpio0;
+		gpio1 = &cp0_gpio0;
+		gpio2 = &cp0_gpio1;
+	};
+
+	memory@00000000 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0x80000000>;
+	};
+};
+
+&uart0 {
+	status = "okay";
+};
+
+/*
+ * AP related configuration
+ */
+&ap_pinctl {
+	/* MPP Bus:
+	 * SDIO  [0-10, 12]
+	 * UART0 [11,19]
+	 */
+		/*   0 1 2 3 4 5 6 7 8 9 */
+	pin-func = < 1 1 1 1 1 1 1 1 1 1
+		     1 3 1 0 0 0 0 0 0 3 >;
+};
+
+/* on-board eMMC - U9 */
+&ap_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ap_emmc_pins>;
+	bus-width = <8>;
+	status = "okay";
+};
+
+/*
+ * CP related configuration
+ */
+&cp0_pinctl {
+	cp0_nand_pins: cp0-nand-pins {
+		marvell,pins = <15 16 17 18 19 20 21 22 23 24 25 26 27 >;
+		marvell,function = <1>;
+	};
+	cp0_nand_rb: cp0-nand-rb {
+		marvell,pins = < 13 >;
+		marvell,function = <2>;
+	};
+};
+
+&cp0_pinctl {
+	/* MPP Bus:
+	 *	[0-11]	RGMII1
+	 *	[12]	GPIO GE-IN
+	 *	[13-14]	SPI1
+	 *	[15-27]	NAND
+	 *	[28]	MSS_GPIO[5] XXX:(mode nr from a3900)
+	 *	[29-30]	SATA
+	 *	[31]	MSS_GPIO[4] XXX:(mode nr from a3900)
+	 *	[32,34]	SMI
+	 *	[33]	SDIO
+	 *	[35-36]	I2C1
+	 *	[37-38]	I2C0
+	 *	[39-43]	SDIOctrl
+	 *	[44-55]	RGMII2
+	 *	[56-62]	SDIO
+	 */
+
+		/*   0   1   2   3   4   5   6   7   8   9 */
+	pin-func = < 3   3   3   3   3   3   3   3   3   3
+		     3   3   0   2   3   1   1   1   1   1
+		     1   1   1   1   1   1   1   1   3   9
+		     9   3   7   6   7   2   2   2   2   1
+		     1   1   1   1   1   1   1   1   1   1
+		     1   1   1   1   1   1   0xe 0xe 0xe 0xe
+		     0xe 0xe 0xe>;
+};
+
+&cp0_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp0_i2c1 {
+	status = "okay";
+};
+
+/* CON 28 */
+&cp0_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_sdhci_pins>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+/* U54 */
+&cp0_nand {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_nand_pins &cp0_nand_rb>;
+	status = "okay";
+};
+
+/* U55 */
+&cp0_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp0_spi0_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>,		/* CS1 */
+	      <0 0xffffffff>,		/* CS2 */
+	      <0 0xffffffff>;		/* CS3 */
+	status = "disabled";
+
+	spi-flash@0 {
+		#address-cells = <0x1>;
+		#size-cells = <0x1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0x0>;
+		/* On-board MUX does not allow higher frequencies */
+		spi-max-frequency = <40000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0x0 0x200000>;
+			};
+
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xe00000>;
+			};
+		};
+	};
+};
+
+&cp0_comphy {
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+};
+
+/* SLM-1521-V2, CON6 */
+&cp0_pcie0 {
+	num-lanes = <4>;
+	status = "okay";
+};
+
+&cp0_mdio {
+	status = "okay";
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+	};
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+	};
+};
+
+&cp0_ethernet {
+	status = "okay";
+};
+
+/* SLM-1521-V2, CON9 */
+&cp0_eth0 {
+	status = "okay";
+	phy-mode = "sfi";
+};
+
+/* CON56 */
+&cp0_eth1 {
+	status = "okay";
+	phy = <&phy0>;
+	phy-mode = "rgmii-id";
+};
+
+/* CON57 */
+&cp0_eth2 {
+	status = "okay";
+	phy = <&phy1>;
+	phy-mode = "rgmii-id";
+};
+
+/* SLM-1521-V2, CON2 */
+&cp0_sata0 {
+	status = "okay";
+};
diff --git a/arch/arm/dts/cn9130-db-dev-info.dtsi b/arch/arm/dts/cn9130-db-dev-info.dtsi
new file mode 100644
index 0000000..f2e7c03
--- /dev/null
+++ b/arch/arm/dts/cn9130-db-dev-info.dtsi
@@ -0,0 +1,44 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+/ {
+	/* This should go only into devel boards */
+	compatible = "marvell,cp110";
+	sar {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		sar_fields {
+			compatible = "marvell,sample-at-reset";
+			reg = <0x4c 0x4e>;
+			chip_count = <2>;
+			bit_width = <5>;
+			freq {
+				key = "freq";
+				description = "CPU/DDR and PIDI frequencies";
+				start-bit = <0>;
+				bit-length = <4>;
+				option-cnt = <3>;
+				options = "0x0", "CPU/DDR = 0x0: 2000/1200 Mhz, PIDI = 0: 1Ghz",
+					  "0x2", "CPU/DDR = 0x6: 2200/1200 Mhz, PIDI = 0: 1Ghz",
+					  "0x4", "CPU/DDR = 0xD: 1600/1200 Mhz, PIDI = 0: 1Ghz";
+				default = <0x2>;
+				status = "okay";
+			};
+			boot_mode {
+				key = "boot_mode";
+				description = "Boot mode options";
+				start-bit = <4>;
+				bit-length = <6>;
+				option-cnt = <4>;
+				options = "0xE", "CP0_NAND PIDI BW-8bit, PS-4KB, ECC-4bit\t(supported configuration: B)",
+					  "0xF", "CP0_NAND PIDI BW-8bit, PS-4KB, ECC-8bit\t(supported configuration: B)",
+					  "0x2A", "AP_EMMC",
+					  "0x32", "CP1_SPI_1 24bits";
+				default = <0x32>;
+				status = "okay";
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/cn9130-db.dtsi b/arch/arm/dts/cn9130-db.dtsi
new file mode 100644
index 0000000..f844e17
--- /dev/null
+++ b/arch/arm/dts/cn9130-db.dtsi
@@ -0,0 +1,133 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include "cn9130.dtsi" /* include SoC device tree */
+#include "cn9130-db-dev-info.dtsi"
+
+/ {
+	model = "DB-CN-9130";
+	compatible = "marvell,cn9030", "marvell,armada-ap806-quad",
+		     "marvell,armada-ap806";
+
+	cp0 {
+		config-space {
+			i2c@701000 {
+				/* U36 */
+				expander0: pca953x@21 {
+					compatible = "nxp,pca9555";
+					#gpio-cells = <2>;
+					reg = <0x21>;
+					status = "okay";
+				};
+			};
+			sdhci@780000 {
+				vqmmc-supply = <&cp0_reg_sd_vccq>;
+				vmmc-supply = <&cp0_reg_sd_vcc>;
+			};
+
+			cp0_reg_usb3_vbus0: cp0_usb3_vbus@0 {
+				compatible = "regulator-fixed";
+				regulator-name = "cp0-xhci0-vbus";
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5000000>;
+				startup-delay-us = <100000>;
+				regulator-force-boot-off;
+				gpio = <&expander0 0 GPIO_ACTIVE_HIGH>;
+			};
+
+			cp0_reg_usb3_vbus1: cp0_usb3_vbus@1 {
+				compatible = "regulator-fixed";
+				regulator-name = "cp0-xhci1-vbus";
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5000000>;
+				startup-delay-us = <100000>;
+				regulator-force-boot-off;
+				gpio = <&expander0 1 GPIO_ACTIVE_HIGH>;
+			};
+			cp0_reg_sd_vccq: cp0_sd_vccq@0 {
+				compatible = "regulator-gpio";
+				regulator-name = "cp0_sd_vccq";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				gpios = <&expander0 15 GPIO_ACTIVE_HIGH>;
+				states = <1800000 0x1
+					  3300000 0x0>;
+			};
+			cp0_reg_sd_vcc: cp0_sd_vcc@0 {
+				compatible = "regulator-fixed";
+				regulator-name = "cp0_sd_vcc";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				gpio = <&expander0 14 GPIO_ACTIVE_HIGH>;
+				enable-active-high;
+				regulator-always-on;
+			};
+			cp0_reg_usb3_current_lim0:cp0_usb3_current_limiter@0 {
+				compatible = "regulator-fixed";
+				regulator-min-microamp = <900000>;
+				regulator-max-microamp = <900000>;
+				regulator-force-boot-off;
+				gpio = <&expander0 4 GPIO_ACTIVE_HIGH>;
+			};
+
+			cp0_reg_usb3_current_lim1: cp0_usb3_current_limiter@1 {
+				compatible = "regulator-fixed";
+				regulator-min-microamp = <900000>;
+				regulator-max-microamp = <900000>;
+				regulator-force-boot-off;
+				gpio = <&expander0 5 GPIO_ACTIVE_HIGH>;
+			};
+		};
+	};
+};
+
+&ap_hd_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse0 {
+	status = "okay";
+};
+
+&ap_ld_efuse1 {
+	status = "okay";
+};
+
+/*
+ * CP0
+ */
+&cp0_ld_efuse0 {
+	status = "okay";
+};
+
+&cp0_ld_efuse1 {
+	status = "okay";
+};
+
+&cp0_utmi0 {
+	status = "okay";
+};
+
+&cp0_utmi1 {
+	status = "okay";
+};
+
+&cp0_usb3_0 {
+	status = "okay";
+	vbus-supply = <&cp0_reg_usb3_vbus0>;
+	current-limiter = <&cp0_reg_usb3_current_lim0>;
+	vbus-disable-delay = <500>;
+};
+
+&cp0_usb3_1 {
+	status = "okay";
+	vbus-supply = <&cp0_reg_usb3_vbus1>;
+	current-limiter = <&cp0_reg_usb3_current_lim1>;
+	vbus-disable-delay = <500>;
+};
+
+&cp0_pcie0 {
+	status = "okay";
+};
diff --git a/arch/arm/dts/cn9130.dtsi b/arch/arm/dts/cn9130.dtsi
new file mode 100644
index 0000000..c02af09
--- /dev/null
+++ b/arch/arm/dts/cn9130.dtsi
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+/*
+ * Device Tree file for the CN 9030 SoC, made of an AP806 Quad and
+ * one CP110.
+ */
+
+#include <dt-bindings/gpio/gpio.h>
+#include "armada-common.dtsi"
+#include "armada-ap807.dtsi"
+#include "armada-ap80x-quad.dtsi"
+
+/* This defines used to calculate the base address of each CP */
+#define CP110_BASE_OFFSET		(0xf2000000)
+#define CP110_SPACE_SIZE		(0x02000000)
+#define CP110_BASE			(CP110_BASE_OFFSET + \
+						(CP110_NUM * CP110_SPACE_SIZE))
+
+#define CP110_PCIE_MEM_SIZE(iface)	((iface == 0) ? 0x1ff00000 : 0xf00000)
+#define CP110_PCIE_BUS_MEM_CFG		(0x82000000)
+
+/* CP110-0 Settings */
+#define CP110_NAME			cp0
+#define CP110_NUM			0
+#define CP110_PCIEx_CPU_MEM_BASE(iface)	((iface == 0) ? 0xc0000000 : \
+					 (0xe0000000 + (iface - 1) * 0x1000000))
+#define CP110_PCIEx_BUS_MEM_BASE(iface)	(CP110_PCIEx_CPU_MEM_BASE(iface))
+
+#include "armada-cp110.dtsi"
+
+/ {
+	model = "Marvell CN 9030";
+	compatible = "marvell,armada70x0", "marvell,armada-ap806-quad",
+		     "marvell,armada-ap806";
+
+	aliases {
+		fuse0 = &ap_hd_efuse0;	/* banks 0-63 RW */
+		fuse1 = &ap_ld_efuse0;	/* bank 64 RO */
+		fuse2 = &ap_ld_efuse1;	/* bank 65 RW */
+		fuse3 = &cp0_ld_efuse0;	/* bank 66 RO */
+		fuse4 = &cp0_ld_efuse1;	/* bank 67 RW */
+	};
+};
+
+&cp0_rtc {
+	status = "okay";
+};
+
+&cp0_pinctl {
+	compatible = "marvell,mvebu-pinctrl", "marvell,armada-8k-cpm-pinctrl";
+	bank-name ="cp0-110";
+
+	cp0_i2c0_pins: cp0-i2c-pins-0 {
+		marvell,pins = < 37 38 >;
+		marvell,function = <2>;
+	};
+	cp0_i2c1_pins: cp0-i2c-pins-1 {
+		marvell,pins = < 35 36 >;
+		marvell,function = <2>;
+	};
+	cp0_ge1_rgmii_pins: cp0-ge-rgmii-pins-0 {
+		marvell,pins = < 0 1 2 3 4 5 6 7 8 9 10 11>;
+		marvell,function = <3>;
+	};
+	cp0_ge2_rgmii_pins: cp0-ge-rgmii-pins-1 {
+		marvell,pins = < 44 45 46 47 48 49 50 51
+				52 53 54 55 >;
+		marvell,function = <1>;
+	};
+	cp0_pca0_pins: cp0-pca0_pins {
+		marvell,pins = <62>;
+		marvell,function = <0>;
+	};
+	cp0_sdhci_pins: cp0-sdhi-pins-0 {
+		marvell,pins = < 56 57 58 59 60 61 >;
+		marvell,function = <14>;
+	};
+	cp0_spi0_pins: cp0-spi-pins-0 {
+		marvell,pins = < 13 14 15 16 >;
+		marvell,function = <3>;
+	};
+};
diff --git a/arch/arm/dts/cn9131-db-A.dts b/arch/arm/dts/cn9131-db-A.dts
new file mode 100644
index 0000000..74a19c7
--- /dev/null
+++ b/arch/arm/dts/cn9131-db-A.dts
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include "cn9130-db-A.dts"
+#include "cn9131-db.dtsi"
+
+/ {
+	model = "Marvell CN9131 development board (CP NOR) setup(A)";
+	compatible = "marvell,cn9131-db", "marvell,armada-ap806-quad",
+		     "marvell,armada-ap806";
+};
+
+&cp1_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0: PCIe0 (x2)
+	 *	Lane 1: PCIe0 (x2)
+	 *	Lane 2: unconnected
+	 *	Lane 3: USB1
+	 *	Lane 4: SFP (port 0)
+	 *	Lane 5: SATA1
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_UNCONNECTED>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+};
+
+&cp1_ethernet {
+	status = "okay";
+};
+
+/* CON50 */
+&cp1_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-4 */
+	marvell,sfp-tx-disable-gpio = <&cp1_gpio0 9 GPIO_ACTIVE_HIGH>;
+};
diff --git a/arch/arm/dts/cn9131-db-B.dts b/arch/arm/dts/cn9131-db-B.dts
new file mode 100644
index 0000000..cd67ed7
--- /dev/null
+++ b/arch/arm/dts/cn9131-db-B.dts
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include "cn9130-db-B.dts"
+#include "cn9131-db.dtsi"
+
+/ {
+	model = "Marvell CN9131 development board (CP NAND) setup(B)";
+	compatible = "marvell,cn9131-db", "marvell,armada-ap806-quad",
+		     "marvell,armada-ap806";
+};
+
+&cp1_comphy {
+	/* Serdes Configuration:
+	 *	Lane 0: PCIe0 (x2)
+	 *	Lane 1: PCIe0 (x2)
+	 *	Lane 2: SFI (port 0)
+	 *	Lane 3: USB1
+	 *	Lane 4: SGMII (port 1)
+	 *	Lane 5: SATA1
+	 */
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+	phy2 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+	phy3 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+	phy4 {
+		phy-type = <COMPHY_TYPE_SGMII1>;
+		phy-speed = <COMPHY_SPEED_1_25G>;
+	};
+	phy5 {
+		phy-type = <COMPHY_TYPE_SATA1>;
+	};
+};
+
+&cp1_ethernet {
+	status = "okay";
+};
+
+/* 3310 RJ45 CON55 */
+&cp1_eth0 {
+	status = "okay";
+	phy-mode = "sfi"; /* lane-2 */
+	phy = <&sfi_phy8>; /* required by 3310 fw download */
+};
+
+/* CON50 */
+&cp1_eth1 {
+	status = "okay";
+	phy-mode = "sgmii"; /* lane-4 */
+	marvell,sfp-tx-disable-gpio = <&cp1_gpio0 9 GPIO_ACTIVE_HIGH>;
+};
+
+&cp1_xmdio {
+	status = "okay";
+	sfi_phy8: ethernet-phy@8 {
+		reg = <8>;
+	};
+};
diff --git a/arch/arm/dts/cn9131-db.dtsi b/arch/arm/dts/cn9131-db.dtsi
new file mode 100644
index 0000000..00f1f1e
--- /dev/null
+++ b/arch/arm/dts/cn9131-db.dtsi
@@ -0,0 +1,178 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#undef CP110_NAME
+#undef CP110_NUM
+#undef CP110_PCIE_MEM_SIZE
+#undef CP110_PCIEx_CPU_MEM_BASE
+#undef CP110_PCIEx_BUS_MEM_BASE
+
+/* CP110-1 Settings */
+#define CP110_NAME			cp1
+#define CP110_NUM			1
+#define CP110_PCIE_MEM_SIZE(iface)	(0xf00000)
+#define CP110_PCIEx_CPU_MEM_BASE(iface)	(0xe2000000 + (iface) * 0x1000000)
+#define CP110_PCIEx_BUS_MEM_BASE(iface)	(CP110_PCIEx_CPU_MEM_BASE(iface))
+
+#include "armada-cp110.dtsi"
+
+/ {
+	model = "Marvell CN9131 development board";
+	compatible = "marvell,cn9131-db";
+
+	aliases {
+		gpio3 = &cp1_gpio0;
+		gpio4 = &cp1_gpio1;
+		fuse5 = &cp1_ld_efuse0;	/* bank 68 RO */
+		fuse6 = &cp1_ld_efuse1;	/* bank 69 RW */
+	};
+
+	cp1 {
+		config-space {
+			cp1_reg_usb3_vbus0: cp1_usb3_vbus@0 {
+				compatible = "regulator-fixed";
+				pinctrl-names = "default";
+				pinctrl-0 = <&cp1_xhci0_vbus_pins>;
+				regulator-name = "cp1-xhci0-vbus";
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5000000>;
+				startup-delay-us = <100000>;
+				regulator-force-boot-off;
+				gpio = <&cp1_gpio0 3 GPIO_ACTIVE_HIGH>;
+			};
+			cp1_reg_usb3_current_lim0: cp1_usb3_current_limiter@0 {
+				compatible = "regulator-fixed";
+				regulator-min-microamp = <900000>;
+				regulator-max-microamp = <900000>;
+				regulator-force-boot-off;
+				gpio = <&cp1_gpio0 2 GPIO_ACTIVE_HIGH>;
+			};
+			cp1_pcie_reset_pins: cp1-pcie-reset-pins {
+				marvell,pins = <0>;
+				marvell,function = <0>;
+			};
+		};
+	};
+};
+
+&cp1_ld_efuse0 {
+	status = "okay";
+};
+
+&cp1_ld_efuse1 {
+	status = "okay";
+};
+
+&cp1_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp1_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+/* CON40 */
+&cp1_pcie0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp1_pcie_reset_pins>;
+	marvell,reset-gpio = <&cp1_gpio0 0 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+	num-lanes = <2>;
+		/* non-prefetchable memory */
+	ranges = <0x82000000 0 0xe2000000 0 0xe2000000 0 0xf00000>;
+};
+
+&cp1_pinctl {
+	compatible = "marvell,mvebu-pinctrl",
+		     "marvell,cp115-standalone-pinctrl";
+	bank-name ="cp1-110";
+
+	/* MPP Bus:
+	 *	[0-12]	GPIO
+	 *	[13-16]	SPI1
+	 *	[17-27]	GPIO (Default)
+	 *	[28]	SATA1_PRESENT_ACTIVEn
+	 *	[29-34]	GPIO (Default)
+	 *	[35-36]	xSMI
+	 *	[37-38] I2C0
+	 *	[39-62]	GPIO
+	 */
+		/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0
+		     0x0  0x0  0x0  0x3  0x3  0x3  0x3  0x0  0x0  0x0
+		     0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x9  0x0
+		     0x0  0x0  0x0  0x0  0x0  0x7  0x7  0x2  0x2  0x0
+		     0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0
+		     0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0
+		     0x0  0x0  0x0 >;
+
+	cp1_i2c0_pins: cp1-i2c-pins-0 {
+		marvell,pins = < 37 38 >;
+		marvell,function = <2>;
+	};
+	cp1_spi0_pins: cp1-spi-pins-0 {
+		marvell,pins = < 13 14 15 16 >;
+		marvell,function = <3>;
+	};
+	cp1_xhci0_vbus_pins: cp1-xhci0-vbus-pins {
+		marvell,pins = <3>;
+		marvell,function = <0>;
+	};
+};
+
+/* CON32 */
+&cp1_sata0 {
+	status = "okay";
+};
+
+/* U24 */
+&cp1_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp1_spi0_pins>;
+	reg = <0x700680 0x50>,		/* control */
+	      <0x2000000 0x1000000>,	/* CS0 */
+	      <0 0xffffffff>,		/* CS1 */
+	      <0 0xffffffff>,		/* CS2 */
+	      <0 0xffffffff>;		/* CS3 */
+	status = "okay";
+
+	spi-flash@0 {
+		#address-cells = <0x1>;
+		#size-cells = <0x1>;
+		compatible = "jedec,spi-nor", "spi-flash";
+		reg = <0x0>;
+		/* On-board MUX does not allow higher frequencies */
+		spi-max-frequency = <40000000>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "U-Boot";
+				reg = <0x0 0x200000>;
+			};
+
+			partition@400000 {
+				label = "Filesystem";
+				reg = <0x200000 0xe00000>;
+			};
+		};
+	};
+};
+
+/* CON58 */
+&cp1_usb3_1 {
+	vbus-supply = <&cp1_reg_usb3_vbus0>;
+	current-limiter = <&cp1_reg_usb3_current_lim0>;
+	vbus-disable-delay = <500>;
+	status = "okay";
+};
+
+&cp1_utmi1 {
+	status = "okay";
+};
diff --git a/arch/arm/dts/cn9132-db-A.dts b/arch/arm/dts/cn9132-db-A.dts
new file mode 100644
index 0000000..a8930d4
--- /dev/null
+++ b/arch/arm/dts/cn9132-db-A.dts
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include "cn9131-db-A.dts"
+#include "cn9132-db.dtsi"
+
+/ {
+	model = "Marvell CN9132 development board (CP NOR) setup(A)";
+	compatible = "marvell,cn9132-db", "marvell,armada-ap806-quad",
+		     "marvell,armada-ap806";
+};
+
+&cp2_comphy {
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+&cp2_ld_efuse1 {
+	status = "okay";
+};
+
+&cp2_ethernet {
+	status = "okay";
+};
+
+/* SLM-1521-V2, CON9 */
+&cp2_eth0 {
+	status = "okay";
+	phy-mode = "sfi";
+};
+
+/* SLM-1521-V2, CON6 */
+&cp2_pcie0 {
+	num-lanes = <2>;
+	status = "okay";
+};
+
+/* SLM-1521-V2, CON8 */
+&cp2_pcie2 {
+	num-lanes = <1>;
+	status = "okay";
+};
+
+&cp2_pinctl {
+	/* MPP Bus:
+	 *	[0-26]		GPIO
+	 *	[27]		SATA0_PRESENT_ACTIVEn
+	 *	[28]		SATA1_PRESENT_ACTIVEn
+	 *	[29-31, 33]	GPIO (Default)
+	 *	[32,34]		SMI
+	 *	[37-38]		I2C0
+	 *	[39-53]		GPIO
+	 *	[54]		SD_CRD_RSTn (out)
+	 *	[55]		SD_CRD_DT (in)
+	 *	[56-62]		SDIO
+	 */
+		/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0
+		     0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0
+		     0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x9  0x9  0x0
+		     0x0  0x0  0x8  0x0  0x8  0x0  0x0  0x2  0x2  0x0
+		     0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0
+		     0x0  0x0  0x0  0x0  0xa  0xb  0xe  0xe  0xe  0xe
+		     0xe  0xe  0xe >;
+};
+
+/* SLM-1521-V2, CON4 */
+&cp2_sata0 {
+	status = "okay";
+};
+
+/* CON 2 on SLM-1683 - microSD */
+&cp2_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp2_sdhci_pins>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+/* SLM-1521-V2, CON11 */
+&cp2_usb3_1 {
+	status = "okay";
+};
diff --git a/arch/arm/dts/cn9132-db-B.dts b/arch/arm/dts/cn9132-db-B.dts
new file mode 100644
index 0000000..1575995
--- /dev/null
+++ b/arch/arm/dts/cn9132-db-B.dts
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include "cn9131-db-B.dts"
+#include "cn9132-db.dtsi"
+
+/ {
+	model = "Marvell CN9132 development board (CP NAND) setup(B)";
+	compatible = "marvell,cn9132-db-B", "marvell,armada-ap806-quad",
+		     "marvell,armada-ap806";
+};
+
+&cp2_comphy {
+	phy0 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy1 {
+		phy-type = <COMPHY_TYPE_PEX0>;
+	};
+
+	phy2 {
+		phy-type = <COMPHY_TYPE_SATA0>;
+	};
+
+	phy3 {
+		phy-type = <COMPHY_TYPE_USB3_HOST1>;
+	};
+
+	phy4 {
+		phy-type = <COMPHY_TYPE_SFI0>;
+		phy-speed = <COMPHY_SPEED_10_3125G>;
+	};
+
+	phy5 {
+		phy-type = <COMPHY_TYPE_PEX2>;
+	};
+};
+
+&cp2_ld_efuse1 {
+	status = "okay";
+};
+
+&cp2_ethernet {
+	status = "okay";
+};
+
+/* SLM-1521-V2, CON9 */
+&cp2_eth0 {
+	status = "okay";
+	phy-mode = "sfi";
+};
+
+/* SLM-1521-V2, CON6 */
+&cp2_pcie0 {
+	num-lanes = <2>;
+	status = "okay";
+};
+
+/* SLM-1521-V2, CON8 */
+&cp2_pcie2 {
+	num-lanes = <1>;
+	status = "okay";
+};
+
+&cp2_pinctl {
+	/* MPP Bus:
+	 *	[0-26]		GPIO
+	 *	[27]		SATA0_PRESENT_ACTIVEn
+	 *	[28]		SATA1_PRESENT_ACTIVEn
+	 *	[29-31, 33]	GPIO (Default)
+	 *	[32,34]		SMI
+	 *	[37-38]		I2C0
+	 *	[39-53]		GPIO
+	 *	[54]		SD_CRD_RSTn (out)
+	 *	[55]		SD_CRD_DT (in)
+	 *	[56-62]		SDIO
+	 */
+		/*   0    1    2    3    4    5    6    7    8    9 */
+	pin-func = < 0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0
+		     0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0
+		     0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x9  0x9  0x0
+		     0x0  0x0  0x8  0x0  0x8  0x0  0x0  0x2  0x2  0x0
+		     0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0  0x0
+		     0x0  0x0  0x0  0x0  0xa  0xb  0xe  0xe  0xe  0xe
+		     0xe  0xe  0xe >;
+};
+
+/* SLM-1521-V2, CON4 */
+&cp2_sata0 {
+	status = "okay";
+};
+
+/* CON 2 on SLM-1683 - microSD */
+&cp2_sdhci0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp2_sdhci_pins>;
+	bus-width = <4>;
+	status = "okay";
+};
+
+/* SLM-1521-V2, CON11 */
+&cp2_usb3_1 {
+	status = "okay";
+};
diff --git a/arch/arm/dts/cn9132-db.dtsi b/arch/arm/dts/cn9132-db.dtsi
new file mode 100644
index 0000000..add9f60
--- /dev/null
+++ b/arch/arm/dts/cn9132-db.dtsi
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#undef CP110_NAME
+#undef CP110_NUM
+#undef CP110_PCIE_MEM_SIZE
+#undef CP110_PCIEx_CPU_MEM_BASE
+#undef CP110_PCIEx_BUS_MEM_BASE
+
+/* CP110-2 Settings */
+#define CP110_NAME			cp2
+#define CP110_NUM			2
+#define CP110_PCIE_MEM_SIZE(iface)	(0xf00000)
+#define CP110_PCIEx_CPU_MEM_BASE(iface)	(0xe5000000 + (iface) *  0x1000000)
+#define CP110_PCIEx_BUS_MEM_BASE(iface)	(CP110_PCIEx_CPU_MEM_BASE(iface))
+
+#include "armada-cp110.dtsi"
+
+/ {
+	model = "Marvell CN9132 development board";
+	compatible = "marvell,cn9132-db";
+
+	aliases {
+		gpio5 = &cp2_gpio0;
+		gpio6 = &cp2_gpio1;
+		fuse7 = &cp2_ld_efuse0;	/* bank 70 RO */
+		fuse8 = &cp2_ld_efuse1;	/* bank 71 RW */
+	};
+
+	cp2 {
+		config-space {
+			sdhci@780000 {
+				vqmmc-supply = <&cp2_reg_sd_vccq>;
+			};
+			cp2_reg_usb3_vbus0: cp2_usb3_vbus@0 {
+				compatible = "regulator-fixed";
+				regulator-name = "cp2-xhci0-vbus";
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5000000>;
+				startup-delay-us = <100000>;
+				regulator-force-boot-off;
+				gpio = <&cp2_gpio0 2 GPIO_ACTIVE_HIGH>;
+			};
+
+			cp2_reg_usb3_vbus1: cp2_usb3_vbus@1 {
+				compatible = "regulator-fixed";
+				regulator-name = "cp2-xhci1-vbus";
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5000000>;
+				startup-delay-us = <100000>;
+				regulator-force-boot-off;
+				gpio = <&cp2_gpio0 3 GPIO_ACTIVE_HIGH>;
+			};
+			cp2_reg_sd_vccq: cp2_sd_vccq@0 {
+				compatible = "regulator-gpio";
+				regulator-name = "cp2_sd_vcc";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				/* cp2_mpp49 */
+				gpios = <&cp2_gpio1 17 GPIO_ACTIVE_HIGH>;
+				states = <1800000 0x1
+					  3300000 0x0>;
+			};
+			cp2_reg_usb3_current_lim0: cp2_usb3_current_limiter@0 {
+				compatible = "regulator-fixed";
+				regulator-min-microamp = <900000>;
+				regulator-max-microamp = <900000>;
+				regulator-force-boot-off;
+				gpio = <&cp2_gpio0 0 GPIO_ACTIVE_HIGH>;
+			};
+
+			cp2_reg_usb3_current_lim1: cp2_usb3_current_limiter@1 {
+				compatible = "regulator-fixed";
+				regulator-min-microamp = <900000>;
+				regulator-max-microamp = <900000>;
+				regulator-force-boot-off;
+				gpio = <&cp2_gpio0 1 GPIO_ACTIVE_HIGH>;
+			};
+		};
+	};
+};
+
+&cp2_i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cp2_i2c0_pins>;
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&cp2_pcie0 {
+		/* non-prefetchable memory */
+	ranges =<0x82000000 0 0xe5000000 0 0xe5000000 0 0x1000000>;
+};
+
+&cp2_pinctl {
+	compatible = "marvell,mvebu-pinctrl",
+		     "marvell,cp115-standalone-pinctrl";
+	bank-name ="cp2-110";
+
+	cp2_i2c0_pins: cp2-i2c-pins-0 {
+		marvell,pins = < 37 38 >;
+		marvell,function = <2>;
+	};
+	cp2_sdhci_pins: cp2-sdhi-pins-0 {
+		marvell,pins = < 56 57 58 59 60 61 >;
+		marvell,function = <14>;
+	};
+};
+
+&cp2_usb3_0 {
+	status = "okay";
+	vbus-supply = <&cp2_reg_usb3_vbus0>;
+	current-limiter = <&cp2_reg_usb3_current_lim0>;
+	vbus-disable-delay = <500>;
+};
+
+&cp2_usb3_1 {
+	status = "okay";
+	vbus-supply = <&cp2_reg_usb3_vbus1>;
+	current-limiter = <&cp2_reg_usb3_current_lim1>;
+	vbus-disable-delay = <500>;
+};
+
+&cp2_utmi0 {
+	status = "okay";
+};
+
+&cp2_utmi1 {
+	status = "okay";
+};
diff --git a/arch/arm/dts/thunderx-88xx.dts b/arch/arm/dts/thunderx-88xx.dts
deleted file mode 100644
index 08f2678..0000000
--- a/arch/arm/dts/thunderx-88xx.dts
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Cavium Thunder DTS file - Thunder board description
- *
- * Copyright (C) 2014, Cavium Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+ or X11
- *
- */
-
-/dts-v1/;
-
-/include/ "thunderx-88xx.dtsi"
-
-/ {
-	model = "Cavium ThunderX CN88XX board";
-	compatible = "cavium,thunder-88xx";
-
-	aliases {
-		serial0 = &uaa0;
-		serial1 = &uaa1;
-	};
-
-	chosen {
-                stdout-path = &uaa0;
-        };
-
-	memory@00000000 {
-		device_type = "memory";
-		reg = <0x0 0x00000000 0x0 0x80000000>;
-	};
-};
diff --git a/arch/arm/dts/thunderx-88xx.dtsi b/arch/arm/dts/thunderx-88xx.dtsi
deleted file mode 100644
index 6e9230b..0000000
--- a/arch/arm/dts/thunderx-88xx.dtsi
+++ /dev/null
@@ -1,363 +0,0 @@
-/*
- * Cavium Thunder DTS file - Thunder SoC description
- *
- * Copyright (C) 2014, Cavium Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+ or X11
- *
- */
-
-/ {
-	compatible = "cavium,thunder-88xx";
-	interrupt-parent = <&gic0>;
-	#address-cells = <2>;
-	#size-cells = <2>;
-
-	psci {
-		compatible = "arm,psci-0.2";
-		method = "smc";
-	};
-
-	cpus {
-		#address-cells = <2>;
-		#size-cells = <0>;
-
-		cpu@000 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x000>;
-			enable-method = "psci";
-		};
-		cpu@001 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x001>;
-			enable-method = "psci";
-		};
-		cpu@002 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x002>;
-			enable-method = "psci";
-		};
-		cpu@003 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x003>;
-			enable-method = "psci";
-		};
-		cpu@004 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x004>;
-			enable-method = "psci";
-		};
-		cpu@005 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x005>;
-			enable-method = "psci";
-		};
-		cpu@006 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x006>;
-			enable-method = "psci";
-		};
-		cpu@007 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x007>;
-			enable-method = "psci";
-		};
-		cpu@008 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x008>;
-			enable-method = "psci";
-		};
-		cpu@009 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x009>;
-			enable-method = "psci";
-		};
-		cpu@00a {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x00a>;
-			enable-method = "psci";
-		};
-		cpu@00b {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x00b>;
-			enable-method = "psci";
-		};
-		cpu@00c {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x00c>;
-			enable-method = "psci";
-		};
-		cpu@00d {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x00d>;
-			enable-method = "psci";
-		};
-		cpu@00e {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x00e>;
-			enable-method = "psci";
-		};
-		cpu@00f {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x00f>;
-			enable-method = "psci";
-		};
-		cpu@100 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x100>;
-			enable-method = "psci";
-		};
-		cpu@101 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x101>;
-			enable-method = "psci";
-		};
-		cpu@102 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x102>;
-			enable-method = "psci";
-		};
-		cpu@103 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x103>;
-			enable-method = "psci";
-		};
-		cpu@104 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x104>;
-			enable-method = "psci";
-		};
-		cpu@105 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x105>;
-			enable-method = "psci";
-		};
-		cpu@106 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x106>;
-			enable-method = "psci";
-		};
-		cpu@107 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x107>;
-			enable-method = "psci";
-		};
-		cpu@108 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x108>;
-			enable-method = "psci";
-		};
-		cpu@109 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x109>;
-			enable-method = "psci";
-		};
-		cpu@10a {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x10a>;
-			enable-method = "psci";
-		};
-		cpu@10b {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x10b>;
-			enable-method = "psci";
-		};
-		cpu@10c {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x10c>;
-			enable-method = "psci";
-		};
-		cpu@10d {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x10d>;
-			enable-method = "psci";
-		};
-		cpu@10e {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x10e>;
-			enable-method = "psci";
-		};
-		cpu@10f {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x10f>;
-			enable-method = "psci";
-		};
-		cpu@200 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x200>;
-			enable-method = "psci";
-		};
-		cpu@201 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x201>;
-			enable-method = "psci";
-		};
-		cpu@202 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x202>;
-			enable-method = "psci";
-		};
-		cpu@203 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x203>;
-			enable-method = "psci";
-		};
-		cpu@204 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x204>;
-			enable-method = "psci";
-		};
-		cpu@205 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x205>;
-			enable-method = "psci";
-		};
-		cpu@206 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x206>;
-			enable-method = "psci";
-		};
-		cpu@207 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x207>;
-			enable-method = "psci";
-		};
-		cpu@208 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x208>;
-			enable-method = "psci";
-		};
-		cpu@209 {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x209>;
-			enable-method = "psci";
-		};
-		cpu@20a {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x20a>;
-			enable-method = "psci";
-		};
-		cpu@20b {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x20b>;
-			enable-method = "psci";
-		};
-		cpu@20c {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x20c>;
-			enable-method = "psci";
-		};
-		cpu@20d {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x20d>;
-			enable-method = "psci";
-		};
-		cpu@20e {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x20e>;
-			enable-method = "psci";
-		};
-		cpu@20f {
-			device_type = "cpu";
-			compatible = "cavium,thunder", "arm,armv8";
-			reg = <0x0 0x20f>;
-			enable-method = "psci";
-		};
-	};
-
-	timer {
-		compatible = "arm,armv8-timer";
-		interrupts = <1 13 0xff01>,
-		             <1 14 0xff01>,
-		             <1 11 0xff01>,
-		             <1 10 0xff01>;
-	};
-
-	soc {
-		compatible = "simple-bus";
-		#address-cells = <2>;
-		#size-cells = <2>;
-		ranges;
-
-		refclk50mhz: refclk50mhz {
-			compatible = "fixed-clock";
-			#clock-cells = <0>;
-			clock-frequency = <50000000>;
-			clock-output-names = "refclk50mhz";
-		};
-
-		gic0: interrupt-controller@8010,00000000 {
-			compatible = "arm,gic-v3";
-			#interrupt-cells = <3>;
-			interrupt-controller;
-			reg = <0x8010 0x00000000 0x0 0x010000>, /* GICD */
-			      <0x8010 0x80000000 0x0 0x600000>; /* GICR */
-			interrupts = <1 9 0xf04>;
-		};
-
-		uaa0: serial@87e0,24000000 {
-			compatible = "arm,pl011", "arm,primecell";
-			reg = <0x87e0 0x24000000 0x0 0x1000>;
-			interrupts = <1 21 4>;
-			clocks = <&refclk50mhz>;
-			clock-names = "apb_pclk";
-			uboot,skip-init;
-		};
-
-		uaa1: serial@87e0,25000000 {
-			compatible = "arm,pl011", "arm,primecell";
-			reg = <0x87e0 0x25000000 0x0 0x1000>;
-			interrupts = <1 22 4>;
-			clocks = <&refclk50mhz>;
-			clock-names = "apb_pclk";
-			uboot,skip-init;
-		};
-	};
-};
diff --git a/arch/arm/include/asm/arch-armada8k/cache_llc.h b/arch/arm/include/asm/arch-armada8k/cache_llc.h
index 8f97e6d..1be5026 100644
--- a/arch/arm/include/asm/arch-armada8k/cache_llc.h
+++ b/arch/arm/include/asm/arch-armada8k/cache_llc.h
@@ -18,4 +18,9 @@
 #define LLC_WAY_MASK			0xffffffff
 #define LLC_CACHE_SYNC_MASK		0x1
 
+#define MVEBU_LLC_BASE			(MVEBU_REGISTER(LLC_BASE_ADDR))
+#define LLC_CTRL_REG_OFFSET		0x100
+#define LLC_EN				0x1
+#define LLC_EXCL_EN			0x100
+
 #endif	/* _CACHE_LLC_H_ */
diff --git a/arch/arm/include/asm/arch-mvebu/thermal.h b/arch/arm/include/asm/arch-mvebu/thermal.h
new file mode 100644
index 0000000..3753596
--- /dev/null
+++ b/arch/arm/include/asm/arch-mvebu/thermal.h
@@ -0,0 +1,34 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#ifndef _MVEBU_THERMAL_H_
+#define _MVEBU_THERMAL_H_
+
+#include <dt-bindings/comphy/comphy_data.h>
+#include <fdtdec.h>
+
+struct thermal_unit_config {
+	/* thermal temperature parameters */
+	s32 tsen_offset;
+	s32 tsen_gain;
+	s32 tsen_divisor;
+	/* thermal data */
+	s32 tsen_ready;
+	void __iomem *regs_base;
+	/* thermal functionality */
+	u32 (*ptr_thermal_sensor_probe)(struct thermal_unit_config *);
+	s32 (*ptr_thermal_sensor_read)(struct thermal_unit_config *);
+};
+
+/* Thermal sensors APIs */
+s32 mvebu_thermal_sensor_read(struct thermal_unit_config *thermal_config);
+u32 mvebu_thermal_sensor_probe(struct thermal_unit_config *thermal_config);
+
+/* External Thermal sensors APIs */
+s32 mvebu_thermal_ext_sensor_read(struct thermal_unit_config *thermal_config);
+u32 mvebu_thermal_ext_sensor_probe(struct thermal_unit_config *thermal_config);
+
+#endif /* _THERMAL_H_ */
+
diff --git a/arch/arm/include/asm/arch-octeontx/atf.h b/arch/arm/include/asm/arch-octeontx/atf.h
new file mode 100644
index 0000000..f52b0c8
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx/atf.h
@@ -0,0 +1,14 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#ifndef __ATF_H__
+#define __ATF_H__
+#include <asm/arch/atf_part.h>
+
+ssize_t atf_dram_size(unsigned int node);
+ssize_t atf_node_count(void);
+#endif
diff --git a/arch/arm/include/asm/arch-octeontx/atf_part.h b/arch/arm/include/asm/arch-octeontx/atf_part.h
new file mode 100644
index 0000000..88b9eaf
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx/atf_part.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#ifndef __ATF_PART_H__
+#define __ATF_PART_H__
+
+struct storage_partition {
+	unsigned int type;
+	unsigned int size;
+	unsigned long offset;
+};
+
+enum {
+	PARTITION_NBL1FW_REST = 0,
+	PARTITION_BL2_BL31 = 1,
+	PARTITION_UBOOT = 2,
+	PARTITION_UEFI = 2,
+	PARTITION_KERNEL = 3,
+	PARTITION_DEVICE_TREE = 4,
+	PARTITION_LAST,
+};
+
+#endif
diff --git a/arch/arm/include/asm/arch-octeontx/cavm-csrs-mio_emm.h b/arch/arm/include/asm/arch-octeontx/cavm-csrs-mio_emm.h
new file mode 100644
index 0000000..f2f026f
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx/cavm-csrs-mio_emm.h
@@ -0,0 +1,1165 @@
+#ifndef __CAVM_CSRS_MIO_EMM_H__
+#define __CAVM_CSRS_MIO_EMM_H__
+/* This file is auto-generated. Do not edit */
+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+/**
+ * @file
+ *
+ * Configuration and status register (CSR) address and type definitions for
+ * Cavium MIO_EMM.
+ *
+ * This file is auto generated. Do not edit.
+ *
+ */
+
+/**
+ * Enumeration mio_emm_bar_e
+ *
+ * eMMC Base Address Register Enumeration Enumerates the base address
+ * registers.
+ */
+#define CAVM_MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN8 (0x87e009000000ll)
+#define CAVM_MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN8_SIZE 0x800000ull
+#define CAVM_MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN9 (0x87e009000000ll)
+#define CAVM_MIO_EMM_BAR_E_MIO_EMM_PF_BAR0_CN9_SIZE 0x10000ull
+#define CAVM_MIO_EMM_BAR_E_MIO_EMM_PF_BAR4 (0x87e009f00000ll)
+#define CAVM_MIO_EMM_BAR_E_MIO_EMM_PF_BAR4_SIZE 0x100000ull
+
+/**
+ * Enumeration mio_emm_int_vec_e
+ *
+ * eMMC MSI-X Vector Enumeration Enumerates the MSI-X interrupt vectors.
+ */
+#define CAVM_MIO_EMM_INT_VEC_E_DMA_INT_DONE (8)
+#define CAVM_MIO_EMM_INT_VEC_E_DMA_INT_FIFO (7)
+#define CAVM_MIO_EMM_INT_VEC_E_EMM_BUF_DONE (0)
+#define CAVM_MIO_EMM_INT_VEC_E_EMM_CMD_DONE (1)
+#define CAVM_MIO_EMM_INT_VEC_E_EMM_CMD_ERR (3)
+#define CAVM_MIO_EMM_INT_VEC_E_EMM_DMA_DONE (2)
+#define CAVM_MIO_EMM_INT_VEC_E_EMM_DMA_ERR (4)
+#define CAVM_MIO_EMM_INT_VEC_E_EMM_SWITCH_DONE (5)
+#define CAVM_MIO_EMM_INT_VEC_E_EMM_SWITCH_ERR (6)
+#define CAVM_MIO_EMM_INT_VEC_E_NCB_FLT (9)
+#define CAVM_MIO_EMM_INT_VEC_E_NCB_RAS (0xa)
+
+/**
+ * Register (RSL) mio_emm_access_wdog
+ *
+ * eMMC Access Watchdog Register
+ */
+union cavm_mio_emm_access_wdog {
+	u64 u;
+	struct cavm_mio_emm_access_wdog_s {
+		u64 clk_cnt                          : 32;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cavm_mio_emm_access_wdog_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_ACCESS_WDOG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_ACCESS_WDOG(void)
+{
+	return 0x20f0;
+}
+
+/**
+ * Register (RSL) mio_emm_buf_dat
+ *
+ * eMMC Data Buffer Access Register
+ */
+union cavm_mio_emm_buf_dat {
+	u64 u;
+	struct cavm_mio_emm_buf_dat_s {
+		u64 dat                              : 64;
+	} s;
+	/* struct cavm_mio_emm_buf_dat_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_BUF_DAT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_BUF_DAT(void)
+{
+	return 0x20e8;
+}
+
+/**
+ * Register (RSL) mio_emm_buf_idx
+ *
+ * eMMC Data Buffer Address Register
+ */
+union cavm_mio_emm_buf_idx {
+	u64 u;
+	struct cavm_mio_emm_buf_idx_s {
+		u64 offset                           : 6;
+		u64 buf_num                          : 1;
+		u64 reserved_7_15                    : 9;
+		u64 inc                              : 1;
+		u64 reserved_17_63                   : 47;
+	} s;
+	/* struct cavm_mio_emm_buf_idx_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_BUF_IDX(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_BUF_IDX(void)
+{
+	return 0x20e0;
+}
+
+/**
+ * Register (RSL) mio_emm_calb
+ *
+ * eMMC Calbration Register This register initiates delay line
+ * characterization.
+ */
+union cavm_mio_emm_calb {
+	u64 u;
+	struct cavm_mio_emm_calb_s {
+		u64 start                            : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_mio_emm_calb_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_CALB(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_CALB(void)
+{
+	return 0x20c0;
+}
+
+/**
+ * Register (RSL) mio_emm_cfg
+ *
+ * eMMC Configuration Register
+ */
+union cavm_mio_emm_cfg {
+	u64 u;
+	struct cavm_mio_emm_cfg_s {
+		u64 bus_ena                          : 4;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cavm_mio_emm_cfg_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_CFG(void)
+{
+	return 0x2000;
+}
+
+/**
+ * Register (RSL) mio_emm_cmd
+ *
+ * eMMC Command Register
+ */
+union cavm_mio_emm_cmd {
+	u64 u;
+	struct cavm_mio_emm_cmd_s {
+		u64 arg                              : 32;
+		u64 cmd_idx                          : 6;
+		u64 rtype_xor                        : 3;
+		u64 ctype_xor                        : 2;
+		u64 reserved_43_48                   : 6;
+		u64 offset                           : 6;
+		u64 dbuf                             : 1;
+		u64 reserved_56_58                   : 3;
+		u64 cmd_val                          : 1;
+		u64 bus_id                           : 2;
+		u64 skip_busy                        : 1;
+		u64 reserved_63                      : 1;
+	} s;
+	/* struct cavm_mio_emm_cmd_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_CMD(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_CMD(void)
+{
+	return 0x2058;
+}
+
+/**
+ * Register (RSL) mio_emm_comp
+ *
+ * eMMC Compensation Register
+ */
+union cavm_mio_emm_comp {
+	u64 u;
+	struct cavm_mio_emm_comp_s {
+		u64 nctl                             : 3;
+		u64 reserved_3_7                     : 5;
+		u64 pctl                             : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct cavm_mio_emm_comp_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_COMP(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_COMP(void)
+{
+	return 0x2040;
+}
+
+/**
+ * Register (RSL) mio_emm_debug
+ *
+ * eMMC Debug Register
+ */
+union cavm_mio_emm_debug {
+	u64 u;
+	struct cavm_mio_emm_debug_s {
+		u64 clk_on                           : 1;
+		u64 reserved_1_7                     : 7;
+		u64 cmd_sm                           : 4;
+		u64 data_sm                          : 4;
+		u64 dma_sm                           : 4;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct cavm_mio_emm_debug_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_DEBUG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_DEBUG(void)
+{
+	return 0x20f8;
+}
+
+/**
+ * Register (RSL) mio_emm_dma
+ *
+ * eMMC External DMA Configuration Register
+ */
+union cavm_mio_emm_dma {
+	u64 u;
+	struct cavm_mio_emm_dma_s {
+		u64 card_addr                        : 32;
+		u64 block_cnt                        : 16;
+		u64 multi                            : 1;
+		u64 rw                               : 1;
+		u64 rel_wr                           : 1;
+		u64 thres                            : 6;
+		u64 dat_null                         : 1;
+		u64 sector                           : 1;
+		u64 dma_val                          : 1;
+		u64 bus_id                           : 2;
+		u64 skip_busy                        : 1;
+		u64 extra_args                       : 1;
+	} s;
+	struct cavm_mio_emm_dma_cn8 {
+		u64 card_addr                        : 32;
+		u64 block_cnt                        : 16;
+		u64 multi                            : 1;
+		u64 rw                               : 1;
+		u64 rel_wr                           : 1;
+		u64 thres                            : 6;
+		u64 dat_null                         : 1;
+		u64 sector                           : 1;
+		u64 dma_val                          : 1;
+		u64 bus_id                           : 2;
+		u64 skip_busy                        : 1;
+		u64 reserved_63                      : 1;
+	} cn8;
+	struct cavm_mio_emm_dma_cn9 {
+		u64 card_addr                        : 32;
+		u64 block_cnt                        : 16;
+		u64 multi                            : 1;
+		u64 rw                               : 1;
+		u64 reserved_50                      : 1;
+		u64 thres                            : 6;
+		u64 dat_null                         : 1;
+		u64 sector                           : 1;
+		u64 dma_val                          : 1;
+		u64 bus_id                           : 2;
+		u64 skip_busy                        : 1;
+		u64 extra_args                       : 1;
+	} cn9;
+};
+
+static inline u64 CAVM_MIO_EMM_DMA(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_DMA(void)
+{
+	return 0x2050;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_adr
+ *
+ * eMMC DMA Address Register This register sets the address for eMMC/SD
+ * flash transfers to/from memory. Sixty-four-bit operations must be used
+ * to access this register. This register is updated by the DMA hardware
+ * and can be reloaded by the values placed in the MIO_EMM_DMA_FIFO_ADR.
+ */
+union cavm_mio_emm_dma_adr {
+	u64 u;
+	struct cavm_mio_emm_dma_adr_s {
+		u64 adr                              : 53;
+		u64 reserved_53_63                   : 11;
+	} s;
+	struct cavm_mio_emm_dma_adr_cn8 {
+		u64 adr                              : 49;
+		u64 reserved_49_63                   : 15;
+	} cn8;
+	/* struct cavm_mio_emm_dma_adr_s cn9; */
+};
+
+static inline u64 CAVM_MIO_EMM_DMA_ADR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_DMA_ADR(void)
+{
+	return 0x188;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_arg
+ *
+ * eMMC External DMA Extra Arguments Register
+ */
+union cavm_mio_emm_dma_arg {
+	u64 u;
+	struct cavm_mio_emm_dma_arg_s {
+		u64 cmd23_args                       : 8;
+		u64 force_pgm                        : 1;
+		u64 context_id                       : 4;
+		u64 tag_req                          : 1;
+		u64 pack_cmd                         : 1;
+		u64 rel_wr                           : 1;
+		u64 alt_cmd                          : 6;
+		u64 skip_blk_cmd                     : 1;
+		u64 reserved_23_31                   : 9;
+		u64 alt_cmd_arg                      : 32;
+	} s;
+	/* struct cavm_mio_emm_dma_arg_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_DMA_ARG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_DMA_ARG(void)
+{
+	return 0x2090;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_cfg
+ *
+ * eMMC DMA Configuration Register This register controls the internal
+ * DMA engine used with the eMMC/SD flash controller. Sixty- four-bit
+ * operations must be used to access this register. This register is
+ * updated by the hardware DMA engine and can also be reloaded by writes
+ * to the MIO_EMM_DMA_FIFO_CMD register.
+ */
+union cavm_mio_emm_dma_cfg {
+	u64 u;
+	struct cavm_mio_emm_dma_cfg_s {
+		u64 reserved_0_35                    : 36;
+		u64 size                             : 20;
+		u64 endian                           : 1;
+		u64 swap8                            : 1;
+		u64 swap16                           : 1;
+		u64 swap32                           : 1;
+		u64 reserved_60                      : 1;
+		u64 clr                              : 1;
+		u64 rw                               : 1;
+		u64 en                               : 1;
+	} s;
+	/* struct cavm_mio_emm_dma_cfg_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_DMA_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_DMA_CFG(void)
+{
+	return 0x180;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_fifo_adr
+ *
+ * eMMC Internal DMA FIFO Address Register This register specifies the
+ * internal address that is loaded into the eMMC internal DMA FIFO. The
+ * FIFO is used to queue up operations for the
+ * MIO_EMM_DMA_CFG/MIO_EMM_DMA_ADR when the DMA completes successfully.
+ */
+union cavm_mio_emm_dma_fifo_adr {
+	u64 u;
+	struct cavm_mio_emm_dma_fifo_adr_s {
+		u64 reserved_0_2                     : 3;
+		u64 adr                              : 50;
+		u64 reserved_53_63                   : 11;
+	} s;
+	struct cavm_mio_emm_dma_fifo_adr_cn8 {
+		u64 reserved_0_2                     : 3;
+		u64 adr                              : 46;
+		u64 reserved_49_63                   : 15;
+	} cn8;
+	/* struct cavm_mio_emm_dma_fifo_adr_s cn9; */
+};
+
+static inline u64 CAVM_MIO_EMM_DMA_FIFO_ADR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_DMA_FIFO_ADR(void)
+{
+	return 0x170;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_fifo_cfg
+ *
+ * eMMC Internal DMA FIFO Configuration Register This register controls
+ * DMA FIFO operations.
+ */
+union cavm_mio_emm_dma_fifo_cfg {
+	u64 u;
+	struct cavm_mio_emm_dma_fifo_cfg_s {
+		u64 count                            : 5;
+		u64 reserved_5_7                     : 3;
+		u64 int_lvl                          : 5;
+		u64 reserved_13_15                   : 3;
+		u64 clr                              : 1;
+		u64 reserved_17_63                   : 47;
+	} s;
+	/* struct cavm_mio_emm_dma_fifo_cfg_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_DMA_FIFO_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_DMA_FIFO_CFG(void)
+{
+	return 0x160;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_fifo_cmd
+ *
+ * eMMC Internal DMA FIFO Command Register This register specifies a
+ * command that is loaded into the eMMC internal DMA FIFO.  The FIFO is
+ * used to queue up operations for the MIO_EMM_DMA_CFG/MIO_EMM_DMA_ADR
+ * when the DMA completes successfully. Writes to this register store
+ * both the MIO_EMM_DMA_FIFO_CMD and the MIO_EMM_DMA_FIFO_ADR contents
+ * into the FIFO and increment the MIO_EMM_DMA_FIFO_CFG[COUNT] field.
+ * Note: This register has a similar format to MIO_EMM_DMA_CFG with the
+ * exception that the EN and CLR fields are absent. These are supported
+ * in MIO_EMM_DMA_FIFO_CFG.
+ */
+union cavm_mio_emm_dma_fifo_cmd {
+	u64 u;
+	struct cavm_mio_emm_dma_fifo_cmd_s {
+		u64 reserved_0_35                    : 36;
+		u64 size                             : 20;
+		u64 endian                           : 1;
+		u64 swap8                            : 1;
+		u64 swap16                           : 1;
+		u64 swap32                           : 1;
+		u64 intdis                           : 1;
+		u64 reserved_61                      : 1;
+		u64 rw                               : 1;
+		u64 reserved_63                      : 1;
+	} s;
+	/* struct cavm_mio_emm_dma_fifo_cmd_s cn81xx; */
+	/* struct cavm_mio_emm_dma_fifo_cmd_s cn83xx; */
+	struct cavm_mio_emm_dma_fifo_cmd_cn88xxp1 {
+		u64 reserved_0_35                    : 36;
+		u64 size                             : 20;
+		u64 endian                           : 1;
+		u64 swap8                            : 1;
+		u64 swap16                           : 1;
+		u64 swap32                           : 1;
+		u64 reserved_60                      : 1;
+		u64 reserved_61                      : 1;
+		u64 rw                               : 1;
+		u64 reserved_63                      : 1;
+	} cn88xxp1;
+	/* struct cavm_mio_emm_dma_fifo_cmd_s cn88xxp2; */
+	/* struct cavm_mio_emm_dma_fifo_cmd_s cn9; */
+};
+
+static inline u64 CAVM_MIO_EMM_DMA_FIFO_CMD(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_DMA_FIFO_CMD(void)
+{
+	return 0x178;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_int
+ *
+ * eMMC DMA Interrupt Register Sixty-four-bit operations must be used to
+ * access this register.
+ */
+union cavm_mio_emm_dma_int {
+	u64 u;
+	struct cavm_mio_emm_dma_int_s {
+		u64 done                             : 1;
+		u64 fifo                             : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cavm_mio_emm_dma_int_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_DMA_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_DMA_INT(void)
+{
+	return 0x190;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_int_ena_w1c
+ *
+ * eMMC DMA Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union cavm_mio_emm_dma_int_ena_w1c {
+	u64 u;
+	struct cavm_mio_emm_dma_int_ena_w1c_s {
+		u64 done                             : 1;
+		u64 fifo                             : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cavm_mio_emm_dma_int_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_DMA_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_DMA_INT_ENA_W1C(void)
+{
+	return 0x1a8;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_int_ena_w1s
+ *
+ * eMMC DMA Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
+ */
+union cavm_mio_emm_dma_int_ena_w1s {
+	u64 u;
+	struct cavm_mio_emm_dma_int_ena_w1s_s {
+		u64 done                             : 1;
+		u64 fifo                             : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cavm_mio_emm_dma_int_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_DMA_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_DMA_INT_ENA_W1S(void)
+{
+	return 0x1a0;
+}
+
+/**
+ * Register (RSL) mio_emm_dma_int_w1s
+ *
+ * eMMC DMA Interrupt Set Register This register sets interrupt bits.
+ */
+union cavm_mio_emm_dma_int_w1s {
+	u64 u;
+	struct cavm_mio_emm_dma_int_w1s_s {
+		u64 done                             : 1;
+		u64 fifo                             : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cavm_mio_emm_dma_int_w1s_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_DMA_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_DMA_INT_W1S(void)
+{
+	return 0x198;
+}
+
+/**
+ * Register (RSL) mio_emm_int
+ *
+ * eMMC Interrupt Register
+ */
+union cavm_mio_emm_int {
+	u64 u;
+	struct cavm_mio_emm_int_s {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 ncb_flt                          : 1;
+		u64 ncb_ras                          : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	struct cavm_mio_emm_int_cn8 {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 reserved_7_63                    : 57;
+	} cn8;
+	/* struct cavm_mio_emm_int_s cn9; */
+};
+
+static inline u64 CAVM_MIO_EMM_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_INT(void)
+{
+	return 0x2078;
+}
+
+/**
+ * Register (RSL) mio_emm_int_ena_w1c
+ *
+ * eMMC Interrupt Enable Clear Register This register clears interrupt
+ * enable bits.
+ */
+union cavm_mio_emm_int_ena_w1c {
+	u64 u;
+	struct cavm_mio_emm_int_ena_w1c_s {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 ncb_flt                          : 1;
+		u64 ncb_ras                          : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	struct cavm_mio_emm_int_ena_w1c_cn8 {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 reserved_7_63                    : 57;
+	} cn8;
+	/* struct cavm_mio_emm_int_ena_w1c_s cn9; */
+};
+
+static inline u64 CAVM_MIO_EMM_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_INT_ENA_W1C(void)
+{
+	return 0x20b8;
+}
+
+/**
+ * Register (RSL) mio_emm_int_ena_w1s
+ *
+ * eMMC Interrupt Enable Set Register This register sets interrupt enable
+ * bits.
+ */
+union cavm_mio_emm_int_ena_w1s {
+	u64 u;
+	struct cavm_mio_emm_int_ena_w1s_s {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 ncb_flt                          : 1;
+		u64 ncb_ras                          : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	struct cavm_mio_emm_int_ena_w1s_cn8 {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 reserved_7_63                    : 57;
+	} cn8;
+	/* struct cavm_mio_emm_int_ena_w1s_s cn9; */
+};
+
+static inline u64 CAVM_MIO_EMM_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_INT_ENA_W1S(void)
+{
+	return 0x20b0;
+}
+
+/**
+ * Register (RSL) mio_emm_int_w1s
+ *
+ * eMMC Interrupt Set Register This register sets interrupt bits.
+ */
+union cavm_mio_emm_int_w1s {
+	u64 u;
+	struct cavm_mio_emm_int_w1s_s {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 ncb_flt                          : 1;
+		u64 ncb_ras                          : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	struct cavm_mio_emm_int_w1s_cn8 {
+		u64 buf_done                         : 1;
+		u64 cmd_done                         : 1;
+		u64 dma_done                         : 1;
+		u64 cmd_err                          : 1;
+		u64 dma_err                          : 1;
+		u64 switch_done                      : 1;
+		u64 switch_err                       : 1;
+		u64 reserved_7_63                    : 57;
+	} cn8;
+	/* struct cavm_mio_emm_int_w1s_s cn9; */
+};
+
+static inline u64 CAVM_MIO_EMM_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_INT_W1S(void)
+{
+	return 0x2080;
+}
+
+/**
+ * Register (RSL) mio_emm_io_ctl
+ *
+ * eMMC I/O Control Register
+ */
+union cavm_mio_emm_io_ctl {
+	u64 u;
+	struct cavm_mio_emm_io_ctl_s {
+		u64 slew                             : 1;
+		u64 reserved_1                       : 1;
+		u64 drive                            : 2;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cavm_mio_emm_io_ctl_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_IO_CTL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_IO_CTL(void)
+{
+	return 0x2040;
+}
+
+/**
+ * Register (RSL) mio_emm_mode#
+ *
+ * eMMC Operating Mode Register
+ */
+union cavm_mio_emm_modex {
+	u64 u;
+	struct cavm_mio_emm_modex_s {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 reserved_36_39                   : 4;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 hs200_timing                     : 1;
+		u64 hs400_timing                     : 1;
+		u64 reserved_51_63                   : 13;
+	} s;
+	struct cavm_mio_emm_modex_cn8 {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 reserved_36_39                   : 4;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 reserved_49_63                   : 15;
+	} cn8;
+	/* struct cavm_mio_emm_modex_s cn9; */
+};
+
+static inline u64 CAVM_MIO_EMM_MODEX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_MODEX(u64 a)
+{
+	return 0x2008 + 8 * a;
+}
+
+/**
+ * Register (RSL) mio_emm_msix_pba#
+ *
+ * eMMC MSI-X Pending Bit Array Registers This register is the MSI-X PBA
+ * table; the bit number is indexed by the MIO_EMM_INT_VEC_E enumeration.
+ */
+union cavm_mio_emm_msix_pbax {
+	u64 u;
+	struct cavm_mio_emm_msix_pbax_s {
+		u64 pend                             : 64;
+	} s;
+	/* struct cavm_mio_emm_msix_pbax_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_MSIX_PBAX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_MSIX_PBAX(u64 a)
+{
+	return 0xf0000 + 8 * a;
+}
+
+/**
+ * Register (RSL) mio_emm_msix_vec#_addr
+ *
+ * eMMC MSI-X Vector-Table Address Register This register is the MSI-X
+ * vector table, indexed by the MIO_EMM_INT_VEC_E enumeration.
+ */
+union cavm_mio_emm_msix_vecx_addr {
+	u64 u;
+	struct cavm_mio_emm_msix_vecx_addr_s {
+		u64 secvec                           : 1;
+		u64 reserved_1                       : 1;
+		u64 addr                             : 51;
+		u64 reserved_53_63                   : 11;
+	} s;
+	struct cavm_mio_emm_msix_vecx_addr_cn8 {
+		u64 secvec                           : 1;
+		u64 reserved_1                       : 1;
+		u64 addr                             : 47;
+		u64 reserved_49_63                   : 15;
+	} cn8;
+	/* struct cavm_mio_emm_msix_vecx_addr_s cn9; */
+};
+
+static inline u64 CAVM_MIO_EMM_MSIX_VECX_ADDR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_MSIX_VECX_ADDR(u64 a)
+{
+	return 0 + 0x10 * a;
+}
+
+/**
+ * Register (RSL) mio_emm_msix_vec#_ctl
+ *
+ * eMMC MSI-X Vector-Table Control and Data Register This register is the
+ * MSI-X vector table, indexed by the MIO_EMM_INT_VEC_E enumeration.
+ */
+union cavm_mio_emm_msix_vecx_ctl {
+	u64 u;
+	struct cavm_mio_emm_msix_vecx_ctl_s {
+		u64 data                             : 32;
+		u64 mask                             : 1;
+		u64 reserved_33_63                   : 31;
+	} s;
+	struct cavm_mio_emm_msix_vecx_ctl_cn8 {
+		u64 data                             : 20;
+		u64 reserved_20_31                   : 12;
+		u64 mask                             : 1;
+		u64 reserved_33_63                   : 31;
+	} cn8;
+	/* struct cavm_mio_emm_msix_vecx_ctl_s cn9; */
+};
+
+static inline u64 CAVM_MIO_EMM_MSIX_VECX_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_MSIX_VECX_CTL(u64 a)
+{
+	return 8 + 0x10 * a;
+}
+
+/**
+ * Register (RSL) mio_emm_rca
+ *
+ * eMMC Relative Card Address Register
+ */
+union cavm_mio_emm_rca {
+	u64 u;
+	struct cavm_mio_emm_rca_s {
+		u64 card_rca                         : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_mio_emm_rca_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_RCA(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_RCA(void)
+{
+	return 0x20a0;
+}
+
+/**
+ * Register (RSL) mio_emm_rsp_hi
+ *
+ * eMMC Response Data High Register
+ */
+union cavm_mio_emm_rsp_hi {
+	u64 u;
+	struct cavm_mio_emm_rsp_hi_s {
+		u64 dat                              : 64;
+	} s;
+	/* struct cavm_mio_emm_rsp_hi_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_RSP_HI(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_RSP_HI(void)
+{
+	return 0x2070;
+}
+
+/**
+ * Register (RSL) mio_emm_rsp_lo
+ *
+ * eMMC Response Data Low Register
+ */
+union cavm_mio_emm_rsp_lo {
+	u64 u;
+	struct cavm_mio_emm_rsp_lo_s {
+		u64 dat                              : 64;
+	} s;
+	/* struct cavm_mio_emm_rsp_lo_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_RSP_LO(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_RSP_LO(void)
+{
+	return 0x2068;
+}
+
+/**
+ * Register (RSL) mio_emm_rsp_sts
+ *
+ * eMMC Response Status Register
+ */
+union cavm_mio_emm_rsp_sts {
+	u64 u;
+	struct cavm_mio_emm_rsp_sts_s {
+		u64 cmd_done                         : 1;
+		u64 cmd_idx                          : 6;
+		u64 cmd_type                         : 2;
+		u64 rsp_type                         : 3;
+		u64 rsp_val                          : 1;
+		u64 rsp_bad_sts                      : 1;
+		u64 rsp_crc_err                      : 1;
+		u64 rsp_timeout                      : 1;
+		u64 stp_val                          : 1;
+		u64 stp_bad_sts                      : 1;
+		u64 stp_crc_err                      : 1;
+		u64 stp_timeout                      : 1;
+		u64 rsp_busybit                      : 1;
+		u64 blk_crc_err                      : 1;
+		u64 blk_timeout                      : 1;
+		u64 dbuf                             : 1;
+		u64 reserved_24_27                   : 4;
+		u64 dbuf_err                         : 1;
+		u64 reserved_29_54                   : 26;
+		u64 acc_timeout                      : 1;
+		u64 dma_pend                         : 1;
+		u64 dma_val                          : 1;
+		u64 switch_val                       : 1;
+		u64 cmd_val                          : 1;
+		u64 bus_id                           : 2;
+		u64 reserved_62_63                   : 2;
+	} s;
+	/* struct cavm_mio_emm_rsp_sts_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_RSP_STS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_RSP_STS(void)
+{
+	return 0x2060;
+}
+
+/**
+ * Register (RSL) mio_emm_sample
+ *
+ * eMMC Sampling Register
+ */
+union cavm_mio_emm_sample {
+	u64 u;
+	struct cavm_mio_emm_sample_s {
+		u64 dat_cnt                          : 10;
+		u64 reserved_10_15                   : 6;
+		u64 cmd_cnt                          : 10;
+		u64 reserved_26_63                   : 38;
+	} s;
+	/* struct cavm_mio_emm_sample_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_SAMPLE(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_SAMPLE(void)
+{
+	return 0x2090;
+}
+
+/**
+ * Register (RSL) mio_emm_sts_mask
+ *
+ * eMMC Status Mask Register
+ */
+union cavm_mio_emm_sts_mask {
+	u64 u;
+	struct cavm_mio_emm_sts_mask_s {
+		u64 sts_msk                          : 32;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cavm_mio_emm_sts_mask_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_STS_MASK(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_STS_MASK(void)
+{
+	return 0x2098;
+}
+
+/**
+ * Register (RSL) mio_emm_switch
+ *
+ * eMMC Operating Mode Switch Register This register allows software to
+ * change eMMC related parameters associated with a specific BUS_ID.  The
+ * MIO_EMM_MODE() registers contain the current setting for each BUS.
+ * This register is also used to switch the [CLK_HI] and [CLK_LO]
+ * settings associated with the common EMMC_CLK.  These settings can only
+ * be changed when [BUS_ID] = 0.
+ */
+union cavm_mio_emm_switch {
+	u64 u;
+	struct cavm_mio_emm_switch_s {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 reserved_36_39                   : 4;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 hs200_timing                     : 1;
+		u64 hs400_timing                     : 1;
+		u64 reserved_51_55                   : 5;
+		u64 switch_err2                      : 1;
+		u64 switch_err1                      : 1;
+		u64 switch_err0                      : 1;
+		u64 switch_exe                       : 1;
+		u64 bus_id                           : 2;
+		u64 reserved_62_63                   : 2;
+	} s;
+	struct cavm_mio_emm_switch_cn8 {
+		u64 clk_lo                           : 16;
+		u64 clk_hi                           : 16;
+		u64 power_class                      : 4;
+		u64 reserved_36_39                   : 4;
+		u64 bus_width                        : 3;
+		u64 reserved_43_47                   : 5;
+		u64 hs_timing                        : 1;
+		u64 reserved_49_55                   : 7;
+		u64 switch_err2                      : 1;
+		u64 switch_err1                      : 1;
+		u64 switch_err0                      : 1;
+		u64 switch_exe                       : 1;
+		u64 bus_id                           : 2;
+		u64 reserved_62_63                   : 2;
+	} cn8;
+	/* struct cavm_mio_emm_switch_s cn9; */
+};
+
+static inline u64 CAVM_MIO_EMM_SWITCH(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_SWITCH(void)
+{
+	return 0x2048;
+}
+
+/**
+ * Register (RSL) mio_emm_tap
+ *
+ * eMMC TAP Delay Register This register indicates the delay line
+ * characteristics.
+ */
+union cavm_mio_emm_tap {
+	u64 u;
+	struct cavm_mio_emm_tap_s {
+		u64 delay                            : 8;
+		u64 reserved_8_63                    : 56;
+	} s;
+	/* struct cavm_mio_emm_tap_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_TAP(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_TAP(void)
+{
+	return 0x20c8;
+}
+
+/**
+ * Register (RSL) mio_emm_timing
+ *
+ * eMMC Timing Register This register determines the number of tap delays
+ * the EMM_DAT, EMM_DS, and EMM_CMD lines are transmitted or received in
+ * relation to EMM_CLK. These values should only be changed when the eMMC
+ * bus is idle.
+ */
+union cavm_mio_emm_timing {
+	u64 u;
+	struct cavm_mio_emm_timing_s {
+		u64 data_out_tap                     : 6;
+		u64 reserved_6_15                    : 10;
+		u64 data_in_tap                      : 6;
+		u64 reserved_22_31                   : 10;
+		u64 cmd_out_tap                      : 6;
+		u64 reserved_38_47                   : 10;
+		u64 cmd_in_tap                       : 6;
+		u64 reserved_54_63                   : 10;
+	} s;
+	/* struct cavm_mio_emm_timing_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_TIMING(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_TIMING(void)
+{
+	return 0x20d0;
+}
+
+/**
+ * Register (RSL) mio_emm_wdog
+ *
+ * eMMC Watchdog Register
+ */
+union cavm_mio_emm_wdog {
+	u64 u;
+	struct cavm_mio_emm_wdog_s {
+		u64 clk_cnt                          : 26;
+		u64 reserved_26_63                   : 38;
+	} s;
+	/* struct cavm_mio_emm_wdog_s cn; */
+};
+
+static inline u64 CAVM_MIO_EMM_WDOG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_MIO_EMM_WDOG(void)
+{
+	return 0x2088;
+}
+
+#endif /* __CAVM_CSRS_MIO_EMM_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx/clock.h b/arch/arm/include/asm/arch-octeontx/clock.h
new file mode 100644
index 0000000..3b7214d
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx/clock.h
@@ -0,0 +1,230 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#ifndef __OCTEONTX_CLOCK_H__
+
+/** System PLL reference clock */
+#define PLL_REF_CLK                     50000000        /* 50 MHz */
+#define NS_PER_REF_CLK_TICK             (1000000000/PLL_REF_CLK)
+
+/** Address of RST_BOOT register */
+#define RST_BOOT	0x87e006001600ll
+
+/**
+ * Register (RSL) rst_boot
+ *
+ * RST Boot Register
+ */
+union cavm_rst_boot {
+	u64 u;
+	struct cavm_rst_boot_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		u64 chipkill:1;
+		u64 jtcsrdis:1;
+		u64 ejtagdis:1;
+		u64 trusted_mode:1;
+		u64 ckill_ppdis:1;
+		u64 jt_tstmode:1;
+		u64 vrm_err:1;
+		u64 dis_huk:1;
+		u64 dis_scan:1;
+		u64 reserved_47_54:8;
+		u64 c_mul:7;
+		u64 reserved_39:1;
+		u64 pnr_mul:6;
+		u64 lboot_oci:3;
+		u64 lboot_pf_flr:4;
+		u64 lboot_ckill:1;
+		u64 lboot_jtg:1;
+		u64 lboot_ext45:6;
+		u64 lboot_ext23:6;
+		u64 lboot:10;
+		u64 rboot:1;
+		u64 rboot_pin:1;
+#else /* Word 0 - Little Endian */
+		u64 rboot_pin:1;
+		u64 rboot:1;
+		u64 lboot:10;
+		u64 lboot_ext23:6;
+		u64 lboot_ext45:6;
+		u64 lboot_jtg:1;
+		u64 lboot_ckill:1;
+		u64 lboot_pf_flr:4;
+		u64 lboot_oci:3;
+		u64 pnr_mul:6;
+		u64 reserved_39:1;
+		u64 c_mul:7;
+		u64 reserved_47_54:8;
+		u64 dis_scan:1;
+		u64 dis_huk:1;
+		u64 vrm_err:1;
+		u64 jt_tstmode:1;
+		u64 ckill_ppdis:1;
+		u64 trusted_mode:1;
+		u64 ejtagdis:1;
+		u64 jtcsrdis:1;
+		u64 chipkill:1;
+#endif /* Word 0 - End */
+	} s;
+	struct cavm_rst_boot_cn81xx {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		u64 chipkill:1;
+		u64 jtcsrdis:1;
+		u64 ejtagdis:1;
+		u64 trusted_mode:1;
+		u64 ckill_ppdis:1;
+		u64 jt_tstmode:1;
+		u64 vrm_err:1;
+		u64 dis_huk:1;
+		u64 dis_scan:1;
+		u64 reserved_47_54:8;
+		u64 c_mul:7;
+		u64 reserved_39:1;
+		u64 pnr_mul:6;
+		u64 lboot_oci:3;
+		u64 reserved_26_29:4;
+		u64 lboot_ckill:1;
+		u64 lboot_jtg:1;
+		u64 lboot_ext45:6;
+		u64 lboot_ext23:6;
+		u64 lboot:10;
+		u64 rboot:1;
+		u64 rboot_pin:1;
+#else /* Word 0 - Little Endian */
+		u64 rboot_pin:1;
+		u64 rboot:1;
+		u64 lboot:10;
+		u64 lboot_ext23:6;
+		u64 lboot_ext45:6;
+		u64 lboot_jtg:1;
+		u64 lboot_ckill:1;
+		u64 reserved_26_29:4;
+		u64 lboot_oci:3;
+		u64 pnr_mul:6;
+		u64 reserved_39:1;
+		u64 c_mul:7;
+		u64 reserved_47_54:8;
+		u64 dis_scan:1;
+		u64 dis_huk:1;
+		u64 vrm_err:1;
+		u64 jt_tstmode:1;
+		u64 ckill_ppdis:1;
+		u64 trusted_mode:1;
+		u64 ejtagdis:1;
+		u64 jtcsrdis:1;
+		u64 chipkill:1;
+#endif /* Word 0 - End */
+	} cn81xx;
+	struct cavm_rst_boot_cn88xx {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		u64 chipkill:1;
+		u64 jtcsrdis:1;
+		u64 ejtagdis:1;
+		u64 trusted_mode:1;
+		u64 ckill_ppdis:1;
+		u64 jt_tstmode:1;
+		u64 vrm_err:1;
+		u64 dis_huk:1;
+		u64 dis_scan:1;
+		u64 reserved_47_54:8;
+		u64 c_mul:7;
+		u64 reserved_39:1;
+		u64 pnr_mul:6;
+		u64 lboot_oci:3;
+		u64 reserved_26_29:4;
+		u64 reserved_24_25:2;
+		u64 lboot_ext45:6;
+		u64 lboot_ext23:6;
+		u64 lboot:10;
+		u64 rboot:1;
+		u64 rboot_pin:1;
+#else /* Word 0 - Little Endian */
+		u64 rboot_pin:1;
+		u64 rboot:1;
+		u64 lboot:10;
+		u64 lboot_ext23:6;
+		u64 lboot_ext45:6;
+		u64 reserved_24_25:2;
+		u64 reserved_26_29:4;
+		u64 lboot_oci:3;
+		u64 pnr_mul:6;
+		u64 reserved_39:1;
+		u64 c_mul:7;
+		u64 reserved_47_54:8;
+		u64 dis_scan:1;
+		u64 dis_huk:1;
+		u64 vrm_err:1;
+		u64 jt_tstmode:1;
+		u64 ckill_ppdis:1;
+		u64 trusted_mode:1;
+		u64 ejtagdis:1;
+		u64 jtcsrdis:1;
+		u64 chipkill:1;
+#endif /* Word 0 - End */
+	} cn88xx;
+	struct cavm_rst_boot_cn83xx {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		u64 chipkill:1;
+		u64 jtcsrdis:1;
+		u64 ejtagdis:1;
+		u64 trusted_mode:1;
+		u64 ckill_ppdis:1;
+		u64 jt_tstmode:1;
+		u64 vrm_err:1;
+		u64 dis_huk:1;
+		u64 dis_scan:1;
+		u64 reserved_47_54:8;
+		u64 c_mul:7;
+		u64 reserved_39:1;
+		u64 pnr_mul:6;
+		u64 lboot_oci:3;
+		u64 lboot_pf_flr:4;
+		u64 lboot_ckill:1;
+		u64 lboot_jtg:1;
+		u64 lboot_ext45:6;
+		u64 lboot_ext23:6;
+		u64 lboot:10;
+		u64 rboot:1;
+		u64 rboot_pin:1;
+#else /* Word 0 - Little Endian */
+		u64 rboot_pin:1;
+		u64 rboot:1;
+		u64 lboot:10;
+		u64 lboot_ext23:6;
+		u64 lboot_ext45:6;
+		u64 lboot_jtg:1;
+		u64 lboot_ckill:1;
+		u64 lboot_pf_flr:4;
+		u64 lboot_oci:3;
+		u64 pnr_mul:6;
+		u64 reserved_39:1;
+		u64 c_mul:7;
+		u64 reserved_47_54:8;
+		u64 dis_scan:1;
+		u64 dis_huk:1;
+		u64 vrm_err:1;
+		u64 jt_tstmode:1;
+		u64 ckill_ppdis:1;
+		u64 trusted_mode:1;
+		u64 ejtagdis:1;
+		u64 jtcsrdis:1;
+		u64 chipkill:1;
+#endif /* Word 0 - End */
+	} cn83xx;
+};
+
+/**
+ * Returns the I/O clock speed in Hz
+ */
+u64 octeontx_get_io_clock(void);
+
+/**
+ * Returns the core clock speed in Hz
+ */
+u64 octeontx_get_core_clock(void);
+
+#endif /* __OCTEONTX_CLOCK_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx/fdt-helper.h b/arch/arm/include/asm/arch-octeontx/fdt-helper.h
new file mode 100644
index 0000000..55ec06f
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx/fdt-helper.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#ifndef __FDT_HELPER_H__
+#define __FDT_HELPER_H__
+
+/**
+ * Given a FDT node, check if it is compatible with a list of devices
+ *
+ * @param[in]	fdt		Flat device tree pointer
+ * @param	node_offset	Node offset in device tree
+ * @param[in]	strlist		Array of FDT devices to check, end must be NULL
+ *
+ * @return	0 if at least one device is compatible, 1 if not compatible.
+ */
+int cavium_fdt_node_check_compatible(const void *fdt, int node_offset,
+				     const char * const *strlist);
+
+/**
+ * Given a FDT node, return the next compatible node.
+ *
+ * @param[in]	fdt_addr	Pointer to flat device tree
+ * @param	start_offset	Starting node offset or -1 to find the first
+ * @param	strlist		Array of FDT device compatibility strings, must
+ *				end with NULL or empty string.
+ *
+ * @return	next matching node or -1 if no more matches.
+ */
+int cavium_fdt_node_offset_by_compatible_list(const void *fdt_addr,
+					      int startoffset,
+					      const char * const *strlist);
+
+#endif /* __FDT_HELPER_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx/octeontx.h b/arch/arm/include/asm/arch-octeontx/octeontx.h
new file mode 100644
index 0000000..93eaa14
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx/octeontx.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#ifndef __OCTEONTX_H__
+#define __OCTEONTX_H__
+
+#define CN81XX	0xA2
+#define CN83XX	0xA3
+#define is_board_model(model)  (g_cavm_bdt.prod_id == (model))
+
+#define MAX_LMAC_PER_BGX 4
+
+/** Reg offsets */
+#define CAVM_MIO_FUS_DAT2	0x87E003001410ULL
+
+#define CAVM_GTI_CWD_POKEX	0x844000050000ULL
+#define CAVM_GTI_CWD_WDOGX	0x844000040000ULL
+
+/** Structure definitions */
+
+/** Function definitions */
+void octeontx_parse_board_info(void);
+int octeontx_board_has_pmp(void);
+void octeontx_parse_phy_info(void);
+void octeontx_board_get_ethaddr(int bgx, int lmac, unsigned char *eth);
+
+/** Board data definitions */
+struct cavm_bdt {
+	u8 resv[6];
+	u8 prod_id;
+	u8 alt_pkg;
+	char type[16];
+};
+extern struct cavm_bdt g_cavm_bdt;
+
+#endif
diff --git a/arch/arm/include/asm/arch-octeontx/octeontx_fdt.h b/arch/arm/include/asm/arch-octeontx/octeontx_fdt.h
new file mode 100644
index 0000000..5c7d567
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx/octeontx_fdt.h
@@ -0,0 +1,12 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#ifndef __OCTEONTX_FDT_H__
+#define __OCTEONTX_FDT_H__
+
+
+#endif
diff --git a/arch/arm/include/asm/arch-octeontx/octeontx_mmc.h b/arch/arm/include/asm/arch-octeontx/octeontx_mmc.h
new file mode 100644
index 0000000..5d434a3
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx/octeontx_mmc.h
@@ -0,0 +1,211 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#ifndef __OCTEONTX_MMC_H__
+#define __OCTEONTX_MMC_H__
+
+#include <mmc.h>
+#include <dm/device.h>
+
+/* NOTE: this file is used by both Octeon and OcteonTX */
+
+/*
+ * Card Command Classes (CCC)
+ */
+#define CCC_BASIC		BIT(0)	/* (0) Basic protocol functions */
+					/* (CMD0,1,2,3,4,7,9,10,12,13,15) */
+					/* (and for SPI, CMD58,59) */
+#define CCC_STREAM_READ		BIT(1)	/* (1) Stream read commands */
+					/* (CMD11) */
+#define CCC_BLOCK_READ		BIT(2)	/* (2) Block read commands */
+					/* (CMD16,17,18) */
+#define CCC_STREAM_WRITE	BIT(3)	/* (3) Stream write commands */
+					/* (CMD20) */
+#define CCC_BLOCK_WRITE		BIT(4)	/* (4) Block write commands */
+					/* (CMD16,24,25,26,27) */
+#define CCC_ERASE		BIT(5)	/* (5) Ability to erase blocks */
+					/* (CMD32,33,34,35,36,37,38,39) */
+#define CCC_WRITE_PROT		BIT(6)	/* (6) Able to write protect blocks */
+					/* (CMD28,29,30) */
+#define CCC_LOCK_CARD		BIT(7)	/* (7) Able to lock down card */
+					/* (CMD16,CMD42) */
+#define CCC_APP_SPEC		BIT(8)	/* (8) Application specific */
+					/* (CMD55,56,57,ACMD*) */
+#define CCC_IO_MODE		BIT(9)	/* (9) I/O mode */
+					/* (CMD5,39,40,52,53) */
+#define CCC_SWITCH		BIT(10)	/* (10) High speed switch */
+					/* (CMD6,34,35,36,37,50) */
+					/* (11) Reserved */
+					/* (CMD?) */
+
+/*
+ * NOTE: This was copied from the Linux kernel.
+ *
+ * MMC status in R1, for native mode (SPI bits are different)
+ * Type
+ *	e:error bit
+ *	s:status bit
+ *	r:detected and set for the actual command response
+ *	x:detected and set during command execution. the host must poll
+ *	    the card by sending status command in order to read these bits.
+ * Clear condition
+ *	a:according to the card state
+ *	b:always related to the previous command. Reception of
+ *	    a valid command will clear it (with a delay of one command)
+ *	c:clear by read
+ */
+#define R1_OUT_OF_RANGE		BIT(31)		/* er, c */
+#define R1_ADDRESS_ERROR	BIT(30)		/* erx, c */
+#define R1_BLOCK_LEN_ERROR	BIT(29)		/* er, c */
+#define R1_ERASE_SEQ_ERROR	BIT(28)		/* er, c */
+#define R1_ERASE_PARAM          BIT(27)		/* ex, c */
+#define R1_WP_VIOLATION		BIT(26)		/* erx, c */
+#define R1_CARD_IS_LOCKED	BIT(25)		/* sx, a */
+#define R1_LOCK_UNLOCK_FAILED	BIT(24)		/* erx, c */
+#define R1_COM_CRC_ERROR	BIT(23)		/* er, b */
+/*#define R1_ILLEGAL_COMMAND	BIT(22)*/		/* er, b */
+#define R1_CARD_ECC_FAILED	BIT(21)		/* ex, c */
+#define R1_CC_ERROR		BIT(20)		/* erx, c */
+#define R1_ERROR		BIT(19)		/* erx, c */
+#define R1_UNDERRUN		BIT(18)		/* ex, c */
+#define R1_OVERRUN		BIT(17)		/* ex, c */
+#define R1_CID_CSD_OVERWRITE	BIT(16)		/* erx, c, CID/CSD overwrite */
+#define R1_WP_ERASE_SKIP	BIT(15)		/* sx, c */
+#define R1_CARD_ECC_DISABLED	BIT(14)		/* sx, a */
+#define R1_ERASE_RESET		BIT(13)		/* sr, c */
+#define R1_STATUS(x)		(x & 0xFFFFE000)
+#define R1_CURRENT_STATE(x)	((x & 0x00001E00) >> 9) /* sx, b (4 bits) */
+#define R1_READY_FOR_DATA	BIT(8)		/* sx, a */
+#define R1_SWITCH_ERROR		BIT(7)		/* sx, c */
+/*#define R1_APP_CMD		BIT(5)*/		/* sr, c */
+
+#define R1_BLOCK_READ_MASK	R1_OUT_OF_RANGE |	\
+				R1_ADDRESS_ERROR |	\
+				R1_BLOCK_LEN_ERROR |	\
+				R1_CARD_IS_LOCKED |	\
+				R1_COM_CRC_ERROR |	\
+				R1_ILLEGAL_COMMAND |	\
+				R1_CARD_ECC_FAILED |	\
+				R1_CC_ERROR |		\
+				R1_ERROR
+#define R1_BLOCK_WRITE_MASK	R1_OUT_OF_RANGE |	\
+				R1_ADDRESS_ERROR |	\
+				R1_BLOCK_LEN_ERROR |	\
+				R1_WP_VIOLATION |	\
+				R1_CARD_IS_LOCKED |	\
+				R1_COM_CRC_ERROR |	\
+				R1_ILLEGAL_COMMAND |	\
+				R1_CARD_ECC_FAILED |	\
+				R1_CC_ERROR |		\
+				R1_ERROR |		\
+				R1_UNDERRUN |		\
+				R1_OVERRUN
+
+/**
+ * Flag indicates that CMD23 is supported.  This is required for multi-block
+ * hardware transfers to work.
+ */
+#define OCTEON_MMC_FLAG_SD_CMD23	1
+
+#ifdef __mips
+# define OCTEON_EMM_BASE_ADDR		0x0x1180000000000
+#endif
+
+/** Maximum supported MMC slots */
+#define OCTEONTX_MAX_MMC_SLOT		3
+
+#define OCTEONTX_MMC_NAME_LEN		32
+
+struct mmc;
+struct mmc_config;
+struct octeontx_mmc_host;
+struct octeontx_mmc_slot;
+struct gpio_desc;
+
+struct octeontx_mmc_slot {
+	char		name[OCTEONTX_MMC_NAME_LEN];	/** Name of device */
+	u8		ext_csd[512];	/** Extended CSD register */
+	struct mmc	*mmc;		/** Ptr back to mmc structure */
+	struct octeontx_mmc_host *host;	/** Host controller data structure */
+#if defined(CONFIG_ARCH_OCTEONTX2)
+	u64		timing_tapps;	/** picoseconds per tap delay */
+#endif
+	struct mmc_config cfg;		/** Slot configuration */
+	struct gpio_desc power_gpio;	/** Power/reset GPIO line (usually 8) */
+	struct gpio_desc cd_gpio;	/** Card detect GPIO */
+	struct gpio_desc wp_gpio;	/** Write-protect GPIO */
+	int		power_delay;	/** Time in usec to wait for power */
+	int		bus_id;		/** BUS ID of device */
+	int		of_offset;	/** Device tree node */
+	int		clk_period;	/** Clock period */
+	int		bus_max_width;	/** Bus width 1, 4 or 8 */
+	int		power_class;	/** Power class for device */
+	int		flags;
+	int		cmd_clk_skew;	/** Clock skew for cmd in SCLK */
+	int		dat_clk_skew;	/** Clock skew for data in SCLK */
+	int		power_gpio_of_offset;	/** Offset of power node */
+	/**
+	 * Register bus-width value where:
+	 * 0: 1-bit
+	 * 1: 4-bit
+	 * 2: 8-bit
+	 * 5: 4-bit DDR
+	 * 6: 8-bit DDR
+	 * All other values are reserved.
+	 */
+	u8		bus_width;
+	bool		non_removable:1;/** True if device is not removable */
+	/** True if have extended CSD register */
+	bool		have_ext_csd:1;
+	bool		sector_mode:1;	/** Sector or byte mode */
+	bool		powered:1;	/** True if powered on */
+	/** True if power GPIO is active high */
+	bool		power_active_high:1;
+	bool		ro_inverted:1;	/** True if write-protect is inverted */
+	bool		cd_inverted:1;	/** True if card-detect is inverted */
+	bool		disable_ddr:1;	/** True to disable DDR */
+#if defined(CONFIG_ARCH_OCTEONTX2)
+	bool		is_asim:1;	/** True if we're running in ASIM */
+#endif
+};
+
+struct octeontx_mmc_host {
+	void		*base_addr;	/** Base address of device */
+	pci_dev_t	pdev;		/** PCI device */
+	u64		sclock;		/** SCLK in hz */
+	int		of_offset;	/** Device tree node */
+	int		cur_slotid;	/** Current slot to use */
+	int		last_slotid;	/** last slot in use */
+	int		max_width;	/** Maximum width hardware supports */
+#ifdef __mips
+	int		node;		/** OCX node for Octeon (MIPS) */
+	bool		use_ndf;	/** Use MIO_NDF_DMA or MIO_EMM_DMA. */
+#endif
+	bool		initialized;	/** True if initialized */
+	struct udevice  *dev;		/** Device host is associated with */
+	/** Slots associated with host controller */
+	struct octeontx_mmc_slot slots[OCTEONTX_MAX_MMC_SLOT];
+};
+
+/**
+ * Returns the card write protect status
+ *
+ * @param mmc	pointer to mmc data structure
+ * @return 1 if card is write protected, 0 otherwise
+ */
+int octeontx_mmc_getwp(struct udevice *dev);
+
+/**
+ * Gets the card-detect status
+ *
+ * @param mmc	pointer to mmc data structure
+ *
+ * @return	1 if card is detected, false if not detected.
+ */
+int octeontx_mmc_getcd(struct udevice *dev);
+
+#endif /* __OCTEONTX_MMC_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx/octeontx_smi.h b/arch/arm/include/asm/arch-octeontx/octeontx_smi.h
new file mode 100644
index 0000000..a721011
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx/octeontx_smi.h
@@ -0,0 +1,14 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#ifndef OCTEONTX_SMI_H_
+#define OCTEONTX_SMI_H_
+
+int octeontx_smi_initialize(bd_t *bis, unsigned int index);
+
+#endif /* OCTEONTX_SMI_H_ */
diff --git a/arch/arm/include/asm/arch-octeontx/octeontx_svc.h b/arch/arm/include/asm/arch-octeontx/octeontx_svc.h
new file mode 100644
index 0000000..5827b63
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx/octeontx_svc.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#ifndef __OCTEONTX_SVC_H__
+#define __OCTEONTX_SVC_H__
+
+/* SMC function IDs for general purpose queries */
+
+#define OCTEONTX_SVC_CALL_COUNT		0xc200ff00
+#define OCTEONTX_SVC_UID		0xc200ff01
+
+#define OCTEONTX_SVC_VERSION		0xc200ff03
+
+/* OcteonTX Service Calls version numbers */
+#define OCTEONTX_VERSION_MAJOR	0x1
+#define OCTEONTX_VERSION_MINOR	0x0
+
+/* x1 - node number
+ */
+#define OCTEONTX_DRAM_SIZE		0xc2000301
+#define OCTEONTX_NODE_COUNT		0xc2000601
+
+#endif /* __OCTEONTX_SVC_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx/octeontx_vnic.h b/arch/arm/include/asm/arch-octeontx/octeontx_vnic.h
new file mode 100644
index 0000000..898765a
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx/octeontx_vnic.h
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#ifndef VNIC_H_
+#define VNIC_H_
+
+struct nicpf;
+struct nicvf;
+
+int octeontx_bgx_initialize(unsigned int bgx_idx, unsigned int node);
+void bgx_get_count(int node, int *bgx_count);
+int bgx_get_lmac_count(int node, int bgx_idx);
+void bgx_set_board_info(int bgx_id, int *mdio_bus,
+			int *phy_addr, bool *autoneg_dis,
+			bool *lmac_reg, bool *lmac_enable);
+
+#endif /* VNIC_H_ */
diff --git a/arch/arm/include/asm/arch-octeontx/octeontx_xcv.h b/arch/arm/include/asm/arch-octeontx/octeontx_xcv.h
new file mode 100644
index 0000000..d8a61a0
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx/octeontx_xcv.h
@@ -0,0 +1,256 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#ifndef OCTEONTX_XCV_H_
+#define OCTEONTX_XCV_H_
+
+#define CAVM_XCVX_RESET		0x87E0DB000000ULL
+#define CAVM_XCVX_DLL_CTL	0x87E0DB000010ULL
+#define CAVM_XCVX_CTL		0x87E0DB000030ULL
+#define CAVM_XCVX_BATCH_CRD_RET	0x87E0DB000100ULL
+
+/**
+ * Register (RSL) xcv#_dll_ctl
+ *
+ * XCV DLL Controller Register
+ * The RGMII timing specification requires that devices transmit clock and
+ * data synchronously. The specification requires external sources (namely
+ * the PC board trace routes) to introduce the appropriate 1.5 to 2.0 ns of
+ * delay.
+ *
+ * To eliminate the need for the PC board delays, the RGMII interface has optional
+ * on-board DLLs for both transmit and receive. For correct operation, at most one
+ * of the transmitter, board, or receiver involved in an RGMII link should
+ * introduce delay. By default/reset, the RGMII receivers delay the received clock,
+ * and the RGMII transmitters do not delay the transmitted clock. Whether this
+ * default works as-is with a given link partner depends on the behavior of the
+ * link partner and the PC board.
+ *
+ * These are the possible modes of RGMII receive operation:
+ *
+ * * XCV()_DLL_CTL[CLKRX_BYP] = 0 (reset value) - The RGMII
+ * receive interface introduces clock delay using its internal DLL.
+ * This mode is appropriate if neither the remote
+ * transmitter nor the PC board delays the clock.
+ *
+ * * XCV()_DLL_CTL[CLKRX_BYP] = 1, [CLKRX_SET] = 0x0 - The
+ * RGMII receive interface introduces no clock delay. This mode
+ * is appropriate if either the remote transmitter or the PC board
+ * delays the clock.
+ *
+ * These are the possible modes of RGMII transmit operation:
+ *
+ * * XCV()_DLL_CTL[CLKTX_BYP] = 1, [CLKTX_SET] = 0x0 (reset value) -
+ * The RGMII transmit interface introduces no clock
+ * delay. This mode is appropriate is either the remote receiver
+ * or the PC board delays the clock.
+ *
+ * * XCV()_DLL_CTL[CLKTX_BYP] = 0 - The RGMII transmit
+ * interface introduces clock delay using its internal DLL.
+ * This mode is appropriate if neither the remote receiver
+ * nor the PC board delays the clock.
+ */
+union cavm_xcvx_dll_ctl
+{
+    uint64_t u;
+    struct cavm_xcvx_dll_ctl_s
+    {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+        uint64_t reserved_32_63        : 32;
+        uint64_t lock                  : 1;  /**< [ 31: 31](RO/H) DLL is locked. */
+        uint64_t clk_set               : 7;  /**< [ 30: 24](RO/H) The clock delay as determined by the on-board hardware DLL. */
+        uint64_t clkrx_byp             : 1;  /**< [ 23: 23](R/W) Bypass the RX clock delay setting.
+                                                                 Skews RXC from RXD, RXCTL.
+                                                                 By default, hardware internally shifts the RXC clock
+                                                                 to sample RXD,RXCTL assuming clock and data and
+                                                                 sourced synchronously from the link partner. */
+        uint64_t clkrx_set             : 7;  /**< [ 22: 16](R/W) RX clock delay setting to use in bypass mode.
+                                                                 Skews RXC from RXD. */
+        uint64_t clktx_byp             : 1;  /**< [ 15: 15](R/W) Bypass the TX clock delay setting.
+                                                                 Skews TXC from TXD, TXCTL.
+                                                                 By default, clock and data and sourced
+                                                                 synchronously. */
+        uint64_t clktx_set             : 7;  /**< [ 14:  8](R/W) TX clock delay setting to use in bypass mode.
+                                                                 Skews TXC from TXD. */
+        uint64_t reserved_2_7          : 6;
+        uint64_t refclk_sel            : 2;  /**< [  1:  0](R/W) Select the reference clock to use.  Normal RGMII specification requires a 125MHz
+                                                                 oscillator.
+                                                                 To reduce system cost, a 500MHz coprocessor clock can be divided down and remove the
+                                                                 requirements for the external oscillator. Additionally, in some well defined systems, the
+                                                                 link partner may be able to source the RXC. The RGMII would operate correctly in 1000Mbs
+                                                                 mode only.
+                                                                 0x0 = RGMII REFCLK.
+                                                                 0x1 = RGMII RXC (1000Mbs only).
+                                                                 0x2 = Divided coprocessor clock.
+                                                                 0x3 = Reserved.
+
+                                                                 Internal:
+                                                                 Some programming magic could allow for 10/100 operation if
+                                                                 critical, use encoding 0x1 but some programming restrictions would apply. */
+#else /* Word 0 - Little Endian */
+        uint64_t refclk_sel            : 2;  /**< [  1:  0](R/W) Select the reference clock to use.  Normal RGMII specification requires a 125MHz
+                                                                 oscillator.
+                                                                 To reduce system cost, a 500MHz coprocessor clock can be divided down and remove the
+                                                                 requirements for the external oscillator. Additionally, in some well defined systems, the
+                                                                 link partner may be able to source the RXC. The RGMII would operate correctly in 1000Mbs
+                                                                 mode only.
+                                                                 0x0 = RGMII REFCLK.
+                                                                 0x1 = RGMII RXC (1000Mbs only).
+                                                                 0x2 = Divided coprocessor clock.
+                                                                 0x3 = Reserved.
+
+                                                                 Internal:
+                                                                 Some programming magic could allow for 10/100 operation if
+                                                                 critical, use encoding 0x1 but some programming restrictions would apply. */
+        uint64_t reserved_2_7          : 6;
+        uint64_t clktx_set             : 7;  /**< [ 14:  8](R/W) TX clock delay setting to use in bypass mode.
+                                                                 Skews TXC from TXD. */
+        uint64_t clktx_byp             : 1;  /**< [ 15: 15](R/W) Bypass the TX clock delay setting.
+                                                                 Skews TXC from TXD, TXCTL.
+                                                                 By default, clock and data and sourced
+                                                                 synchronously. */
+        uint64_t clkrx_set             : 7;  /**< [ 22: 16](R/W) RX clock delay setting to use in bypass mode.
+                                                                 Skews RXC from RXD. */
+        uint64_t clkrx_byp             : 1;  /**< [ 23: 23](R/W) Bypass the RX clock delay setting.
+                                                                 Skews RXC from RXD, RXCTL.
+                                                                 By default, hardware internally shifts the RXC clock
+                                                                 to sample RXD,RXCTL assuming clock and data and
+                                                                 sourced synchronously from the link partner. */
+        uint64_t clk_set               : 7;  /**< [ 30: 24](RO/H) The clock delay as determined by the on-board hardware DLL. */
+        uint64_t lock                  : 1;  /**< [ 31: 31](RO/H) DLL is locked. */
+        uint64_t reserved_32_63        : 32;
+#endif /* Word 0 - End */
+    } s;
+    /* struct cavm_xcvx_dll_ctl_s cn; */
+};
+
+
+/**
+ * Register (RSL) xcv#_reset
+ *
+ * XCV Reset Registers
+ * This register controls reset.
+ */
+union cavm_xcvx_reset
+{
+    uint64_t u;
+    struct cavm_xcvx_reset_s
+    {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+        uint64_t enable                : 1;  /**< [ 63: 63](R/W) Port enable. */
+        uint64_t reserved_16_62        : 47;
+        uint64_t clkrst                : 1;  /**< [ 15: 15](R/W) DLL CLK reset. [CLKRST] must be set if DLL bypass mode
+                                                                 XCV_DLL_CTL[CLKRX_BYP,CLKTX_BYP] is used. */
+        uint64_t reserved_12_14        : 3;
+        uint64_t dllrst                : 1;  /**< [ 11: 11](R/W) DLL reset. */
+        uint64_t reserved_8_10         : 3;
+        uint64_t comp                  : 1;  /**< [  7:  7](R/W) Compensation enable. */
+        uint64_t reserved_4_6          : 3;
+        uint64_t tx_pkt_rst_n          : 1;  /**< [  3:  3](R/W) Packet reset for TX. */
+        uint64_t tx_dat_rst_n          : 1;  /**< [  2:  2](R/W) Datapath reset for TX. */
+        uint64_t rx_pkt_rst_n          : 1;  /**< [  1:  1](R/W) Packet reset for RX. */
+        uint64_t rx_dat_rst_n          : 1;  /**< [  0:  0](R/W) Datapath reset for RX. */
+#else /* Word 0 - Little Endian */
+        uint64_t rx_dat_rst_n          : 1;  /**< [  0:  0](R/W) Datapath reset for RX. */
+        uint64_t rx_pkt_rst_n          : 1;  /**< [  1:  1](R/W) Packet reset for RX. */
+        uint64_t tx_dat_rst_n          : 1;  /**< [  2:  2](R/W) Datapath reset for TX. */
+        uint64_t tx_pkt_rst_n          : 1;  /**< [  3:  3](R/W) Packet reset for TX. */
+        uint64_t reserved_4_6          : 3;
+        uint64_t comp                  : 1;  /**< [  7:  7](R/W) Compensation enable. */
+        uint64_t reserved_8_10         : 3;
+        uint64_t dllrst                : 1;  /**< [ 11: 11](R/W) DLL reset. */
+        uint64_t reserved_12_14        : 3;
+        uint64_t clkrst                : 1;  /**< [ 15: 15](R/W) DLL CLK reset. [CLKRST] must be set if DLL bypass mode
+                                                                 XCV_DLL_CTL[CLKRX_BYP,CLKTX_BYP] is used. */
+        uint64_t reserved_16_62        : 47;
+        uint64_t enable                : 1;  /**< [ 63: 63](R/W) Port enable. */
+#endif /* Word 0 - End */
+    } s;
+    /* struct cavm_xcvx_reset_s cn; */
+};
+
+/**
+ * Register (RSL) xcv#_ctl
+ *
+ * XCV Control Register
+ * This register contains the status control bits.
+ */
+union cavm_xcvx_ctl
+{
+    uint64_t u;
+    struct cavm_xcvx_ctl_s
+    {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+        uint64_t reserved_4_63         : 60;
+        uint64_t lpbk_ext              : 1;  /**< [  3:  3](R/W) Enable external loopback mode. External loopback loops the RX datapath to the TX
+                                                                 datapath. For correct operation, the following CSRs must be configured:
+                                                                 * XCV_CTL[SPEED]          = 0x2.
+                                                                 * XCV_DLL_CTL[REFCLK_SEL] = 1.
+                                                                 * XCV_RESET[CLKRST]       = 1. */
+        uint64_t lpbk_int              : 1;  /**< [  2:  2](R/W) Enable internal loopback mode. Internal loopback loops the TX datapath to the RX
+                                                                 datapath. For correct operation, the following CSRs must be configured:
+                                                                 * XCV_CTL[SPEED]          = 0x2.
+                                                                 * XCV_DLL_CTL[REFCLK_SEL] = 0.
+                                                                 * XCV_RESET[CLKRST]       = 0. */
+        uint64_t speed                 : 2;  /**< [  1:  0](R/W) XCV operational speed:
+                                                                   0x0 = 10 Mbps.
+                                                                   0x1 = 100 Mbps.
+                                                                   0x2 = 1 Gbps.
+                                                                   0x3 = Reserved. */
+#else /* Word 0 - Little Endian */
+        uint64_t speed                 : 2;  /**< [  1:  0](R/W) XCV operational speed:
+                                                                   0x0 = 10 Mbps.
+                                                                   0x1 = 100 Mbps.
+                                                                   0x2 = 1 Gbps.
+                                                                   0x3 = Reserved. */
+        uint64_t lpbk_int              : 1;  /**< [  2:  2](R/W) Enable internal loopback mode. Internal loopback loops the TX datapath to the RX
+                                                                 datapath. For correct operation, the following CSRs must be configured:
+                                                                 * XCV_CTL[SPEED]          = 0x2.
+                                                                 * XCV_DLL_CTL[REFCLK_SEL] = 0.
+                                                                 * XCV_RESET[CLKRST]       = 0. */
+        uint64_t lpbk_ext              : 1;  /**< [  3:  3](R/W) Enable external loopback mode. External loopback loops the RX datapath to the TX
+                                                                 datapath. For correct operation, the following CSRs must be configured:
+                                                                 * XCV_CTL[SPEED]          = 0x2.
+                                                                 * XCV_DLL_CTL[REFCLK_SEL] = 1.
+                                                                 * XCV_RESET[CLKRST]       = 1. */
+        uint64_t reserved_4_63         : 60;
+#endif /* Word 0 - End */
+    } s;
+    /* struct cavm_xcvx_ctl_s cn; */
+};
+
+
+/**
+ * Register (RSL) xcv#_batch_crd_ret
+ *
+ * XCV Batch Credit Return Register
+ */
+union cavm_xcvx_batch_crd_ret
+{
+    uint64_t u;
+    struct cavm_xcvx_batch_crd_ret_s
+    {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+        uint64_t reserved_1_63         : 63;
+        uint64_t crd_ret               : 1;  /**< [  0:  0](WO) In case of the reset event, when this register is written XCV sends out the
+                                                                 initial credit batch to BGX. Initial credit value of 16. The write will only
+                                                                 take effect when XCV_RESET[ENABLE] is set. */
+#else /* Word 0 - Little Endian */
+        uint64_t crd_ret               : 1;  /**< [  0:  0](WO) In case of the reset event, when this register is written XCV sends out the
+                                                                 initial credit batch to BGX. Initial credit value of 16. The write will only
+                                                                 take effect when XCV_RESET[ENABLE] is set. */
+        uint64_t reserved_1_63         : 63;
+#endif /* Word 0 - End */
+    } s;
+    /* struct cavm_xcvx_batch_crd_ret_s cn; */
+};
+
+
+
+
+#endif /* OCTEONTX_XCV_H_ */
diff --git a/arch/arm/include/asm/arch-octeontx2/atf.h b/arch/arm/include/asm/arch-octeontx2/atf.h
new file mode 100644
index 0000000..7b2a248
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx2/atf.h
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#ifndef __ATF_H__
+#define __ATF_H__
+
+ssize_t atf_dram_size(unsigned int node);
+ssize_t atf_node_count(void);
+ssize_t atf_disable_rvu_lfs(unsigned int node);
+ssize_t atf_flsf_fw_booted(void);
+ssize_t atf_flsf_clr_force_2ndry(void);
+ssize_t atf_mdio_dbg_read(int cgx_lmac, int mode, int phyaddr, int devad,
+			  int reg);
+ssize_t atf_mdio_dbg_write(int cgx_lmac, int mode, int phyaddr, int devad,
+			   int reg, int val);
+#endif
diff --git a/arch/arm/include/asm/arch-octeontx2/cavium_mmc.h b/arch/arm/include/asm/arch-octeontx2/cavium_mmc.h
new file mode 100644
index 0000000..2095443
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx2/cavium_mmc.h
@@ -0,0 +1,1815 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#ifndef __OCTEON_MMC_H__
+#define __OCTEON_MMC_H__
+
+#include <mmc.h>
+#include <dm/device.h>
+
+/* NOTE: this file is used by both Octeon and OcteonTX */
+
+/*
+ * Card Command Classes (CCC)
+ */
+#define CCC_BASIC		(1<<0)	/* (0) Basic protocol functions */
+					/* (CMD0,1,2,3,4,7,9,10,12,13,15) */
+					/* (and for SPI, CMD58,59) */
+#define CCC_STREAM_READ		(1<<1)	/* (1) Stream read commands */
+					/* (CMD11) */
+#define CCC_BLOCK_READ		(1<<2)	/* (2) Block read commands */
+					/* (CMD16,17,18) */
+#define CCC_STREAM_WRITE	(1<<3)	/* (3) Stream write commands */
+					/* (CMD20) */
+#define CCC_BLOCK_WRITE		(1<<4)	/* (4) Block write commands */
+					/* (CMD16,24,25,26,27) */
+#define CCC_ERASE		(1<<5)	/* (5) Ability to erase blocks */
+					/* (CMD32,33,34,35,36,37,38,39) */
+#define CCC_WRITE_PROT		(1<<6)	/* (6) Able to write protect blocks */
+					/* (CMD28,29,30) */
+#define CCC_LOCK_CARD		(1<<7)	/* (7) Able to lock down card */
+					/* (CMD16,CMD42) */
+#define CCC_APP_SPEC		(1<<8)	/* (8) Application specific */
+					/* (CMD55,56,57,ACMD*) */
+#define CCC_IO_MODE		(1<<9)	/* (9) I/O mode */
+					/* (CMD5,39,40,52,53) */
+#define CCC_SWITCH		(1<<10)	/* (10) High speed switch */
+					/* (CMD6,34,35,36,37,50) */
+					/* (11) Reserved */
+					/* (CMD?) */
+
+/*
+ * NOTE: This was copied from the Linux kernel.
+ *
+ * MMC status in R1, for native mode (SPI bits are different)
+ * Type
+ *	e:error bit
+ *	s:status bit
+ *	r:detected and set for the actual command response
+ *	x:detected and set during command execution. the host must poll
+ *	    the card by sending status command in order to read these bits.
+ * Clear condition
+ *	a:according to the card state
+ *	b:always related to the previous command. Reception of
+ *	    a valid command will clear it (with a delay of one command)
+ *	c:clear by read
+ */
+#define R1_OUT_OF_RANGE         (1 << 31)       /* er, c */
+#define R1_ADDRESS_ERROR        (1 << 30)       /* erx, c */
+#define R1_BLOCK_LEN_ERROR      (1 << 29)       /* er, c */
+#define R1_ERASE_SEQ_ERROR      (1 << 28)       /* er, c */
+#define R1_ERASE_PARAM          (1 << 27)       /* ex, c */
+#define R1_WP_VIOLATION         (1 << 26)       /* erx, c */
+#define R1_CARD_IS_LOCKED       (1 << 25)       /* sx, a */
+#define R1_LOCK_UNLOCK_FAILED   (1 << 24)       /* erx, c */
+#define R1_COM_CRC_ERROR        (1 << 23)       /* er, b */
+#define R1_ILLEGAL_COMMAND      (1 << 22)       /* er, b */
+#define R1_CARD_ECC_FAILED      (1 << 21)       /* ex, c */
+#define R1_CC_ERROR             (1 << 20)       /* erx, c */
+#define R1_ERROR                (1 << 19)       /* erx, c */
+#define R1_UNDERRUN             (1 << 18)       /* ex, c */
+#define R1_OVERRUN              (1 << 17)       /* ex, c */
+#define R1_CID_CSD_OVERWRITE    (1 << 16)       /* erx, c, CID/CSD overwrite */
+#define R1_WP_ERASE_SKIP        (1 << 15)       /* sx, c */
+#define R1_CARD_ECC_DISABLED    (1 << 14)       /* sx, a */
+#define R1_ERASE_RESET          (1 << 13)       /* sr, c */
+#define R1_STATUS(x)            (x & 0xFFFFE000)
+#define R1_CURRENT_STATE(x)     ((x & 0x00001E00) >> 9) /* sx, b (4 bits) */
+#define R1_READY_FOR_DATA       (1 << 8)        /* sx, a */
+#define R1_SWITCH_ERROR         (1 << 7)        /* sx, c */
+#define R1_APP_CMD              (1 << 5)        /* sr, c */
+
+#define R1_BLOCK_READ_MASK	R1_OUT_OF_RANGE |	\
+				R1_ADDRESS_ERROR |	\
+				R1_BLOCK_LEN_ERROR |	\
+				R1_CARD_IS_LOCKED |	\
+				R1_COM_CRC_ERROR |	\
+				R1_ILLEGAL_COMMAND |	\
+				R1_CARD_ECC_FAILED |	\
+				R1_CC_ERROR |		\
+				R1_ERROR;
+#define R1_BLOCK_WRITE_MASK	R1_OUT_OF_RANGE |	\
+				R1_ADDRESS_ERROR |	\
+				R1_BLOCK_LEN_ERROR |	\
+				R1_WP_VIOLATION |	\
+				R1_CARD_IS_LOCKED |	\
+				R1_COM_CRC_ERROR |	\
+				R1_ILLEGAL_COMMAND |	\
+				R1_CARD_ECC_FAILED |	\
+				R1_CC_ERROR |		\
+				R1_ERROR |		\
+				R1_UNDERRUN |		\
+				R1_OVERRUN
+
+/**
+ * Flag indicates that CMD23 is supported.  This is required for multi-block
+ * hardware transfers to work.
+ */
+#define OCTEON_MMC_FLAG_SD_CMD23	1
+
+#ifdef __mips
+# define OCTEON_EMM_BASE_ADDR		0x0x1180000000000
+#endif
+
+/* Offsets of various registers */
+#define MIO_EMM_DMA_FIFO_CFG		0x0160
+#define MIO_EMM_DMA_FIFO_ADR		0x0170
+#define MIO_EMM_DMA_FIFO_CMD		0x0178
+#define MIO_EMM_DMA_CFG			0x0180
+#define MIO_EMM_DMA_ADR			0x0188
+#define MIO_EMM_DMA_INT			0x0190
+#define NDF_DMA_INT			(-1)	/** Not supported yet */
+#define MIO_EMM_DMA_INT_W1S		0x0198
+#ifdef __arm
+# define MIO_EMM_DMA_INT_ENA_W1S	0x01A0
+# define MIO_EMM_DMA_INT_ENA_W1C	0x01A8
+#endif
+#define MIO_EMM_CFG			0x2000
+#define MIO_EMM_MODEX(X)		(0x2008 + ((X) * 0x8))
+#ifdef __arm
+# define MIO_EMM_COMP			0x2040
+#endif
+#define MIO_EMM_SWITCH			0x2048
+#define MIO_EMM_DMA			0x2050
+#define MIO_EMM_CMD			0x2058
+#define MIO_EMM_RSP_STS			0x2060
+#define MIO_EMM_RSP_LO			0x2068
+#define MIO_EMM_RSP_HI			0x2070
+#define MIO_EMM_INT			0x2078
+#ifdef __arm
+# define MIO_EMM_INT_W1S		0x2080
+#endif
+#define MIO_EMM_WDOG			0x2088
+#define MIO_EMM_SAMPLE			0x2090
+#define MIO_EMM_STS_MASK		0x2098
+#define MIO_EMM_RCA			0x20A0
+#ifdef __arm
+# define MIO_EMM_INT_ENA_W1S		0x20B0
+# define MIO_EMM_INT_ENA_W1C		0x20B8
+#endif
+#define MIO_EMM_BUF_IDX			0x20E0
+#define MIO_EMM_BUF_DAT			0x20E8
+#define MIO_EMM_ACCESS_WDOG		0x20F0
+
+/** Maximum supported MMC slots */
+#define CAVIUM_MAX_MMC_SLOT		2
+
+#define CAVIUM_MMC_NAME_LEN		32
+
+struct mmc;
+struct mmc_config;
+struct cavium_mmc_host;
+struct cavium_mmc_slot;
+struct gpio_desc;
+
+struct cavium_mmc_slot {
+	char		name[CAVIUM_MMC_NAME_LEN];	/** Name of device */
+	uint8_t		ext_csd[512];	/** Extended CSD register */
+	struct mmc	*mmc;		/** Ptr back to mmc structure */
+	struct cavium_mmc_host *host;	/** Host controller data structure */
+	struct mmc_config cfg;		/** Slot configuration */
+	struct gpio_desc power_gpio;	/** Power/reset GPIO line (usually 8) */
+	struct gpio_desc cd_gpio;	/** Card detect GPIO */
+	struct gpio_desc wp_gpio;	/** Write-protect GPIO */
+	int		power_delay;	/** Time in usec to wait for power */
+	int		bus_id;		/** BUS ID of device */
+	int		of_offset;	/** Device tree node */
+	int		clk_period;	/** Clock period */
+	int		bus_max_width;	/** Bus width 1, 4 or 8 */
+	int		power_class;	/** Power class for device */
+	int		flags;
+	int		cmd_clk_skew;	/** Clock skew for cmd in SCLK */
+	int		dat_clk_skew;	/** Clock skew for data in SCLK */
+	int		power_gpio_of_offset;	/** Offset of power node */
+	/**
+	 * Register bus-width value where:
+	 * 0: 1-bit
+	 * 1: 4-bit
+	 * 2: 8-bit
+	 * 5: 4-bit DDR
+	 * 6: 8-bit DDR
+	 * All other values are reserved.
+	 */
+	uint8_t		bus_width;
+	bool		non_removable:1;/** True if device is not removable */
+	bool		have_ext_csd:1;	/** True if have extended CSD register */
+	bool		sector_mode:1;	/** Sector or byte mode */
+	bool		powered:1;	/** True if powered on */
+	/** True if power GPIO is active high */
+	bool		power_active_high:1;
+	bool		ro_inverted:1;	/** True if write-protect is inverted */
+	bool		cd_inverted:1;	/** True if card-detect is inverted */
+};
+
+struct cavium_mmc_host {
+	void		*base_addr;	/** Base address of device */
+	pci_dev_t	pdev;		/** PCI device */
+	uint64_t	sclock;		/** SCLK in hz */
+	int		of_offset;	/** Device tree node */
+	int		cur_slotid;	/** Current slot to use */
+	int		last_slotid;	/** last slot in use */
+	int		max_width;	/** Maximum width hardware supports */
+#ifdef __mips
+	int		node;		/** OCX node for Octeon (MIPS) */
+	bool		use_ndf;	/** Use MIO_NDF_DMA or MIO_EMM_DMA. */
+#endif
+	bool		initialized;
+	struct udevice  *dev;		/** Device host is associated with */
+	/** Slots associated with host controller */
+	struct cavium_mmc_slot slots[CAVIUM_MAX_MMC_SLOT];
+};
+
+
+/* Register definitions */
+
+/**
+ * Register (RSL) mio_emm_buf_dat
+ *
+ * eMMC Data Buffer Access Register
+ */
+union mio_emm_buf_dat {
+	uint64_t u;
+	struct mio_emm_buf_dat_s {
+		/**
+		 * [ 63:  0](R/W/H) Direct access to the 1 KB data
+		 * buffer memory. Address specified by MIO_EMM_BUF_IDX.
+		 */
+		uint64_t dat:64;
+	} s;
+	/* struct mio_emm_buf_dat_s cn; */
+};
+
+/**
+ * Register (RSL) mio_emm_buf_idx
+ *
+ * eMMC Data Buffer Address Register
+ */
+union mio_emm_buf_idx {
+	uint64_t u;
+	struct mio_emm_buf_idx_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t reserved_17_63:47;
+		/**
+		 * [ 16: 16](R/W) Automatically advance [BUF_NUM]/[OFFSET]
+		 * after each access to MIO_EMM_BUF_DAT.  Wraps after the
+		 * last offset of the last data buffer.
+		 */
+		uint64_t inc:1;
+		uint64_t reserved_7_15:9;
+		/**
+		 * [ 6:  6](R/W/H) Specify the data buffer for the next
+		 * access to MIO_EMM_BUF_DAT.
+		 */
+		uint64_t buf_num:1;
+		/**
+		 * [  5:  0](R/W/H) Specify the 8B data buffer offset for
+		 * the next access to MIO_EMM_BUF_DAT.
+		 */
+		uint64_t offset:6;
+#else /* Word 0 - Little Endian */
+		uint64_t offset:6;
+		uint64_t buf_num:1;
+		uint64_t reserved_7_15:9;
+		uint64_t inc:1;
+		uint64_t reserved_17_63:47;
+#endif /* Word 0 - End */
+	} s;
+};
+
+/**
+ * Register (RSL) mio_emm_cfg
+ *
+ * eMMC Configuration Register
+ */
+union mio_emm_cfg {
+	uint64_t u;
+	struct mio_emm_cfg_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t reserved_4_63:60;
+		/**
+		 * [  3:  0](R/W) eMMC bus enable mask.
+		 *
+		 * Setting bit0 of [BUS_ENA] causes EMMC_CMD[0] to become
+		 * dedicated eMMC bus 0 command (i.e. disabling any NOR use).
+		 *
+		 * Setting bit1 of [BUS_ENA] causes EMMC_CMD[1] to become
+		 * dedicated eMMC bus 1 command (i.e. disabling any NOR use).
+		 *
+		 * Setting bit2 of [BUS_ENA] causes EMMC_CMD[2] to become
+		 * dedicated eMMC bus 2 command (i.e. disabling any NOR use).
+		 *
+		 * Bit3 of [BUS_ENA] is reserved.
+		 *
+		 * Clearing all bits of this field will reset the other
+		 * MIO_EMM_* registers.
+		 * To ensure a proper reset the BUS_ENA bits should be
+		 * cleared for a minimum of 2 EMMC_CLK periods.  This
+		 * period be determined by waiting twice the number of
+		 * coprocessor clocks specified in MIO_EMM_MODE0[CLK_HI]
+		 * and MIO_EMM_MODE0[CLK_LO].
+		 *
+		 * Setting one or more bits will enable EMMC_CLK operation.
+		 */
+		uint64_t bus_ena:4;
+#else /* Word 0 - Little Endian */
+		uint64_t bus_ena:4;
+		uint64_t reserved_4_63:60;
+#endif /* Word 0 - End */
+	} s;
+	/* struct mio_emm_cfg_s cn; */
+};
+
+/**
+ * Register (RSL) mio_emm_cmd
+ *
+ * eMMC Command Register
+ */
+union  mio_emm_cmd {
+	uint64_t u;
+	struct mio_emm_cmd_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t reserved_63:1;
+		/**
+		 * [ 62: 62](R/W) Controls when command is completed.
+		 * 0 = Command doesn't complete until card has dropped
+		 *     the BUSY signal.
+		 * 1 = Complete command regardless of the BUSY signal.
+		 *     Status of signal can be read in
+		 *     MIO_EMM_RSP_STS[RSP_BUSYBIT].
+		 */
+		uint64_t skip_busy:1;
+		/** [ 61: 60](R/W) Specify the eMMC bus */
+		uint64_t bus_id:2;
+		/**
+		 * [ 59: 59](R/W/H) Request valid. Software writes this bit
+		 * to a 1.  Hardware clears it when the operation completes.
+		 */
+		uint64_t cmd_val:1;
+		uint64_t reserved_56_58:3;
+		/**
+		 * [ 55: 55](R/W) Specify the data buffer to be used for a
+		 * block transfer.
+		 */
+		uint64_t dbuf:1;
+		/**
+		 * [ 54: 49](R/W/H) Debug only.  Specify the number of
+		 * 8-byte transfers used in the command.  Value is 64-OFFSET.
+		 * The block transfer still starts at the first byte in
+		 * the 512 B data buffer.
+		 * Software must ensure CMD16 has updated the card block
+		 * length.
+		 */
+		uint64_t offset:6;
+		uint64_t reserved_43_48:6;
+		/**
+		 * [ 42: 41](R/W) Command type override; typically zero.
+		 * Value is XOR'd with the default command type.  See
+		 * Command and Response Types for command types per command
+		 * index. Types are:
+		 * 0x0 = No data.
+		 * 0x1 = Read data into Dbuf.
+		 * 0x2 = Write data from Dbuf.
+		 * 0x3 = Reserved.
+		 */
+		uint64_t ctype_xor:2;
+		/**
+		 * [ 40: 38](R/W) Response type override; typically zero.
+		 * Value is XOR'd with default response type.  See
+		 * Command and Response Types for response types per command
+		 * index.
+		 * Types are:
+		 * 0x0 = No Response.
+		 * 0x1 = R1, 48 bits.
+		 * 0x2 = R2, 136 bits.
+		 * 0x3 = R3, 48 bits.
+		 * 0x4 = R4, 48 bits.
+		 * 0x5 = R5, 48 bits.
+		 * 0x6, 0x7 = Reserved.
+		 */
+		uint64_t rtype_xor:3;
+		/** [ 37: 32](R/W/H) eMMC command */
+		uint64_t cmd_idx:6;
+		/** [ 31:  0](R/W/H) eMMC command argument */
+		uint64_t arg:32;
+#else /* Word 0 - Little Endian */
+		uint64_t arg:32;
+		uint64_t cmd_idx:6;
+		uint64_t rtype_xor:3;
+		uint64_t ctype_xor:2;
+		uint64_t reserved_43_48:6;
+		uint64_t offset:6;
+		uint64_t dbuf:1;
+		uint64_t reserved_56_58:3;
+		uint64_t cmd_val:1;
+		uint64_t bus_id:2;
+		uint64_t skip_busy:1;
+		uint64_t reserved_63:1;
+#endif /* Word 0 - End */
+	} s;
+	/* struct mio_emm_cmd_s cn; */
+};
+
+/**
+ * Register (RSL) mio_emm_comp
+ *
+ * eMMC Compensation Register
+ */
+union mio_emm_comp {
+	uint64_t u;
+	struct mio_emm_comp_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t reserved_11_63:53;
+		/**
+		 * [ 10:  8](R/W) eMMC bus driver PCTL. Typical values:
+		 * 0x4 = 60 ohm.
+		 * 0x6 = 40 ohm.
+		 * 0x7 = 30 ohm.
+		 */
+		uint64_t pctl:3;
+
+		uint64_t reserved_3_7:5;
+		/**
+		 * [  2:  0](R/W) eMMC bus driver NCTL. Typical values:
+		 * 0x4 = 60 ohm.
+		 * 0x6 = 40 ohm.
+		 * 0x7 = 30 ohm.
+		 */
+		uint64_t nctl:3;
+#else /* Word 0 - Little Endian */
+		uint64_t nctl:3;
+		uint64_t reserved_3_7:5;
+		uint64_t pctl:3;
+		uint64_t reserved_11_63:53;
+#endif /* Word 0 - End */
+	} s;
+	/* struct mio_emm_comp_s cn; */
+};
+
+/**
+ * Register (RSL) mio_emm_dma
+ *
+ * eMMC External DMA Configuration Register
+ */
+union mio_emm_dma {
+	uint64_t u;
+	struct mio_emm_dma_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t reserved_63:1;
+		/**
+		 * [ 62: 62](R/W) Controls when DMA is completed.
+		 * 0 = DMA doesn't complete until card has dropped the BUSY
+		 *     signal.
+		 * 1 = Complete DMA after last transfer regardless of the BUSY
+		 *     signal.  Status of signal can be read in
+		 *     MIO_EMM_RSP_STS[RSP_BUSYBIT].
+		 */
+		uint64_t skip_busy:1;
+		/** [ 61: 60](R/W) Specify the eMMC bus */
+		uint64_t bus_id:2;
+		/**
+		 * [ 59: 59](R/W/H) Software writes this bit to a 1 to
+		 * indicate that hardware should perform the DMA
+		 * transfer.
+		 * Hardware clears this bit when the DMA operation
+		 * completes or is terminated.
+		 */
+		uint64_t dma_val:1;
+		/**
+		 * [ 58: 58](R/W/H) Specify CARD_ADDR and eMMC are using
+		 * sector (512 B) addressing.
+		 */
+		uint64_t sector:1;
+		/**
+		 * [ 57: 57](R/W) Do not perform any eMMC commands.  A DMA
+		 * read returns all 0s.  A DMA write tosses the data.
+		 * In the case of a failure, this can be used to unwind the
+		 * DMA engine.
+		 */
+		uint64_t dat_null:1;
+		/**
+		 * [ 56: 51](R/W) Number of 8-byte blocks of data that
+		 * must exist in the DBUF before starting the 512-byte
+		 * block transfer.  Zero indicates to wait for the
+		 * entire block.
+		 */
+		uint64_t thres:6;
+		/**
+		 * [ 50: 50](R/W) Set the reliable write parameter when
+		 * performing CMD23 (SET_BLOCK_COUNT) for a multiple block.
+		 */
+		uint64_t rel_wr:1;
+		/** [ 49: 49](R/W) Read/write bit (0 = read, 1 = write). */
+		uint64_t rw:1;
+		/**
+		 * [ 48: 48](R/W) Perform operation using a multiple block
+		 * command instead of a series of single block commands.
+		 */
+		uint64_t multi:1;
+		/**
+		 * [ 47: 32](R/W/H) Number of blocks to read/write.  Hardware
+		 * decrements the block count after each successful
+		 * block transfer.
+		 */
+		uint64_t block_cnt:16;
+		/**
+		 * [ 31:  0](R/W/H) Data address for media <= 2 GB is a 32-bit
+		 * byte address, and data address for media > 2 GB is a 32-bit
+		 * sector (512 B) address.  Hardware advances the card address
+		 * after each successful block transfer by 512 for byte
+		 * addressing and by 1 for sector addressing.
+		 */
+		uint64_t card_addr:32;
+#else /* Word 0 - Little Endian */
+		uint64_t card_addr:32;
+		uint64_t block_cnt:16;
+		uint64_t multi:1;
+		uint64_t rw:1;
+		uint64_t rel_wr:1;
+		uint64_t thres:6;
+		uint64_t dat_null:1;
+		uint64_t sector:1;
+		uint64_t dma_val:1;
+		uint64_t bus_id:2;
+		uint64_t skip_busy:1;
+		uint64_t reserved_63:1;
+#endif /* Word 0 - End */
+	} s;
+	/* struct mio_emm_dma_s cn; */
+};
+
+/**
+ * Register (RSL) mio_emm_dma_adr
+ *
+ * eMMC DMA Address Register
+ * This register sets the address for eMMC/SD flash transfers to/from memory.
+ * Sixty-four-bit operations must be used to access this register.  This
+ * register is updated by the DMA hardware and can be reloaded by the values
+ * placed in the MIO_EMM_DMA_FIFO_ADR.
+ */
+union mio_emm_dma_adr {
+	uint64_t u;
+	struct mio_emm_dma_adr_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t reserved_49_63:15;
+		/** [ 48:  0](R/W/H) DMA engine IOVA. Must be 64-bit aligned. */
+		uint64_t adr:49;
+#else /* Word 0 - Little Endian */
+		uint64_t adr:49;
+		uint64_t reserved_49_63:15;
+#endif /* Word 0 - End */
+	} s;
+	/* struct mio_emm_dma_adr_s cn; */
+};
+
+/**
+ * Register (RSL) mio_emm_dma_cfg
+ *
+ * eMMC DMA Configuration Register
+ * This register controls the internal DMA engine used with the eMMC/SD flash
+ * controller. Sixty-four-bit operations must be used to access this register.
+ * This register is updated by the hardware DMA engine and can also be reloaded
+ * by writes to the MIO_EMM_DMA_FIFO_CMD register.
+ */
+union mio_emm_dma_cfg {
+	uint64_t u;
+	struct mio_emm_dma_cfg_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		/** [ 63: 63](R/W/H) DMA engine enable. */
+		uint64_t en:1;
+		/** [ 62: 62](R/W/H) DMA engine R/W bit: 0 = read, 1 = write. */
+		uint64_t rw:1;
+		/**
+		 * [ 61: 61](R/W/H) DMA engine abort.  When set to 1, DMA is
+		 * aborted and EN is cleared on completion.
+		 */
+		uint64_t clr:1;
+		uint64_t reserved_60:1;
+		/** [ 59: 59](R/W/H) DMA engine 32-bit swap. */
+		uint64_t swap32:1;
+		/** [ 58: 58](R/W/H) DMA engine enable 16-bit swap. */
+		uint64_t swap16:1;
+		/** [ 57: 57](R/W/H) DMA engine enable 8-bit swap. */
+		uint64_t swap8:1;
+		/**
+		 * [ 56: 56](R/W/H) DMA engine endian mode: 0 = big-endian,
+		 * 1 = little-endian.
+		 */
+		uint64_t endian:1;
+		/**
+		 * [ 55: 36](R/W/H) DMA engine size. Specified in the number of
+		 * 64-bit transfers (encoded in -1 notation).  For example, to
+		 * transfer 512 bytes, SIZE = 64 - 1 = 63.
+		 */
+		uint64_t size:20;
+		uint64_t reserved_0_35:36;
+#else /* Word 0 - Little Endian */
+		uint64_t reserved_0_35:36;
+		uint64_t size:20;
+		uint64_t endian:1;
+		uint64_t swap8:1;
+		uint64_t swap16:1;
+		uint64_t swap32:1;
+		uint64_t reserved_60:1;
+		uint64_t clr:1;
+		uint64_t rw:1;
+		uint64_t en:1;
+#endif /* Word 0 - End */
+	} s;
+	/* struct mio_emm_dma_cfg_s cn; */
+};
+
+/**
+ * Register (RSL) mio_emm_dma_fifo_adr
+ *
+ * eMMC Internal DMA FIFO Address Register
+ * This register specifies the internal address that is loaded into the eMMC
+ * internal DMA FIFO.  The FIFO is used to queue up operations for the
+ * MIO_EMM_DMA_CFG/MIO_EMM_DMA_ADR when the DMA completes successfully.
+ */
+union mio_emm_dma_fifo_adr {
+	uint64_t u;
+	struct mio_emm_dma_fifo_adr_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t reserved_49_63:15;
+		/** [ 48:  3](R/W) DMA engine IOVA. Must be 64-bit aligned. */
+		uint64_t adr:46;
+		uint64_t reserved_0_2:3;
+#else /* Word 0 - Little Endian */
+		uint64_t reserved_0_2:3;
+		uint64_t adr:46;
+		uint64_t reserved_49_63:15;
+#endif /* Word 0 - End */
+	} s;
+	/* struct mio_emm_dma_fifo_adr_s cn; */
+};
+
+/**
+ * Register (RSL) mio_emm_dma_fifo_cfg
+ *
+ * eMMC Internal DMA FIFO Configuration Register
+ * This register controls DMA FIFO Operations.
+ */
+union mio_emm_dma_fifo_cfg {
+	uint64_t u;
+	struct mio_emm_dma_fifo_cfg_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t reserved_17_63:47;
+		/**
+		 * [ 16: 16](R/W) DMA FIFO Clear. When set erases all commands
+		 * in the DMA FIFO. Must be zero for normal operation.
+		 */
+		uint64_t clr:1;
+		uint64_t reserved_13_15:3;
+		/**
+		 * [ 12:  8](R/W) Interrupt threshold indicating the number of
+		 * entries remaining in the DMA FIFO.  An interrupt occurs if
+		 * the FIFO is read at the level specified.
+		 * A value of 0 disables the interrupt.  A value of 17 or
+		 * greater will cause an interrupt only if the FIFO is
+		 * overflowed.
+		 * See MIO_EMM_DMA_INT[FIFO].
+		 */
+		uint64_t int_lvl:5;
+		uint64_t reserved_5_7:3;
+		/**
+		 * [  4:  0](RO/H) Number of entries in the DMA FIFO.  This
+		 * count is incremented by writes to the MIO_EMM_DMA_FIFO_CMD
+		 * register and decremented each time the internal DMA engine
+		 * completes the previous command successfully.
+		 *
+		 * Up to 16 entries can be placed in the FIFO.  Entries written
+		 * to a full FIFO will potentially corrupt existing entries.
+		 * Care must be taken by software to insure that this condition
+		 * does not occur.
+		 */
+		uint64_t count:5;
+#else /* Word 0 - Little Endian */
+		uint64_t count:5;
+		uint64_t reserved_5_7:3;
+		uint64_t int_lvl:5;
+		uint64_t reserved_13_15:3;
+		uint64_t clr:1;
+		uint64_t reserved_17_63:47;
+#endif /* Word 0 - End */
+	} s;
+	/* struct mio_emm_dma_fifo_cfg_s cn; */
+};
+
+/**
+ * Register (RSL) mio_emm_dma_fifo_cmd
+ *
+ * eMMC Internal DMA FIFO Command Register
+ * This register specifies a command that is loaded into the eMMC internal DMA
+ * FIFO.  The FIFO is used to queue up operations for the
+ * MIO_EMM_DMA_CFG/MIO_EMM_DMA_ADR when the DMA completes successfully.  Writes
+ * to this register store both the MIO_EMM_DMA_FIFO_CMD and the
+ * MIO_EMM_DMA_FIFO_ADR contents into the FIFO and increment the
+ * MIO_EMM_DMA_FIFO_CFG[COUNT] field.
+ *
+ * Note: This register has a similar format to the MIO_EMM_DMA_CFG register with
+ * the exception that the EN and CLR fields are absent.  These are supported in
+ * the MIO_EMM_DMA_FIFO_CFG.
+ */
+union mio_emm_dma_fifo_cmd {
+	uint64_t u;
+	struct mio_emm_dma_fifo_cmd_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t reserved_63:1;
+		/** [ 62: 62](R/W) DMA engine R/W bit: 0 = read, 1 = write. */
+		uint64_t rw:1;
+		uint64_t reserved_61:1;
+		/**
+		 * [ 60: 60](R/W) DMA command interrupt disable.  When set, the
+		 * DMA command being submitted will not generate a
+		 * MIO_EMM_DMA_INT[DONE] interrupt when it completes.  When
+		 * cleared the command will generate the interrupt.
+		 *
+		 * For example, this field can be set for all the DMA commands
+		 * submitted to the DMA FIFO in the case of a write to the eMMC
+		 * device because the MIO_EMM_INT[DMA_DONE] interrupt would
+		 * signify the end of the operation.  It could be cleared on the
+		 * last DMA command being submitted to the DMA FIFO and the
+		 * MIO_EMM_DMA_INT[DONE] would occur when the read data from the
+		 * eMMC device was available in local memory.
+		 */
+		uint64_t intdis:1;
+		/**
+		 * [ 59: 59](R/W) DMA engine 32-bit swap enable.
+		 *  See [ENDIAN].
+		 */
+		uint64_t swap32:1;
+		/**
+		 * [ 58: 58](R/W) DMA engine 16-bit swap enable.
+		 * See [ENDIAN].
+		 */
+		uint64_t swap16:1;
+		/**
+		 * [ 57: 57](R/W) DMA engine 8-bit swap enable.
+		 * See [ENDIAN].
+		 */
+		uint64_t swap8:1;
+		/**
+		 * [ 56: 56](R/W) DMA engine endian mode:
+		 *  0 = little-endian
+		 *  1 = big-endian
+		 * Using 0..7 to identify bytes.
+		 *
+		 * [SWAP32] [SWAP16] [SWAP8] [ENDIAN]  Result
+		 * 0        0        0      0       7 6 5 4 3 2 1 0
+		 * 0        0        1      0       6 7 4 5 2 3 0 1
+		 * 0        1        0      0       5 4 7 6 1 0 3 2
+		 * 1        0        0      0       3 2 1 0 7 6 5 4
+		 * 0        0        0      1       0 1 2 3 4 5 6 7
+		 * 0        0        1      1       1 0 3 2 5 4 7 6
+		 * 0        1        0      1       2 3 0 1 6 7 4 5
+		 * 1        0        0      1       4 5 6 7 0 1 2 3
+		 */
+		uint64_t endian:1;
+		/**
+		 * [ 55: 36](R/W/H) DMA engine size. Specified in the number of
+		 * 64-bit transfers (encoded in -1 notation).  For
+		 * example, to transfer 512 bytes, SIZE = 64 - 1 = 63.
+		 */
+		uint64_t size:20;
+		uint64_t reserved_0_35:36;
+#else /* Word 0 - Little Endian */
+		uint64_t reserved_0_35:36;
+		uint64_t size:20;
+		uint64_t endian:1;
+		uint64_t swap8:1;
+		uint64_t swap16:1;
+		uint64_t swap32:1;
+		uint64_t intdis:1;
+		uint64_t reserved_61:1;
+		uint64_t rw:1;
+		uint64_t reserved_63:1;
+#endif /* Word 0 - End */
+	} s;
+	struct mio_emm_dma_fifo_cmd_cn88xxp1 {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t reserved_63:1;
+		/** [ 62: 62](R/W) DMA engine R/W bit: 0 = read, 1 = write. */
+		uint64_t rw:1;
+		uint64_t reserved_61:1;
+		uint64_t reserved_60:1;
+		/**
+		 * [ 59: 59](R/W) DMA engine 32-bit swap enable.
+		 * See [ENDIAN].
+		 */
+		uint64_t swap32:1;
+		/**
+		 * [ 58: 58](R/W) DMA engine 16-bit swap enable.
+		 * See [ENDIAN].
+		 */
+		uint64_t swap16:1;
+		/**
+		 * [ 57: 57](R/W) DMA engine 8-bit swap enable.
+		 * See [ENDIAN].
+		 */
+		uint64_t swap8:1;
+		/**
+		 * [ 56: 56](R/W) DMA engine endian mode:
+		 *  0 = little-endian
+		 *  1 = big-endian
+		 * Using 0..7 to identify bytes.
+		 *
+		 * [SWAP32] [SWAP16] [SWAP8] [ENDIAN]  Result
+		 * 0        0        0      0       7 6 5 4 3 2 1 0
+		 * 0        0        1      0       6 7 4 5 2 3 0 1
+		 * 0        1        0      0       5 4 7 6 1 0 3 2
+		 * 1        0        0      0       3 2 1 0 7 6 5 4
+		 * 0        0        0      1       0 1 2 3 4 5 6 7
+		 * 0        0        1      1       1 0 3 2 5 4 7 6
+		 * 0        1        0      1       2 3 0 1 6 7 4 5
+		 * 1        0        0      1       4 5 6 7 0 1 2 3
+		 */
+		uint64_t endian:1;
+		uint64_t size:20;
+		uint64_t reserved_0_35:36;
+#else /* Word 0 - Little Endian */
+		uint64_t reserved_0_35:36;
+		uint64_t size:20;
+		uint64_t endian:1;
+		uint64_t swap8:1;
+		uint64_t swap16:1;
+		uint64_t swap32:1;
+		uint64_t reserved_60:1;
+		uint64_t reserved_61:1;
+		uint64_t rw:1;
+		uint64_t reserved_63:1;
+#endif /* Word 0 - End */
+	} cn88xxp1;
+	/* struct mio_emm_dma_fifo_cmd_s cn9; */
+	/* struct mio_emm_dma_fifo_cmd_s cn81xx; */
+	/* struct mio_emm_dma_fifo_cmd_s cn83xx; */
+	/* struct mio_emm_dma_fifo_cmd_s cn88xxp2; */
+};
+
+/**
+ * Register (RSL) mio_emm_dma_int
+ *
+ * eMMC DMA Interrupt Register
+ * Sixty-four-bit operations must be used to access this register.
+ */
+union mio_emm_dma_int {
+	uint64_t u;
+	struct mio_emm_dma_int_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t reserved_2_63:62;
+		/**
+		 * [  1:  1](R/W1C/H) Internal DMA FIFO has dropped to level
+		 * specified by MIO_EMM_DMA_FIFO_CFG[INT_LVL].
+		 */
+		uint64_t fifo:1;
+		/**
+		 * [  0:  0](R/W1C/H) Internal DMA engine request completion
+		 * interrupt.
+		 */
+		uint64_t done:1;
+#else /* Word 0 - Little Endian */
+		uint64_t done:1;
+		uint64_t fifo:1;
+		uint64_t reserved_2_63:62;
+#endif /* Word 0 - End */
+	} s;
+	/* struct mio_emm_dma_int_s cn; */
+};
+
+/**
+ * Register (RSL) mio_emm_dma_int_ena_w1c
+ *
+ * eMMC DMA Interrupt Enable Clear Register
+ * This register clears interrupt enable bits.
+ */
+union mio_emm_dma_int_ena_w1c {
+	uint64_t u;
+	struct mio_emm_dma_int_ena_w1c_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t reserved_2_63:62;
+		/**
+		 * [  1:  1](R/W1C/H) Reads or clears enable for
+		 * MIO_EMM_DMA_INT[FIFO].
+		 */
+		uint64_t fifo:1;
+		/**
+		 * [  0:  0](R/W1C/H) Reads or clears enable for
+		 * MIO_EMM_DMA_INT[DONE].
+		 */
+		uint64_t done:1;
+#else /* Word 0 - Little Endian */
+		uint64_t done:1;
+		uint64_t fifo:1;
+		uint64_t reserved_2_63:62;
+#endif /* Word 0 - End */
+	} s;
+	/* struct mio_emm_dma_int_ena_w1c_s cn; */
+};
+
+/**
+ * Register (RSL) mio_emm_dma_int_ena_w1s
+ *
+ * eMMC DMA Interrupt Enable Set Register
+ * This register sets interrupt enable bits.
+ */
+union mio_emm_dma_int_ena_w1s {
+	uint64_t u;
+	struct mio_emm_dma_int_ena_w1s_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t reserved_2_63:62;
+		/**
+		 * [  1:  1](R/W1S/H) Reads or sets enable for
+		 * MIO_EMM_DMA_INT[FIFO].
+		 */
+		uint64_t fifo:1;
+		/**
+		 * [  0:  0](R/W1S/H) Reads or sets enable for
+		 * MIO_EMM_DMA_INT[DONE].
+		 */
+		uint64_t done:1;
+#else /* Word 0 - Little Endian */
+		uint64_t done:1;
+		uint64_t fifo:1;
+		uint64_t reserved_2_63:62;
+#endif /* Word 0 - End */
+	} s;
+	/* struct mio_emm_dma_int_ena_w1s_s cn; */
+};
+
+/**
+ * Register (RSL) mio_emm_dma_int_w1s
+ *
+ * eMMC DMA Interrupt Set Register
+ * This register sets interrupt bits.
+ */
+union mio_emm_dma_int_w1s {
+	uint64_t u;
+	struct mio_emm_dma_int_w1s_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t reserved_2_63:62;
+		/** [  1:  1](R/W1S/H) Reads or sets MIO_EMM_DMA_INT[FIFO]. */
+		uint64_t fifo:1;
+		/** [  0:  0](R/W1S/H) Reads or sets MIO_EMM_DMA_INT[DONE]. */
+		uint64_t done:1;
+#else /* Word 0 - Little Endian */
+		uint64_t done:1;
+		uint64_t fifo:1;
+		uint64_t reserved_2_63:62;
+#endif /* Word 0 - End */
+	} s;
+	/* struct mio_emm_dma_int_w1s_s cn; */
+};
+
+/**
+ * Register (RSL) mio_emm_int
+ *
+ * eMMC Interrupt Register
+ */
+union mio_emm_int {
+	uint64_t u;
+	struct mio_emm_int_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t reserved_7_63:57;
+		/** [  6:  6](R/W1C/H) Switch operation encountered an error. */
+		uint64_t switch_err:1;
+		/**
+		 * [  5:  5](R/W1C/H) Switch operation completed successfully.
+		 */
+		uint64_t switch_done:1;
+		/**
+		 * [  4:  4](R/W1C/H) External DMA transfer encountered an
+		 * error. See MIO_EMM_RSP_STS.
+		 */
+		uint64_t dma_err:1;
+		/**
+		 * [  3:  3](R/W1C/H) Operation specified by MIO_EMM_CMD
+		 * encountered an error. See MIO_EMM_RSP_STS.
+		 */
+		uint64_t cmd_err:1;
+		/**
+		 * [  2:  2](R/W1C/H) External DMA transfer completed
+		 * successfully.
+		 */
+		uint64_t dma_done:1;
+		/** [  1:  1](R/W1C/H) Operation specified by MIO_EMM_CMD
+		 * completed successfully.
+		 */
+		uint64_t cmd_done:1;
+		/**
+		 * [  0:  0](R/W1C/H) The next 512B block transfer of a
+		 * multiblock transfer has completed.
+		 */
+		uint64_t buf_done:1;
+#else /* Word 0 - Little Endian */
+		uint64_t buf_done:1;
+		uint64_t cmd_done:1;
+		uint64_t dma_done:1;
+		uint64_t cmd_err:1;
+		uint64_t dma_err:1;
+		uint64_t switch_done:1;
+		uint64_t switch_err:1;
+		uint64_t reserved_7_63:57;
+#endif /* Word 0 - End */
+	} s;
+	/* struct mio_emm_int_s cn; */
+};
+
+/**
+ * Register (RSL) mio_emm_int_ena_w1c
+ *
+ * eMMC Interrupt Enable Clear Register
+ * This register clears interrupt enable bits.
+ */
+union mio_emm_int_ena_w1c {
+	uint64_t u;
+	struct mio_emm_int_ena_w1c_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t reserved_7_63:57;
+		/**
+		 * [  6:  6](R/W1C/H) Reads or clears enable for
+		 * MIO_EMM_INT[SWITCH_ERR].
+		 */
+		uint64_t switch_err:1;
+		/**
+		 * [  5:  5](R/W1C/H) Reads or clears enable for
+		 * MIO_EMM_INT[SWITCH_DONE].
+		 */
+		uint64_t switch_done:1;
+		/**
+		 * [  4:  4](R/W1C/H) Reads or clears enable for
+		 * MIO_EMM_INT[DMA_ERR].
+		 */
+		uint64_t dma_err:1;
+		/**
+		 * [  3:  3](R/W1C/H) Reads or clears enable for
+		 * MIO_EMM_INT[CMD_ERR].
+		 */
+		uint64_t cmd_err:1;
+		/**
+		 * [  2:  2](R/W1C/H) Reads or clears enable for
+		 * MIO_EMM_INT[DMA_DONE].
+		 */
+		uint64_t dma_done:1;
+		/**
+		 * [  1:  1](R/W1C/H) Reads or clears enable for
+		 * MIO_EMM_INT[CMD_DONE].
+		 */
+		uint64_t cmd_done:1;
+		/** [  0:  0](R/W1C/H) Reads or clears enable for
+		 * MIO_EMM_INT[BUF_DONE].
+		 */
+		uint64_t buf_done:1;
+#else /* Word 0 - Little Endian */
+		uint64_t buf_done:1;
+		uint64_t cmd_done:1;
+		uint64_t dma_done:1;
+		uint64_t cmd_err:1;
+		uint64_t dma_err:1;
+		uint64_t switch_done:1;
+		uint64_t switch_err:1;
+		uint64_t reserved_7_63:57;
+#endif /* Word 0 - End */
+	} s;
+	/* struct mio_emm_int_ena_w1c_s cn; */
+};
+
+/**
+ * Register (RSL) mio_emm_int_ena_w1s
+ *
+ * eMMC Interrupt Enable Set Register
+ * This register sets interrupt enable bits.
+ */
+union mio_emm_int_ena_w1s {
+	uint64_t u;
+	struct mio_emm_int_ena_w1s_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t reserved_7_63:57;
+		/**
+		 * [  6:  6](R/W1S/H) Reads or sets enable for
+		 * MIO_EMM_INT[SWITCH_ERR].
+		 */
+		uint64_t switch_err:1;
+		/**
+		 * [  5:  5](R/W1S/H) Reads or sets enable for
+		 * MIO_EMM_INT[SWITCH_DONE].
+		 */
+		uint64_t switch_done:1;
+		/**
+		 * [  4:  4](R/W1S/H) Reads or sets enable for
+		 * MIO_EMM_INT[DMA_ERR].
+		 */
+		uint64_t dma_err:1;
+		/**
+		 * [  3:  3](R/W1S/H) Reads or sets enable for
+		 * MIO_EMM_INT[CMD_ERR].
+		 */
+		uint64_t cmd_err:1;
+		/** [  2:  2](R/W1S/H) Reads or sets enable for
+		 * MIO_EMM_INT[DMA_DONE].
+		 */
+		uint64_t dma_done:1;
+		/**
+		 * [  1:  1](R/W1S/H) Reads or sets enable for
+		 * MIO_EMM_INT[CMD_DONE].
+		 */
+		uint64_t cmd_done:1;
+		/**
+		 * [  0:  0](R/W1S/H) Reads or sets enable for
+		 * MIO_EMM_INT[BUF_DONE].
+		 */
+		uint64_t buf_done:1;
+#else /* Word 0 - Little Endian */
+		uint64_t buf_done:1;
+		uint64_t cmd_done:1;
+		uint64_t dma_done:1;
+		uint64_t cmd_err:1;
+		uint64_t dma_err:1;
+		uint64_t switch_done:1;
+		uint64_t switch_err:1;
+		uint64_t reserved_7_63:57;
+#endif /* Word 0 - End */
+	} s;
+	/* struct mio_emm_int_ena_w1s_s cn; */
+};
+
+/**
+ * Register (RSL) mio_emm_int_w1s
+ *
+ * eMMC Interrupt Set Register
+ * This register sets interrupt bits.
+ */
+union mio_emm_int_w1s {
+	uint64_t u;
+	struct mio_emm_int_w1s_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t reserved_7_63:57;
+		/** [  6:  6](R/W1S/H) Reads or sets MIO_EMM_INT[SWITCH_ERR]. */
+		uint64_t switch_err:1;
+		/**
+		 * [  5:  5](R/W1S/H) Reads or sets MIO_EMM_INT[SWITCH_DONE].
+		 */
+		uint64_t switch_done:1;
+		/** [  4:  4](R/W1S/H) Reads or sets MIO_EMM_INT[DMA_ERR]. */
+		uint64_t dma_err:1;
+		/** [  3:  3](R/W1S/H) Reads or sets MIO_EMM_INT[CMD_ERR]. */
+		uint64_t cmd_err:1;
+		/** [  2:  2](R/W1S/H) Reads or sets MIO_EMM_INT[DMA_DONE]. */
+		uint64_t dma_done:1;
+		/** [  1:  1](R/W1S/H) Reads or sets MIO_EMM_INT[CMD_DONE]. */
+		uint64_t cmd_done:1;
+		/** [  0:  0](R/W1S/H) Reads or sets MIO_EMM_INT[BUF_DONE]. */
+		uint64_t buf_done:1;
+#else /* Word 0 - Little Endian */
+		uint64_t buf_done:1;
+		uint64_t cmd_done:1;
+		uint64_t dma_done:1;
+		uint64_t cmd_err:1;
+		uint64_t dma_err:1;
+		uint64_t switch_done:1;
+		uint64_t switch_err:1;
+		uint64_t reserved_7_63:57;
+#endif /* Word 0 - End */
+	} s;
+	/* struct mio_emm_int_w1s_s cn; */
+};
+
+/**
+ * Register (RSL) mio_emm_mode#
+ *
+ * eMMC Operating Mode Register
+ */
+union mio_emm_modex {
+	uint64_t u;
+	struct mio_emm_modex_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t reserved_49_63:15;
+		/**
+		 * [ 48: 48](RO/H) Current high-speed timing mode.  Required
+		 * when CLK frequency is higher than 20 MHz.
+		 */
+		uint64_t hs_timing:1;
+		uint64_t reserved_43_47:5;
+		/**
+		 * [ 42: 40](RO/H) Current card bus mode. Out of reset, the
+		 * card is in 1-bit data bus mode. Select bus width.
+		 * 0x0 = 1-bit data b*us (power on).
+		 * 0x1 = 4-bit data bus.
+		 * 0x2 = 8-bit data bus.
+		 * 0x3 = Reserved.
+		 * 0x4 = Reserved.
+		 * 0x5 = 4-bit data bus (dual data rate).
+		 * 0x6 = 8-bit data bus (dual data rate).
+		 * 0x7 = Reserved.
+		 * 0x8 = Reserved.
+		 */
+		uint64_t bus_width:3;
+		uint64_t reserved_36_39:4;
+		/**
+		 * [ 35: 32](RO/H) Out of reset, the card power class is 0,
+		 * which is the minimum current consumption class for the card.
+		 * EXT_CSD bytes [203:200] and [239:238] contain the power class
+		 * for different BUS_WITDH and CLK frequencies.  Software should
+		 * write this field with the 4-bit field from the EXT_CSD bytes
+		 * corresponding to the selected operating mode.
+		 */
+		uint64_t power_class:4;
+		/**
+		 * [ 31: 16](RO/H) Current number of coprocessor-clocks to hold
+		 * the eMMC CLK pin high.
+		 */
+		uint64_t clk_hi:16;
+		/**
+		 * [ 15:  0](RO/H) Current number of coprocessor-clocks to
+		 * hold the eMMC CLK pin low.
+		 */
+		uint64_t clk_lo:16;
+#else /* Word 0 - Little Endian */
+		uint64_t clk_lo:16;
+		uint64_t clk_hi:16;
+		uint64_t power_class:4;
+		uint64_t reserved_36_39:4;
+		uint64_t bus_width:3;
+		uint64_t reserved_43_47:5;
+		uint64_t hs_timing:1;
+		uint64_t reserved_49_63:15;
+#endif /* Word 0 - End */
+	} s;
+	/* struct mio_emm_modex_s cn; */
+};
+
+/**
+ * Register (RSL) mio_emm_msix_pba#
+ *
+ * eMMC MSI-X Pending Bit Array Registers
+ * This register is the MSI-X PBA table; the bit number is indexed by the
+ * MIO_EMM_INT_VEC_E enumeration.
+ */
+union mio_emm_msix_pbax {
+	uint64_t u;
+	struct mio_emm_msix_pbax_s {
+		/**
+		 * [ 63:  0](RO/H) Pending message for the associated
+		 * MIO_EMM_MSIX_VEC()_CTL, enumerated by MIO_EMM_INT_VEC_E.
+		 * Bits that have no associated MIO_EMM_INT_VEC_E are 0.
+		 */
+		uint64_t pend:64;
+	} s;
+	/* struct mio_emm_msix_pbax_s cn; */
+};
+
+/**
+ * Register (RSL) mio_emm_msix_vec#_addr
+ *
+ * eMMC MSI-X Vector-Table Address Register
+ * This register is the MSI-X vector table, indexed by the MIO_EMM_INT_VEC_E
+ * enumeration.
+ */
+union mio_emm_msix_vecx_addr {
+	uint64_t u;
+	struct mio_emm_msix_vecx_addr_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t reserved_49_63:15;
+		/**
+		 * [ 48:  2](R/W) IOVA to use for MSI-X delivery of this vector.
+		 */
+		uint64_t addr:47;
+		uint64_t reserved_1:1;
+		/**
+		 * [  0:  0](SR/W) Secure vector.
+		 * 0 = This vector may be read or written by either secure or
+		 *     nonsecure states.
+		 * 1 = This vector's MIO_EMM_MSIX_VEC()_ADDR,
+		 *     MIO_EMM_MSIX_VEC()_CTL, and corresponding bit of
+		 *     MIO_EMM_MSIX_PBA() are RAZ/WI and does not cause a fault
+		 *     when accessed by the nonsecure world.
+		 *
+		 * If PCCPF_MIO_EMM_VSEC_SCTL[MSIX_SEC] (for documentation, see
+		 * PCCPF_XXX_VSEC_SCTL[MSIX_SEC]) is set, all vectors are secure
+		 * and function as if [SECVEC] was set.
+		 */
+		uint64_t secvec:1;
+#else /* Word 0 - Little Endian */
+		uint64_t secvec:1;
+		uint64_t reserved_1:1;
+		uint64_t addr:47;
+		uint64_t reserved_49_63:15;
+#endif /* Word 0 - End */
+	} s;
+	/* struct mio_emm_msix_vecx_addr_s cn; */
+};
+
+/**
+ * Register (RSL) mio_emm_msix_vec#_ctl
+ *
+ * eMMC MSI-X Vector-Table Control and Data Register
+ * This register is the MSI-X vector table, indexed by the MIO_EMM_INT_VEC_E
+ * enumeration.
+ */
+union mio_emm_msix_vecx_ctl {
+	uint64_t u;
+	struct mio_emm_msix_vecx_ctl_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t reserved_33_63:31;
+		/**
+		 * [ 32: 32](R/W) When set, no MSI-X interrupts are sent to this
+		 * vector.
+		 */
+		uint64_t mask:1;
+		uint64_t reserved_20_31:12;
+		/**
+		 * [ 19:  0](R/W) Data to use for MSI-X delivery of this vector.
+		 */
+		uint64_t data:20;
+#else /* Word 0 - Little Endian */
+		uint64_t data:20;
+		uint64_t reserved_20_31:12;
+		uint64_t mask:1;
+		uint64_t reserved_33_63:31;
+#endif /* Word 0 - End */
+	} s;
+	/* struct mio_emm_msix_vecx_ctl_s cn; */
+};
+
+/**
+ * Register (RSL) mio_emm_rca
+ *
+ * eMMC Relative Card Address Register
+ */
+union mio_emm_rca {
+	uint64_t u;
+	struct mio_emm_rca_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t reserved_16_63:48;
+		/**
+		 * [ 15:  0](R/W/H) Whenever software performs CMD7, hardware
+		 * updates [CARD_RCA] with the relative card address from the
+		 * MIO_EMM_CMD[ARG], unless the operation encounters an error.
+		 */
+		uint64_t card_rca:16;
+#else /* Word 0 - Little Endian */
+		uint64_t card_rca:16;
+		uint64_t reserved_16_63:48;
+#endif /* Word 0 - End */
+	} s;
+	/* struct mio_emm_rca_s cn; */
+};
+
+/**
+ * Register (RSL) mio_emm_rsp_hi
+ *
+ * eMMC Response Data High Register
+ */
+union mio_emm_rsp_hi {
+	uint64_t u;
+	struct mio_emm_rsp_hi_s {
+		/**
+		 * [ 63:  0](RO/H) Command response (as per JEDEC eMMC spec and
+		 * SD Specifications):
+		 * _ RSP_TYPE = 1: DAT[63:0] = 0x0.   *
+		 * _ RSP_TYPE = 2: DAT[63:0] = CID[127:64] or CSD[127:64].
+		 * _ RSP_TYPE = 3: DAT[63:0] = 0x0.
+		 * _ RSP_TYPE = 4: DAT[63:0] = 0x0.
+		 * _ RSP_TYPE = 5: DAT[63:0] = 0x0.
+		 */
+		uint64_t dat:64;
+	} s;
+	/* struct mio_emm_rsp_hi_s cn; */
+};
+
+/**
+ * Register (RSL) mio_emm_rsp_lo
+ *
+ * eMMC Response Data Low Register
+ */
+union mio_emm_rsp_lo {
+	uint64_t u;
+	struct mio_emm_rsp_lo_s {
+		/**
+		 * [ 63:  0](RO/H) Command response (as per JEDEC eMMC spec and
+		 * SD Specifications).
+		 *
+		 *
+		 * RSP_TYPE = 1:
+		 * DAT[63:46] = 0x0
+		 * DAT[45:40] = Command index
+		 * DAT[39: 8] = Card status
+		 * DAT[ 7: 1] = CRC7
+		 * DAT[    0] = End bit
+		 *
+		 * RSP_TYPE = 2:
+		 * DAT[63: 1] = CID[63:1] or CSD[63:1] including CRC
+		 * DAT[    0] = End bit
+		 *
+		 * RSP_TYPE = 3:
+		 * DAT[63:46] = 0x0
+		 * DAT[45:40] = Check bits (0x3F)
+		 * DAT[39: 8] = OCR register
+		 * DAT[ 7: 1] = Check bits (0x7F)
+		 * DAT[    0] = End bit
+		 *
+		 * RSP_TYPE = 4:
+		 * DAT[63:46] = 0x0
+		 * DAT[45:40] = CMD39 ('10111')
+		 * DAT[39:24] = RCA[31:16]
+		 * DAT[   23] = Status
+		 * DAT[22:16] = Register address
+		 * DAT[15: 8] = Register contents
+		 * DAT[ 7: 1] = CRC7
+		 * DAT[    0] = End bit
+		 *
+		 * RSP_TYPE = 5:
+		 * DAT[63:46] = 0x0
+		 * DAT[45:40] = CMD40 ('10100')
+		 * DAT[39:24] = RCA[31:16]
+		 * DAT[   23] = Status
+		 * DAT[22:16] = Register address
+		 * DAT[15: 8] = Not defined. May be used for IRQ data
+		 * DAT[ 7: 1] = CRC7
+		 * DAT[    0] = End bit
+		 */
+		uint64_t dat:64;
+	} s;
+	/* struct mio_emm_rsp_lo_s cn; */
+};
+
+/**
+ * Register (RSL) mio_emm_rsp_sts
+ *
+ * eMMC Response Status Register
+ */
+union mio_emm_rsp_sts {
+	uint64_t u;
+	struct mio_emm_rsp_sts_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t reserved_62_63:2;
+		/**
+		 * [ 61: 60](RO/H) eMMC bus ID to which the response status
+		 * corresponds.
+		 */
+		uint64_t bus_id:2;
+		/**
+		 * [ 59: 59](RO/H) Read-only copy of MIO_EMM_CMD[CMD_VAL].
+		 * [CMD_VAL] = 1 indicates that a direct operation is in
+		 * progress.
+		 */
+		uint64_t cmd_val:1;
+		/**
+		 * [ 58: 58](RO/H) Read-only copy of MIO_EMM_SWITCH[SWITCH_EXE].
+		 * [SWITCH_VAL] = 1 indicates that a switch operation is in
+		 * progress.
+		 */
+		uint64_t switch_val:1;
+		/**
+		 * [ 57: 57](RO/H) Read-only copy of MIO_EMM_DMA[DMA_VAL].
+		 * [DMA_VAL] = 1 indicates that a DMA operation is in progress.
+		 */
+		uint64_t dma_val:1;
+		/**
+		 * [ 56: 56](RO/H) The DMA engine has a pending transfer
+		 * resulting from an error. Software can resume the transfer by
+		 * writing MIO_EMM_DMA[DMA_VAL] = 1.
+		 *
+		 * Software can terminate the transfer by writing
+		 * MIO_EMM_DMA[DMA_VAL] = 1 and MIO_EMM_DMA[DAT_NULL] = 1.
+		 * Hardware will then clear [DMA_PEND] and perform the DMA
+		 * operation.
+		 */
+		uint64_t dma_pend:1;
+		/**
+		 * [ 55: 55](RO/H) The store operation to the device took longer
+		 * than MIO_EMM_ACCESS_WDOG[CLK_CNT] coprocessor-clocks to
+		 * complete.
+		 * Valid when [DMA_PEND] is set.
+		 */
+		uint64_t acc_timeout:1;
+		uint64_t reserved_29_54:26;
+		/**
+		 * [ 28: 28](RO/H) For [CMD_TYPE] = 1, indicates that a DMA read
+		 * data arrived from the card without a free DBUF.  For
+		 * [CMD_TYPE] = 2, indicates a DBUF underflow occurred during a
+		 * DMA write. See MIO_EMM_DMA[THRES].
+		 */
+		uint64_t dbuf_err:1;
+		uint64_t reserved_24_27:4;
+		/**
+		 * [ 23: 23](RO/H) DBUF corresponding to the most recently
+		 * attempted block transfer.
+		 */
+		uint64_t dbuf:1;
+		/**
+		 * [ 22: 22](RO/H) Timeout waiting for read data or 3-bit CRC
+		 * token.
+		 */
+		uint64_t blk_timeout:1;
+		/**
+		 * [ 21: 21](RO/H) For [CMD_TYPE] = 1, indicates a card read
+		 * data CRC mismatch.  MIO_EMM_RSP_STS[DBUF] indicates the
+		 * failing data buffer.
+		 *
+		 * For [CMD_TYPE] = 2, indicates card returned 3-bit CRC status
+		 * token indicating that the card encountered a write data CRC
+		 * check mismatch.  MIO_EMM_RSP_STS[DBUF] indicates the failing
+		 * data buffer.
+		 */
+		uint64_t blk_crc_err:1;
+		/**
+		 * [ 20: 20](RO/H) Debug only. eMMC protocol utilizes DAT0 as a
+		 * busy signal during block writes and R1b responses.  This bit
+		 * should read zero before any DMA or Command with data is
+		 * executed.
+		 */
+		uint64_t rsp_busybit:1;
+		/** [ 19: 19](RO/H) Stop transmission response timeout. */
+		uint64_t stp_timeout:1;
+		/**
+		 * [ 18: 18](RO/H) Stop transmission response had a CRC error.
+		 */
+		uint64_t stp_crc_err:1;
+		/**
+		 * [ 17: 17](RO/H) Stop transmission response had bad status.
+		 */
+		uint64_t stp_bad_sts:1;
+		/** [ 16: 16](RO/H) Stop transmission response valid. */
+		uint64_t stp_val:1;
+		/** [ 15: 15](RO/H) Response timeout. */
+		uint64_t rsp_timeout:1;
+		/** [ 14: 14](RO/H) Response CRC error. */
+		uint64_t rsp_crc_err:1;
+		/** [ 13: 13](RO/H) Response bad status. */
+		uint64_t rsp_bad_sts:1;
+		/**
+		 * [ 12: 12](RO/H) Response ID.  See
+		 * MIO_EMM_RSP_HI/MIO_EMM_RSP_LO.
+		 */
+		uint64_t rsp_val:1;
+		/**
+		 * [ 11:  9](RO/H) Indicates the response type.  See
+		 * MIO_EMM_RSP_HI/MIO_EMM_RSP_LO.
+		 */
+		uint64_t rsp_type:3;
+		/**
+		 * [  8:  7](RO/H) eMMC command type.
+		 * 0x0 = No data.
+		 * 0x1 = Read.
+		 * 0x2 = Write.
+		 */
+		uint64_t cmd_type:2;
+		/**
+		 * [  6:  1](RO/H) eMMC command index most recently attempted.
+		 */
+		uint64_t cmd_idx:6;
+		/**
+		 * [  0:  0](RO/H) eMMC command completed.  Once the command has
+		 * completed, the status is final and can be examined by
+		 * software.
+		 */
+		uint64_t cmd_done:1;
+#else /* Word 0 - Little Endian */
+		uint64_t cmd_done:1;
+		uint64_t cmd_idx:6;
+		uint64_t cmd_type:2;
+		uint64_t rsp_type:3;
+		uint64_t rsp_val:1;
+		uint64_t rsp_bad_sts:1;
+		uint64_t rsp_crc_err:1;
+		uint64_t rsp_timeout:1;
+		uint64_t stp_val:1;
+		uint64_t stp_bad_sts:1;
+		uint64_t stp_crc_err:1;
+		uint64_t stp_timeout:1;
+		uint64_t rsp_busybit:1;
+		uint64_t blk_crc_err:1;
+		uint64_t blk_timeout:1;
+		uint64_t dbuf:1;
+		uint64_t reserved_24_27:4;
+		uint64_t dbuf_err:1;
+		uint64_t reserved_29_54:26;
+		uint64_t acc_timeout:1;
+		uint64_t dma_pend:1;
+		uint64_t dma_val:1;
+		uint64_t switch_val:1;
+		uint64_t cmd_val:1;
+		uint64_t bus_id:2;
+		uint64_t reserved_62_63:2;
+#endif /* Word 0 - End */
+	} s;
+	/* struct mio_emm_rsp_sts_s cn; */
+};
+
+/**
+ * Register (RSL) mio_emm_sample
+ *
+ * eMMC Sampling Register
+ */
+union mio_emm_sample {
+	uint64_t u;
+	struct mio_emm_sample_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t reserved_26_63:38;
+		/**
+		 * [ 25: 16](R/W) Number of coprocessor-clocks before the eMMC
+		 * clock rising edge to sample the command pin.
+		 */
+		uint64_t cmd_cnt:10;
+		uint64_t reserved_10_15:6;
+		/**
+		 * [  9:  0](R/W) Number of coprocessor-clocks before the eMMC
+		 * clock edge to sample the data pin.
+		 */
+		uint64_t dat_cnt:10;
+#else /* Word 0 - Little Endian */
+		uint64_t dat_cnt:10;
+		uint64_t reserved_10_15:6;
+		uint64_t cmd_cnt:10;
+		uint64_t reserved_26_63:38;
+#endif /* Word 0 - End */
+	} s;
+	/* struct mio_emm_sample_s cn; */
+};
+
+/**
+ * Register (RSL) mio_emm_sts_mask
+ *
+ * eMMC Status Mask Register
+ */
+union mio_emm_sts_mask {
+	uint64_t u;
+	struct mio_emm_sts_mask_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t reserved_32_63:32;
+		/**
+		 * [ 31:  0](R/W) Any bit set in [STS_MSK] causes the
+		 * corresponding bit in the card status to be considered when
+		 * computing response bad status.
+		 */
+		uint64_t sts_msk:32;
+#else /* Word 0 - Little Endian */
+		uint64_t sts_msk:32;
+		uint64_t reserved_32_63:32;
+#endif /* Word 0 - End */
+	} s;
+	/* struct mio_emm_sts_mask_s cn; */
+};
+
+/**
+ * Register (RSL) mio_emm_switch
+ *
+ * eMMC Operating Mode Switch Register
+ */
+union mio_emm_switch {
+	uint64_t u;
+	struct mio_emm_switch_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t reserved_62_63:2;
+		/** [ 61: 60](R/W/H) Specifies the eMMC bus id. */
+		uint64_t bus_id:2;
+		/**
+		 * [ 59: 59](R/W/H) When clear, the operating modes are updated
+		 * directly without performing any SWITCH operations.  This
+		 * allows software to perform the SWITCH operations manually,
+		 * then update the hardware.
+		 *
+		 * Software writes this bit to a 1 to indicate that hardware
+		 * should perform the necessary SWITCH operations.
+		 *
+		 * First, the POWER_CLASS switch is performed.  If it fails,
+		 * [SWITCH_ERR0] is set and the remaining SWITCH operations are
+		 * not performed.  If it succeeds, [POWER_CLASS] is updated and
+		 * the HS_TIMING switch is performed.
+		 *
+		 * If the HS_TIMING switch fails, [SWITCH_ERR1] is set and the
+		 * remaining SWITCH operations are not performed.  If it
+		 * succeeds, [HS_TIMING] is updated and the BUS_WIDTH switch
+		 * operation is performed.
+		 *
+		 * If the BUS_WIDTH switch operation fails, [SWITCH_ERR2] is
+		 * set.  If it succeeds, the BUS_WITDH is updated.
+		 *
+		 * Changes to CLK_HI and CLK_LO are discarded if any SWITCH_ERR
+		 * occurs.
+		 */
+		uint64_t switch_exe:1;
+		/**
+		 * [ 58: 58](RO/H) Error encountered while performing
+		 * POWER_CLASS switch. See MIO_EMM_RSP_STS.
+		 */
+		uint64_t switch_err0:1;
+		/**
+		 * [ 57: 57](RO/H) Error encountered while performing HS_TIMING
+		 * switch.  See MIO_EMM_RSP_STS.
+		 */
+		uint64_t switch_err1:1;
+		/**
+		 * [ 56: 56](RO/H) Error encountered while performing BUS_WIDTH
+		 * switch. See MIO_EMM_RSP_STS.
+		 */
+		uint64_t switch_err2:1;
+		uint64_t reserved_49_55:7;
+		/** [ 48: 48](R/W) Requested update to HS_TIMING. */
+		uint64_t hs_timing:1;
+		uint64_t reserved_43_47:5;
+		/** [ 42: 40](R/W) Requested update to BUS_WIDTH. */
+		uint64_t bus_width:3;
+		uint64_t reserved_36_39:4;
+		/** [ 35: 32](R/W) Requested update to POWER_CLASS. */
+		uint64_t power_class:4;
+		/** [ 31: 16](R/W) Requested update to CLK_HI. */
+		uint64_t clk_hi:16;
+		/** [ 15:  0](R/W) Requested update to CLK_LO. */
+		uint64_t clk_lo:16;
+#else /* Word 0 - Little Endian */
+		uint64_t clk_lo:16;
+		uint64_t clk_hi:16;
+		uint64_t power_class:4;
+		uint64_t reserved_36_39:4;
+		uint64_t bus_width:3;
+		uint64_t reserved_43_47:5;
+		uint64_t hs_timing:1;
+		uint64_t reserved_49_55:7;
+		uint64_t switch_err2:1;
+		uint64_t switch_err1:1;
+		uint64_t switch_err0:1;
+		uint64_t switch_exe:1;
+		uint64_t bus_id:2;
+		uint64_t reserved_62_63:2;
+#endif /* Word 0 - End */
+	} s;
+	/* struct mio_emm_switch_s cn; */
+};
+
+/**
+ * Register (RSL) mio_emm_wdog
+ *
+ * eMMC Watchdog Register
+ */
+union mio_emm_wdog {
+	uint64_t u;
+	struct mio_emm_wdog_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t reserved_26_63:38;
+		/**
+		 * [ 25:  0](R/W) Maximum number of CLK_CNT cycles to wait for
+		 * the card to return a response, read data, or the 3-bit CRC
+		 * status token following write data.  The following timeouts
+		 * are detected:
+		 *
+		 * Expected response to a command doesn't occur causing
+		 * MIO_EMM_RSP_STS[RSP_TIMEOUT].
+		 *
+		 * On a read command, expected data isn't returned causing
+		 * MIO_EMM_RSP_STS[BLK_TIMEOUT].
+		 *
+		 * On a multi read command, expected data isn't returned causing
+		 * MIO_EMM_RSP_STS[BLK_TIMEOUT].
+		 *
+		 * On a write command, expected token to a write block isn't
+		 * received causing MIO_EMM_RSP_STS[BLK_TIMEOUT].
+		 *
+		 * If a stop command is issued by the hardware and no response
+		 * is returned causing MIO_EMM_RSP_STS[STP_TIMEOUT].
+		 *
+		 * Issues this timeout doesn't cover are stalls induced by the
+		 * card which are not limited by the specifications.
+		 * For example, when a write multi command is issued to the card
+		 * and a block (not the last) is transferred the card can
+		 * "stall" CNXXXX by forcing emmc_data<0> low for as long as
+		 * it wants to free up buffer space.
+		 *
+		 * The second case is when the last block of a write or multi
+		 * write is being transferred and the card elects to perform
+		 * some background tasks. The same stall mechanism with
+		 * emmc_data<0> is used but this can last for an extend time
+		 * period.
+		 */
+		uint64_t clk_cnt:26;
+#else /* Word 0 - Little Endian */
+		uint64_t clk_cnt:26;
+		uint64_t reserved_26_63:38;
+#endif /* Word 0 - End */
+	} s;
+	/* struct mio_emm_wdog_s cn; */
+};
+
+/**
+ * Returns the card write protect status
+ *
+ * @param mmc	pointer to mmc data structure
+ * @return 1 if card is write protected, 0 otherwise
+ */
+int cavium_mmc_getwp(struct udevice *dev);
+
+/**
+ * Gets the card-detect status
+ *
+ * @param mmc	pointer to mmc data structure
+ *
+ * @return	1 if card is detected, false if not detected.
+ */
+int cavium_mmc_getcd(struct udevice *dev);
+
+
+#endif /* __OCTEON_MMC_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx2/cavm-csrs-mio_emm.h b/arch/arm/include/asm/arch-octeontx2/cavm-csrs-mio_emm.h
new file mode 120000
index 0000000..303a622
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx2/cavm-csrs-mio_emm.h
@@ -0,0 +1 @@
+../arch-octeontx/cavm-csrs-mio_emm.h
\ No newline at end of file
diff --git a/arch/arm/include/asm/arch-octeontx2/clock.h b/arch/arm/include/asm/arch-octeontx2/clock.h
new file mode 100644
index 0000000..d436495
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx2/clock.h
@@ -0,0 +1,231 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#ifndef __OCTEONTX2_CLOCK_H__
+
+/** System PLL reference clock */
+#define PLL_REF_CLK                     50000000        /* 50 MHz */
+#define NS_PER_REF_CLK_TICK             (1000000000/PLL_REF_CLK)
+
+/** Address of RST_BOOT register */
+#define RST_BOOT	0x87e006001600ll
+
+/**
+ * Register (RSL) rst_boot
+ *
+ * RST Boot Register
+ */
+union cavm_rst_boot {
+	u64 u;
+	struct cavm_rst_boot_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		u64 chipkill:1;
+		u64 jtcsrdis:1;
+		u64 ejtagdis:1;
+		u64 trusted_mode:1;
+		u64 ckill_ppdis:1;
+		u64 jt_tstmode:1;
+		u64 vrm_err:1;
+		u64 dis_huk:1;
+		u64 dis_scan:1;
+		u64 reserved_47_54:8;
+		u64 c_mul:7;
+		u64 reserved_39:1;
+		u64 pnr_mul:6;
+		u64 lboot_oci:3;
+		u64 lboot_pf_flr:4;
+		u64 lboot_ckill:1;
+		u64 lboot_jtg:1;
+		u64 lboot_ext45:6;
+		u64 lboot_ext23:6;
+		u64 lboot:10;
+		u64 rboot:1;
+		u64 rboot_pin:1;
+#else /* Word 0 - Little Endian */
+		u64 rboot_pin:1;
+		u64 rboot:1;
+		u64 lboot:10;
+		u64 lboot_ext23:6;
+		u64 lboot_ext45:6;
+		u64 lboot_jtg:1;
+		u64 lboot_ckill:1;
+		u64 lboot_pf_flr:4;
+		u64 lboot_oci:3;
+		u64 pnr_mul:6;
+		u64 reserved_39:1;
+		u64 c_mul:7;
+		u64 reserved_47_54:8;
+		u64 dis_scan:1;
+		u64 dis_huk:1;
+		u64 vrm_err:1;
+		u64 jt_tstmode:1;
+		u64 ckill_ppdis:1;
+		u64 trusted_mode:1;
+		u64 ejtagdis:1;
+		u64 jtcsrdis:1;
+		u64 chipkill:1;
+#endif /* Word 0 - End */
+	} s;
+	struct cavm_rst_boot_cn81xx {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		u64 chipkill:1;
+		u64 jtcsrdis:1;
+		u64 ejtagdis:1;
+		u64 trusted_mode:1;
+		u64 ckill_ppdis:1;
+		u64 jt_tstmode:1;
+		u64 vrm_err:1;
+		u64 dis_huk:1;
+		u64 dis_scan:1;
+		u64 reserved_47_54:8;
+		u64 c_mul:7;
+		u64 reserved_39:1;
+		u64 pnr_mul:6;
+		u64 lboot_oci:3;
+		u64 reserved_26_29:4;
+		u64 lboot_ckill:1;
+		u64 lboot_jtg:1;
+		u64 lboot_ext45:6;
+		u64 lboot_ext23:6;
+		u64 lboot:10;
+		u64 rboot:1;
+		u64 rboot_pin:1;
+#else /* Word 0 - Little Endian */
+		u64 rboot_pin:1;
+		u64 rboot:1;
+		u64 lboot:10;
+		u64 lboot_ext23:6;
+		u64 lboot_ext45:6;
+		u64 lboot_jtg:1;
+		u64 lboot_ckill:1;
+		u64 reserved_26_29:4;
+		u64 lboot_oci:3;
+		u64 pnr_mul:6;
+		u64 reserved_39:1;
+		u64 c_mul:7;
+		u64 reserved_47_54:8;
+		u64 dis_scan:1;
+		u64 dis_huk:1;
+		u64 vrm_err:1;
+		u64 jt_tstmode:1;
+		u64 ckill_ppdis:1;
+		u64 trusted_mode:1;
+		u64 ejtagdis:1;
+		u64 jtcsrdis:1;
+		u64 chipkill:1;
+#endif /* Word 0 - End */
+	} cn81xx;
+	struct cavm_rst_boot_cn88xx {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		u64 chipkill:1;
+		u64 jtcsrdis:1;
+		u64 ejtagdis:1;
+		u64 trusted_mode:1;
+		u64 ckill_ppdis:1;
+		u64 jt_tstmode:1;
+		u64 vrm_err:1;
+		u64 dis_huk:1;
+		u64 dis_scan:1;
+		u64 reserved_47_54:8;
+		u64 c_mul:7;
+		u64 reserved_39:1;
+		u64 pnr_mul:6;
+		u64 lboot_oci:3;
+		u64 reserved_26_29:4;
+		u64 reserved_24_25:2;
+		u64 lboot_ext45:6;
+		u64 lboot_ext23:6;
+		u64 lboot:10;
+		u64 rboot:1;
+		u64 rboot_pin:1;
+#else /* Word 0 - Little Endian */
+		u64 rboot_pin:1;
+		u64 rboot:1;
+		u64 lboot:10;
+		u64 lboot_ext23:6;
+		u64 lboot_ext45:6;
+		u64 reserved_24_25:2;
+		u64 reserved_26_29:4;
+		u64 lboot_oci:3;
+		u64 pnr_mul:6;
+		u64 reserved_39:1;
+		u64 c_mul:7;
+		u64 reserved_47_54:8;
+		u64 dis_scan:1;
+		u64 dis_huk:1;
+		u64 vrm_err:1;
+		u64 jt_tstmode:1;
+		u64 ckill_ppdis:1;
+		u64 trusted_mode:1;
+		u64 ejtagdis:1;
+		u64 jtcsrdis:1;
+		u64 chipkill:1;
+#endif /* Word 0 - End */
+	} cn88xx;
+	struct cavm_rst_boot_cn83xx {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		u64 chipkill:1;
+		u64 jtcsrdis:1;
+		u64 ejtagdis:1;
+		u64 trusted_mode:1;
+		u64 ckill_ppdis:1;
+		u64 jt_tstmode:1;
+		u64 vrm_err:1;
+		u64 dis_huk:1;
+		u64 dis_scan:1;
+		u64 reserved_47_54:8;
+		u64 c_mul:7;
+		u64 reserved_39:1;
+		u64 pnr_mul:6;
+		u64 lboot_oci:3;
+		u64 lboot_pf_flr:4;
+		u64 lboot_ckill:1;
+		u64 lboot_jtg:1;
+		u64 lboot_ext45:6;
+		u64 lboot_ext23:6;
+		u64 lboot:10;
+		u64 rboot:1;
+		u64 rboot_pin:1;
+#else /* Word 0 - Little Endian */
+		u64 rboot_pin:1;
+		u64 rboot:1;
+		u64 lboot:10;
+		u64 lboot_ext23:6;
+		u64 lboot_ext45:6;
+		u64 lboot_jtg:1;
+		u64 lboot_ckill:1;
+		u64 lboot_pf_flr:4;
+		u64 lboot_oci:3;
+		u64 pnr_mul:6;
+		u64 reserved_39:1;
+		u64 c_mul:7;
+		u64 reserved_47_54:8;
+		u64 dis_scan:1;
+		u64 dis_huk:1;
+		u64 vrm_err:1;
+		u64 jt_tstmode:1;
+		u64 ckill_ppdis:1;
+		u64 trusted_mode:1;
+		u64 ejtagdis:1;
+		u64 jtcsrdis:1;
+		u64 chipkill:1;
+#endif /* Word 0 - End */
+	} cn83xx;
+};
+
+/**
+ * Returns the I/O clock speed in Hz
+ */
+u64 octeontx_get_io_clock(void);
+
+/**
+ * Returns the core clock speed in Hz
+ */
+u64 octeontx_get_core_clock(void);
+
+#endif /* __OCTEONTX2_CLOCK_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx2/fdt-helper.h b/arch/arm/include/asm/arch-octeontx2/fdt-helper.h
new file mode 100644
index 0000000..b01dbe0
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx2/fdt-helper.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#ifndef __FDT_HELPER_H__
+#define __FDT_HELPER_H__
+
+/**
+ * Given a FDT node, check if it is compatible with a list of devices
+ *
+ * @param[in]	fdt		Flat device tree pointer
+ * @param	node_offset	Node offset in device tree
+ * @param[in]	strlist		Array of FDT devices to check, end must be NULL
+ *
+ * @return	0 if at least one device is compatible, 1 if not compatible.
+ */
+int cavium_fdt_node_check_compatible(const void *fdt, int node_offset,
+				     const char * const *strlist);
+
+/**
+ * Given a FDT node, return the next compatible node.
+ *
+ * @param[in]	fdt_addr	Pointer to flat device tree
+ * @param	start_offset	Starting node offset or -1 to find the first
+ * @param	strlist		Array of FDT device compatibility strings, must
+ *				end with NULL or empty string.
+ *
+ * @return	next matching node or -1 if no more matches.
+ */
+int cavium_fdt_node_offset_by_compatible_list(const void *fdt_addr,
+					      int startoffset,
+					      const char * const *strlist);
+
+#endif /* __FDT_HELPER_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx2/octeontx2.h b/arch/arm/include/asm/arch-octeontx2/octeontx2.h
new file mode 100644
index 0000000..07b0a4c
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx2/octeontx2.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#ifndef __OCTEONTX2_H__
+#define __OCTEONTX2_H__
+
+#define CN98XX	0xB1
+#define CN96XX	0xB2
+#define CN95XX	0xB3
+#define LOKI	0xB4
+
+#define is_board_model(model)	(g_cavm_bdt.prod_id == (model))
+
+/** Reg offsets */
+#define CAVM_RST_BOOT		0x87E006001600ULL
+#define CAVM_RST_CHIP_DOM_W1S	0x87E006001810ULL
+
+#define CAVM_CPC_BOOT_OWNERX(a)	0x86D000000160ULL + (8 * a)
+
+#define CAVM_GTI_CWD_POKEX	0x802000050000ULL
+#define CAVM_GTI_CWD_WDOGX	0x802000040000ULL
+
+/** Structure definitions */
+/**
+ * Register (NCB32b) cpc_boot_owner#
+ *
+ * CPC Boot Owner Registers These registers control an external arbiter
+ * for the boot device (SPI/eMMC) across multiple external devices. There
+ * is a register for each requester: _ \<0\> - SCP          - reset on
+ * SCP reset _ \<1\> - MCP          - reset on MCP reset _ \<2\> - AP
+ * Secure    - reset on core reset _ \<3\> - AP Nonsecure - reset on core
+ * reset  These register is only writable to the corresponding
+ * requestor(s) permitted with CPC_PERMIT.
+ */
+union cavm_cpc_boot_ownerx {
+        u32 u;
+        struct cavm_cpc_boot_ownerx_s {
+                u32 boot_req                         : 1;
+                u32 reserved_1_7                     : 7;
+                u32 boot_wait                        : 1;
+                u32 reserved_9_31                    : 23;
+        } s;
+        /* struct cavm_cpc_boot_ownerx_s cn; */
+};
+
+
+/** Function definitions */
+void octeontx2_parse_board_info(void);
+void octeontx2_board_get_mac_addr(u8 index, u8 *mac_addr);
+void acquire_flash_arb(bool acquire);
+
+/** Board data definitions */
+struct cavm_bdt {
+	u8 resv[6];
+	u8 prod_id;
+	u8 alt_pkg;
+	char type[16];
+};
+extern struct cavm_bdt g_cavm_bdt;
+
+#endif /* __OCTEONTX2_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx2/octeontx2_fdt.h b/arch/arm/include/asm/arch-octeontx2/octeontx2_fdt.h
new file mode 100644
index 0000000..fb406c6
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx2/octeontx2_fdt.h
@@ -0,0 +1,13 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#ifndef __OCTEONTX2_FDT_H__
+#define __OCTEONTX2_FDT_H__
+
+
+#endif
diff --git a/arch/arm/include/asm/arch-octeontx2/octeontx2_svc.h b/arch/arm/include/asm/arch-octeontx2/octeontx2_svc.h
new file mode 100644
index 0000000..81d16f9
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx2/octeontx2_svc.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#ifndef __OCTEONTX2_SVC_H__
+#define __OCTEONTX2_SVC_H__
+
+/* SMC function IDs for general purpose queries */
+
+#define OCTEONTX2_SVC_CALL_COUNT		0xc200ff00
+#define OCTEONTX2_SVC_UID		0xc200ff01
+
+#define OCTEONTX2_SVC_VERSION		0xc200ff03
+
+/* OcteonTX Service Calls version numbers */
+#define OCTEONTX2_VERSION_MAJOR	0x1
+#define OCTEONTX2_VERSION_MINOR	0x0
+
+/* x1 - node number
+ */
+#define OCTEONTX2_DRAM_SIZE		0xc2000301
+#define OCTEONTX2_NODE_COUNT		0xc2000601
+#define OCTEONTX2_DISABLE_RVU_LFS	0xc2000b01
+
+#define OCTEONTX2_CONFIG_OOO		0xc2000b04
+
+/* fail safe */
+#define OCTEONTX2_FSAFE_PR_BOOT_SUCCESS	0xc2000b02
+#define OCTEONTX2_FSAFE_CLR_FORCE_SEC	0xc2000b03
+
+#define OCTEONTX2_MDIO_DBG_READ		0xc2000d01
+#define OCTEONTX2_MDIO_DBG_WRITE	0xc2000d02
+
+#endif /* __OCTEONTX2_SVC_H__ */
diff --git a/arch/arm/include/asm/arch-octeontx2/octeontx_mmc.h b/arch/arm/include/asm/arch-octeontx2/octeontx_mmc.h
new file mode 120000
index 0000000..dfa9755
--- /dev/null
+++ b/arch/arm/include/asm/arch-octeontx2/octeontx_mmc.h
@@ -0,0 +1 @@
+../arch-octeontx/octeontx_mmc.h
\ No newline at end of file
diff --git a/arch/arm/include/asm/gpio.h b/arch/arm/include/asm/gpio.h
index 1c5e873..2f92f89 100644
--- a/arch/arm/include/asm/gpio.h
+++ b/arch/arm/include/asm/gpio.h
@@ -1,4 +1,4 @@
-#if !defined(CONFIG_ARCH_UNIPHIER) && !defined(CONFIG_ARCH_STI)
+#if !defined(CONFIG_ARCH_UNIPHIER) && !defined(CONFIG_ARCH_STI) && !defined(CONFIG_ARM64)
 #include <asm/arch/gpio.h>
 #endif
 #include <asm-generic/gpio.h>
diff --git a/arch/arm/include/asm/io.h b/arch/arm/include/asm/io.h
index 5df7472..c1a7e7f 100644
--- a/arch/arm/include/asm/io.h
+++ b/arch/arm/include/asm/io.h
@@ -192,6 +192,15 @@ static inline void __raw_readsl(unsigned long addr, void *data, int longlen)
 #define setbits_8(addr, set) setbits(8, addr, set)
 #define clrsetbits_8(addr, clear, set) clrsetbits(8, addr, clear, set)
 
+#define clrbits_be64(addr, clear) clrbits(be64, addr, clear)
+#define setbits_be64(addr, set) setbits(be64, addr, set)
+#define clrsetbits_be64(addr, clear, set) clrsetbits(be64, addr, clear, set)
+
+#define clrbits_le64(addr, clear) clrbits(le64, addr, clear)
+#define setbits_le64(addr, set) setbits(le64, addr, set)
+#define clrsetbits_le64(addr, clear, set) clrsetbits(le64, addr, clear, set)
+
+
 /*
  * Now, pick up the machine-defined IO definitions
  */
diff --git a/arch/arm/include/asm/system.h b/arch/arm/include/asm/system.h
index 4f043ca..937b711 100644
--- a/arch/arm/include/asm/system.h
+++ b/arch/arm/include/asm/system.h
@@ -175,6 +175,41 @@ static inline unsigned long read_mpidr(void)
 	return val;
 }
 
+static inline unsigned long read_far(void)
+{
+	unsigned int el;
+	unsigned long val;
+
+	el = current_el();
+	if (el == 1)
+		asm volatile("mrs %0, far_el1" : "=r" (val) : : "cc");
+	else if (el == 2)
+		asm volatile("mrs %0, far_el2" : "=r" (val) : : "cc");
+	else
+		asm volatile("mrs %0, far_el3" : "=r" (val) : : "cc");
+
+	asm volatile("isb");
+
+	return val;
+}
+
+static inline long unsigned int read_spsr(void)
+{
+	unsigned int el, val;
+
+	el = current_el();
+	if (el == 1)
+		asm volatile("mrs %0, spsr_el1" : "=r" (val) : : "cc");
+	else if (el == 2)
+		asm volatile("mrs %0, spsr_el2" : "=r" (val) : : "cc");
+	else
+		asm volatile("mrs %0, spsr_el3" : "=r" (val) : : "cc");
+
+	asm volatile("isb");
+
+	return val;
+}
+
 #define BSP_COREID	0
 
 void __asm_flush_dcache_all(void);
diff --git a/arch/arm/lib/interrupts_64.c b/arch/arm/lib/interrupts_64.c
index 8a5d824..cf263b3 100644
--- a/arch/arm/lib/interrupts_64.c
+++ b/arch/arm/lib/interrupts_64.c
@@ -30,6 +30,11 @@ void show_regs(struct pt_regs *regs)
 {
 	int i;
 
+	printf("MPIDR:     %lx\n", read_mpidr());
+	printf("FAR:       %lx\n", read_far());
+	printf("SPSR:      %lx\n", read_spsr());
+	printf("Rel. offs: %lx\n", gd->reloc_off);
+
 	if (gd->flags & GD_FLG_RELOC)
 		printf("elr: %016lx lr : %016lx (reloc)\n",
 		       regs->elr - gd->reloc_off,
@@ -86,6 +91,9 @@ void do_bad_error(struct pt_regs *pt_regs, unsigned int esr)
 	panic("Resetting CPU ...\n");
 }
 
+__weak void plat_do_sync(void)
+{
+}
 /*
  * do_sync handles the Synchronous Abort exception.
  */
@@ -93,6 +101,8 @@ void do_sync(struct pt_regs *pt_regs, unsigned int esr)
 {
 	efi_restore_gd();
 	printf("\"Synchronous Abort\" handler, esr 0x%08x\n", esr);
+
+	plat_do_sync();
 	show_regs(pt_regs);
 	panic("Resetting CPU ...\n");
 }
diff --git a/arch/arm/mach-mvebu/Kconfig b/arch/arm/mach-mvebu/Kconfig
index 01d700b..1f2c19e 100644
--- a/arch/arm/mach-mvebu/Kconfig
+++ b/arch/arm/mach-mvebu/Kconfig
@@ -15,10 +15,6 @@ config ARMADA_32BIT
 	select BOARD_EARLY_INIT_F
 	select ARCH_MISC_INIT
 
-config ARMADA_64BIT
-	bool
-	select ARM64
-
 # ARMv7 SoCs...
 config ARMADA_375
 	bool
@@ -42,6 +38,7 @@ config ARMADA_3700
 config ARMADA_8K
 	bool
 	select ARM64
+	select HAVE_MVEBU_EFUSE
 
 # Armada PLL frequency (used for NAND clock generation)
 config SYS_MVEBU_PLL_CLOCK
@@ -102,6 +99,12 @@ config TARGET_MVEBU_ARMADA_8K
 	select BOARD_LATE_INIT
 	imply SCSI
 
+config TARGET_OCTEONTX2_CN913x
+	bool "Support CN913x"
+	select ARMADA_8K
+	select BOARD_LATE_INIT
+	imply SCSI
+
 config TARGET_DB_MV784MP_GP
 	bool "Support db-mv784mp-gp"
 	select MV78460
@@ -134,6 +137,7 @@ config SYS_BOARD
 	default "db-88f6820-amc" if TARGET_DB_88F6820_AMC
 	default "turris_omnia" if TARGET_TURRIS_OMNIA
 	default "mvebu_armada-8k" if TARGET_MVEBU_ARMADA_8K
+	default "octeontx2_cn913x" if TARGET_OCTEONTX2_CN913x
 	default "db-mv784mp-gp" if TARGET_DB_MV784MP_GP
 	default "ds414" if TARGET_DS414
 	default "maxbcm" if TARGET_MAXBCM
@@ -146,6 +150,7 @@ config SYS_CONFIG_NAME
 	default "db-88f6820-gp" if TARGET_DB_88F6820_GP
 	default "db-88f6820-amc" if TARGET_DB_88F6820_AMC
 	default "mvebu_armada-8k" if TARGET_MVEBU_ARMADA_8K
+	default "octeontx2_cn913x" if TARGET_OCTEONTX2_CN913x
 	default "db-mv784mp-gp" if TARGET_DB_MV784MP_GP
 	default "ds414" if TARGET_DS414
 	default "maxbcm" if TARGET_MAXBCM
@@ -159,6 +164,7 @@ config SYS_VENDOR
 	default "Marvell" if TARGET_DB_88F6820_GP
 	default "Marvell" if TARGET_DB_88F6820_AMC
 	default "Marvell" if TARGET_MVEBU_ARMADA_8K
+	default "Marvell" if TARGET_OCTEONTX2_CN913x
 	default "solidrun" if TARGET_CLEARFOG
 	default "Synology" if TARGET_DS414
 	default "CZ.NIC" if TARGET_TURRIS_OMNIA
@@ -181,23 +187,6 @@ endchoice
 
 endif
 
-config MVEBU_EFUSE
-	bool "Enable eFuse support"
-	default n
-	depends on HAVE_MVEBU_EFUSE
-	help
-	  Enable support for reading and writing eFuses on mvebu SoCs.
-
-config MVEBU_EFUSE_FAKE
-	bool "Fake eFuse access (dry run)"
-	default n
-	depends on MVEBU_EFUSE
-	help
-	  This enables a "dry run" mode where eFuses are not really programmed.
-	  Instead the eFuse accesses are emulated by writing to and reading
-	  from a memory block.
-	  This is can be used for testing prog scripts.
-
 config SECURED_MODE_IMAGE
 	bool "Build image for trusted boot"
 	default false
diff --git a/arch/arm/mach-mvebu/Makefile b/arch/arm/mach-mvebu/Makefile
index d4210af..081256a 100644
--- a/arch/arm/mach-mvebu/Makefile
+++ b/arch/arm/mach-mvebu/Makefile
@@ -9,7 +9,6 @@ ifdef CONFIG_ARM64
 obj-$(CONFIG_ARMADA_3700) += armada3700/
 obj-$(CONFIG_ARMADA_8K) += armada8k/
 obj-y += arm64-common.o
-obj-y += sata.o
 
 else # CONFIG_ARM64
 
@@ -27,7 +26,6 @@ ifndef CONFIG_SPL_BUILD
 obj-$(CONFIG_ARMADA_375) += ../../../drivers/ddr/marvell/axp/xor.o
 obj-$(CONFIG_ARMADA_38X) += ../../../drivers/ddr/marvell/a38x/xor.o
 obj-$(CONFIG_ARMADA_XP) += ../../../drivers/ddr/marvell/axp/xor.o
-obj-$(CONFIG_MVEBU_EFUSE) += efuse.o
 endif # CONFIG_SPL_BUILD
 obj-y	+= gpio.o
 obj-y	+= mbus.o
diff --git a/arch/arm/mach-mvebu/arm64-common.c b/arch/arm/mach-mvebu/arm64-common.c
index 3c84043..cbc980a 100644
--- a/arch/arm/mach-mvebu/arm64-common.c
+++ b/arch/arm/mach-mvebu/arm64-common.c
@@ -14,6 +14,8 @@
 #include <asm/arch/cpu.h>
 #include <asm/arch/soc.h>
 #include <asm/armv8/mmu.h>
+#include <power/regulator.h>
+#include <mach/fw_info.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -46,16 +48,24 @@ const struct mbus_dram_target_info *mvebu_mbus_dram_info(void)
 
 /* DRAM init code ... */
 
-int dram_init_banksize(void)
+__weak int mvebu_dram_init(void)
 {
-	fdtdec_setup_memory_banksize();
+	return fdtdec_setup_memory_size();
+}
 
-	return 0;
+__weak int mvebu_dram_init_banksize(void)
+{
+	return fdtdec_setup_memory_banksize();
+}
+
+int dram_init_banksize(void)
+{
+	return mvebu_dram_init_banksize();
 }
 
 int dram_init(void)
 {
-	if (fdtdec_setup_memory_size() != 0)
+	if (mvebu_dram_init() != 0)
 		return -EINVAL;
 
 	return 0;
@@ -73,6 +83,8 @@ int arch_early_init_r(void)
 	int ret;
 	int i;
 
+	printf("Running in RAM - U-Boot at: 0x%08lx\n", gd->relocaddr);
+	printf("                 Env at:    0x%08lx\n", gd->env_addr);
 	/*
 	 * Loop over all MISC uclass drivers to call the comphy code
 	 * and init all CP110 devices enabled in the DT
@@ -87,6 +99,16 @@ int arch_early_init_r(void)
 			break;
 	}
 
+	i = 0;
+	while (1) {
+		/* Call the pinctrl code via the PINCTRL uclass driver */
+		ret = uclass_get_device(UCLASS_PINCTRL, i++, &dev);
+
+		/* We're done, once no further CP110 device is found */
+		if (ret)
+			break;
+	}
+
 	/* Cause the SATA device to do its early init */
 	uclass_first_device(UCLASS_AHCI, &dev);
 
@@ -97,3 +119,24 @@ int arch_early_init_r(void)
 
 	return 0;
 }
+
+void plat_do_sync(void)
+{
+	u32 far, el;
+
+	el = current_el();
+
+	if (el == 1)
+		asm volatile("mrs %0, far_el1" : "=r" (far));
+	else if (el == 2)
+		asm volatile("mrs %0, far_el2" : "=r" (far));
+	else
+		asm volatile("mrs %0, far_el3" : "=r" (far));
+
+	if (far >= ATF_REGION_START && far <= ATF_REGION_END) {
+		pr_err("\n\tAttempt to access RT service or TEE region (addr: 0x%x, el%d)\n",
+		       far, el);
+		pr_err("\tDo not use address range 0x%x-0x%x\n\n",
+		       ATF_REGION_START, ATF_REGION_END);
+	}
+}
diff --git a/arch/arm/mach-mvebu/armada3700/Makefile b/arch/arm/mach-mvebu/armada3700/Makefile
index 84c69d9..33f2c52 100644
--- a/arch/arm/mach-mvebu/armada3700/Makefile
+++ b/arch/arm/mach-mvebu/armada3700/Makefile
@@ -5,3 +5,4 @@
 #
 
 obj-y = cpu.o
+obj-y += clock.o
diff --git a/arch/arm/mach-mvebu/armada3700/clock.c b/arch/arm/mach-mvebu/armada3700/clock.c
new file mode 100644
index 0000000..f81ba48
--- /dev/null
+++ b/arch/arm/mach-mvebu/armada3700/clock.c
@@ -0,0 +1,244 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0+
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <asm/arch/cpu.h>
+#include <asm/io.h>
+#include <asm/arch/soc.h>
+#include <mach/clock.h>
+
+#define NB_CLOCK_REGS_BASE	(MVEBU_REGISTER(0x13000))
+#define NB_PLL_BASE		(NB_CLOCK_REGS_BASE + 0x200)
+#define NB_TBG_CTRL0		(NB_PLL_BASE + 0x4)
+ #define NB_TBG_CTRL0_TBG_A_FBDIV_OFFSET		2
+ #define NB_TBG_CTRL0_TBG_A_FBDIV_MASK			0x1FFUL
+ #define NB_TBG_CTRL0_TBG_B_FBDIV_OFFSET		18
+ #define NB_TBG_CTRL0_TBG_B_FBDIV_MASK			0x1FFUL
+
+#define NB_TBG_CTRL1		(NB_PLL_BASE + 0x8)
+ #define NB_TBG_CTRL1_TBG_B_VCODIV_SEL_SE_OFFSET	16
+ #define NB_TBG_CTRL1_TBG_B_VCODIV_SEL_SE_MASK		0x1FFUL
+ #define NB_TBG_CTRL1_TBG_A_VCODIV_SEL_SE_MASK		0x1FFUL
+
+#define NB_TBG_CTRL7		(NB_PLL_BASE + 0x20)
+ #define NB_TBG_CTRL7_TBG_B_REFDIV_OFFSET		16
+ #define NB_TBG_CTRL7_TBG_B_REFDIV_MASK			0x1FFUL
+ #define NB_TBG_CTRL7_TBG_A_REFDIV_MASK			0x1FFUL
+
+#define NB_TBG_CTRL8		(NB_PLL_BASE + 0x30)
+ #define NB_TBG_CTRL8_TBG_A_VCODIV_SEL_DIFF_OFFSET	1
+ #define NB_TBG_CTRL8_TBG_A_VCODIV_SEL_DIFF_MASK	0x1FFUL
+ #define NB_TBG_CTRL8_TBG_B_VCODIV_SEL_DIFF_OFFSET	17
+ #define NB_TBG_CTRL8_TBG_B_VCODIV_SEL_DIFF_MASK	0x1FFUL
+
+#define NB_CLOCK_TBG_SELECT_REG	NB_CLOCK_REGS_BASE
+ #define NB_CLOCK_TBG_SEL_A53_CPU_PCLK_OFFSET		22
+ #define NB_CLOCK_TBG_SEL_A53_CPU_PCLK_MASK		0x3
+
+/* north bridge clock divider select registers */
+#define NB_CLOCK_DIV_SEL0_REG	(NB_CLOCK_REGS_BASE + 0x4)
+ #define NB_CLOCK_DIV_SEL0_A53_CPU_CLK_PRSCL_OFFSET	28
+ #define NB_CLOCK_DIV_SEL0_A53_CPU_CLK_PRSCL_MASK	0x7
+
+/* north bridge clock source register */
+#define NB_CLOCK_SELECT_REG	(NB_CLOCK_REGS_BASE + 0x10)
+ #define NB_CLOCK_SEL_DDR_PHY_CLK_SEL_OFFSET		10
+ #define NB_CLOCK_SEL_DDR_PHY_CLK_SEL_MASK		0x1
+ #define NB_CLOCK_SEL_A53_CPU_CLK_OFFSET		15
+ #define NB_CLOCK_SEL_A53_CPU_CLK_MASK			0x1
+
+#define TBG_A_REFDIV_GET(reg_val)	((reg_val >> 0) &\
+					NB_TBG_CTRL7_TBG_A_REFDIV_MASK)
+#define TBG_B_REFDIV_GET(reg_val)	((reg_val >>\
+					NB_TBG_CTRL7_TBG_B_REFDIV_OFFSET) &\
+					NB_TBG_CTRL7_TBG_B_REFDIV_MASK)
+#define	TBG_A_FBDIV_GET(reg_val)	((reg_val >>\
+					NB_TBG_CTRL0_TBG_A_FBDIV_OFFSET) &\
+					NB_TBG_CTRL0_TBG_A_FBDIV_MASK)
+#define TBG_B_FBDIV_GET(reg_val)	((reg_val >>\
+					NB_TBG_CTRL0_TBG_B_FBDIV_OFFSET) &\
+					NB_TBG_CTRL0_TBG_B_FBDIV_MASK)
+#define TBG_A_VCODIV_SEL_SE_GET(reg_val)	((reg_val >> 0) &\
+					NB_TBG_CTRL1_TBG_A_VCODIV_SEL_SE_MASK)
+#define TBG_B_VCODIV_SEL_SE_GET(reg_val)	((reg_val >>\
+				NB_TBG_CTRL1_TBG_B_VCODIV_SEL_SE_OFFSET) &\
+				NB_TBG_CTRL1_TBG_B_VCODIV_SEL_SE_MASK)
+#define TBG_A_VCODIV_SEL_DIFF_GET(reg_val)	((reg_val >>\
+				NB_TBG_CTRL8_TBG_A_VCODIV_SEL_DIFF_OFFSET) &\
+				NB_TBG_CTRL8_TBG_A_VCODIV_SEL_DIFF_MASK)
+#define TBG_B_VCODIV_SEL_DIFF_GET(reg_val)	((reg_val >>\
+				NB_TBG_CTRL8_TBG_B_VCODIV_SEL_DIFF_OFFSET) &\
+				NB_TBG_CTRL8_TBG_B_VCODIV_SEL_DIFF_MASK)
+#define A53_CPU_CLK_SEL_GET(reg_val)	((reg_val >>\
+					NB_CLOCK_SEL_A53_CPU_CLK_OFFSET) &\
+					NB_CLOCK_SEL_A53_CPU_CLK_MASK)
+#define A53_CPU_PCLK_SEL_GET(reg_val)	((reg_val >>\
+					NB_CLOCK_TBG_SEL_A53_CPU_PCLK_OFFSET) &\
+					NB_CLOCK_TBG_SEL_A53_CPU_PCLK_MASK)
+#define A53_CPU_CLK_PRSCL_GET(reg_val)	((reg_val >>\
+				NB_CLOCK_DIV_SEL0_A53_CPU_CLK_PRSCL_OFFSET) &\
+				NB_CLOCK_DIV_SEL0_A53_CPU_CLK_PRSCL_MASK)
+#define DDR_PHY_CLK_SEL_GET(reg_val)	((reg_val >>\
+					NB_CLOCK_SEL_DDR_PHY_CLK_SEL_OFFSET) &\
+					NB_CLOCK_SEL_DDR_PHY_CLK_SEL_MASK)
+
+#define TCLK		200
+#define L2_CLK		800
+#define TIMER_CLK	800
+
+enum a3700_clock_line {
+	TBG_A_P = 0,
+	TBG_B_P = 1,
+	TBG_A_S = 2,
+	TBG_B_S = 3
+};
+
+/* Clock source selection */
+enum a3700_clk_select {
+	CLK_SEL_OSC = 0,
+	CLK_SEL_TBG,
+};
+
+/* TBG divider */
+enum a3700_tbg_divider {
+	TBG_DIVIDER_1 = 1,
+	TBG_DIVIDER_2,
+	TBG_DIVIDER_3,
+	TBG_DIVIDER_4,
+	TBG_DIVIDER_5,
+	TBG_DIVIDER_6,
+	TBG_DIVIDER_NUM
+};
+
+static u32 get_tbg_clk(enum a3700_clock_line tbg_typ)
+{
+	u32 tbg_M, tbg_N, vco_div;
+	u32 ref, reg_val;
+
+	/* get ref clock */
+	ref = get_ref_clk();
+
+	/* get M, N */
+	reg_val = readl(NB_TBG_CTRL7);
+	tbg_M = ((tbg_typ == TBG_A_S) || (tbg_typ == TBG_A_P)) ?
+		TBG_A_REFDIV_GET(reg_val) : TBG_B_REFDIV_GET(reg_val);
+	tbg_M = (tbg_M == 0) ? 1 : tbg_M;
+
+	reg_val = readl(NB_TBG_CTRL0);
+	tbg_N = ((tbg_typ == TBG_A_S) || (tbg_typ == TBG_A_P)) ?
+		TBG_A_FBDIV_GET(reg_val) : TBG_B_FBDIV_GET(reg_val);
+
+	if ((tbg_typ == TBG_A_S) || (tbg_typ == TBG_B_S)) {
+		/* get SE VCODIV */
+		reg_val = readl(NB_TBG_CTRL1);
+		reg_val = (tbg_typ == TBG_A_S) ?
+			  TBG_A_VCODIV_SEL_SE_GET(reg_val) :
+			  TBG_B_VCODIV_SEL_SE_GET(reg_val);
+	} else {
+		/* get DIFF VCODIV */
+		reg_val = readl(NB_TBG_CTRL8);
+		reg_val = (tbg_typ == TBG_A_P) ?
+			  TBG_A_VCODIV_SEL_DIFF_GET(reg_val) :
+			  TBG_B_VCODIV_SEL_DIFF_GET(reg_val);
+	}
+	if (reg_val > 7)
+		return 0; /*invalid*/
+
+	vco_div = 0x1 << reg_val;
+
+	return ((tbg_N * ref) << 2) / (tbg_M * vco_div);
+}
+
+u32 soc_cpu_clk_get(void)
+{
+	u32 tbg, cpu_prscl;
+	enum a3700_clock_line tbg_typ;
+
+	/* 1. check cpu clock select */
+	if (!A53_CPU_CLK_SEL_GET(readl(NB_CLOCK_SELECT_REG)))
+		return 0; /* CPU clock is using XTAL output*/
+
+	/* 2. get TBG select */
+	tbg_typ = A53_CPU_PCLK_SEL_GET(readl(NB_CLOCK_TBG_SELECT_REG));
+
+	/* 3. get TBG clock */
+	tbg = get_tbg_clk(tbg_typ);
+	if (tbg == 0)
+		return 0;
+
+	/* 4. get CPU clk divider */
+	cpu_prscl = A53_CPU_CLK_PRSCL_GET(readl(NB_CLOCK_DIV_SEL0_REG));
+	if (cpu_prscl == 7)
+		return 0; /* divider value error */
+
+	return tbg / cpu_prscl;
+}
+
+u32 soc_ddr_clk_get(void)
+{
+	u32 tbg;
+
+	/* 1. check DDR clock select */
+	if (!DDR_PHY_CLK_SEL_GET(readl(NB_CLOCK_SELECT_REG)))
+		return 0; /* DDR clock is using XTAL output*/
+
+	/* 2. get TBG_A clock */
+	tbg = get_tbg_clk(TBG_A_S);
+	if (tbg == 0)
+		return 0;
+
+	return tbg >> 1;
+}
+
+/******************************************************************************
+ * Name: get_cpu_clk_src_div
+ *
+ * Description: Get CPU clock source selection and prescaling divider
+ *
+ * Input:	None
+ * Output:	cpu_clk_sel: CPU clock source selection
+ *		cpu_clk_prscl: CPU clock prescaling divider
+ * Return:	Non-zero if failed to get the CPU clock selection and prescaling
+ *******************************************************************************
+ */
+int get_cpu_clk_src_div(u32 *cpu_clk_sel, u32 *cpu_clk_prscl)
+{
+	/* 1. check cpu clock select */
+	if (!A53_CPU_CLK_SEL_GET(readl(NB_CLOCK_SELECT_REG)))
+		return -1; /* CPU clock is using XTAL output*/
+
+	/* 2. get TBG select */
+	*cpu_clk_sel = A53_CPU_PCLK_SEL_GET(readl(NB_CLOCK_TBG_SELECT_REG));
+
+	/* 3. get CPU clk divider */
+	*cpu_clk_prscl = A53_CPU_CLK_PRSCL_GET(readl(NB_CLOCK_DIV_SEL0_REG));
+
+	return 0;
+}
+
+u32 soc_tclk_get(void)
+{
+	return TCLK;
+}
+
+u32 soc_l2_clk_get(void)
+{
+	return L2_CLK;
+}
+
+u32 soc_timer_clk_get(void)
+{
+	return TIMER_CLK;
+}
+
+void soc_print_clock_info(void)
+{
+	printf("       CPU     %d [MHz]\n", soc_cpu_clk_get());
+	printf("       L2      %d [MHz]\n", soc_l2_clk_get());
+	printf("       TClock  %d [MHz]\n", soc_tclk_get());
+	printf("       DDR     %d [MHz]\n", soc_ddr_clk_get());
+}
diff --git a/arch/arm/mach-mvebu/armada3700/cpu.c b/arch/arm/mach-mvebu/armada3700/cpu.c
index b9214f7..33d53a4 100644
--- a/arch/arm/mach-mvebu/armada3700/cpu.c
+++ b/arch/arm/mach-mvebu/armada3700/cpu.c
@@ -5,14 +5,11 @@
  */
 
 #include <common.h>
-#include <dm.h>
-#include <fdtdec.h>
-#include <linux/libfdt.h>
-#include <asm/io.h>
-#include <asm/system.h>
-#include <asm/arch/cpu.h>
-#include <asm/arch/soc.h>
 #include <asm/armv8/mmu.h>
+#include <asm/io.h>
+#include <linux/sizes.h>
+#include <mach/clock.h>
+#include <mach/fw_info.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -33,6 +30,15 @@ static struct mm_region mvebu_mem_map[] = {
 		/* RAM */
 		.phys = 0x0UL,
 		.virt = 0x0UL,
+		.size = ATF_REGION_START,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) |
+			 PTE_BLOCK_INNER_SHARE
+	},
+	/* ATF and TEE region 0x4000000-0x5400000 not mapped */
+	{
+		/* RAM */
+		.phys = ATF_REGION_END,
+		.virt = ATF_REGION_END,
 		.size = 0x80000000UL,
 		.attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) |
 			 PTE_BLOCK_INNER_SHARE
@@ -46,6 +52,14 @@ static struct mm_region mvebu_mem_map[] = {
 			 PTE_BLOCK_NON_SHARE
 	},
 	{
+		/* PCI regions */
+		.phys = 0xe8000000UL,
+		.virt = 0xe8000000UL,
+		.size = 0x02000000UL,	/* 32MiB master PCI space */
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE
+	},
+	{
 		/* List terminator */
 		0,
 	}
@@ -79,3 +93,63 @@ u32 get_ref_clk(void)
 	else
 		return 40;
 }
+
+#if defined(CONFIG_DISPLAY_BOARDINFO)
+int print_cpuinfo(void)
+{
+	soc_print_clock_info();
+
+	return 0;
+}
+#endif
+
+static u64 mvebu_dram_scan_ap_sz(void)
+{
+	struct pt_regs pregs = {0};
+
+	pregs.regs[0] = MV_SIP_DRAM_SIZE;
+
+	smc_call(&pregs);
+
+	if (!pregs.regs[0])
+		pr_err("Failed to get ddr size\n");
+
+	return pregs.regs[0];
+}
+
+int mvebu_dram_init(void)
+{
+	gd->ram_size = mvebu_dram_scan_ap_sz();
+
+	if (gd->ram_size == 0) {
+		pr_err("DRAM size not initialized - check DRAM configuration\n");
+		printf("\n Using temporary DRAM size of 512MB.\n\n");
+		gd->ram_size = SZ_512M;
+	}
+
+	return 0;
+}
+
+int mvebu_dram_init_banksize(void)
+{
+	/* If ddr size is bellow 2GB there is only one ddr bank used */
+	gd->bd->bi_dram[0].start = CONFIG_SYS_SDRAM_BASE;
+	if (gd->ram_size <= SZ_2G) {
+		gd->bd->bi_dram[0].size = gd->ram_size;
+		return 0;
+	}
+
+	/*
+	 * If ddr size is above 2GB there is only one case 4GB but the firmware
+	 * uses 4 decoding windows for describing it in way reflected below.
+	 */
+	gd->bd->bi_dram[0].size = SZ_2G;
+	gd->bd->bi_dram[1].start = SZ_2G;
+	gd->bd->bi_dram[1].size = SZ_1G;
+	gd->bd->bi_dram[2].start = SZ_2G + SZ_1G;
+	gd->bd->bi_dram[2].size = SZ_256M;
+	gd->bd->bi_dram[3].start = 0xe0000000;
+	gd->bd->bi_dram[3].size = SZ_128M;
+
+	return 0;
+}
diff --git a/arch/arm/mach-mvebu/armada8k/Makefile b/arch/arm/mach-mvebu/armada8k/Makefile
index 0facf14..1381f74 100644
--- a/arch/arm/mach-mvebu/armada8k/Makefile
+++ b/arch/arm/mach-mvebu/armada8k/Makefile
@@ -5,4 +5,6 @@
 #
 
 obj-y = cpu.o
+obj-y += soc.o
+obj-y += clock.o
 obj-y += cache_llc.o
diff --git a/arch/arm/mach-mvebu/armada8k/clock.c b/arch/arm/mach-mvebu/armada8k/clock.c
new file mode 100644
index 0000000..3b02bea
--- /dev/null
+++ b/arch/arm/mach-mvebu/armada8k/clock.c
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0+
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <mach/clock.h>
+#include <mvebu/mvebu_chip_sar.h>
+
+#ifndef CONFIG_PALLADIUM
+#define CONFIG_MSS_FREQUENCY    (200 * 1000000)
+#else
+#define CONFIG_MSS_FREQUENCY    (384000)
+#endif
+
+u32 soc_ring_clk_get(void)
+{
+	struct sar_val sar;
+
+	mvebu_sar_value_get(SAR_AP_FABRIC_FREQ, &sar);
+	return sar.freq;
+}
+
+u32 soc_mss_clk_get(void)
+{
+	return CONFIG_MSS_FREQUENCY;
+}
+
+u32 soc_cpu_clk_get(void)
+{
+	struct sar_val sar;
+
+	mvebu_sar_value_get(SAR_CPU_FREQ, &sar);
+	return sar.freq;
+}
+
+u32 soc_ddr_clk_get(void)
+{
+	struct sar_val sar;
+
+	mvebu_sar_value_get(SAR_DDR_FREQ, &sar);
+	return sar.freq;
+}
+
+void soc_print_clock_info(void)
+{
+	printf("Clock:  CPU     %-4d [MHz]\n", soc_cpu_clk_get() / MHz);
+	printf("\tDDR     %-4d [MHz]\n", soc_ddr_clk_get() / MHz);
+	printf("\tFABRIC  %-4d [MHz]\n", soc_ring_clk_get() / MHz);
+	printf("\tMSS     %-4d [MHz]\n", soc_mss_clk_get() / MHz);
+}
diff --git a/arch/arm/mach-mvebu/armada8k/cpu.c b/arch/arm/mach-mvebu/armada8k/cpu.c
index ce7e913..cb63986 100644
--- a/arch/arm/mach-mvebu/armada8k/cpu.c
+++ b/arch/arm/mach-mvebu/armada8k/cpu.c
@@ -11,8 +11,12 @@
 #include <asm/io.h>
 #include <asm/system.h>
 #include <asm/arch/cpu.h>
+#include <linux/sizes.h>
 #include <asm/arch/soc.h>
 #include <asm/armv8/mmu.h>
+#include <mach/clock.h>
+#include <mach/soc.h>
+#include <mach/fw_info.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -21,62 +25,31 @@ DECLARE_GLOBAL_DATA_PTR;
 #define RFU_GLOBAL_SW_RST		(MVEBU_RFU_BASE + 0x84)
 #define RFU_SW_RESET_OFFSET		0
 
-/*
- * The following table includes all memory regions for Armada 7k and
- * 8k SoCs. The Armada 7k is missing the CP110 slave regions here. Lets
- * define these regions at the beginning of the struct so that they
- * can be easier removed later dynamically if an Armada 7k device is detected.
- * For a detailed memory map, please see doc/mvebu/armada-8k-memory.txt
- */
-#define ARMADA_7K8K_COMMON_REGIONS_START	2
 static struct mm_region mvebu_mem_map[] = {
 	/* Armada 80x0 memory regions include the CP1 (slave) units */
 	{
-		/* SRAM, MMIO regions - CP110 slave region */
-		.phys = 0xf4000000UL,
-		.virt = 0xf4000000UL,
-		.size = 0x02000000UL,	/* 32MiB internal registers */
-		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
-			 PTE_BLOCK_NON_SHARE
-	},
-	{
-		/* PCI CP1 regions */
-		.phys = 0xfa000000UL,
-		.virt = 0xfa000000UL,
-		.size = 0x04000000UL,	/* 64MiB CP110 slave PCI space */
-		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
-			 PTE_BLOCK_NON_SHARE
-	},
-	/* Armada 80x0 and 70x0 common memory regions start here */
-	{
-		/* RAM */
+		/* RAM 0-64MB */
 		.phys = 0x0UL,
 		.virt = 0x0UL,
-		.size = 0x80000000UL,
+		.size = ATF_REGION_START,
 		.attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) |
 			 PTE_BLOCK_INNER_SHARE
 	},
+	/* ATF and TEE region 0x4000000-0x5400000 not mapped */
 	{
-		/* SRAM, MMIO regions - AP806 region */
-		.phys = 0xf0000000UL,
-		.virt = 0xf0000000UL,
-		.size = 0x01000000UL,	/* 16MiB internal registers */
-		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
-			 PTE_BLOCK_NON_SHARE
-	},
-	{
-		/* SRAM, MMIO regions - CP110 master region */
-		.phys = 0xf2000000UL,
-		.virt = 0xf2000000UL,
-		.size = 0x02000000UL,	/* 32MiB internal registers */
-		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
-			 PTE_BLOCK_NON_SHARE
+		/* RAM 66MB-2GB */
+		.phys = ATF_REGION_END,
+		.virt = ATF_REGION_END,
+		.size = SZ_2G,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) |
+			 PTE_BLOCK_INNER_SHARE
 	},
 	{
-		/* PCI CP0 regions */
-		.phys = 0xf6000000UL,
-		.virt = 0xf6000000UL,
-		.size = 0x04000000UL,	/* 64MiB CP110 master PCI space */
+		/* MMIO regions */
+		.phys = MMIO_REGS_PHY_BASE,
+		.virt = MMIO_REGS_PHY_BASE,
+		.size = SZ_1G,
+
 		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
 			 PTE_BLOCK_NON_SHARE
 	},
@@ -89,15 +62,6 @@ struct mm_region *mem_map = mvebu_mem_map;
 
 void enable_caches(void)
 {
-	/*
-	 * Armada 7k is not equipped with the CP110 slave CP. In case this
-	 * code runs on an Armada 7k device, lets remove the CP110 slave
-	 * entries from the memory mapping by moving the start to the
-	 * common regions.
-	 */
-	if (of_machine_is_compatible("marvell,armada7040"))
-		mem_map = &mvebu_mem_map[ARMADA_7K8K_COMMON_REGIONS_START];
-
 	icache_enable();
 	dcache_enable();
 }
@@ -111,20 +75,63 @@ void reset_cpu(ulong ignored)
 	writel(reg, RFU_GLOBAL_SW_RST);
 }
 
-/*
- * TODO - implement this functionality using platform
- *        clock driver once it gets available
- * Return NAND clock in Hz
- */
-u32 mvebu_get_nand_clock(void)
+#if defined(CONFIG_DISPLAY_BOARDINFO)
+int print_cpuinfo(void)
 {
-	unsigned long NAND_FLASH_CLK_CTRL = 0xF2440700UL;
-	unsigned long NF_CLOCK_SEL_MASK = 0x1;
-	u32 reg;
+	soc_print_device_info();
+	soc_print_clock_info();
+	soc_print_system_cache_info();
+
+	return 0;
+}
+#endif
+
+static u64 mvebu_dram_scan_ap_sz(void)
+{
+	struct pt_regs pregs = {0};
+
+	pregs.regs[0] = MV_SIP_DRAM_SIZE;
+	pregs.regs[1] = (unsigned long)SOC_REGS_PHY_BASE;
+
+	smc_call(&pregs);
+
+	if (!pregs.regs[0])
+		pr_err("Failed to get ddr size\n");
+
+	return pregs.regs[0];
+}
+
+int mvebu_dram_init(void)
+{
+	gd->ram_size = mvebu_dram_scan_ap_sz();
+
+	/* if DRAM size == 0, print error message */
+	if (gd->ram_size == 0) {
+		pr_err("DRAM size not initialized - check DRAM configuration\n");
+		printf("\n Using temporary DRAM size of 256MB.\n\n");
+		gd->ram_size = SZ_256M;
+	}
+
+	return 0;
+}
+
+int mvebu_dram_init_banksize(void)
+{
+	/*
+	 * Config 2 DRAM banks:
+	 * Bank 0 - max size 4G - 1G
+	 * Bank 1 - ram size - 4G + 1G
+	 */
+	gd->bd->bi_dram[0].start = CONFIG_SYS_SDRAM_BASE;
+	if (gd->ram_size <= SZ_4G - SZ_1G) {
+		gd->bd->bi_dram[0].size = min(gd->ram_size,
+					      (phys_size_t)(SZ_4G - SZ_1G));
+		return 0;
+	}
+
+	gd->bd->bi_dram[0].size = SZ_4G - SZ_1G;
+	gd->bd->bi_dram[1].start = SZ_4G;
+	gd->bd->bi_dram[1].size = gd->ram_size - SZ_4G + SZ_1G;
 
-	reg = readl(NAND_FLASH_CLK_CTRL);
-	if (reg & NF_CLOCK_SEL_MASK)
-		return 400 * 1000000;
-	else
-		return 250 * 1000000;
+	return 0;
 }
diff --git a/arch/arm/mach-mvebu/armada8k/soc.c b/arch/arm/mach-mvebu/armada8k/soc.c
new file mode 100644
index 0000000..322668c
--- /dev/null
+++ b/arch/arm/mach-mvebu/armada8k/soc.c
@@ -0,0 +1,314 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <asm/arch-armada8k/cache_llc.h>
+#include <asm/io.h>
+#include <asm/arch/soc.h>
+#include <mvebu/mvebu_chip_sar.h>
+#include <dm/device.h>
+
+#define CP_DEV_ID_STATUS_REG		(MVEBU_REGISTER(0x2400240))
+#define DEVICE_ID_STATUS_MASK		0xffff
+#define AP_DEV_ID_STATUS_REG		(SOC_REGS_PHY_BASE + 0x6F8240)
+#define JTAG_DEV_ID_STATUS_REG		(SOC_REGS_PHY_BASE + 0x6F8244)
+#define AP_DEV_ID_STATUS_MASK		0xfff
+#define AP_DEV_REV_ID_STATUS_MASK	0xf0000000
+#define SW_REV_STATUS_OFFSET		16
+#define AP_REV_STATUS_OFFSET		28
+#define SW_REV_STATUS_MASK		0xf
+
+#define A8040_DEVICE_ID			0x8040
+#define CN9130_DEVICE_ID		0x7025
+
+#define AP807_ID			0x807
+
+/* to differentiate differnet SOC with similar DEVICE_ID */
+#define AP807_SHARED_DEVICE_ID_A0	0x7045
+#define AP807_SHARED_DEVICE_ID_A1	0x6025
+
+#define DEVICE_ID_SUB_REV		(MVEBU_REGISTER(0x2400230))
+#define DEVICE_ID_SUB_REV_OFFSET	7
+#define DEVICE_ID_SUB_REV_MASK		(0xffff << DEVICE_ID_SUB_REV_OFFSET)
+
+#define NF_CLOCK_SEL_MASK		0x1
+#define SOC_MUX_NAND_EN_MASK		0x1
+#define CLOCK_1Mhz			1000000
+
+struct mochi_module {
+	u32 module_type;
+	u32 module_rev;
+};
+
+struct soc_info {
+	struct mochi_module soc;
+	char *soc_name;
+	struct mochi_module ap;
+	struct mochi_module cp;
+	u32 ap_num;
+	u32 cp_num;
+	u32 sub_rev;
+};
+
+static struct soc_info soc_info_table[] = {
+	{ {0x7025, 0}, "cn9130-A1",	{0x807, 2}, {0x115, 0}, 1, 1, 0},
+	{ {0x7025, 0}, "cn9131-A1",	{0x807, 2}, {0x115, 0}, 1, 2, 0},
+	{ {0x7025, 0}, "cn9132-A1",	{0x807, 2}, {0x115, 0}, 1, 3, 0},
+	{ {0x6025, 0}, "Armada3900-A1",	{0x807, 1}, {0x115, 0}, 1, 1, 0},
+	{ {0x6025, 0}, "Armada3900-A3",	{0x807, 2}, {0x115, 0}, 1, 1, 0},
+	{ {0x7045, 0}, "Armada3900-A0", {0x807, 0}, {0x115, 0}, 1, 1, 0},
+	{ {0x7040, 1}, "Armada7040-A1", {0x806, 1}, {0x110, 1}, 1, 1, 0},
+	{ {0x7040, 2}, "Armada7040-A2", {0x806, 1}, {0x110, 2}, 1, 1, 0},
+	{ {0x7045, 0}, "Armada7040-B0", {0x806, 2}, {0x115, 0}, 1, 1, 0},
+	{ {0x8040, 1}, "Armada8040-A1", {0x806, 1}, {0x110, 1}, 1, 2, 0},
+	{ {0x8040, 2}, "Armada8040-A2", {0x806, 1}, {0x110, 2}, 1, 2, 0},
+	{ {0x8045, 0}, "Armada8040-B0", {0x806, 2}, {0x115, 0}, 1, 2, 0},
+};
+
+static int get_soc_type_rev(u32 *type, u32 *rev)
+{
+	*type = readl(CP_DEV_ID_STATUS_REG) & DEVICE_ID_STATUS_MASK;
+	*rev = (readl(CP_DEV_ID_STATUS_REG) >> SW_REV_STATUS_OFFSET) &
+		SW_REV_STATUS_MASK;
+
+	return 0;
+}
+
+static int get_ap_soc_type(u32 *type)
+{
+	*type = readl(AP_DEV_ID_STATUS_REG) & AP_DEV_ID_STATUS_MASK;
+
+	return 0;
+}
+
+static int get_ap_soc_rev(u32 *rev)
+{
+	*rev = (readl(JTAG_DEV_ID_STATUS_REG) & AP_DEV_REV_ID_STATUS_MASK)
+					>> AP_REV_STATUS_OFFSET;
+	return 0;
+}
+
+static int get_soc_sub_rev(u32 *sub_rev)
+{
+	u32 soc_type, rev, ap_type;
+
+	get_soc_type_rev(&soc_type, &rev);
+	get_ap_soc_type(&ap_type);
+
+	if (ap_type == AP807_ID) {
+		*sub_rev = readl(DEVICE_ID_SUB_REV) & DEVICE_ID_SUB_REV_MASK;
+		*sub_rev >>= DEVICE_ID_SUB_REV_OFFSET;
+		return 0;
+	}
+
+	*sub_rev = 0;
+
+	return -1;
+}
+
+static int get_soc_table_index(u32 *index)
+{
+	u32 soc_type;
+	u32 rev, i, ret = 1;
+	u32 ap_type, sub_rev, ap_rev;
+
+	*index = 0;
+	get_soc_type_rev(&soc_type, &rev);
+	get_ap_soc_type(&ap_type);
+	get_ap_soc_rev(&ap_rev);
+
+	/* specific checks needed for 9131,9132, */
+	/* since their soc+ap characteristics same as 9130*/
+	if ((of_machine_is_compatible("marvell,cn9131-db"))) {
+		for (i = 0; i < ARRAY_SIZE(soc_info_table) && ret != 0; i++) {
+			if (strcmp(soc_info_table[i].soc_name,
+				   "cn9131-A1") != 0)
+				continue;
+			*index = i;
+			ret = 0;
+		}
+	} else if ((of_machine_is_compatible("marvell,cn9132-db"))) {
+		for (i = 0; i < ARRAY_SIZE(soc_info_table) && ret != 0; i++) {
+			if (strcmp(soc_info_table[i].soc_name,
+				   "cn9132-A1") != 0)
+				continue;
+			*index = i;
+			ret = 0;
+		}
+	} else	{
+		for (i = 0; i < ARRAY_SIZE(soc_info_table) && ret != 0; i++) {
+			if ((soc_type != soc_info_table[i].soc.module_type) ||
+			    (rev != soc_info_table[i].soc.module_rev) ||
+				ap_type != soc_info_table[i].ap.module_type ||
+				(ap_rev != soc_info_table[i].ap.module_rev))
+				continue;
+
+			if (!get_soc_sub_rev(&sub_rev) &&
+			    (sub_rev != soc_info_table[i].sub_rev))
+				continue;
+
+			*index = i;
+			ret = 0;
+		}
+	}
+
+	if (ret)
+		pr_err("using default SoC info: %s\n",
+		       soc_info_table[*index].soc_name);
+
+	return ret;
+}
+
+static int get_soc_name(char **soc_name)
+{
+	u32 index;
+
+	get_soc_table_index(&index);
+	*soc_name = soc_info_table[index].soc_name;
+
+	return 0;
+}
+
+int soc_get_ap_cp_num(void *ap_num, void *cp_num)
+{
+	u32 index;
+
+	get_soc_table_index(&index);
+	*((u32 *)ap_num) = soc_info_table[index].ap_num;
+	*((u32 *)cp_num) = soc_info_table[index].cp_num;
+
+	return 0;
+}
+
+/* Get SoC's Application Processor (AP) module type and revision */
+static int get_ap_type_rev(u32 *type, u32 *rev)
+{
+	u32 index;
+
+	get_soc_table_index(&index);
+	*type = soc_info_table[index].ap.module_type;
+	*rev = soc_info_table[index].ap.module_rev;
+
+	return 0;
+}
+
+/* Get SoC's Communication Processor (CP) module type and revision */
+static int get_cp_type_rev(u32 *type, u32 *rev)
+{
+	u32 index;
+
+	get_soc_table_index(&index);
+	*type = soc_info_table[index].cp.module_type;
+	*rev = soc_info_table[index].cp.module_rev;
+
+	return 0;
+}
+
+/* Print device's SoC name and AP & CP information */
+void soc_print_device_info(void)
+{
+	u32 ap_num, cp_num, ap_type, ap_rev, cp_type, cp_rev;
+	char *soc_name = NULL;
+
+	soc_get_ap_cp_num(&ap_num, &cp_num);
+
+	get_soc_name(&soc_name);
+	get_ap_type_rev(&ap_type, &ap_rev);
+	get_cp_type_rev(&cp_type, &cp_rev);
+
+	if (ap_rev > 1)
+		printf("SoC: %s; AP%x-B0; ", soc_name, ap_type);
+	else
+		printf("SoC: %s; AP%x-A%d; ", soc_name, ap_type, ap_rev);
+
+	/* more than one cp module */
+	if (cp_num > 1)
+		printf("%dxCP%x-A%d\n", cp_num, cp_type, cp_rev);
+	else
+		printf("CP%x-A%d\n", cp_type, cp_rev);
+}
+
+/* Print System cache (LLC) status and mode */
+void soc_print_system_cache_info(void)
+{
+	u32 val;
+	int llc_en = 0, excl = 0;
+
+	val = readl(MVEBU_LLC_BASE + LLC_CTRL_REG_OFFSET);
+	if (val & LLC_EN) {
+		llc_en = 1;
+		if (val & LLC_EXCL_EN)
+			excl = 1;
+	}
+
+	printf("LLC %s%s\n", llc_en ? "Enabled" : "Disabled",
+	       excl ? " (Exclusive Mode)" : "");
+}
+
+#ifdef CONFIG_NAND_PXA3XX
+/* Return NAND clock in Hz */
+u32 mvebu_get_nand_clock(void __iomem *nand_flash_clk_ctrl_reg)
+{
+	u32 reg;
+
+	if (!nand_flash_clk_ctrl_reg)
+		return 0;
+
+	reg = readl(nand_flash_clk_ctrl_reg);
+	if (reg & NF_CLOCK_SEL_MASK)
+		return 400 * CLOCK_1Mhz;
+	else
+		return 250 * CLOCK_1Mhz;
+}
+
+/* Select NAND in the device bus multiplexer */
+void mvebu_nand_select(void __iomem *soc_dev_multiplex_reg)
+{
+	if (!soc_dev_multiplex_reg)
+		return;
+
+	setbits_le32(soc_dev_multiplex_reg, SOC_MUX_NAND_EN_MASK);
+}
+#endif
+
+int soc_early_init_f(void)
+{
+#ifdef CONFIG_MVEBU_SAR
+	/* Sample at reset register init */
+	mvebu_sar_init();
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_ARCH_MISC_INIT
+int arch_misc_init(void)
+{
+	u32 type, rev;
+
+	get_soc_type_rev(&type, &rev);
+
+	/* A8040 A1/A2 doesn't support linux kernel cpuidle feautre,
+	 * so U-boot needs to update Linux bootargs according
+	 * to the device id:
+	 *
+	 * Device	Device_ID
+	 * -------------------------------
+	 * A8040 A1	0x18040
+	 * A8040 A2	0x28040
+	 * A8040 B0	0x08045
+	 *
+	 * So we need to check if 16 LSB bits are 0x8040.
+	 * The variable 'type', which is returned by
+	 * get_soc_type_rev() holds these bits.
+	 */
+	if (type == A8040_DEVICE_ID)
+		env_set("cpuidle", "cpuidle.off=1");
+
+	return 0;
+}
+#endif
diff --git a/arch/arm/mach-mvebu/cpu.c b/arch/arm/mach-mvebu/cpu.c
index 7c64a68..0f68650 100644
--- a/arch/arm/mach-mvebu/cpu.c
+++ b/arch/arm/mach-mvebu/cpu.c
@@ -5,6 +5,7 @@
  */
 
 #include <common.h>
+#include <dm.h>
 #include <ahci.h>
 #include <linux/mbus.h>
 #include <asm/io.h>
@@ -13,9 +14,15 @@
 #include <asm/arch/soc.h>
 #include <sdhci.h>
 
+#if defined(CONFIG_MVEBU_EFUSE)
+#include <mvebu/fuse-mvebu.h>
+#endif
+
 #define DDR_BASE_CS_OFF(n)	(0x0000 + ((n) << 3))
 #define DDR_SIZE_CS_OFF(n)	(0x0004 + ((n) << 3))
 
+#define SOC_MUX_NAND_EN_MASK		0x1
+
 static struct mbus_win windows[] = {
 	/* SPI */
 	{ MBUS_SPI_BASE, MBUS_SPI_SIZE,
@@ -462,11 +469,22 @@ int arch_cpu_init(void)
 	/* Disable MBUS error propagation */
 	clrsetbits_le32(SOC_COHERENCY_FABRIC_CTRL_REG, MBUS_ERR_PROP_EN, 0);
 
+#if defined(CONFIG_MVEBU_EFUSE)
+	if (mvebu_soc_family() == MVEBU_SOC_A38X) {
+		struct fuse_ops a38x_ops;
+
+		a38x_ops.fuse_init = mvebu_efuse_init_hw;
+		a38x_ops.fuse_hd_read = NULL;
+		a38x_ops.fuse_hd_prog = NULL;
+		reg_fuse_ops(&a38x_ops);
+	}
+#endif
+
 	return 0;
 }
 #endif /* CONFIG_ARCH_CPU_INIT */
 
-u32 mvebu_get_nand_clock(void)
+u32 mvebu_get_nand_clock(void __iomem *unused)
 {
 	u32 reg;
 
@@ -480,6 +498,14 @@ u32 mvebu_get_nand_clock(void)
 		  NAND_ECC_DIVCKL_RATIO_MASK) >> NAND_ECC_DIVCKL_RATIO_OFFS);
 }
 
+void mvebu_nand_select(void __iomem *soc_dev_multiplex_reg)
+{
+	if (!soc_dev_multiplex_reg)
+		return;
+
+	setbits_le32(soc_dev_multiplex_reg, SOC_MUX_NAND_EN_MASK);
+}
+
 /*
  * SOC specific misc init
  */
@@ -642,3 +668,28 @@ void v7_outer_cache_disable(void)
 
 	clrbits_le32(&pl310->pl310_ctrl, L2X0_CTRL_EN);
 }
+
+int arch_early_init_r(void)
+{
+	struct udevice *dev;
+	int ret;
+	int i;
+
+	/* Loop over all MISC uclass drivers */
+	i = 0;
+	while (1) {
+		/* Call relevant driver code via the MISC uclass driver */
+		ret = uclass_get_device(UCLASS_MISC, i++, &dev);
+
+		/* We're done, once no further MISC device node is found */
+		if (ret)
+			break;
+	}
+
+#ifdef CONFIG_DM_PCI
+	/* Trigger PCIe devices detection */
+	pci_init();
+#endif
+
+	return 0;
+}
diff --git a/arch/arm/mach-mvebu/efuse.c b/arch/arm/mach-mvebu/efuse.c
deleted file mode 100644
index 67fcadc..0000000
--- a/arch/arm/mach-mvebu/efuse.c
+++ /dev/null
@@ -1,264 +0,0 @@
-/*
- * Copyright (C) 2015-2016 Reinhard Pfau <reinhard.pfau@gdsys.cc>
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#include <config.h>
-#include <common.h>
-#include <errno.h>
-#include <asm/io.h>
-#include <asm/arch/cpu.h>
-#include <asm/arch/efuse.h>
-#include <asm/arch/soc.h>
-#include <linux/mbus.h>
-
-#if defined(CONFIG_MVEBU_EFUSE_FAKE)
-#define DRY_RUN
-#else
-#undef DRY_RUN
-#endif
-
-#define MBUS_EFUSE_BASE 0xF6000000
-#define MBUS_EFUSE_SIZE BIT(20)
-
-#define MVEBU_EFUSE_CONTROL (MVEBU_REGISTER(0xE4008))
-
-enum {
-	MVEBU_EFUSE_CTRL_PROGRAM_ENABLE = (1 << 31),
-};
-
-struct mvebu_hd_efuse {
-	u32 bits_31_0;
-	u32 bits_63_32;
-	u32 bit64;
-	u32 reserved0;
-};
-
-#ifndef DRY_RUN
-static struct mvebu_hd_efuse *efuses =
-	(struct mvebu_hd_efuse *)(MBUS_EFUSE_BASE + 0xF9000);
-#else
-static struct mvebu_hd_efuse efuses[EFUSE_LINE_MAX + 1];
-#endif
-
-static int efuse_initialised;
-
-static struct mvebu_hd_efuse *get_efuse_line(int nr)
-{
-	if (nr < 0 || nr > 63 || !efuse_initialised)
-		return NULL;
-
-	return efuses + nr;
-}
-
-static void enable_efuse_program(void)
-{
-#ifndef DRY_RUN
-	setbits_le32(MVEBU_EFUSE_CONTROL, MVEBU_EFUSE_CTRL_PROGRAM_ENABLE);
-#endif
-}
-
-static void disable_efuse_program(void)
-{
-#ifndef DRY_RUN
-	clrbits_le32(MVEBU_EFUSE_CONTROL, MVEBU_EFUSE_CTRL_PROGRAM_ENABLE);
-#endif
-}
-
-static int do_prog_efuse(struct mvebu_hd_efuse *efuse,
-			 struct efuse_val *new_val, u32 mask0, u32 mask1)
-{
-	struct efuse_val val;
-
-	val.dwords.d[0] = readl(&efuse->bits_31_0);
-	val.dwords.d[1] = readl(&efuse->bits_63_32);
-	val.lock = readl(&efuse->bit64);
-
-	if (val.lock & 1)
-		return -EPERM;
-
-	val.dwords.d[0] |= (new_val->dwords.d[0] & mask0);
-	val.dwords.d[1] |= (new_val->dwords.d[1] & mask1);
-	val.lock |= new_val->lock;
-
-	writel(val.dwords.d[0], &efuse->bits_31_0);
-	mdelay(1);
-	writel(val.dwords.d[1], &efuse->bits_63_32);
-	mdelay(1);
-	writel(val.lock, &efuse->bit64);
-	mdelay(5);
-
-	return 0;
-}
-
-static int prog_efuse(int nr, struct efuse_val *new_val, u32 mask0, u32 mask1)
-{
-	struct mvebu_hd_efuse *efuse;
-	int res = 0;
-
-	res = mvebu_efuse_init_hw();
-	if (res)
-		return res;
-
-	efuse = get_efuse_line(nr);
-	if (!efuse)
-		return -ENODEV;
-
-	if (!new_val)
-		return -EINVAL;
-
-	/* only write a fuse line with lock bit */
-	if (!new_val->lock)
-		return -EINVAL;
-
-	/* according to specs ECC protection bits must be 0 on write */
-	if (new_val->bytes.d[7] & 0xFE)
-		return -EINVAL;
-
-	if (!new_val->dwords.d[0] && !new_val->dwords.d[1] && (mask0 | mask1))
-		return 0;
-
-	enable_efuse_program();
-
-	res = do_prog_efuse(efuse, new_val, mask0, mask1);
-
-	disable_efuse_program();
-
-	return res;
-}
-
-int mvebu_efuse_init_hw(void)
-{
-	int ret;
-
-	if (efuse_initialised)
-		return 0;
-
-	ret = mvebu_mbus_add_window_by_id(
-		CPU_TARGET_SATA23_DFX, 0xA, MBUS_EFUSE_BASE, MBUS_EFUSE_SIZE);
-
-	if (ret)
-		return ret;
-
-	efuse_initialised = 1;
-
-	return 0;
-}
-
-int mvebu_read_efuse(int nr, struct efuse_val *val)
-{
-	struct mvebu_hd_efuse *efuse;
-	int res;
-
-	res = mvebu_efuse_init_hw();
-	if (res)
-		return res;
-
-	efuse = get_efuse_line(nr);
-	if (!efuse)
-		return -ENODEV;
-
-	if (!val)
-		return -EINVAL;
-
-	val->dwords.d[0] = readl(&efuse->bits_31_0);
-	val->dwords.d[1] = readl(&efuse->bits_63_32);
-	val->lock = readl(&efuse->bit64);
-	return 0;
-}
-
-int mvebu_write_efuse(int nr, struct efuse_val *val)
-{
-	return prog_efuse(nr, val, ~0, ~0);
-}
-
-int mvebu_lock_efuse(int nr)
-{
-	struct efuse_val val = {
-		.lock = 1,
-	};
-
-	return prog_efuse(nr, &val, 0, 0);
-}
-
-/*
- * wrapper funcs providing the fuse API
- *
- * we use the following mapping:
- *   "bank" ->	eFuse line
- *   "word" ->	0: bits 0-31
- *		1: bits 32-63
- *		2: bit 64 (lock)
- */
-
-static struct efuse_val prog_val;
-static int valid_prog_words;
-
-int fuse_read(u32 bank, u32 word, u32 *val)
-{
-	struct efuse_val fuse_line;
-	int res;
-
-	if (bank < EFUSE_LINE_MIN || bank > EFUSE_LINE_MAX || word > 2)
-		return -EINVAL;
-
-	res = mvebu_read_efuse(bank, &fuse_line);
-	if (res)
-		return res;
-
-	if (word < 2)
-		*val = fuse_line.dwords.d[word];
-	else
-		*val = fuse_line.lock;
-
-	return res;
-}
-
-int fuse_sense(u32 bank, u32 word, u32 *val)
-{
-	/* not supported */
-	return -ENOSYS;
-}
-
-int fuse_prog(u32 bank, u32 word, u32 val)
-{
-	int res = 0;
-
-	/*
-	 * NOTE: Fuse line should be written as whole.
-	 * So how can we do that with this API?
-	 * For now: remember values for word == 0 and word == 1 and write the
-	 * whole line when word == 2.
-	 * This implies that we always require all 3 fuse prog cmds (one for
-	 * for each word) to write a single fuse line.
-	 * Exception is a single write to word 2 which will lock the fuse line.
-	 *
-	 * Hope that will be OK.
-	 */
-
-	if (bank < EFUSE_LINE_MIN || bank > EFUSE_LINE_MAX || word > 2)
-		return -EINVAL;
-
-	if (word < 2) {
-		prog_val.dwords.d[word] = val;
-		valid_prog_words |= (1 << word);
-	} else if ((valid_prog_words & 3) == 0 && val) {
-		res = mvebu_lock_efuse(bank);
-		valid_prog_words = 0;
-	} else if ((valid_prog_words & 3) != 3 || !val) {
-		res = -EINVAL;
-	} else {
-		prog_val.lock = val != 0;
-		res = mvebu_write_efuse(bank, &prog_val);
-		valid_prog_words = 0;
-	}
-
-	return res;
-}
-
-int fuse_override(u32 bank, u32 word, u32 val)
-{
-	/* not supported */
-	return -ENOSYS;
-}
diff --git a/arch/arm/mach-mvebu/include/mach/clock.h b/arch/arm/mach-mvebu/include/mach/clock.h
new file mode 100644
index 0000000..9cfd757
--- /dev/null
+++ b/arch/arm/mach-mvebu/include/mach/clock.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0+
+ * https://spdx.org/licenses
+ */
+
+#ifndef _MVEBU_CLOCK_H_
+#define _MVEBU_CLOCK_H_
+
+#define KHz			1000
+#define MHz			1000000
+#define GHz			1000000000
+
+u32 soc_cpu_clk_get(void);
+u32 soc_ddr_clk_get(void);
+u32 soc_tclk_get(void);
+u32 soc_l2_clk_get(void);
+u32 soc_timer_clk_get(void);
+
+void soc_print_clock_info(void);
+
+#endif /* _MVEBU_CLOCK_H_ */
diff --git a/arch/arm/mach-mvebu/include/mach/cpu.h b/arch/arm/mach-mvebu/include/mach/cpu.h
index b67b77a..b213ad3 100644
--- a/arch/arm/mach-mvebu/include/mach/cpu.h
+++ b/arch/arm/mach-mvebu/include/mach/cpu.h
@@ -136,7 +136,8 @@ unsigned int mvebu_sdram_bs(enum memory_bank bank);
 void mvebu_sdram_size_adjust(enum memory_bank bank);
 int mvebu_mbus_probe(struct mbus_win windows[], int count);
 int mvebu_soc_family(void);
-u32 mvebu_get_nand_clock(void);
+u32 mvebu_get_nand_clock(void __iomem *maybe_unused);
+void mvebu_nand_select(void __iomem *maybe_unused);
 
 void return_to_bootrom(void);
 
diff --git a/arch/arm/mach-mvebu/include/mach/efuse.h b/arch/arm/mach-mvebu/include/mach/efuse.h
deleted file mode 100644
index ef693e6..0000000
--- a/arch/arm/mach-mvebu/include/mach/efuse.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright (C) 2015 Reinhard Pfau <reinhard.pfau@gdsys.cc>
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#ifndef _MVEBU_EFUSE_H
-#define _MVEBU_EFUSE_H
-
-#include <common.h>
-
-struct efuse_val {
-	union {
-		struct {
-			u8 d[8];
-		} bytes;
-		struct {
-			u16 d[4];
-		} words;
-		struct {
-			u32 d[2];
-		} dwords;
-	};
-	u32 lock;
-};
-
-#if defined(CONFIG_ARMADA_38X)
-
-enum efuse_line {
-	EFUSE_LINE_SECURE_BOOT = 24,
-	EFUSE_LINE_PUBKEY_DIGEST_0 = 26,
-	EFUSE_LINE_PUBKEY_DIGEST_1 = 27,
-	EFUSE_LINE_PUBKEY_DIGEST_2 = 28,
-	EFUSE_LINE_PUBKEY_DIGEST_3 = 29,
-	EFUSE_LINE_PUBKEY_DIGEST_4 = 30,
-	EFUSE_LINE_CSK_0_VALID = 31,
-	EFUSE_LINE_CSK_1_VALID = 32,
-	EFUSE_LINE_CSK_2_VALID = 33,
-	EFUSE_LINE_CSK_3_VALID = 34,
-	EFUSE_LINE_CSK_4_VALID = 35,
-	EFUSE_LINE_CSK_5_VALID = 36,
-	EFUSE_LINE_CSK_6_VALID = 37,
-	EFUSE_LINE_CSK_7_VALID = 38,
-	EFUSE_LINE_CSK_8_VALID = 39,
-	EFUSE_LINE_CSK_9_VALID = 40,
-	EFUSE_LINE_CSK_10_VALID = 41,
-	EFUSE_LINE_CSK_11_VALID = 42,
-	EFUSE_LINE_CSK_12_VALID = 43,
-	EFUSE_LINE_CSK_13_VALID = 44,
-	EFUSE_LINE_CSK_14_VALID = 45,
-	EFUSE_LINE_CSK_15_VALID = 46,
-	EFUSE_LINE_FLASH_ID = 47,
-	EFUSE_LINE_BOX_ID = 48,
-
-	EFUSE_LINE_MIN = 0,
-	EFUSE_LINE_MAX = 63,
-};
-
-#endif
-
-int mvebu_efuse_init_hw(void);
-
-int mvebu_read_efuse(int nr, struct efuse_val *val);
-
-int mvebu_write_efuse(int nr, struct efuse_val *val);
-
-int mvebu_lock_efuse(int nr);
-
-#endif
diff --git a/arch/arm/mach-mvebu/include/mach/fw_info.h b/arch/arm/mach-mvebu/include/mach/fw_info.h
new file mode 100644
index 0000000..cc51fda
--- /dev/null
+++ b/arch/arm/mach-mvebu/include/mach/fw_info.h
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+#ifndef _FW_INFO_H_
+#define _FW_INFO_H_
+
+/* Protected ATF and TEE region */
+#define ATF_REGION_START		0x4000000
+#define ATF_REGION_END			0x5400000
+
+/* Firmware related definition used for SMC calls */
+#define MV_SIP_DRAM_SIZE		0x82000010
+
+#define MMIO_REGS_PHY_BASE		0xc0000000
+
+#endif /* _FW_INFO_H_ */
diff --git a/arch/arm/mach-mvebu/include/mach/soc.h b/arch/arm/mach-mvebu/include/mach/soc.h
index 1a06a1e..67025d4 100644
--- a/arch/arm/mach-mvebu/include/mach/soc.h
+++ b/arch/arm/mach-mvebu/include/mach/soc.h
@@ -36,7 +36,33 @@
 
 /* SOC specific definations */
 #define INTREG_BASE		0xd0000000
+
+#if defined(CONFIG_ARMADA_8K_PLUS)
+/*=============== A8K+ =================*/
+#define MVEBU_REGS_BASE_AP(ap)		(0xe8000000ULL - (ap) * 0x04000000)
+#define MVEBU_REGS_BASE_CP(ap, cp)	(0x8100000000ULL + \
+						(ap) * 0x1d00000000ULL + \
+						(cp) * 0x700000000ULL)
+#define MVEBU_CCU_MAX_WINS		(5)
+#define MVEBU_IO_WIN_MAX_WINS		(11)
+#define MVEBU_IO_WIN_GCR_OFFSET		(0xF0)
+#define MVEBU_GWIN_MAX_WINS		(16)
+#elif defined(CONFIG_ARMADA_8K)
+/*=============== A8K =================*/
+#define MVEBU_REGS_BASE_AP(ap)		(0xf0000000ULL)
+#define MVEBU_REGS_BASE_CP(ap, cp)	(0xf2000000ULL + (cp) * 0x02000000)
+#define MVEBU_CCU_MAX_WINS		(8)
+#define MVEBU_IO_WIN_MAX_WINS		(7)
+#define MVEBU_IO_WIN_GCR_OFFSET		(0x70)
+#endif
+
 #define INTREG_BASE_ADDR_REG	(INTREG_BASE + 0x20080)
+
+#if defined(CONFIG_ARMADA_8K)
+/*=============== A8K =================*/
+#define MVEBU_REGS_BASE_AP(ap)		(0xf0000000ULL)
+#endif
+
 #if defined(CONFIG_SPL_BUILD) || defined(CONFIG_ARMADA_3700)
 /*
  * The SPL U-Boot version still runs with the default
@@ -174,4 +200,9 @@
 #define BOOT_FROM_SPI		0x3
 #endif
 
+#ifndef __ASSEMBLY__
+void soc_print_device_info(void);
+int soc_get_ap_cp_num(void *ap_num, void *cp_num);
+void soc_print_system_cache_info(void);
+#endif /* __ASSEMBLY__ */
 #endif /* _MVEBU_SOC_H */
diff --git a/arch/arm/mach-mvebu/sata.c b/arch/arm/mach-mvebu/sata.c
deleted file mode 100644
index 5d8032b..0000000
--- a/arch/arm/mach-mvebu/sata.c
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (C) 2016 Stefan Roese <sr@denx.de>
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#include <common.h>
-#include <ahci.h>
-#include <dm.h>
-
-DECLARE_GLOBAL_DATA_PTR;
-
-/*
- * Dummy implementation that can be overwritten by a board
- * specific function
- */
-__weak int board_ahci_enable(void)
-{
-	return 0;
-}
-
-#ifdef CONFIG_ARMADA_8K
-/* CP110 has different AHCI port addresses */
-void __iomem *ahci_port_base(void __iomem *base, u32 port)
-{
-	return base + 0x10000 + (port * 0x10000);
-}
-#endif
-
-static int mvebu_ahci_probe(struct udevice *dev)
-{
-	/*
-	 * Board specific SATA / AHCI enable code, e.g. enable the
-	 * AHCI power or deassert reset
-	 */
-	board_ahci_enable();
-
-	ahci_init(devfdt_get_addr_ptr(dev));
-
-	return 0;
-}
-
-static const struct udevice_id mvebu_ahci_ids[] = {
-	{ .compatible = "marvell,armada-3700-ahci" },
-	{ .compatible = "marvell,armada-8k-ahci" },
-	{ }
-};
-
-U_BOOT_DRIVER(ahci_mvebu_drv) = {
-	.name		= "ahci_mvebu",
-	.id		= UCLASS_AHCI,
-	.of_match	= mvebu_ahci_ids,
-	.probe		= mvebu_ahci_probe,
-};
diff --git a/arch/arm/mach-mvebu/serdes/a38x/sys_env_lib.c b/arch/arm/mach-mvebu/serdes/a38x/sys_env_lib.c
index cc3e5e2..4f15746 100644
--- a/arch/arm/mach-mvebu/serdes/a38x/sys_env_lib.c
+++ b/arch/arm/mach-mvebu/serdes/a38x/sys_env_lib.c
@@ -235,3 +235,27 @@ u32 sys_env_device_id_get(void)
 
 	return g_dev_id;
 }
+
+/*
+ * sys_env_device_rev_get - Get Marvell controller device revision number
+ *
+ * DESCRIPTION:
+ *       This function returns 8bit describing the device revision as defined
+ *       Revision ID Register.
+ *
+ * INPUT:
+ *       None.
+ *
+ * OUTPUT:
+ *       None.
+ *
+ * RETURN:
+ *       8bit desscribing Marvell controller revision number
+ */
+u8 sys_env_device_rev_get(void)
+{
+	u32 value;
+
+	value = reg_read(DEV_VERSION_ID_REG);
+	return (value & (REVISON_ID_MASK)) >> REVISON_ID_OFFS;
+}
diff --git a/arch/arm/mach-octeontx/Kconfig b/arch/arm/mach-octeontx/Kconfig
new file mode 100644
index 0000000..cb520f5
--- /dev/null
+++ b/arch/arm/mach-octeontx/Kconfig
@@ -0,0 +1,19 @@
+if ARCH_OCTEONTX
+
+config SYS_VENDOR
+	string
+	default	"Marvell"
+
+config SYS_SOC
+	string
+	default "octeontx"
+
+config SYS_BOARD
+	string
+	default "octeontx"
+
+config SYS_PCI_64BIT
+	bool
+	default y
+
+endif
diff --git a/arch/arm/mach-octeontx/Makefile b/arch/arm/mach-octeontx/Makefile
new file mode 100644
index 0000000..c319234
--- /dev/null
+++ b/arch/arm/mach-octeontx/Makefile
@@ -0,0 +1,9 @@
+#/*
+# * Copyright (C) 2018 Marvell International Ltd.
+# *
+# * SPDX-License-Identifier:    GPL-2.0
+# * https://spdx.org/licenses
+# */
+
+obj-y += lowlevel_init.o clock.o cpu.o
+
diff --git a/arch/arm/mach-octeontx/clock.c b/arch/arm/mach-octeontx/clock.c
new file mode 100644
index 0000000..b6c127d
--- /dev/null
+++ b/arch/arm/mach-octeontx/clock.c
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+
+/**
+ * Returns the I/O clock speed in Hz
+ */
+u64 octeontx_get_io_clock(void)
+{
+	union cavm_rst_boot rst_boot;
+
+	rst_boot.u = readq(RST_BOOT);
+
+	return rst_boot.s.pnr_mul * PLL_REF_CLK;
+}
+
+/**
+ * Returns the core clock speed in Hz
+ */
+u64 octeontx_get_core_clock(void)
+{
+	union cavm_rst_boot rst_boot;
+
+	rst_boot.u = readq(RST_BOOT);
+
+	return rst_boot.s.c_mul * PLL_REF_CLK;
+}
diff --git a/arch/arm/mach-octeontx/cpu.c b/arch/arm/mach-octeontx/cpu.c
new file mode 100644
index 0000000..013dd81
--- /dev/null
+++ b/arch/arm/mach-octeontx/cpu.c
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <asm/armv8/mmu.h>
+#include <asm/io.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static struct mm_region octeontx_mem_map[] = {
+	{
+		.virt = 0x0UL,
+		.phys = 0x0UL,
+		.size = 0x40000000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) |
+			 PTE_BLOCK_NON_SHARE
+	}, {
+		.virt = 0x800000000000UL,
+		.phys = 0x800000000000UL,
+		.size = 0x40000000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE
+	}, {
+		.virt = 0x840000000000UL,
+		.phys = 0x840000000000UL,
+		.size = 0x40000000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE
+	}, {
+		.virt = 0x880000000000UL,
+		.phys = 0x880000000000UL,
+		.size = 0x40000000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE
+	}, {
+		/* List terminator */
+		0,
+	}
+};
+struct mm_region *mem_map = octeontx_mem_map;
+
+u64 get_page_table_size(void)
+{
+	return 0x4c000;
+}
+
+void reset_cpu(ulong addr)
+{
+
+}
diff --git a/arch/arm/mach-octeontx/fdt-helper.c b/arch/arm/mach-octeontx/fdt-helper.c
new file mode 100644
index 0000000..0bef17a
--- /dev/null
+++ b/arch/arm/mach-octeontx/fdt-helper.c
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+/* This file contains flat device-tree helper functions.
+ * At some later point these functions should be moved into U-Boot common code.
+ */
+
+#include <common.h>
+#include <libfdt.h>
+#include <fdtdec.h>
+#include <fdt_support.h>
+#include <asm/arch/fdt-helper.h>
+
+/**
+ * Given a FDT node, check if it is compatible with a list of devices
+ *
+ * @param[in]	fdt		Flat device tree pointer
+ * @param	node_offset	Node offset in device tree
+ * @param[in]	strlist		Array of FDT devices to check, end must be NULL
+ *
+ * @return	0 if at least one device is compatible, 1 if not compatible.
+ */
+int cavium_fdt_node_check_compatible(const void *fdt, int node_offset,
+				     const char * const *strlist)
+{
+	while (*strlist && **strlist) {
+		debug("%s: Checking %s\n", __func__, *strlist);
+		if (!fdt_node_check_compatible(fdt, node_offset, *strlist)) {
+			debug("%s: match found\n", __func__);
+			return 0;
+		}
+		strlist++;
+	}
+	debug("%s: No match found\n", __func__);
+	return 1;
+}
+
+/**
+ * Given a FDT node, return the next compatible node.
+ *
+ * @param[in]	fdt_addr	Pointer to flat device tree
+ * @param	start_offset	Starting node offset or -1 to find the first
+ * @param	strlist		Array of FDT device compatibility strings, must
+ *				end with NULL or empty string.
+ *
+ * @return	next matching node or -1 if no more matches.
+ */
+int cavium_fdt_node_offset_by_compatible_list(const void *fdt_addr,
+					      int startoffset,
+					      const char * const *strlist)
+{
+	int offset;
+	const char * const *searchlist;
+
+	for (offset = fdt_next_node(fdt_addr, startoffset, NULL);
+	     offset >= 0;
+	offset = fdt_next_node(fdt_addr, offset, NULL)) {
+		searchlist = strlist;
+		while (*searchlist && **searchlist) {
+			if (!fdt_node_check_compatible(fdt_addr, offset,
+				*searchlist))
+				return offset;
+			searchlist++;
+		}
+	}
+	return -1;
+}
+
diff --git a/arch/arm/mach-octeontx/lowlevel_init.S b/arch/arm/mach-octeontx/lowlevel_init.S
new file mode 100644
index 0000000..ed52ed2
--- /dev/null
+++ b/arch/arm/mach-octeontx/lowlevel_init.S
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <config.h>
+#include <linux/linkage.h>
+#include <asm/arch/octeontx_svc.h>
+
+#include <asm/macro.h>
+
+.align 8
+.global fdt_base_addr
+fdt_base_addr:
+	.dword 0x0
+
+.global save_boot_params
+save_boot_params:
+	/* Read FDT base from x1 register passed by ATF */
+	adr	x21, fdt_base_addr
+	str	x1, [x21]
+
+	/* Returns */
+	b	save_boot_params_ret
+
+ENTRY(lowlevel_init)
+	mov	x29, lr			/* Save LR */
+
+	/* any lowlevel init should go here */
+
+	mov	lr, x29			/* Restore LR */
+	ret
+ENDPROC(lowlevel_init)
+
diff --git a/arch/arm/mach-octeontx2/Kconfig b/arch/arm/mach-octeontx2/Kconfig
new file mode 100644
index 0000000..dcb50db
--- /dev/null
+++ b/arch/arm/mach-octeontx2/Kconfig
@@ -0,0 +1,29 @@
+if ARCH_OCTEONTX2
+
+choice
+	prompt "OcteonTX2 board select"
+	optional
+
+config TARGET_OCTEONTX2_95XX
+	bool "Marvell OcteonTX2 CN95XX"
+
+config TARGET_OCTEONTX2_96XX
+	bool "Marvell OcteonTX2 CN96XX"
+
+config TARGET_OCTEONTX2_LOKI
+	bool "Marvell OcteonTX2 LOKI"
+
+config TARGET_OCTEONTX2_98XX
+	bool "Marvell OcteonTX2 CN98XX"
+
+endchoice
+
+config SYS_SOC
+	string
+	default "octeontx2"
+
+config SYS_PCI_64BIT
+	bool
+	default y
+
+endif
diff --git a/arch/arm/mach-octeontx2/Makefile b/arch/arm/mach-octeontx2/Makefile
new file mode 100644
index 0000000..c319234
--- /dev/null
+++ b/arch/arm/mach-octeontx2/Makefile
@@ -0,0 +1,9 @@
+#/*
+# * Copyright (C) 2018 Marvell International Ltd.
+# *
+# * SPDX-License-Identifier:    GPL-2.0
+# * https://spdx.org/licenses
+# */
+
+obj-y += lowlevel_init.o clock.o cpu.o
+
diff --git a/arch/arm/mach-octeontx2/clock.c b/arch/arm/mach-octeontx2/clock.c
new file mode 100644
index 0000000..b6c127d
--- /dev/null
+++ b/arch/arm/mach-octeontx2/clock.c
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+
+/**
+ * Returns the I/O clock speed in Hz
+ */
+u64 octeontx_get_io_clock(void)
+{
+	union cavm_rst_boot rst_boot;
+
+	rst_boot.u = readq(RST_BOOT);
+
+	return rst_boot.s.pnr_mul * PLL_REF_CLK;
+}
+
+/**
+ * Returns the core clock speed in Hz
+ */
+u64 octeontx_get_core_clock(void)
+{
+	union cavm_rst_boot rst_boot;
+
+	rst_boot.u = readq(RST_BOOT);
+
+	return rst_boot.s.c_mul * PLL_REF_CLK;
+}
diff --git a/arch/arm/mach-octeontx2/config.mk b/arch/arm/mach-octeontx2/config.mk
new file mode 100644
index 0000000..9214f6b
--- /dev/null
+++ b/arch/arm/mach-octeontx2/config.mk
@@ -0,0 +1,4 @@
+ifeq ($(CONFIG_ARCH_OCTEONTX2),y)
+PLATFORM_CPPFLAGS += $(call cc-option,-march=armv8.2-a,)
+PLATFORM_CPPFLAGS += $(call cc-option,-mtune=octeontx2,)
+endif
diff --git a/arch/arm/mach-octeontx2/cpu.c b/arch/arm/mach-octeontx2/cpu.c
new file mode 100644
index 0000000..12d1daa
--- /dev/null
+++ b/arch/arm/mach-octeontx2/cpu.c
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <asm/armv8/mmu.h>
+#include <asm/io.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static struct mm_region octeontx2_mem_map[] = {
+	{
+		.virt = 0x0UL,
+		.phys = 0x0UL,
+		.size = 0x40000000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) |
+			 PTE_BLOCK_NON_SHARE
+	}, {
+		.virt = 0x800000000000UL,
+		.phys = 0x800000000000UL,
+		.size = 0x40000000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE
+	}, {
+		.virt = 0x840000000000UL,
+		.phys = 0x840000000000UL,
+		.size = 0x40000000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE
+	}, {
+		.virt = 0x880000000000UL,
+		.phys = 0x880000000000UL,
+		.size = 0x40000000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE
+	}, {
+		.virt = 0x8c0000000000UL,
+		.phys = 0x8c0000000000UL,
+		.size = 0x40000000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE
+	}, {
+		/* List terminator */
+		0,
+	}
+};
+struct mm_region *mem_map = octeontx2_mem_map;
+
+u64 get_page_table_size(void)
+{
+	return 0x6c000;
+}
+
+void reset_cpu(ulong addr)
+{
+
+}
diff --git a/arch/arm/mach-octeontx2/fdt-helper.c b/arch/arm/mach-octeontx2/fdt-helper.c
new file mode 100644
index 0000000..0bef17a
--- /dev/null
+++ b/arch/arm/mach-octeontx2/fdt-helper.c
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+/* This file contains flat device-tree helper functions.
+ * At some later point these functions should be moved into U-Boot common code.
+ */
+
+#include <common.h>
+#include <libfdt.h>
+#include <fdtdec.h>
+#include <fdt_support.h>
+#include <asm/arch/fdt-helper.h>
+
+/**
+ * Given a FDT node, check if it is compatible with a list of devices
+ *
+ * @param[in]	fdt		Flat device tree pointer
+ * @param	node_offset	Node offset in device tree
+ * @param[in]	strlist		Array of FDT devices to check, end must be NULL
+ *
+ * @return	0 if at least one device is compatible, 1 if not compatible.
+ */
+int cavium_fdt_node_check_compatible(const void *fdt, int node_offset,
+				     const char * const *strlist)
+{
+	while (*strlist && **strlist) {
+		debug("%s: Checking %s\n", __func__, *strlist);
+		if (!fdt_node_check_compatible(fdt, node_offset, *strlist)) {
+			debug("%s: match found\n", __func__);
+			return 0;
+		}
+		strlist++;
+	}
+	debug("%s: No match found\n", __func__);
+	return 1;
+}
+
+/**
+ * Given a FDT node, return the next compatible node.
+ *
+ * @param[in]	fdt_addr	Pointer to flat device tree
+ * @param	start_offset	Starting node offset or -1 to find the first
+ * @param	strlist		Array of FDT device compatibility strings, must
+ *				end with NULL or empty string.
+ *
+ * @return	next matching node or -1 if no more matches.
+ */
+int cavium_fdt_node_offset_by_compatible_list(const void *fdt_addr,
+					      int startoffset,
+					      const char * const *strlist)
+{
+	int offset;
+	const char * const *searchlist;
+
+	for (offset = fdt_next_node(fdt_addr, startoffset, NULL);
+	     offset >= 0;
+	offset = fdt_next_node(fdt_addr, offset, NULL)) {
+		searchlist = strlist;
+		while (*searchlist && **searchlist) {
+			if (!fdt_node_check_compatible(fdt_addr, offset,
+				*searchlist))
+				return offset;
+			searchlist++;
+		}
+	}
+	return -1;
+}
+
diff --git a/arch/arm/mach-octeontx2/lowlevel_init.S b/arch/arm/mach-octeontx2/lowlevel_init.S
new file mode 100644
index 0000000..cb6a5a0
--- /dev/null
+++ b/arch/arm/mach-octeontx2/lowlevel_init.S
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <config.h>
+#include <linux/linkage.h>
+#include <asm/macro.h>
+
+.align 8
+.global fdt_base_addr
+fdt_base_addr:
+	.dword 0x0
+
+.global save_boot_params
+save_boot_params:
+	/* Read FDT base from x1 register passed by ATF */
+	adr	x21, fdt_base_addr
+	str	x1, [x21]
+
+	/* Returns */
+	b	save_boot_params_ret
+
+ENTRY(lowlevel_init)
+	mov	x29, lr			/* Save LR */
+
+	/* any lowlevel init should go here */
+
+	mov	lr, x29			/* Restore LR */
+	ret
+ENDPROC(lowlevel_init)
+
diff --git a/board/Marvell/common/Kconfig b/board/Marvell/common/Kconfig
new file mode 100644
index 0000000..ec9d115
--- /dev/null
+++ b/board/Marvell/common/Kconfig
@@ -0,0 +1,22 @@
+menu "MVEBU Development Board Utilities"
+	depends on ARCH_MVEBU
+
+config BOARD_CONFIG_EEPROM
+	bool "Support configuration EEPROM"
+	default n
+	help
+	  If this option is enabled, U-Boot will initialize
+	  configuration EEPROM on board.
+	  It will be enabled once the CMD_MVEBU_BOX_INFO or
+	  MULTI_DT_FILE is enabled
+
+config MVEBU_SAR
+	bool "Support MVEBU SAR Utility"
+	default n
+	help
+	  Say Y here to add support for Sample
+	  at Reset Utility. You need this only if
+	  you work on a Marvell development board.
+	  If not, keep this off to reduce code size
+
+endmenu
diff --git a/board/Marvell/common/Makefile b/board/Marvell/common/Makefile
new file mode 100644
index 0000000..1adfef4
--- /dev/null
+++ b/board/Marvell/common/Makefile
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2018 Marvell International Ltd.
+#
+# SPDX-License-Identifier: GPL-2.0+
+# https://spdx.org/licenses
+#
+
+obj-$(CONFIG_BOARD_CONFIG_EEPROM)	+= cfg_eeprom.o
+obj-$(CONFIG_MVEBU_SAR)	+= sar.o
diff --git a/board/Marvell/common/cfg_eeprom.c b/board/Marvell/common/cfg_eeprom.c
new file mode 100644
index 0000000..6091568
--- /dev/null
+++ b/board/Marvell/common/cfg_eeprom.c
@@ -0,0 +1,386 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include <common.h>
+#include <mvebu/cfg_eeprom.h>
+
+struct eeprom_struct board_config_val = CFG_DEFAULT_VALUE;
+struct config_types_info config_types_info[] = MV_EEPROM_CONFIG_INFO;
+int eeprom_initialized = -1;
+int g_board_hw_info = -1;
+
+static char hw_info_param_list[][HW_INFO_MAX_NAME_LEN] = {
+	"pcb_slm",
+	"pcb_rev",
+	"eco_rev",
+	"pcb_sn",
+	"ethaddr",
+	"eth1addr",
+	"eth2addr",
+	"eth3addr",
+	"eth4addr",
+	"eth5addr",
+	"eth6addr",
+	"eth7addr",
+	"eth8addr",
+	"eth9addr"
+};
+
+static int hw_info_param_num = (sizeof(hw_info_param_list) /
+				sizeof(hw_info_param_list[0]));
+
+static u32 cfg_eeprom_checksum8(u8 *start, u32 len)
+{
+	u32 sum = 0;
+	u8 *startp = start;
+
+	do {
+		sum += *startp;
+		startp++;
+		len--;
+	} while (len > 0);
+	return sum;
+}
+
+/* cfg_eeprom_get_config_type
+ * config_info input pointer receive the mapping of the
+ * required field in the local struct
+ */
+static bool cfg_eeprom_get_config_type(enum mv_config_type_id id,
+				       struct config_types_info *config_info)
+{
+	int i;
+
+	/* verify existence of requested config type, pull its data */
+	for (i = 0; i < MV_CONFIG_TYPE_MAX_OPTION ; i++)
+		if (config_types_info[i].config_id == id) {
+			*config_info = config_types_info[i];
+			return true;
+		}
+	pr_err("requested MV_CONFIG_TYPE_ID was not found (%d)\n", id);
+
+	return false;
+}
+
+/* read specific field from EEPROM
+ * @data_length: if equal to -1 read number of bytes as the length of the field.
+ */
+static void read_field_from_eeprom(enum mv_config_type_id id,
+				   u8 *data, int data_length)
+{
+	struct config_types_info config_info;
+	struct udevice *dev;
+	int err;
+
+	err = i2c_get_chip_for_busnum(BOARD_HW_INFO_EEPROM_DEV,
+				      BOARD_DEV_TWSI_INIT_EEPROM,
+				      BOARD_HW_INFO_EEPROM_ADDR_LEN,
+				      &dev);
+	if (err) {
+		debug("%s: Cannot find EEPROM I2C chip\n", __func__);
+		return;
+	}
+
+	if (!cfg_eeprom_get_config_type(id, &config_info)) {
+		pr_err("Could not find field %x in EEPROM struct\n", id);
+		return;
+	}
+
+	if (data_length == READ_SPECIFIC_FIELD)
+		data_length = config_info.byte_cnt;
+
+	dm_i2c_read(dev, config_info.byte_num, data, data_length);
+}
+
+/* cfg_eeprom_write_to_eeprom - write the global struct to EEPROM. */
+int cfg_eeprom_write_to_eeprom(int length)
+{
+	int reserve_length, size_of_loop, i;
+	struct udevice *dev;
+	u8 *pattern = (u8 *)&board_config_val.pattern;
+	int err;
+
+	err = i2c_get_chip_for_busnum(BOARD_HW_INFO_EEPROM_DEV,
+				      BOARD_DEV_TWSI_INIT_EEPROM,
+				      BOARD_HW_INFO_EEPROM_ADDR_LEN,
+				      &dev);
+	if (err) {
+		debug("%s: Cannot find EEPROM I2C chip\n", __func__);
+		return err;
+	}
+
+	/* calculate checksum and save it in struct */
+	board_config_val.checksum = cfg_eeprom_checksum8(pattern,
+							 EEPROM_STRUCT_SIZE -
+							 4);
+
+	/* write fdt struct to EEPROM */
+	size_of_loop = length / I2C_PAGE_WRITE_SIZE;
+	reserve_length = length % I2C_PAGE_WRITE_SIZE;
+
+	/* i2c support on page write with size 32-byets */
+	for (i = 0; i < size_of_loop; i++) {
+		u8 *buffer = (u8 *)&(board_config_val) +
+						i * I2C_PAGE_WRITE_SIZE;
+		dm_i2c_write(dev, i * I2C_PAGE_WRITE_SIZE,
+			     buffer,
+			     I2C_PAGE_WRITE_SIZE);
+#ifdef CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS
+		/* EEPROM write need delay, or cause write operation fail */
+		udelay(CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS * 1000);
+#endif
+	}
+
+	/* write the reserve data from 32-bytes */
+	if (reserve_length) {
+		u8 *buffer = (u8 *)&(board_config_val) +
+						i * I2C_PAGE_WRITE_SIZE;
+		dm_i2c_write(dev, i * I2C_PAGE_WRITE_SIZE,
+			     buffer,
+			     reserve_length);
+#ifdef CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS
+		/* EEPROM write need delay */
+		udelay(CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS * 1000);
+#endif
+	}
+
+	return 0;
+}
+
+/* cfg_eeprom_save - write the local struct to EEPROM */
+void cfg_eeprom_save(int length)
+{
+	/* write local struct with fdt blob to EEPROM */
+	cfg_eeprom_write_to_eeprom(length);
+	/* reset g_board_id so it will get board ID from EEPROM again */
+	g_board_hw_info = -1;
+}
+
+/* cfg_eeprom_get_board_config - return the whole board config
+ * It is assumed the cfg_eeprom_init must be called prior to this routine,
+ * otherwise static default configuration will be used.
+ */
+struct eeprom_struct *cfg_eeprom_get_board_config(void)
+{
+	return &board_config_val;
+}
+
+/* cfg_eeprom_get_hw_info_str - copy hw_info from cfg_eeprom to destination */
+void cfg_eeprom_get_hw_info_str(uchar *hw_info_str)
+{
+	int len;
+
+	/* hw_info isn't initialized, need to read hw_info from EEPROM */
+	if (g_board_hw_info == -1) {
+		u8 *hw_info = (u8 *)board_config_val.man_info.hw_info;
+		/* read hw_info config from EEPROM */
+		read_field_from_eeprom(MV_CONFIG_HW_INFO,
+				       hw_info,
+				       READ_SPECIFIC_FIELD);
+	}
+	len = strlen((const char *)board_config_val.man_info.hw_info);
+	if (len >= MVEBU_HW_INFO_LEN)
+		len = MVEBU_HW_INFO_LEN - 1;
+
+	memcpy(hw_info_str, board_config_val.man_info.hw_info, len);
+}
+
+/* cfg_eeprom_set_hw_info_str - copy hw_info sting to cfg_eeprom module
+ * It is assumed the cfg_eeprom_init must be called prior to this routine,
+ * otherwise static default configuration will be used.
+ */
+void cfg_eeprom_set_hw_info_str(uchar *hw_info_str)
+{
+	int len;
+	struct config_types_info config_info;
+
+	/* read hw_info config from EEPROM */
+	if (!cfg_eeprom_get_config_type(MV_CONFIG_HW_INFO, &config_info)) {
+		pr_err("Could not find MV_CONFIG_hw_info\n");
+		return;
+	}
+
+	len = strlen((const char *)hw_info_str);
+	if (len >= config_info.byte_cnt)
+		len = config_info.byte_cnt - 1;
+
+	/* need to set all value to 0 at first for later string operation */
+	memset(board_config_val.man_info.hw_info, 0, config_info.byte_cnt);
+	memcpy(board_config_val.man_info.hw_info, hw_info_str, len);
+}
+
+/* cfg_eeprom_skip_space - skip the space character */
+static char *cfg_eeprom_skip_space(char *buf)
+{
+	while ((buf[0] == ' ' || buf[0] == '\t'))
+		++buf;
+	return buf;
+}
+
+/*
+ * cfg_eeprom_parse_hw_info
+ * - parse the hw_info from string to name/value pairs
+ */
+int cfg_eeprom_parse_hw_info(struct hw_info_data_struct *hw_info_data_array)
+{
+	int count;
+	char *name;
+	char *value;
+	int len;
+	uchar hw_info_str[MVEBU_HW_INFO_LEN];
+
+	/* need to set all to 0 for later string operation */
+	memset(hw_info_str, 0, sizeof(hw_info_str));
+
+	cfg_eeprom_get_hw_info_str(hw_info_str);
+	name = (char *)hw_info_str;
+	name = cfg_eeprom_skip_space(name);
+	/* return 0 in case the string is empty */
+	if (!name)
+		return 0;
+
+	for (count = 0; name; count++) {
+		value = strchr(name, '=');
+
+		if (!value)
+			return count;
+
+		*value = '\0';
+		len = strlen(name);
+		memcpy(hw_info_data_array[count].name, name, len);
+		hw_info_data_array[count].name[len] = '\0';
+		value++;
+
+		name = strchr(value, ' ');
+		if (!name)
+			return ++count;
+
+		*name = '\0';
+		len = strlen(value);
+		memcpy(hw_info_data_array[count].value, value, len);
+		hw_info_data_array[count].value[len] = '\0';
+		name = cfg_eeprom_skip_space(name + 1);
+	}
+	count++;
+
+	return count;
+}
+
+/* cfg_eeprom_validate_name - check parameter's name is valid or not
+ * valid - return 0
+ * invalid - return -1
+ */
+int cfg_eeprom_validate_name(char *name)
+{
+	int idx;
+
+	for (idx = 0; idx < hw_info_param_num; idx++) {
+		if (strcmp(name, hw_info_param_list[idx]) == 0)
+			return 0;
+	}
+
+	return -1;
+}
+
+/* cfg_eeprom_parse_env - parse the env from env to name/value pairs */
+int cfg_eeprom_parse_env(struct hw_info_data_struct *data_array,
+			 int size)
+{
+	int param_num = 0;
+	int idx;
+	int len;
+	char *name;
+	char *value;
+
+	/* need to memset to 0 for later string operation */
+	memset(data_array, 0, size);
+	for (idx = 0; idx < hw_info_param_num; idx++) {
+		name = hw_info_param_list[idx];
+		value = env_get(name);
+
+		if (!value) {
+			printf("miss %s in env, please set it at first\n",
+			       hw_info_param_list[idx]);
+			continue;
+		}
+
+		len = strlen(name);
+		if (len > HW_INFO_MAX_NAME_LEN)
+			len  = HW_INFO_MAX_NAME_LEN;
+		memcpy(data_array[param_num].name, name, len);
+		len = strlen(value);
+		if (len > HW_INFO_MAX_NAME_LEN)
+			len  = HW_INFO_MAX_NAME_LEN;
+		memcpy(data_array[param_num].value, value, len);
+
+		param_num++;
+	}
+
+	return param_num;
+}
+
+/*
+ * cfg_eeprom_init - initialize FDT configuration struct
+ * The EEPROM FDT is used if 1) the checksum is valid, 2) the system
+ * is not in recovery mode, 3) validation_counter < AUTO_RECOVERY_RETRY_TIMES
+ * Otherwise the default FDT is used.
+ */
+int cfg_eeprom_init(void)
+{
+	struct eeprom_struct eeprom_buffer;
+	u32 calculate_checksum;
+	struct udevice *dev;
+	u8 *pattern = (u8 *)&eeprom_buffer.pattern;
+	int err;
+
+	err = i2c_get_chip_for_busnum(BOARD_HW_INFO_EEPROM_DEV,
+				      BOARD_DEV_TWSI_INIT_EEPROM,
+				      BOARD_HW_INFO_EEPROM_ADDR_LEN,
+				      &dev);
+	if (err) {
+		debug("%s: Cannot find EEPROM I2C chip\n", __func__);
+		return err;
+	}
+
+	/* It is possible that this init will be called by several
+	 * modules during init, however only need to initialize it
+	 * for one time
+	 */
+	if (eeprom_initialized == 1)
+		return 0;
+
+	/* read pattern from EEPROM */
+	read_field_from_eeprom(MV_CONFIG_PATTERN,
+			       pattern,
+			       READ_SPECIFIC_FIELD);
+
+	/* check if pattern in EEPROM is invalid */
+	if (eeprom_buffer.pattern != board_config_val.pattern) {
+		printf("EEPROM configuration pattern not detected.\n");
+		goto init_done;
+	}
+
+	/* read struct from EEPROM */
+	err = dm_i2c_read(dev, 0,
+			  (u8 *)&eeprom_buffer,
+			  EEPROM_STRUCT_SIZE);
+	if (err) {
+		pr_err("read error from device: %p", dev);
+		return err;
+	}
+
+	/* calculate checksum */
+	calculate_checksum = cfg_eeprom_checksum8(pattern,
+						  EEPROM_STRUCT_SIZE - 4);
+	if (calculate_checksum == eeprom_buffer.checksum) {
+		/* update board_config_val struct with read from EEPROM */
+		board_config_val = eeprom_buffer;
+	}
+
+init_done:
+	eeprom_initialized = 1;
+	return 0;
+}
+
diff --git a/board/Marvell/common/sar.c b/board/Marvell/common/sar.c
new file mode 100644
index 0000000..6e94196
--- /dev/null
+++ b/board/Marvell/common/sar.c
@@ -0,0 +1,516 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:       GPL-2.0+
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <i2c.h>
+#include <fdtdec.h>
+#include <mvebu/sar.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+struct sar_data  __attribute__((section(".data"))) sar_board;
+#define board_get_sar() (&sar_board)
+#define board_get_sar_table() (sar_board.sar_lookup)
+
+static u32 swap_value(u32 val, u32 bit_length)
+{
+	u32 var_mask = (1 << bit_length) - 1;
+
+	val = (val & 0xFFFF0000) >> 16 | (val & 0x0000FFFF) << 16;
+	val = (val & 0xFF00FF00) >> 8 | (val & 0x00FF00FF) << 8;
+	val = (val & 0xF0F0F0F0) >> 4 | (val & 0x0F0F0F0F) << 4;
+	val = (val & 0xCCCCCCCC) >> 2 | (val & 0x33333333) << 2;
+	val = (val & 0xAAAAAAAA) >> 1 | (val & 0x55555555) << 1;
+	val = (val >> (32 - bit_length)) & var_mask;
+	debug("value is swaped, new value = 0x%x\n", val);
+
+	return val;
+}
+
+static int sar_read_reg(u32 *reg)
+{
+	struct udevice *dev;
+	uchar byte = 0;
+	int ret, chip;
+	u32 sar_reg = 0;
+	struct sar_data *sar = board_get_sar();
+	int reg_width = sar->bit_width;
+	u8  reg_mask = (1 << reg_width) - 1;
+
+	for (chip = 0; chip  < sar->chip_count; chip++) {
+		ret = i2c_get_chip_for_busnum(0, sar->chip_addr[chip], 1, &dev);
+		if (ret) {
+			printf("Error: %s: Failed getting chip busnum 0x%x\n",
+			       __func__, sar->chip_addr[chip]);
+			return -1;
+		}
+		ret = dm_i2c_read(dev, 0, &byte, 1);
+		if (ret) {
+			printf("Error: %s: Failed reading from chip 0x%x\n",
+			       __func__, sar->chip_addr[chip]);
+			return -1;
+		}
+		sar_reg |= (byte & reg_mask) << (chip * reg_width);
+	}
+	debug("read: sar register = 0x%08x\n", sar_reg);
+	*reg = sar_reg;
+
+	return 0;
+}
+
+int sar_write_reg(u32 sar_reg)
+{
+	struct udevice *dev;
+	uchar byte = 0;
+	int ret, chip;
+	struct sar_data *sar = board_get_sar();
+	int reg_width = sar->bit_width;
+	u8  reg_mask = (1 << reg_width) - 1;
+
+	for (chip = 0; chip  < sar->chip_count; chip++) {
+		byte = (sar_reg >> (chip * reg_width)) & reg_mask;
+		ret = i2c_get_chip_for_busnum(0, sar->chip_addr[chip], 1, &dev);
+		if (ret) {
+			printf("Error: %s: Failed getting chip busnum 0x%x\n",
+			       __func__, sar->chip_addr[chip]);
+			return -1;
+		}
+
+		ret = dm_i2c_write(dev, 0, &byte, 1);
+		if (ret) {
+			printf("Error: %s: Failed writing to chip 0x%x\n",
+			       __func__, sar->chip_addr[chip]);
+			return -1;
+		}
+	}
+	debug("write: sar register = 0x%08x\n", sar_reg);
+	/*
+	 * Wait for the write to complete. The write can take
+	 * up to 10mSec (we allow a little more time).
+	 */
+	mdelay(11);
+
+	return 0;
+}
+
+int sar_read_var(struct sar_var *var, int *val)
+{
+	u32 sar_reg;
+	u32 var_mask = (1 << var->bit_length) - 1;
+
+	if (sar_read_reg(&sar_reg))
+		return -1;
+
+	(*val) = (sar_reg >> var->start_bit) & var_mask;
+	if (var->swap_bit)
+		(*val) = swap_value(*val, var->bit_length);
+
+	debug("var offset = %d len = %d val = 0x%x\n", var->start_bit,
+	      var->bit_length, (*val));
+
+	return 0;
+}
+
+int sar_write_var(struct sar_var *var, int val)
+{
+	u32 sar_reg;
+	u32 var_mask = (1 << var->bit_length) - 1;
+
+	if (sar_read_reg(&sar_reg))
+		return -1;
+
+	/* Update the bitfield inside the sar register */
+	if (var->swap_bit)
+		val = swap_value(val, var->bit_length);
+	val &= var_mask;
+	sar_reg &= ~(var_mask << var->start_bit);
+	sar_reg |= (val << var->start_bit);
+
+	/* Write the full sar register back to i2c */
+	if (sar_write_reg(sar_reg))
+		return -1;
+
+	return 0;
+}
+
+static int sar_default_var(struct sar_var *var)
+{
+	struct var_opts *opts;
+	struct var_opts *dflt =	NULL;
+	int i;
+
+	opts = var->option_desc;
+
+	for (i = 0; i < var->option_cnt; i++, opts++) {
+		if (opts->flags & VAR_IS_DEFAULT)
+			dflt = opts;
+	}
+
+	if (!dflt) {
+		printf("Error: Failed to find default option");
+		return -1;
+	}
+
+	if (sar_write_var(var, dflt->value)) {
+		printf("Error: Failed to write default value");
+		return -1;
+	}
+
+	debug("Wrote default value 0x%x = %s\n", dflt->value, dflt->desc);
+	return 0;
+}
+
+int sar_get_key_id(const char *key)
+{
+	struct sar_var *sar_table = board_get_sar_table();
+	int id;
+
+	for (id = 0; id < MAX_SAR; id++) {
+		if (strcmp(key, sar_table[id].key) == 0)
+			return id;
+	}
+	return -1;
+}
+
+int sar_is_var_active(int id)
+{
+	struct sar_var *sar_table = board_get_sar_table();
+
+	return sar_table[id].active;
+}
+
+struct var_opts *sar_get_var_opts(int id, int *cnt)
+{
+	struct sar_var *sar_table = board_get_sar_table();
+
+	(*cnt) = sar_table[id].option_cnt;
+
+	return sar_table[id].option_desc;
+}
+
+int sar_validate_key(const char *key)
+{
+	int id = sar_get_key_id(key);
+
+	if (id  == -1) {
+		printf("Satr: Error: Unknown key \"%s\"\n", key);
+		return -1;
+	}
+	if (sar_is_var_active(id) == 0) {
+		printf("Satr: Error: Key \"%s\" is inactive on this board\n",
+		       key);
+		return -1;
+	}
+	return id;
+}
+
+struct sar_var *sar_id_to_var(int id)
+{
+	struct sar_var *sar_table = board_get_sar_table();
+
+	sar_table += id;
+	return sar_table;
+}
+
+/* Interface to SatR command */
+int sar_is_available(void)
+{
+	if (!board_get_sar_table())
+		return 0;
+	else
+		return 1;
+}
+
+void sar_print_var(int id, bool print_opts)
+{
+	int cnt;
+	struct var_opts *opts;
+	struct sar_var *sar_table = board_get_sar_table();
+
+	printf("%-10s %s\n", sar_table[id].key, sar_table[id].desc);
+
+	if (print_opts) {
+		opts = sar_get_var_opts(id, &cnt);
+		while (cnt--) {
+			printf("\t0x%-2x %s ", opts->value, opts->desc);
+			if (opts->flags & VAR_IS_DEFAULT)
+				printf("[Default]");
+			printf("\n");
+			opts++;
+		}
+	}
+}
+
+int sar_read_all(void)
+{
+	struct sar_var *var;
+	int id;
+
+	for (id = 0; id < MAX_SAR; id++)
+		if (sar_is_var_active(id)) {
+			var = sar_id_to_var(id);
+			sar_print_key(var->key);
+		}
+
+	return 0;
+}
+
+void sar_list_keys(void)
+{
+	int id;
+
+	printf("\n");
+	for (id = 0; id < MAX_SAR; id++) {
+		if (sar_is_var_active(id))
+			sar_print_var(id, 0);
+	}
+	printf("\n");
+}
+
+int sar_list_key_opts(const char *key)
+{
+	int id = sar_validate_key(key);
+
+	if (id == -1)
+		return -EINVAL;
+
+	printf("\n");
+	sar_print_var(id, 1);
+	printf("\n");
+
+	return 0;
+}
+
+int  sar_print_key(const char *key)
+{
+	int id = sar_validate_key(key);
+	struct sar_var *var;
+	struct var_opts *opts;
+	char *desc = NULL;
+	int val, ret, cnt;
+
+	if (id == -1)
+		return -EINVAL;
+
+	var = sar_id_to_var(id);
+	ret = sar_read_var(var, &val);
+	if (ret)
+		return ret;
+
+	opts = sar_get_var_opts(id, &cnt);
+	while (cnt--) {
+		if (opts->value == val)
+			desc = opts->desc;
+		opts++;
+	}
+
+	if (!desc)
+		printf("%s = 0x%x  ERROR: UNKNOWN OPTION\n", key, val);
+	else
+		printf("%s = 0x%x  %s\n", key, val, desc);
+
+	return 0;
+}
+
+int  sar_write_key(const char *key, int val)
+{
+	int id = sar_validate_key(key);
+	struct sar_var *var;
+	struct var_opts *opts;
+	char *desc = NULL;
+	int cnt;
+
+	if (id == -1)
+		return -EINVAL;
+
+	var = sar_id_to_var(id);
+	opts = sar_get_var_opts(id, &cnt);
+	while (cnt--) {
+		if (opts->value == val)
+			desc = opts->desc;
+		opts++;
+	}
+
+	if (!desc) {
+		printf("ERROR: value 0x%x not supported for key %s\n",
+		       val, key);
+		printf("use \"SatR list %s\" to print supported values\n",
+		       key);
+		return -1;
+	}
+
+	if (sar_write_var(var, val))
+		return -1;
+
+	/* Display the updated variable */
+	sar_print_key(key);
+
+	return 0;
+}
+
+int sar_default_all(void)
+{
+	struct sar_var *var;
+	int id;
+	int ret = 0;
+
+	for (id = 0; id < MAX_SAR; id++) {
+		if (sar_is_var_active(id)) {
+			var = sar_id_to_var(id);
+			ret |= sar_default_var(var);
+			sar_print_key(var->key);
+		}
+	}
+
+	return ret;
+}
+
+int  sar_default_key(const char *key)
+{
+	int id = sar_validate_key(key);
+	struct sar_var *var;
+	int ret;
+
+	if (id == -1)
+		return -EINVAL;
+
+	var = sar_id_to_var(id);
+	ret = sar_default_var(var);
+	if (ret)
+		return ret;
+
+	/* Display the updated variable */
+	sar_print_key(key);
+
+	return 0;
+}
+
+static void sar_dump(void)
+{
+#ifdef DEBUG
+	struct sar_data *sar = board_get_sar();
+	struct sar_var *sar_var;
+	int i, id;
+
+	printf("Sample at reset Dumper:\n");
+	printf("\tSatR had %d chip addresses: ", sar->chip_count);
+	for (i = 0; i < sar->chip_count; i++)
+		printf("0x%x ", sar->chip_addr[i]);
+	printf("\n\tBit width for the I2C chip is: 0x%x\n", sar->bit_width);
+	printf("\tAll SatR variables thet available:\n");
+	for (i = 0, sar_var = sar->sar_lookup; i < MAX_SAR; i++, sar_var++) {
+		if (sar_var->active == 0)
+			continue;
+		printf("\t\tID = %d, ", i);
+		printf("Key = %s, ", sar_var->key);
+		printf("Desc. = %s", sar_var->desc);
+		if (sar_var->swap_bit)
+			printf(", BIT is swapped");
+		printf("\n\t\tStart bit = 0x%x, ", sar_var->start_bit);
+		printf("Bit length = %d\n", sar_var->bit_length);
+		printf("\t\tThis variable had %d options:\n",
+		       sar_var->option_cnt);
+		for (id = 0; id < sar_var->option_cnt; id++) {
+			printf("\t\t\tValue = 0x%x, ",
+			       sar_var->option_desc[id].value);
+			printf("Desc. = %s, ", sar_var->option_desc[id].desc);
+			printf("Is Default = %d\n",
+			       sar_var->option_desc[id].flags);
+		}
+	}
+#endif
+}
+
+void sar_init(void)
+{
+	int i, var_default;
+	int node, var, len, lenp;
+	const char *str;
+	const void *blob = gd->fdt_blob;
+	struct sar_var *sar_var;
+	struct sar_data *sar = board_get_sar();
+
+	/* Get sar node from the FDT blob */
+	node = fdt_node_offset_by_compatible(blob, -1,
+					     fdtdec_get_compatible(
+					     COMPAT_MVEBU_SAR));
+	if (node < 0) {
+		debug("No sar node found in FDT blob\n");
+		return;
+	}
+
+	/* Get the bit width of the sapmple at reset i2c register */
+	sar->bit_width = fdtdec_get_int(blob, node, "bit_width", 1);
+	/* Get the address count of sample at reset i2c */
+	sar->chip_count = fdtdec_get_int(blob, node, "chip_count", 1);
+	/* get the address in array */
+	if (fdtdec_get_int_array(blob, node, "reg",
+				 sar->chip_addr, sar->chip_count) != 0) {
+		pr_err("No sample at reset addresses found in FDT blob\n");
+		return;
+	}
+	/* Get the fisrt variable in sample at reset */
+	var = fdt_first_subnode(blob, node);
+	if (!var) {
+		pr_err("No sample at reset variables found in FDT\n");
+		return;
+	}
+	sar_var = sar->sar_lookup;
+	/* Find the variables under sample at reset node */
+	while (var > 0) {
+		/* if the variable is disabled skip it */
+		if (!fdtdec_get_is_enabled(blob, var)) {
+			/* Get the offset of the next subnode */
+			var = fdt_next_subnode(blob, var);
+			sar_var++;
+			continue;
+		}
+		/* Get the key of the var option */
+		sar_var->key = (char *)fdt_stringlist_get(blob, var, "key",
+							  0, &lenp);
+		/* Get the description of the var */
+		sar_var->desc = (char *)fdt_stringlist_get(blob, var,
+							   "description", 0,
+							   &lenp);
+		/* set the different options of the var */
+		sar_var->active = 1;
+		sar_var->start_bit = fdtdec_get_int(blob, var, "start-bit", 0);
+		sar_var->bit_length = fdtdec_get_int(blob, var,
+						     "bit-length", 0);
+		sar_var->option_cnt = fdtdec_get_int(blob, var,
+						     "option-cnt", 0);
+		sar_var->swap_bit = fdtdec_get_bool(blob, var, "swap-bit");
+		/* Get the options list */
+		len = fdt_stringlist_count(blob, var, "options");
+		if ((len < 0) || (sar_var->option_cnt * 2 != len)) {
+			pr_err("%s: failed to parse the \"options\" property",
+			       __func__);
+			return;
+		}
+		var_default = fdtdec_get_int(blob, var, "default", 0);
+		/* Fill the struct with the options from the FDT */
+		for (i = 0; i < len; i += 2) {
+			str = fdt_stringlist_get(blob, var, "options", i,
+						 &lenp);
+			sar_var->option_desc[i / 2].value = simple_strtoul(
+							  str, NULL, 16);
+			sar_var->option_desc[i / 2].desc =
+			(char *)fdt_stringlist_get(blob, var, "options",
+						   i + 1, &lenp);
+			if (sar_var->option_desc[i / 2].value == var_default)
+				sar_var->option_desc[i / 2].flags =
+				VAR_IS_DEFAULT;
+		}
+		/* Get the offset of the next subnode */
+		var = fdt_next_subnode(blob, var);
+		sar_var++;
+	}
+
+	sar_dump();
+}
diff --git a/board/Marvell/mvebu_armada-37xx/board.c b/board/Marvell/mvebu_armada-37xx/board.c
index ac3e3a3..24ab3c0 100644
--- a/board/Marvell/mvebu_armada-37xx/board.c
+++ b/board/Marvell/mvebu_armada-37xx/board.c
@@ -11,15 +11,29 @@
 #include <asm/io.h>
 #include <asm/arch/cpu.h>
 #include <asm/arch/soc.h>
+#include <power/regulator.h>
+#ifdef CONFIG_BOARD_CONFIG_EEPROM
+#include <mvebu/cfg_eeprom.h>
+#endif
 
 DECLARE_GLOBAL_DATA_PTR;
 
+/* on Armada3700 rev2 devel-board, IO expander (with I2C address 0x22) bit
+ * 14 is used as Serdes Lane 2 muxing, which could be used as SATA PHY or
+ * USB3 PHY.
+ */
+enum COMPHY_LANE2_MUXING {
+	COMPHY_LANE2_MUX_USB3,
+	COMPHY_LANE2_MUX_SATA
+};
+
 /* IO expander I2C device */
 #define I2C_IO_EXP_ADDR		0x22
 #define I2C_IO_CFG_REG_0	0x6
 #define I2C_IO_DATA_OUT_REG_0	0x2
 #define I2C_IO_REG_0_SATA_OFF	2
 #define I2C_IO_REG_0_USB_H_OFF	1
+#define I2C_IO_COMPHY_SATA3_USB_MUX_BIT	14
 
 /* The pin control values are the same for DB and Espressobin */
 #define PINCTRL_NB_REG_VALUE	0x000173fa
@@ -48,39 +62,84 @@ DECLARE_GLOBAL_DATA_PTR;
 #define MVEBU_G2_SMI_PHY_CMD_REG	(24)
 #define MVEBU_G2_SMI_PHY_DATA_REG	(25)
 
-int board_early_init_f(void)
+/*
+* For Armada3700 A0 chip, comphy serdes lane 2 could be used as PHY for SATA
+* or USB3.
+* For Armada3700 rev2 devel-board, pin 14 of IO expander PCA9555 with I2C
+* address 0x22 is used as Serdes Lane 2 muxing; the pin needs to be set in
+* output mode: high level is for SATA while low level is for USB3;
+*/
+static int board_comphy_usb3_sata_mux(enum COMPHY_LANE2_MUXING comphy_mux)
 {
-	const void *blob = gd->fdt_blob;
-	const char *bank_name;
-	const char *compat = "marvell,armada-3700-pinctl";
-	int off, len;
-	void __iomem *addr;
-
-	/* FIXME
-	 * Temporary WA for setting correct pin control values
-	 * until the real pin control driver is awailable.
-	 */
-	off = fdt_node_offset_by_compatible(blob, -1, compat);
-	while (off != -FDT_ERR_NOTFOUND) {
-		bank_name = fdt_getprop(blob, off, "bank-name", &len);
-		addr = (void __iomem *)fdtdec_get_addr_size_auto_noparent(
-				blob, off, "reg", 0, NULL, true);
-		if (!strncmp(bank_name, "armada-3700-nb", len))
-			writel(PINCTRL_NB_REG_VALUE, addr);
-		else if (!strncmp(bank_name, "armada-3700-sb", len))
-			writel(PINCTRL_SB_REG_VALUE, addr);
-
-		off = fdt_node_offset_by_compatible(blob, off, compat);
+	int ret;
+	u8 buf[8];
+	struct udevice *i2c_dev;
+	int i2c_byte, i2c_bit_in_byte;
+
+	if (!of_machine_is_compatible("marvell,armada-3720-db-v2") &&
+	    !of_machine_is_compatible("marvell,armada-3720-db-v3"))
+		return 0;
+
+	ret = i2c_get_chip_for_busnum(0, I2C_IO_EXP_ADDR, 1, &i2c_dev);
+	if (ret) {
+		printf("Cannot find PCA9555: %d\n", ret);
+		return 0;
+	}
+
+	ret = dm_i2c_read(i2c_dev, I2C_IO_CFG_REG_0, buf, 2);
+	if (ret) {
+		printf("Failed to read IO expander value via I2C\n");
+		return ret;
+	}
+
+	i2c_byte = I2C_IO_COMPHY_SATA3_USB_MUX_BIT / 8;
+	i2c_bit_in_byte = I2C_IO_COMPHY_SATA3_USB_MUX_BIT % 8;
+
+	/* Configure IO exander bit 14 of address 0x22 in output mode */
+	buf[i2c_byte] &= ~(1 << i2c_bit_in_byte);
+	ret = dm_i2c_write(i2c_dev, I2C_IO_CFG_REG_0, buf, 2);
+	if (ret) {
+		printf("Failed to set IO expander via I2C\n");
+		return ret;
+	}
+
+	ret = dm_i2c_read(i2c_dev, I2C_IO_DATA_OUT_REG_0, buf, 2);
+	if (ret) {
+		printf("Failed to read IO expander value via I2C\n");
+		return ret;
+	}
+
+	/* Configure output level for IO exander bit 14 of address 0x22 */
+	if (comphy_mux == COMPHY_LANE2_MUX_SATA)
+		buf[i2c_byte] |= (1 << i2c_bit_in_byte);
+	else
+		buf[i2c_byte] &= ~(1 << i2c_bit_in_byte);
+
+	ret = dm_i2c_write(i2c_dev, I2C_IO_DATA_OUT_REG_0, buf, 2);
+	if (ret) {
+		printf("Failed to set IO expander via I2C\n");
+		return ret;
 	}
 
 	return 0;
 }
 
+int board_early_init_f(void)
+{
+#ifdef CONFIG_BOARD_CONFIG_EEPROM
+	cfg_eeprom_init();
+#endif
+	return 0;
+}
+
 int board_init(void)
 {
 	/* adress of boot parameters */
 	gd->bd->bi_boot_params = CONFIG_SYS_SDRAM_BASE + 0x100;
 
+	/* enable serdes lane 2 mux for sata phy */
+	board_comphy_usb3_sata_mux(COMPHY_LANE2_MUX_SATA);
+
 	return 0;
 }
 
diff --git a/board/Marvell/mvebu_armada-8k/board.c b/board/Marvell/mvebu_armada-8k/board.c
index f4eabfb..ff4cda4 100644
--- a/board/Marvell/mvebu_armada-8k/board.c
+++ b/board/Marvell/mvebu_armada-8k/board.c
@@ -10,153 +10,71 @@
 #include <asm/io.h>
 #include <asm/arch/cpu.h>
 #include <asm/arch/soc.h>
+#include <power/regulator.h>
+#ifdef CONFIG_BOARD_CONFIG_EEPROM
+#include <mvebu/cfg_eeprom.h>
+#endif
 
-DECLARE_GLOBAL_DATA_PTR;
+#define CP_USB20_BASE_REG(cp, p)	(MVEBU_REGS_BASE_CP(0, cp) + \
+						0x00580000 + 0x1000 * (p))
+#define CP_USB20_TX_CTRL_REG(cp, p)	(CP_USB20_BASE_REG(cp, p) + 0xC)
+#define CP_USB20_TX_OUT_AMPL_MASK	(0x7 << 20)
+#define CP_USB20_TX_OUT_AMPL_VALUE	(0x3 << 20)
 
-/*
- * Information specific to the DB-88F7040 eval board. We strive to use
- * DT for such platform specfic configurations. At some point, this
- * might be removed here and implemented via DT.
- */
-/* IO expander I2C device */
-#define I2C_IO_EXP_ADDR		0x21
-#define I2C_IO_CFG_REG_0	0x6
-#define I2C_IO_DATA_OUT_REG_0	0x2
-/* VBus enable */
-#define I2C_IO_REG_0_USB_H0_OFF	0
-#define I2C_IO_REG_0_USB_H1_OFF	1
-#define I2C_IO_REG_VBUS		((1 << I2C_IO_REG_0_USB_H0_OFF) | \
-				 (1 << I2C_IO_REG_0_USB_H1_OFF))
-/* Current limit */
-#define I2C_IO_REG_0_USB_H0_CL	4
-#define I2C_IO_REG_0_USB_H1_CL	5
-#define I2C_IO_REG_CL		((1 << I2C_IO_REG_0_USB_H0_CL) | \
-				 (1 << I2C_IO_REG_0_USB_H1_CL))
-
-static int usb_enabled = 0;
-
-/* Board specific xHCI dis-/enable code */
+DECLARE_GLOBAL_DATA_PTR;
 
-/*
- * Set USB VBUS signals (via I2C IO expander/GPIO) as output and set
- * output value as disabled
- *
- * Set USB Current Limit signals (via I2C IO expander/GPIO) as output
- * and set output value as enabled
- */
-int board_xhci_config(void)
+int __soc_early_init_f(void)
 {
-	struct udevice *dev;
-	int ret;
-	u8 buf[8];
-
-	if (of_machine_is_compatible("marvell,armada7040-db")) {
-		/* Configure IO exander PCA9555: 7bit address 0x21 */
-		ret = i2c_get_chip_for_busnum(0, I2C_IO_EXP_ADDR, 1, &dev);
-		if (ret) {
-			printf("Cannot find PCA9555: %d\n", ret);
-			return 0;
-		}
-
-		/*
-		 * Read configuration (direction) and set VBUS pin as output
-		 * (reset pin = output)
-		 */
-		ret = dm_i2c_read(dev, I2C_IO_CFG_REG_0, buf, 1);
-		if (ret) {
-			printf("Failed to read IO expander value via I2C\n");
-			return -EIO;
-		}
-		buf[0] &= ~I2C_IO_REG_VBUS;
-		buf[0] &= ~I2C_IO_REG_CL;
-		ret = dm_i2c_write(dev, I2C_IO_CFG_REG_0, buf, 1);
-		if (ret) {
-			printf("Failed to set IO expander via I2C\n");
-			return -EIO;
-		}
-
-		/* Read output value and configure it */
-		ret = dm_i2c_read(dev, I2C_IO_DATA_OUT_REG_0, buf, 1);
-		if (ret) {
-			printf("Failed to read IO expander value via I2C\n");
-			return -EIO;
-		}
-		buf[0] &= ~I2C_IO_REG_VBUS;
-		buf[0] |= I2C_IO_REG_CL;
-		ret = dm_i2c_write(dev, I2C_IO_DATA_OUT_REG_0, buf, 1);
-		if (ret) {
-			printf("Failed to set IO expander via I2C\n");
-			return -EIO;
-		}
-
-		mdelay(500); /* required delay to let output value settle */
-	}
-
 	return 0;
 }
 
-int board_xhci_enable(fdt_addr_t base)
+int soc_early_init_f(void)
+			__attribute__((weak, alias("__soc_early_init_f")));
+
+int board_early_init_f(void)
 {
-	struct udevice *dev;
-	int ret;
-	u8 buf[8];
-
-	if (of_machine_is_compatible("marvell,armada7040-db")) {
-		/*
-		 * This function enables all USB ports simultaniously,
-		 * it only needs to get called once
-		 */
-		if (usb_enabled)
-			return 0;
-
-		/* Configure IO exander PCA9555: 7bit address 0x21 */
-		ret = i2c_get_chip_for_busnum(0, I2C_IO_EXP_ADDR, 1, &dev);
-		if (ret) {
-			printf("Cannot find PCA9555: %d\n", ret);
-			return 0;
-		}
-
-		/* Read VBUS output value */
-		ret = dm_i2c_read(dev, I2C_IO_DATA_OUT_REG_0, buf, 1);
-		if (ret) {
-			printf("Failed to read IO expander value via I2C\n");
-			return -EIO;
-		}
-
-		/* Enable VBUS power: Set output value of VBUS pin as enabled */
-		buf[0] |= I2C_IO_REG_VBUS;
-		ret = dm_i2c_write(dev, I2C_IO_DATA_OUT_REG_0, buf, 1);
-		if (ret) {
-			printf("Failed to set IO expander via I2C\n");
-			return -EIO;
-		}
-
-		mdelay(500); /* required delay to let output value settle */
-		usb_enabled = 1;
-	}
+	soc_early_init_f();
 
 	return 0;
 }
 
-int board_early_init_f(void)
+int board_early_init_r(void)
 {
-	/* Nothing to do (yet), perhaps later some pin-muxing etc */
+#ifdef CONFIG_DM_REGULATOR
+	/* Check if any existing regulator should be turned down */
+	regulators_enable_boot_off(false);
+#endif
 
 	return 0;
 }
 
 int board_init(void)
 {
-	/* adress of boot parameters */
+	/* address of boot parameters */
 	gd->bd->bi_boot_params = CONFIG_SYS_SDRAM_BASE + 0x100;
 
+#ifdef CONFIG_BOARD_CONFIG_EEPROM
+	cfg_eeprom_init();
+#endif
+
 	return 0;
 }
 
 int board_late_init(void)
 {
 	/* Pre-configure the USB ports (overcurrent, VBus) */
-	board_xhci_config();
+
+	/* Adjust the USB 2.0 port TX output driver amplitude
+	 * for passing compatibility tests
+	 */
+	if (of_machine_is_compatible("marvell,armada3900-vd")) {
+		u32 port;
+
+		for (port = 0; port < 2; port++)
+			clrsetbits_le32(CP_USB20_TX_CTRL_REG(0, port),
+					CP_USB20_TX_OUT_AMPL_MASK,
+					CP_USB20_TX_OUT_AMPL_VALUE);
+	}
 
 	return 0;
 }
diff --git a/board/Marvell/octeontx/Kconfig b/board/Marvell/octeontx/Kconfig
new file mode 100644
index 0000000..016d024
--- /dev/null
+++ b/board/Marvell/octeontx/Kconfig
@@ -0,0 +1,18 @@
+if ARCH_OCTEONTX
+
+choice
+	prompt "Target board"
+
+config	TARGET_OCTEONTX_83XX
+	bool "OcteonTX CN83XX"
+
+config	TARGET_OCTEONTX_81XX
+	bool "OcteonTX CN81XX"
+
+endchoice
+
+config SYS_CONFIG_NAME
+	default "octeontx_81xx" if TARGET_OCTEONTX_81XX
+	default "octeontx_83xx" if TARGET_OCTEONTX_83XX
+
+endif
diff --git a/board/Marvell/octeontx/MAINTAINERS b/board/Marvell/octeontx/MAINTAINERS
new file mode 100644
index 0000000..7cd0e60
--- /dev/null
+++ b/board/Marvell/octeontx/MAINTAINERS
@@ -0,0 +1,5 @@
+OCTEONTX BOARD
+M:	Sergey Temerkhanov <s.temerkhanov@gmail.com>
+M:	Suneel Garapati <sgarapati@caviumnetworks.com>
+S:	Maintained
+F:	board/Marvell/octeontx/
diff --git a/board/Marvell/octeontx/Makefile b/board/Marvell/octeontx/Makefile
new file mode 100644
index 0000000..331a849
--- /dev/null
+++ b/board/Marvell/octeontx/Makefile
@@ -0,0 +1,9 @@
+#/*
+# * Copyright (C) 2018 Marvell International Ltd.
+# *
+# * SPDX-License-Identifier:    GPL-2.0
+# * https://spdx.org/licenses
+# */
+
+obj-y	:= octeontx.o atf.o
+obj-$(CONFIG_OF_LIBFDT) += fdt.o
diff --git a/board/Marvell/octeontx/atf.c b/board/Marvell/octeontx/atf.c
new file mode 100644
index 0000000..073eccc
--- /dev/null
+++ b/board/Marvell/octeontx/atf.c
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <asm/io.h>
+
+#include <asm/system.h>
+#include <asm/arch/octeontx_svc.h>
+#include <asm/arch/atf.h>
+#include <asm/arch/atf_part.h>
+
+#include <asm/psci.h>
+
+#include <malloc.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+ssize_t atf_dram_size(unsigned int node)
+{
+	struct pt_regs regs;
+	regs.regs[0] = OCTEONTX_DRAM_SIZE;
+	regs.regs[1] = node;
+
+	smc_call(&regs);
+
+	return regs.regs[0];
+}
+
+ssize_t atf_node_count(void)
+{
+	struct pt_regs regs;
+	regs.regs[0] = OCTEONTX_NODE_COUNT;
+
+	smc_call(&regs);
+
+	return regs.regs[0];
+}
+
diff --git a/board/Marvell/octeontx/fdt.c b/board/Marvell/octeontx/fdt.c
new file mode 100644
index 0000000..faf866c
--- /dev/null
+++ b/board/Marvell/octeontx/fdt.c
@@ -0,0 +1,208 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <errno.h>
+#include <environment.h>
+#include <asm/io.h>
+#include <linux/compiler.h>
+#include <linux/libfdt.h>
+#include <fdtdec.h>
+#include <fdt_support.h>
+#include <asm/arch/atf.h>
+#include <asm/arch/octeontx.h>
+#include <asm/arch/octeontx_vnic.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+extern unsigned long fdt_base_addr;
+
+#ifdef CONFIG_NET_OCTEONTX
+static int octeontx_get_mdio_bus(const void *fdt, int phy_offset)
+{
+	int node, bus = -1;
+	const u64 *reg;
+	u64 addr;
+
+	if (phy_offset < 0)
+		return -1;
+	/* obtain mdio node and get the reg prop */
+	node = fdt_parent_offset(fdt, phy_offset);
+	if (node < 0)
+		return -1;
+
+	reg = fdt_getprop(fdt, node, "reg", NULL);
+	addr = fdt64_to_cpu(*reg);
+	bus = (addr & (1 << 7)) ? 1 : 0;
+	return bus;
+}
+
+static int octeontx_get_phy_addr(const void *fdt, int phy_offset)
+{
+	const u32 *reg;
+	int addr = -1;
+
+	if (phy_offset < 0)
+		return -1;
+	reg = fdt_getprop(fdt, phy_offset, "reg", NULL);
+	addr = fdt32_to_cpu(*reg);
+	return addr;
+}
+#endif
+
+void octeontx_parse_phy_info(void)
+{
+#ifdef CONFIG_NET_OCTEONTX
+	const void *fdt = gd->fdt_blob;
+	int offset = 0, node, bgx_id = 0, lmacid = 0;
+	const u32 *val;
+	char bgxname[24];
+	int len, rgx_id = 0, eth_id = 0;
+	int phandle, phy_offset;
+	int subnode, i;
+
+	int bgxnode;
+	bgxnode = fdt_path_offset(gd->fdt_blob, "/cavium,bdk");
+	if (bgxnode < 0) {
+		printf("%s: /cavium,bdk is missing from device tree: %s\n",
+			__func__, fdt_strerror(bgxnode));
+	}
+
+	offset = fdt_node_offset_by_compatible(fdt, -1, "pci-bridge");
+	if (offset > 1) {
+		for (bgx_id = 0; bgx_id < CONFIG_MAX_BGX_PER_NODE; bgx_id++) {
+			int phy_addr[MAX_LMAC_PER_BGX] = { [0 ... MAX_LMAC_PER_BGX - 1] = -1};
+			bool autoneg_dis[MAX_LMAC_PER_BGX] = { [0 ... MAX_LMAC_PER_BGX - 1] = 0};
+			int mdio_bus[MAX_LMAC_PER_BGX] = { [0 ... MAX_LMAC_PER_BGX - 1] = -1};
+			bool lmac_reg[MAX_LMAC_PER_BGX] = { [0 ... MAX_LMAC_PER_BGX - 1] = 0};
+			bool lmac_enable[MAX_LMAC_PER_BGX] = { [0 ... MAX_LMAC_PER_BGX - 1] = 0};
+			snprintf(bgxname, sizeof(bgxname),
+				 "bgx%d", bgx_id);
+			node = fdt_subnode_offset(fdt, offset, bgxname);
+			if (node < 0) {
+				/* check if it is rgx node */
+				snprintf(bgxname, sizeof(bgxname),
+					 "rgx%d", rgx_id);
+				node = fdt_subnode_offset(fdt, offset, bgxname);
+				if (node < 0) {
+					debug("bgx%d/rgx0 node not found\n",
+					       bgx_id);
+					return;
+				}
+			}
+			debug("bgx%d node found\n", bgx_id);
+
+			/* loop through each of the bgx/rgx nodes
+			to find PHY nodes */
+			fdt_for_each_subnode(subnode, fdt, node) {
+				/* Check for reg property */
+				val = fdt_getprop(fdt, subnode, "reg",
+						  &len);
+
+				if (val) {
+					debug("lmacid = %d\n", lmacid);
+					lmac_reg[lmacid] = 1;
+				}
+				/* check for phy-handle property */
+				val = fdt_getprop(fdt, subnode, "phy-handle",
+						  &len);
+				if (val) {
+					phandle = fdt32_to_cpu(*val);
+					if (!phandle) {
+						debug("phandle not valid %d\n",
+						      lmacid);
+					} else {
+						phy_offset =
+						fdt_node_offset_by_phandle
+							(fdt, phandle);
+						phy_addr[lmacid] =
+						octeontx_get_phy_addr
+							(fdt, phy_offset);
+
+						mdio_bus[lmacid] =
+						octeontx_get_mdio_bus
+							(fdt, phy_offset);
+					}
+				} else
+					debug("phy-handle property not found %d\n",
+					      lmacid);
+
+				/* check for autonegotiation property */
+				val = fdt_getprop(fdt, subnode,
+						  "cavium,disable-autonegotiation",
+						  &len);
+				if (val)
+					autoneg_dis[lmacid] = 1;
+
+				eth_id++;
+				lmacid++;
+			}
+
+			for (i = 0; i < MAX_LMAC_PER_BGX; i++) {
+				const char *str;
+				snprintf(bgxname, sizeof(bgxname), "BGX-ENABLE.N0.BGX%d.P%d", bgx_id, i);
+				if (bgxnode >= 0) {
+					str = fdt_getprop(gd->fdt_blob, bgxnode, bgxname, &len);
+					if (str)
+						lmac_enable[i] = simple_strtol(str, NULL, 10);
+				}
+			}
+
+			lmacid = 0;
+			bgx_set_board_info(bgx_id, mdio_bus, phy_addr,
+					   autoneg_dis, lmac_reg, lmac_enable);
+		}
+	}
+#endif
+}
+
+int arch_fixup_memory_node(void *blob)
+{
+	return 0;
+}
+
+int ft_board_setup(void *blob, bd_t *bd)
+{
+	/* remove "cavium, bdk" node from DT */
+	int ret = 0, offset;
+
+	ret = fdt_check_header(blob);
+	if (ret < 0) {
+		printf("ERROR: %s\n", fdt_strerror(ret));
+		return ret;
+	}
+
+	if (blob != NULL) {
+		offset = fdt_path_offset(blob, "/cavium,bdk");
+		if(offset < 0) {
+			printf("ERROR: FDT BDK node not found\n");
+			return offset;
+		}
+
+		/* delete node */
+		ret = fdt_del_node(blob, offset);
+		if (ret < 0) {
+			printf("WARNING : could not remove cavium, bdk node\n");
+			return ret;
+		}
+
+		debug("%s deleted 'cavium,bdk' node\n", __FUNCTION__);
+	}
+
+	return 0;
+}
+
+/**
+ * Return the FDT base address that was passed by ATF
+ *
+ * @return	FDT base address received from ATF in x1 register
+ */
+void *board_fdt_blob_setup(void)
+{
+	return (void *)fdt_base_addr;
+}
diff --git a/board/Marvell/octeontx/octeontx.c b/board/Marvell/octeontx/octeontx.c
new file mode 100644
index 0000000..aa346f5
--- /dev/null
+++ b/board/Marvell/octeontx/octeontx.c
@@ -0,0 +1,272 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <malloc.h>
+#include <errno.h>
+#include <netdev.h>
+#include <asm/io.h>
+#include <linux/compiler.h>
+#include <linux/libfdt.h>
+#include <fdt_support.h>
+#include <asm/arch/octeontx.h>
+#include <asm/arch/atf.h>
+#include <dm/util.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+struct cavm_bdt g_cavm_bdt;
+
+extern unsigned long fdt_base_addr;
+extern void eth_common_init(void);
+
+void octeontx_cleanup_ethaddr(void)
+{
+	char ename[32];
+	for (int i = 0; i < 20; i++) {
+		sprintf(ename, i ? "eth%daddr" : "ethaddr", i);
+		if(env_get(ename))
+			env_set_force(ename, NULL);
+	}
+}
+
+void octeontx_board_get_ethaddr(int bgx, int lmac, unsigned char *eth)
+{
+	const void *fdt = gd->fdt_blob;
+	const char *mac = NULL;
+	int offset = 0, node, len;
+	int subnode, i = 0;
+	char bgxname[24];
+
+	offset = fdt_node_offset_by_compatible(fdt, -1, "pci-bridge");
+	if (offset < 0) {
+		printf("%s couldn't find mrml bridge node in fdt\n",
+			 __func__);
+		return;
+	}
+	if (bgx == 2 && is_board_model(CN81XX)) {
+		snprintf(bgxname, sizeof(bgxname), "rgx%d", 0);
+		lmac = 0;
+	} else
+		snprintf(bgxname, sizeof(bgxname), "bgx%d", bgx);
+
+	node = fdt_subnode_offset(fdt, offset, bgxname);
+
+	fdt_for_each_subnode(subnode, fdt, node) {
+		if (i++ != lmac)
+			continue;
+		/* check for local-mac-address */
+		mac = fdt_getprop(fdt, subnode,
+				       "local-mac-address", &len);
+		if(mac) {
+			debug("%s mac %pM\n", __func__, mac);
+			memcpy(eth, mac, ARP_HLEN);
+		} else
+			memset(eth, 0, ARP_HLEN);
+		debug("%s eth %pM\n", __func__, eth);
+		return;
+	}
+}
+
+int octeontx_board_has_pmp(void)
+{
+	if ((strcasecmp(g_cavm_bdt.type, "sff8104") == 0) ||
+		(strcasecmp(g_cavm_bdt.type, "nas8104") == 0))
+		return 1;
+
+	return 0;
+}
+
+void octeontx_parse_board_info(void)
+{
+	const char *str;
+	int node;
+	int ret = 0, len = 16;
+	u64 midr, val;
+
+	debug("%s: ENTER\n", __func__);
+
+	asm ("mrs %[rd],MIDR_EL1" : [rd] "=r" (midr));
+
+	g_cavm_bdt.prod_id = (midr >> 4) & 0xff;
+
+	val = readq(CAVM_MIO_FUS_DAT2);
+	g_cavm_bdt.alt_pkg = (val >> 22) & 0x3;
+	if ((g_cavm_bdt.prod_id == CN81XX) &&
+		(g_cavm_bdt.alt_pkg || ((val >> 30) & 0x1)))
+		g_cavm_bdt.alt_pkg = 2;
+
+	if (!gd->fdt_blob) {
+		printf("ERROR: %s: no valid device tree found\n", __func__);
+		return;
+	}
+
+	debug("%s: fdt blob at %p\n", __func__, gd->fdt_blob);
+	ret = fdt_check_header(gd->fdt_blob);
+	if (ret < 0) {
+		printf("fdt: %s\n", fdt_strerror(ret));
+		return;
+	}
+	debug("fdt:size %d\n", fdt_totalsize(gd->fdt_blob));
+
+	node = fdt_path_offset(gd->fdt_blob, "/cavium,bdk");
+	if (node < 0) {
+		printf("%s: /cavium,bdk is missing from device tree: %s\n",
+		       __func__, fdt_strerror(node));
+		return;
+	}
+	str = fdt_getprop(gd->fdt_blob, node, "BOARD-MODEL", &len);
+	debug("fdt: BOARD-MODEL str %s len %d\n", str, len);
+	if (str) {
+		strlcpy(g_cavm_bdt.type, str, sizeof(g_cavm_bdt.type));
+		debug("fdt: BOARD-MODEL bdt.type %s \n", g_cavm_bdt.type);
+	} else {
+		printf("Error: cannot retrieve board type from fdt\n");
+	}
+}
+
+int board_early_init_r(void)
+{
+	pci_init();
+	return 0;
+}
+
+int misc_init_r(void)
+{
+	struct udevice *bus;
+
+	eth_common_init();
+
+	/*
+	 * Enumerate all miscellaneous devices.
+	 * So BGX/NIC/vNIC devices will be enumerated too.
+	 */
+	for (uclass_first_device_check(UCLASS_MISC, &bus);
+	     bus;
+	     uclass_next_device_check(&bus)) {
+		;
+	}
+	return 0;
+}
+
+int board_init(void)
+{
+	octeontx_parse_phy_info();
+	/* populates cavm_bdt structure */
+	octeontx_parse_board_info();
+
+	return 0;
+}
+
+int timer_init(void)
+{
+	return 0;
+}
+
+int dram_init(void)
+{
+	ssize_t node_count = atf_node_count();
+	ssize_t dram_size;
+	int node;
+
+	debug("Initializing\nNodes in system: %zd\n", node_count);
+
+	gd->ram_size = 0;
+
+	for (node = 0; node < node_count; node++) {
+		dram_size = atf_dram_size(node);
+		debug("Node %d: %zd MBytes of DRAM\n", node, dram_size >> 20);
+		gd->ram_size += dram_size;
+	}
+
+	gd->ram_size -= CONFIG_SYS_SDRAM_BASE;
+
+	return 0;
+}
+
+/**
+ * Board late initialization routine.
+ */
+int board_late_init(void)
+{
+	char boardname[20];
+
+	debug("%s()\n", __func__);
+
+	/*
+	 * Now that pci_init initializes env device.
+	 * Try to cleanup ethaddr env variables, this is needed
+	 * as with each boot, configuration of QLM can change.
+	 */
+	octeontx_cleanup_ethaddr();
+
+	debug("bdt.type %s\n", g_cavm_bdt.type);
+	snprintf(boardname, sizeof(boardname), "%s> ", g_cavm_bdt.type);
+	env_set("prompt", boardname);
+	set_working_fdt_addr(env_get_hex("fdtcontroladdr", fdt_base_addr));
+	return 0;
+}
+
+/*
+ * Invoked before relocation, so limit to stack variables.
+ */
+int show_board_info(void)
+{
+	const char *str;
+	int node, prod_id;
+	int ret = 0, len = 16;
+	u64 midr;
+
+	asm ("mrs %[rd],MIDR_EL1" : [rd] "=r" (midr));
+
+	prod_id = (midr >> 4) & 0xff;
+
+	if (!gd->fdt_blob) {
+		printf("ERROR: %s: no valid device tree found\n", __func__);
+		return ret;
+	}
+
+	debug("%s: fdt blob at %p\n", __func__, gd->fdt_blob);
+	ret = fdt_check_header(gd->fdt_blob);
+	if (ret < 0) {
+		printf("fdt: %s\n", fdt_strerror(ret));
+		return ret;
+	}
+	debug("fdt:size %d\n", fdt_totalsize(gd->fdt_blob));
+
+	node = fdt_path_offset(gd->fdt_blob, "/cavium,bdk");
+	if (node < 0) {
+		printf("%s: /cavium,bdk is missing from device tree: %s\n",
+		       __func__, fdt_strerror(node));
+		return ret;
+	}
+	str = fdt_getprop(gd->fdt_blob, node, "BOARD-MODEL", &len);
+	debug("fdt: BOARD-MODEL str %s len %d\n", str, len);
+	if (!str) {
+		printf("Error: cannot retrieve board type from fdt\n");
+	}
+
+	if (prod_id == CN81XX)
+		printf("OcteonTX CN81XX ARM V8 Core\n");
+	if (prod_id == CN83XX)
+		printf("OcteonTX CN83XX ARM V8 Core\n");
+
+	printf("Board: %s\n", str);
+	return 0;
+}
+
+#ifdef CONFIG_HW_WATCHDOG
+void hw_watchdog_reset(void)
+{
+	writeq(~0ULL, CAVM_GTI_CWD_POKEX);
+}
+
+void hw_watchdog_disable(void)
+{
+	writeq(0ULL, CAVM_GTI_CWD_WDOGX);
+}
+#endif
diff --git a/board/Marvell/octeontx2/Kconfig b/board/Marvell/octeontx2/Kconfig
new file mode 100644
index 0000000..9eeb850
--- /dev/null
+++ b/board/Marvell/octeontx2/Kconfig
@@ -0,0 +1,17 @@
+if TARGET_OCTEONTX2_95XX || TARGET_OCTEONTX2_96XX || TARGET_OCTEONTX2_LOKI || TARGET_OCTEONTX2_98XX
+
+config SYS_VENDOR
+	string
+	default	"Marvell"
+
+config SYS_BOARD
+	string
+	default "octeontx2"
+
+config SYS_CONFIG_NAME
+	default "octeontx2_96xx" if TARGET_OCTEONTX2_96XX
+	default "octeontx2_95xx" if TARGET_OCTEONTX2_95XX
+	default "octeontx2_loki" if TARGET_OCTEONTX2_LOKI
+	default "octeontx2_98xx" if TARGET_OCTEONTX2_98XX
+
+endif
diff --git a/board/Marvell/octeontx2/MAINTAINERS b/board/Marvell/octeontx2/MAINTAINERS
new file mode 100644
index 0000000..8acac70
--- /dev/null
+++ b/board/Marvell/octeontx2/MAINTAINERS
@@ -0,0 +1,6 @@
+OCTEONTX2 BOARD
+M:	Suneel Garapati <sgarapati@caviumnetworks.com>
+S:	Maintained
+F:	board/Marvell/octeontx2/
+F:	include/configs/octeontx2_96xx.h
+F:	configs/octeontx2_96xx_defconfig
diff --git a/board/Marvell/octeontx2/Makefile b/board/Marvell/octeontx2/Makefile
new file mode 100644
index 0000000..4827bf7
--- /dev/null
+++ b/board/Marvell/octeontx2/Makefile
@@ -0,0 +1,9 @@
+#/*
+# * Copyright (C) 2018 Marvell International Ltd.
+# *
+# * SPDX-License-Identifier:    GPL-2.0
+# * https://spdx.org/licenses
+# */
+
+obj-y	:= octeontx2.o atf.o
+obj-$(CONFIG_OF_LIBFDT) += fdt.o
diff --git a/board/Marvell/octeontx2/atf.c b/board/Marvell/octeontx2/atf.c
new file mode 100644
index 0000000..e508a06
--- /dev/null
+++ b/board/Marvell/octeontx2/atf.c
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <asm/io.h>
+
+#include <asm/system.h>
+#include <asm/arch/octeontx2_svc.h>
+#include <asm/arch/atf.h>
+
+#include <asm/psci.h>
+
+#include <malloc.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+ssize_t atf_dram_size(unsigned int node)
+{
+	struct pt_regs regs;
+	regs.regs[0] = OCTEONTX2_DRAM_SIZE;
+	regs.regs[1] = node;
+
+	smc_call(&regs);
+
+	return regs.regs[0];
+}
+
+ssize_t atf_node_count(void)
+{
+	struct pt_regs regs;
+	regs.regs[0] = OCTEONTX2_NODE_COUNT;
+
+	smc_call(&regs);
+
+	return regs.regs[0];
+}
+
+ssize_t atf_disable_rvu_lfs(unsigned int node)
+{
+	struct pt_regs regs;
+	regs.regs[0] = OCTEONTX2_DISABLE_RVU_LFS;
+	regs.regs[1] = node;
+
+	smc_call(&regs);
+
+	return regs.regs[0];
+}
+
+ssize_t atf_configure_ooo(unsigned int val)
+{
+	struct pt_regs regs;
+	regs.regs[0] = OCTEONTX2_CONFIG_OOO;
+	regs.regs[1] = val;
+
+	smc_call(&regs);
+
+	return regs.regs[0];
+}
+
+ssize_t atf_flsf_fw_booted(void)
+{
+	struct pt_regs regs;
+
+	regs.regs[0] = OCTEONTX2_FSAFE_PR_BOOT_SUCCESS;
+
+	smc_call(&regs);
+
+	return regs.regs[0];
+}
+
+ssize_t atf_flsf_clr_force_2ndry(void)
+{
+	struct pt_regs regs;
+
+	regs.regs[0] = OCTEONTX2_FSAFE_CLR_FORCE_SEC;
+
+	smc_call(&regs);
+
+	return regs.regs[0];
+}
+
+ssize_t atf_mdio_dbg_read(int cgx_lmac, int mode, int phyaddr, int devad,
+			  int reg)
+{
+	struct pt_regs regs;
+
+	regs.regs[0] = OCTEONTX2_MDIO_DBG_READ;
+	regs.regs[1] = cgx_lmac;
+	regs.regs[2] = mode;
+	regs.regs[3] = phyaddr;
+	regs.regs[4] = devad;
+	regs.regs[5] = reg;
+
+	smc_call(&regs);
+
+	return regs.regs[0];
+}
+
+ssize_t atf_mdio_dbg_write(int cgx_lmac, int mode, int phyaddr, int devad,
+			   int reg, int val)
+{
+	struct pt_regs regs;
+
+	regs.regs[0] = OCTEONTX2_MDIO_DBG_WRITE;
+	regs.regs[1] = cgx_lmac;
+	regs.regs[2] = mode;
+	regs.regs[3] = phyaddr;
+	regs.regs[4] = devad;
+	regs.regs[5] = reg;
+	regs.regs[6] = val;
+
+	smc_call(&regs);
+
+	return regs.regs[0];
+}
diff --git a/board/Marvell/octeontx2/fdt.c b/board/Marvell/octeontx2/fdt.c
new file mode 100644
index 0000000..292112e
--- /dev/null
+++ b/board/Marvell/octeontx2/fdt.c
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <errno.h>
+#include <environment.h>
+#include <asm/io.h>
+#include <linux/compiler.h>
+#include <linux/libfdt.h>
+#include <fdtdec.h>
+#include <fdt_support.h>
+#include <asm/arch/atf.h>
+#include <asm/arch/octeontx2.h>
+
+
+DECLARE_GLOBAL_DATA_PTR;
+
+extern unsigned long fdt_base_addr;
+
+int arch_fixup_memory_node(void *blob)
+{
+	return 0;
+}
+
+int ft_board_setup(void *blob, bd_t *bd)
+{
+	/* remove "cavium, bdk" node from DT */
+	int ret = 0, offset;
+
+	ret = fdt_check_header(blob);
+	if (ret < 0) {
+		printf("ERROR: %s\n", fdt_strerror(ret));
+		return ret;
+	}
+
+	if (blob != NULL) {
+		offset = fdt_path_offset(blob, "/cavium,bdk");
+		if(offset < 0) {
+			printf("ERROR: FDT BDK node not found\n");
+			return offset;
+		}
+
+		/* delete node */
+		ret = fdt_del_node(blob, offset);
+		if (ret < 0) {
+			printf("WARNING : could not remove cavium, bdk node\n");
+			return ret;
+		}
+
+		debug("%s deleted 'cavium,bdk' node\n", __FUNCTION__);
+	}
+
+	return 0;
+}
+
+/**
+ * Return the FDT base address that was passed by ATF
+ *
+ * @return	FDT base address received from ATF in x1 register
+ */
+void *board_fdt_blob_setup(void)
+{
+	return (void *)fdt_base_addr;
+}
diff --git a/board/Marvell/octeontx2/octeontx2.c b/board/Marvell/octeontx2/octeontx2.c
new file mode 100644
index 0000000..7ff99a8
--- /dev/null
+++ b/board/Marvell/octeontx2/octeontx2.c
@@ -0,0 +1,387 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <console.h>
+#include <dm.h>
+#include <dm/uclass-internal.h>
+#include <malloc.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <linux/compiler.h>
+#include <linux/libfdt.h>
+#include <fdt_support.h>
+#include <asm/arch/octeontx2.h>
+#include <asm/arch/atf.h>
+#include <dm/util.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+struct cavm_bdt g_cavm_bdt;
+static int board_mac_num;
+u64 board_mac_addr;
+
+extern unsigned long fdt_base_addr;
+extern void cgx_intf_shutdown(void);
+extern void eth_common_init(void);
+extern ssize_t atf_configure_ooo(unsigned int val);
+
+void octeontx2_cleanup_ethaddr(void)
+{
+	char ename[32];
+
+	for (int i = 0; i < 20; i++) {
+		sprintf(ename, i ? "eth%daddr" : "ethaddr", i);
+		if (env_get(ename))
+			env_set_force(ename, NULL);
+	}
+}
+
+void octeontx2_board_get_mac_addr(u8 index, u8 *mac_addr)
+{
+	u64 tmp_mac = board_mac_addr;
+
+	if ((!is_zero_ethaddr((u8 *)&board_mac_addr)) && board_mac_num) {
+		tmp_mac += index;
+		tmp_mac = swab64(tmp_mac) >> 16;
+		memcpy(mac_addr, (u8 *)&tmp_mac, ARP_HLEN);
+		board_mac_num--;
+	} else {
+		memset(mac_addr, 0, ARP_HLEN);
+	}
+	debug("%s mac %pM\n", __func__, mac_addr);
+}
+
+void board_get_env_spi_bus_cs(int *bus, int *cs)
+{
+	const void *blob = gd->fdt_blob;
+	int env_bus, env_cs;
+	int node, preg;
+
+	env_bus = -1;
+	env_cs = -1;
+	node = fdt_node_offset_by_compatible(blob, -1, "spi-flash");
+	while (node > 0) {
+		if (fdtdec_get_bool(blob, node, "u-boot,env")) {
+			env_cs = fdtdec_get_int(blob, node, "reg", -1);
+			preg = fdtdec_get_int(blob,
+					      fdt_parent_offset(blob, node),
+					      "reg", -1);
+			/* SPI node will have PCI addr, so map it */
+			if (preg == 0x3000)
+				env_bus = 0;
+			if (preg == 0x3800)
+				env_bus = 1;
+			debug("\n Env SPI [bus:cs] [%d:%d]\n",
+			      env_bus, env_cs);
+			break;
+		}
+		node = fdt_node_offset_by_compatible(blob, node, "spi-flash");
+	}
+	if (env_bus == -1)
+		debug("\'u-boot,env\' property not found in fdt\n");
+
+	*bus = env_bus;
+	*cs = env_cs;
+}
+
+void octeontx_parse_board_info(void)
+{
+	const char *str;
+	int node;
+	int ret = 0, len = 16;
+	u64 midr;
+
+	debug("%s: ENTER\n", __func__);
+
+	asm ("mrs %[rd],MIDR_EL1" : [rd] "=r" (midr));
+
+	g_cavm_bdt.prod_id = (midr >> 4) & 0xff;
+
+	if (!gd->fdt_blob) {
+		printf("ERROR: %s: no valid device tree found\n", __func__);
+		return;
+	}
+
+	debug("%s: fdt blob at %p\n", __func__, gd->fdt_blob);
+	ret = fdt_check_header(gd->fdt_blob);
+	if (ret < 0) {
+		printf("fdt: %s\n", fdt_strerror(ret));
+		return;
+	}
+	debug("fdt:size %d\n", fdt_totalsize(gd->fdt_blob));
+
+	node = fdt_path_offset(gd->fdt_blob, "/cavium,bdk");
+	if (node < 0) {
+		printf("%s: /cavium,bdk is missing from device tree: %s\n",
+		       __func__, fdt_strerror(node));
+		return;
+	}
+	str = fdt_getprop(gd->fdt_blob, node, "BOARD-MODEL", &len);
+	debug("fdt: BOARD-MODEL str %s len %d\n", str, len);
+	if (str) {
+		strlcpy(g_cavm_bdt.type, str, sizeof(g_cavm_bdt.type));
+		debug("fdt: BOARD-MODEL bdt.type %s \n", g_cavm_bdt.type);
+	} else {
+		printf("Error: cannot retrieve board type from fdt\n");
+	}
+	str = fdt_getprop(gd->fdt_blob, node, "BOARD-MAC-ADDRESS-NUM", &len);
+	if (str) {
+		board_mac_num = simple_strtol(str, NULL, 10);
+		if (!board_mac_num)
+			board_mac_num = simple_strtol(str, NULL, 16);
+		debug("fdt: MAC_NUM %d\n", board_mac_num);
+	} else {
+		printf("Error: cannot retrieve mac num prop from fdt\n");
+	}
+	str = fdt_getprop(gd->fdt_blob, node, "BOARD-MAC-ADDRESS-NUM-OVERRIDE",
+			  &len);
+	if (str) {
+		if (simple_strtol(str, NULL, 10) >= 0)
+			board_mac_num = simple_strtol(str, NULL, 10);
+		debug("fdt: MAC_NUM %d\n", board_mac_num);
+	} else {
+		printf("Error: cannot retrieve macnum override prop\n");
+	}
+	str = fdt_getprop(gd->fdt_blob, node, "BOARD-MAC-ADDRESS", &len);
+	if (str) {
+		board_mac_addr = simple_strtoul(str, NULL, 16);
+		debug("%s mac %llx\n", __func__, board_mac_addr);
+	} else {
+		board_mac_addr = 0;
+	}
+}
+
+void board_quiesce_devices(void)
+{
+	ssize_t node_count = atf_node_count();
+	int node;
+	struct uclass *uc_dev;
+	int ret;
+
+	/* Removes all RVU PF devices */
+	ret = uclass_get(UCLASS_ETH, &uc_dev);
+	if (uc_dev)
+		ret = uclass_destroy(uc_dev);
+	if (ret)
+		printf("couldn't remove rvu pf devices\n");
+
+#ifdef CONFIG_OCTEONTX2_CGX_INTF
+	/* Bring down all cgx lmac links */
+	cgx_intf_shutdown();
+#endif
+
+	/* Removes all CGX and RVU AF devices */
+	ret = uclass_get(UCLASS_MISC, &uc_dev);
+	if (uc_dev)
+		ret = uclass_destroy(uc_dev);
+	if (ret)
+		printf("couldn't remove misc (cgx/rvu_af) devices\n");
+
+	/* SMC call - removes all LF<->PF mappings */
+	for (node = 0; node < node_count; node++) {
+		atf_disable_rvu_lfs(node);
+	}
+}
+
+int board_early_init_r(void)
+{
+	pci_init();
+	return 0;
+}
+
+int board_init(void)
+{
+	octeontx_parse_board_info();
+	return 0;
+}
+
+int timer_init(void)
+{
+	return 0;
+}
+
+int dram_init(void)
+{
+	ssize_t node_count = atf_node_count();
+	ssize_t dram_size;
+	int node;
+
+	debug("Initializing\nNodes in system: %zd\n", node_count);
+
+	gd->ram_size = 0;
+
+	for (node = 0; node < node_count; node++) {
+		dram_size = atf_dram_size(node);
+		debug("Node %d: %zd MBytes of DRAM\n", node, dram_size >> 20);
+		gd->ram_size += dram_size;
+	}
+
+	gd->ram_size -= CONFIG_SYS_SDRAM_BASE;
+
+	return 0;
+}
+
+/**
+ * Board misc devices initialization routine.
+ */
+int misc_init_r(void)
+{
+	struct udevice *bus;
+
+	eth_common_init();
+	/*
+	 * Enumerate all known miscellaneous devices.
+	 * Enumeration has the side-effect of probing them,
+	 * so CGX and RVU AF devices will get enumerated.
+	 */
+	for (uclass_first_device_check(UCLASS_MISC, &bus);
+	     bus;
+	     uclass_next_device_check(&bus)) {
+		;
+	}
+	return 0;
+}
+
+/**
+ * Board late initialization routine.
+ */
+int board_late_init(void)
+{
+	char boardname[20];
+	long val;
+#ifdef CONFIG_OCTEONTX_SERIAL_BOOTCMD
+	struct udevice *bootcmd_dev;
+	int ret;
+	char *stdinname = env_get("stdin");
+#endif
+
+	debug("%s()\n", __func__);
+
+	/*
+	 * Now that pci_init initializes env device.
+	 * Try to cleanup ethaddr env variables, this is needed
+	 * as with each boot, configuration of QLM can change.
+	 */
+	octeontx2_cleanup_ethaddr();
+
+	debug("bdt.type %s\n", g_cavm_bdt.type);
+	snprintf(boardname, sizeof(boardname), "%s> ", g_cavm_bdt.type);
+	env_set("prompt", boardname);
+	set_working_fdt_addr(env_get_hex("fdtcontroladdr", fdt_base_addr));
+
+	val = env_get_hex("disable_ooo", 0);
+	atf_configure_ooo(val);
+
+#ifdef CONFIG_OCTEONTX_SERIAL_BOOTCMD
+	/* This will cause the pci-bootcmd driver to be probed. */
+	ret = uclass_get_device_by_name(UCLASS_SERIAL, "pci-bootcmd",
+					&bootcmd_dev);
+	if (!ret && bootcmd_dev)
+		debug("%s: %s found!\n", __func__, bootcmd_dev->name);
+#if CONFIG_IS_ENABLED(CONSOLE_MUX)
+	if (stdinname) {
+		ret = iomux_doenv(stdin, stdinname);
+		if (ret)
+			printf("%s: Error setting stdin to %s\n",
+			       __func__, stdinname);
+	}
+#endif
+#endif
+	return 0;
+}
+
+/*
+ * Invoked before relocation, so limit to stack variables.
+ */
+int show_board_info(void)
+{
+	const char *str;
+	int node, prod_id;
+	int ret = 0, len = 16;
+	u64 midr;
+
+	asm ("mrs %[rd],MIDR_EL1" : [rd] "=r" (midr));
+
+	prod_id = (midr >> 4) & 0xff;
+
+	if (!gd->fdt_blob) {
+		printf("ERROR: %s: no valid device tree found\n", __func__);
+		return ret;
+	}
+
+	debug("%s: fdt blob at %p\n", __func__, gd->fdt_blob);
+	ret = fdt_check_header(gd->fdt_blob);
+	if (ret < 0) {
+		printf("fdt: %s\n", fdt_strerror(ret));
+		return ret;
+	}
+	debug("fdt:size %d\n", fdt_totalsize(gd->fdt_blob));
+
+	node = fdt_path_offset(gd->fdt_blob, "/cavium,bdk");
+	if (node < 0) {
+		printf("%s: /cavium,bdk is missing from device tree: %s\n",
+		       __func__, fdt_strerror(node));
+		return ret;
+	}
+	str = fdt_getprop(gd->fdt_blob, node, "BOARD-MODEL", &len);
+	debug("fdt: BOARD-MODEL str %s len %d\n", str, len);
+	if (!str) {
+		printf("Error: cannot retrieve board type from fdt\n");
+	}
+
+	if (prod_id == CN96XX)
+		printf("OcteonTX2 CN96XX ARM V8 Core\n");
+	if (prod_id == CN95XX)
+		printf("OcteonTX2 CN95XX ARM V8 Core\n");
+	if (prod_id == LOKI)
+		printf("OcteonTX2 LOKI ARM V8 Core\n");
+	if (prod_id == CN98XX)
+		printf("OcteonTX2 CN98XX ARM V8 Core\n");
+
+	printf("Board: %s\n", str);
+	return 0;
+}
+
+void acquire_flash_arb(bool acquire)
+{
+	union cavm_cpc_boot_ownerx ownerx;
+
+	if (acquire == false) {
+		ownerx.u = readl(CAVM_CPC_BOOT_OWNERX(3));
+		ownerx.s.boot_req = 0;
+		writel(ownerx.u, CAVM_CPC_BOOT_OWNERX(3));
+	} else {
+		ownerx.u = 0;
+		ownerx.s.boot_req = 1;
+		writel(ownerx.u, CAVM_CPC_BOOT_OWNERX(3));
+		udelay(1);
+		do {
+			ownerx.u = readl(CAVM_CPC_BOOT_OWNERX(3));
+		} while (ownerx.s.boot_wait);
+	}
+}
+
+#ifdef CONFIG_HW_WATCHDOG
+void hw_watchdog_reset(void)
+{
+	writeq(~0ULL, CAVM_GTI_CWD_POKEX);
+}
+
+void hw_watchdog_disable(void)
+{
+	writeq(0ULL, CAVM_GTI_CWD_WDOGX);
+}
+#endif
+
+#ifdef CONFIG_LAST_STAGE_INIT
+int last_stage_init(void)
+{
+	(void)atf_flsf_fw_booted();
+	return 0;
+}
+#endif
diff --git a/board/Marvell/octeontx2_cn913x/MAINTAINERS b/board/Marvell/octeontx2_cn913x/MAINTAINERS
new file mode 100644
index 0000000..9e390a2
--- /dev/null
+++ b/board/Marvell/octeontx2_cn913x/MAINTAINERS
@@ -0,0 +1,4 @@
+OCTEONTX2_CN913x BOARD
+F:	board/Marvell/octeontx2_cn913x/
+F:	include/configs/octeontx2_cn913x.h
+F:	configs/mvebu_db_cn91xx_defconfig
diff --git a/board/Marvell/octeontx2_cn913x/Makefile b/board/Marvell/octeontx2_cn913x/Makefile
new file mode 100644
index 0000000..8c6ffb9
--- /dev/null
+++ b/board/Marvell/octeontx2_cn913x/Makefile
@@ -0,0 +1,8 @@
+#
+# Copyright (C) 2016 Stefan Roese <sr@denx.de>
+# Copyright (C) 2019 Marvell International Ltd.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y	:= board.o
diff --git a/board/Marvell/octeontx2_cn913x/board.c b/board/Marvell/octeontx2_cn913x/board.c
new file mode 100644
index 0000000..dced21a
--- /dev/null
+++ b/board/Marvell/octeontx2_cn913x/board.c
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2016 Stefan Roese <sr@denx.de>
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <i2c.h>
+#include <asm/io.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/soc.h>
+#include <power/regulator.h>
+#ifdef CONFIG_BOARD_CONFIG_EEPROM
+#include <mvebu/cfg_eeprom.h>
+#endif
+
+#define CP_USB20_BASE_REG(cp, p)	(MVEBU_REGS_BASE_CP(0, cp) + \
+						0x00580000 + 0x1000 * (p))
+#define CP_USB20_TX_CTRL_REG(cp, p)	(CP_USB20_BASE_REG(cp, p) + 0xC)
+#define CP_USB20_TX_OUT_AMPL_MASK	(0x7 << 20)
+#define CP_USB20_TX_OUT_AMPL_VALUE	(0x3 << 20)
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int __soc_early_init_f(void)
+{
+	return 0;
+}
+
+int soc_early_init_f(void)
+			__attribute__((weak, alias("__soc_early_init_f")));
+
+int board_early_init_f(void)
+{
+	soc_early_init_f();
+
+	return 0;
+}
+
+int board_early_init_r(void)
+{
+#ifdef CONFIG_DM_REGULATOR
+	/* Check if any existing regulator should be turned down */
+	regulators_enable_boot_off(false);
+#endif
+
+	return 0;
+}
+
+int board_init(void)
+{
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = CONFIG_SYS_SDRAM_BASE + 0x100;
+
+#ifdef CONFIG_BOARD_CONFIG_EEPROM
+	cfg_eeprom_init();
+#endif
+
+	return 0;
+}
+
+int board_late_init(void)
+{
+	return 0;
+}
diff --git a/board/cavium/thunderx/Kconfig b/board/cavium/thunderx/Kconfig
deleted file mode 100644
index 927d876..0000000
--- a/board/cavium/thunderx/Kconfig
+++ /dev/null
@@ -1,27 +0,0 @@
-if TARGET_THUNDERX_88XX
-
-config SYS_CPU
-	string
-	default "armv8"
-
-config SYS_BOARD
-	string
-	default "thunderx"
-
-config SYS_VENDOR
-	string
-	default "cavium"
-
-config SYS_CONFIG_NAME
-	string
-	default "thunderx_88xx"
-
-config CMD_ATF
-	bool "Enable ATF query commands"
-	default y
-	help
-	  Enable vendor specific ATF query commands such as SPI and SD/MMC
-	  devices access, low level environment query, boot device layout
-	  and node count.
-
-endif
diff --git a/board/cavium/thunderx/MAINTAINERS b/board/cavium/thunderx/MAINTAINERS
deleted file mode 100644
index c84d3b5..0000000
--- a/board/cavium/thunderx/MAINTAINERS
+++ /dev/null
@@ -1,6 +0,0 @@
-THUNDERX BOARD
-M:	Sergey Temerkhanov <s.temerkhanov@gmail.com>
-S:	Maintained
-F:	board/cavium/thunderx/
-F:	include/configs/thunderx_88xx.h
-F:	configs/thunderx_88xx_defconfig
diff --git a/board/cavium/thunderx/Makefile b/board/cavium/thunderx/Makefile
deleted file mode 100644
index c78c414..0000000
--- a/board/cavium/thunderx/Makefile
+++ /dev/null
@@ -1,8 +0,0 @@
-#
-#
-# (C) Copyright 2014, Cavium Inc.
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-
-obj-y	:= thunderx.o atf.o
diff --git a/board/cavium/thunderx/atf.c b/board/cavium/thunderx/atf.c
deleted file mode 100644
index 6ab9de9..0000000
--- a/board/cavium/thunderx/atf.c
+++ /dev/null
@@ -1,312 +0,0 @@
-/**
- * (C) Copyright 2014, Cavium Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
-**/
-
-#include <common.h>
-#include <asm/io.h>
-
-#include <asm/system.h>
-#include <cavium/thunderx_svc.h>
-#include <cavium/atf.h>
-#include <cavium/atf_part.h>
-
-#include <asm/psci.h>
-
-#include <malloc.h>
-
-DECLARE_GLOBAL_DATA_PTR;
-
-ssize_t atf_read_mmc(uintptr_t offset, void *buffer, size_t size)
-{
-	struct pt_regs regs;
-	regs.regs[0] = THUNDERX_MMC_READ;
-	regs.regs[1] = offset;
-	regs.regs[2] = size;
-	regs.regs[3] = (uintptr_t)buffer;
-
-	smc_call(&regs);
-
-	return regs.regs[0];
-}
-
-ssize_t atf_read_nor(uintptr_t offset, void *buffer, size_t size)
-{
-	struct pt_regs regs;
-	regs.regs[0] = THUNDERX_NOR_READ;
-	regs.regs[1] = offset;
-	regs.regs[2] = size;
-	regs.regs[3] = (uintptr_t)buffer;
-
-	smc_call(&regs);
-
-	return regs.regs[0];
-}
-
-ssize_t atf_get_pcount(void)
-{
-	struct pt_regs regs;
-	regs.regs[0] = THUNDERX_PART_COUNT;
-
-	smc_call(&regs);
-
-	return regs.regs[0];
-}
-
-ssize_t atf_get_part(struct storage_partition *part, unsigned int index)
-{
-	struct pt_regs regs;
-	regs.regs[0] = THUNDERX_GET_PART;
-	regs.regs[1] = (uintptr_t)part;
-	regs.regs[2] = index;
-
-	smc_call(&regs);
-
-	return regs.regs[0];
-}
-
-ssize_t atf_erase_nor(uintptr_t offset, size_t size)
-{
-	struct pt_regs regs;
-
-	regs.regs[0] = THUNDERX_NOR_ERASE;
-	regs.regs[1] = offset;
-
-	smc_call(&regs);
-
-	return regs.regs[0];
-}
-
-ssize_t atf_write_nor(uintptr_t offset, const void *buffer, size_t size)
-{
-	struct pt_regs regs;
-
-	regs.regs[0] = THUNDERX_NOR_WRITE;
-	regs.regs[1] = offset;
-	regs.regs[2] = size;
-	regs.regs[3] = (uintptr_t)buffer;
-
-	smc_call(&regs);
-
-	return regs.regs[0];
-}
-
-ssize_t atf_write_mmc(uintptr_t offset, const void *buffer, size_t size)
-{
-	struct pt_regs regs;
-
-	regs.regs[0] = THUNDERX_MMC_WRITE;
-	regs.regs[1] = offset;
-	regs.regs[2] = size;
-	regs.regs[3] = (uintptr_t)buffer;
-
-	smc_call(&regs);
-
-	return regs.regs[0];
-}
-
-ssize_t atf_dram_size(unsigned int node)
-{
-	struct pt_regs regs;
-	regs.regs[0] = THUNDERX_DRAM_SIZE;
-	regs.regs[1] = node;
-
-	smc_call(&regs);
-
-	return regs.regs[0];
-}
-
-ssize_t atf_node_count(void)
-{
-	struct pt_regs regs;
-	regs.regs[0] = THUNDERX_NODE_COUNT;
-
-	smc_call(&regs);
-
-	return regs.regs[0];
-}
-
-ssize_t atf_env_count(void)
-{
-	struct pt_regs regs;
-	regs.regs[0] = THUNDERX_ENV_COUNT;
-
-	smc_call(&regs);
-
-	return regs.regs[0];
-}
-
-ssize_t atf_env_string(size_t index, char *str)
-{
-	uint64_t *buf = (void *)str;
-	struct pt_regs regs;
-	regs.regs[0] = THUNDERX_ENV_STRING;
-	regs.regs[1] = index;
-
-	smc_call(&regs);
-
-	if (regs.regs > 0) {
-		buf[0] = regs.regs[0];
-		buf[1] = regs.regs[1];
-		buf[2] = regs.regs[2];
-		buf[3] = regs.regs[3];
-
-		return 1;
-	} else {
-		return regs.regs[0];
-	}
-}
-
-#ifdef CONFIG_CMD_ATF
-
-static void atf_print_ver(void)
-{
-	struct pt_regs regs;
-	regs.regs[0] = ARM_STD_SVC_VERSION;
-
-	smc_call(&regs);
-
-	printf("ARM Std FW version: %ld.%ld\n", regs.regs[0], regs.regs[1]);
-
-	regs.regs[0] = THUNDERX_SVC_VERSION;
-
-	smc_call(&regs);
-
-	printf("ThunderX OEM ver: %ld.%ld\n", regs.regs[0], regs.regs[1]);
-}
-
-static void atf_print_uid(void)
-{
-}
-
-static void atf_print_part_table(void)
-{
-	size_t pcount;
-	unsigned long i;
-	int ret;
-	char *ptype;
-
-	struct storage_partition *part = (void *)CONFIG_SYS_LOWMEM_BASE;
-
-	pcount = atf_get_pcount();
-
-	printf("Partition count: %lu\n\n", pcount);
-	printf("%10s %10s %10s\n", "Type", "Size", "Offset");
-
-	for (i = 0; i < pcount; i++) {
-		ret = atf_get_part(part, i);
-
-		if (ret < 0) {
-			printf("Uknown error while reading partition: %d\n",
-			       ret);
-			return;
-		}
-
-		switch (part->type) {
-		case PARTITION_NBL1FW_REST:
-			ptype = "NBL1FW";
-			break;
-		case PARTITION_BL2_BL31:
-			ptype = "BL2_BL31";
-			break;
-		case PARTITION_UBOOT:
-			ptype = "BOOTLDR";
-			break;
-		case PARTITION_KERNEL:
-			ptype = "KERNEL";
-			break;
-		case PARTITION_DEVICE_TREE:
-			ptype = "DEVTREE";
-			break;
-		default:
-			ptype = "UNKNOWN";
-		}
-		printf("%10s %10d %10lx\n", ptype, part->size, part->offset);
-	}
-}
-
-int do_atf(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
-{
-	ssize_t ret;
-	size_t size, offset;
-	void *buffer = 0;
-	unsigned int index, node;
-	char str[4 * sizeof(uint64_t)];
-
-	if ((argc == 5) && !strcmp(argv[1], "readmmc")) {
-		buffer = (void *)simple_strtoul(argv[2], NULL, 16);
-		offset = simple_strtoul(argv[3], NULL, 10);
-		size = simple_strtoul(argv[4], NULL, 10);
-
-		ret = atf_read_mmc(offset, buffer, size);
-	} else if ((argc == 5) && !strcmp(argv[1], "readnor")) {
-		buffer = (void *)simple_strtoul(argv[2], NULL, 16);
-		offset = simple_strtoul(argv[3], NULL, 10);
-		size = simple_strtoul(argv[4], NULL, 10);
-
-		ret = atf_read_nor(offset, buffer, size);
-	} else if ((argc == 5) && !strcmp(argv[1], "writemmc")) {
-		buffer = (void *)simple_strtoul(argv[2], NULL, 16);
-		offset = simple_strtoul(argv[3], NULL, 10);
-		size = simple_strtoul(argv[4], NULL, 10);
-
-		ret = atf_write_mmc(offset, buffer, size);
-	} else if ((argc == 5) && !strcmp(argv[1], "writenor")) {
-		buffer = (void *)simple_strtoul(argv[2], NULL, 16);
-		offset = simple_strtoul(argv[3], NULL, 10);
-		size = simple_strtoul(argv[4], NULL, 10);
-
-		ret = atf_write_nor(offset, buffer, size);
-	} else if ((argc == 2) && !strcmp(argv[1], "part")) {
-		atf_print_part_table();
-	} else if ((argc == 4) && !strcmp(argv[1], "erasenor")) {
-		offset = simple_strtoul(argv[2], NULL, 10);
-		size = simple_strtoul(argv[3], NULL, 10);
-
-		ret = atf_erase_nor(offset, size);
-	} else if ((argc == 2) && !strcmp(argv[1], "envcount")) {
-		ret = atf_env_count();
-		printf("Number of environment strings: %zd\n", ret);
-	} else if ((argc == 3) && !strcmp(argv[1], "envstring")) {
-		index = simple_strtoul(argv[2], NULL, 10);
-		ret = atf_env_string(index, str);
-		if (ret > 0)
-			printf("Environment string %d: %s\n", index, str);
-		else
-			printf("Return code: %zd\n", ret);
-	} else if ((argc == 3) && !strcmp(argv[1], "dramsize")) {
-		node = simple_strtoul(argv[2], NULL, 10);
-		ret = atf_dram_size(node);
-		printf("DRAM size: %zd Mbytes\n", ret >> 20);
-	} else if ((argc == 2) && !strcmp(argv[1], "nodes")) {
-		ret = atf_node_count();
-		printf("Nodes count: %zd\n", ret);
-	} else if ((argc == 2) && !strcmp(argv[1], "ver")) {
-		atf_print_ver();
-	} else if ((argc == 2) && !strcmp(argv[1], "uid")) {
-		atf_print_uid();
-	} else {
-		return CMD_RET_USAGE;
-	}
-
-	return 0;
-}
-
-U_BOOT_CMD(
-	atf,   10,   1,     do_atf,
-	"issue calls to ATF",
-	"\t readmmc addr offset size - read MMC card\n"
-	"\t readnor addr offset size - read NOR flash\n"
-	"\t writemmc addr offset size - write MMC card\n"
-	"\t writenor addr offset size - write NOR flash\n"
-	"\t erasenor offset size - erase NOR flash\n"
-	"\t nodes - number of nodes\n"
-	"\t dramsize node - size of DRAM attached to node\n"
-	"\t envcount - number of environment strings\n"
-	"\t envstring index - print the environment string\n"
-	"\t part - print MMC partition table\n"
-	"\t ver - print ATF call set versions\n"
-);
-
-#endif
diff --git a/board/cavium/thunderx/thunderx.c b/board/cavium/thunderx/thunderx.c
deleted file mode 100644
index 02253af..0000000
--- a/board/cavium/thunderx/thunderx.c
+++ /dev/null
@@ -1,129 +0,0 @@
-/**
- * (C) Copyright 2014, Cavium Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
-**/
-
-#include <common.h>
-#include <dm.h>
-#include <malloc.h>
-#include <errno.h>
-#include <linux/compiler.h>
-
-#include <cavium/atf.h>
-#include <asm/armv8/mmu.h>
-
-#if !CONFIG_IS_ENABLED(OF_CONTROL)
-#include <dm/platform_data/serial_pl01x.h>
-
-static const struct pl01x_serial_platdata serial0 = {
-	.base = CONFIG_SYS_SERIAL0,
-	.type = TYPE_PL011,
-	.clock = 0,
-	.skip_init = true,
-};
-
-U_BOOT_DEVICE(thunderx_serial0) = {
-	.name = "serial_pl01x",
-	.platdata = &serial0,
-};
-
-static const struct pl01x_serial_platdata serial1 = {
-	.base = CONFIG_SYS_SERIAL1,
-	.type = TYPE_PL011,
-	.clock = 0,
-	.skip_init = true,
-};
-
-U_BOOT_DEVICE(thunderx_serial1) = {
-	.name = "serial_pl01x",
-	.platdata = &serial1,
-};
-#endif
-
-DECLARE_GLOBAL_DATA_PTR;
-
-static struct mm_region thunderx_mem_map[] = {
-	{
-		.virt = 0x000000000000UL,
-		.phys = 0x000000000000UL,
-		.size = 0x40000000000UL,
-		.attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) | PTE_BLOCK_NON_SHARE,
-	}, {
-		.virt = 0x800000000000UL,
-		.phys = 0x800000000000UL,
-		.size = 0x40000000000UL,
-		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
-			 PTE_BLOCK_NON_SHARE,
-	}, {
-		.virt = 0x840000000000UL,
-		.phys = 0x840000000000UL,
-		.size = 0x40000000000UL,
-		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
-			 PTE_BLOCK_NON_SHARE,
-	}, {
-		/* List terminator */
-		0,
-	}
-};
-
-struct mm_region *mem_map = thunderx_mem_map;
-
-int board_init(void)
-{
-	return 0;
-}
-
-int timer_init(void)
-{
-	return 0;
-}
-
-int dram_init(void)
-{
-	ssize_t node_count = atf_node_count();
-	ssize_t dram_size;
-	int node;
-
-	printf("Initializing\nNodes in system: %zd\n", node_count);
-
-	gd->ram_size = 0;
-
-	for (node = 0; node < node_count; node++) {
-		dram_size = atf_dram_size(node);
-		printf("Node %d: %zd MBytes of DRAM\n", node, dram_size >> 20);
-		gd->ram_size += dram_size;
-	}
-
-	gd->ram_size -= MEM_BASE;
-
-	*(unsigned long *)CPU_RELEASE_ADDR = 0;
-
-	puts("DRAM size:");
-
-	return 0;
-}
-
-/*
- * Board specific reset that is system reset.
- */
-void reset_cpu(ulong addr)
-{
-}
-
-/*
- * Board specific ethernet initialization routine.
- */
-int board_eth_init(bd_t *bis)
-{
-	int rc = 0;
-
-	return rc;
-}
-
-#ifdef CONFIG_PCI
-void pci_init_board(void)
-{
-	printf("DEBUG: PCI Init TODO *****\n");
-}
-#endif
diff --git a/board/raspberrypi/rpi/rpi.c b/board/raspberrypi/rpi/rpi.c
index 177f4af..78c15b0 100644
--- a/board/raspberrypi/rpi/rpi.c
+++ b/board/raspberrypi/rpi/rpi.c
@@ -443,6 +443,16 @@ void *board_fdt_blob_setup(void)
 	return (void *)fw_dtb_pointer;
 }
 
+/*
+ * If the firmware passed a device tree use it for U-Boot.
+ */
+void *board_fdt_blob_setup(void)
+{
+	if (fdt_magic(fw_dtb_pointer) != FDT_MAGIC)
+		return NULL;
+	return (void *)fw_dtb_pointer;
+}
+
 int ft_board_setup(void *blob, bd_t *bd)
 {
 	/*
diff --git a/cmd/Kconfig b/cmd/Kconfig
index 136836d..a61e176 100644
--- a/cmd/Kconfig
+++ b/cmd/Kconfig
@@ -146,6 +146,13 @@ comment "Commands"
 
 menu "Info commands"
 
+config CMD_MVEBU_SAR
+	bool "sar"
+	depends on MVEBU_SAR
+	default n
+	help
+	  sar - Modify SOC's sample at reset (SAR) values
+
 config CMD_BDI
 	bool "bdinfo"
 	default y
@@ -894,6 +901,15 @@ config CMD_SATA
 	  Attachment, where AT refers to an IBM AT (Advanced Technology)
 	  computer released in 1984.
 
+config CMD_NVME
+	bool "NVMe"
+	depends on NVME
+	help
+	  NVMe support.
+	  This enables nvme commands in command line
+	  You can use comamnd "nvme" to show what commands it supports
+	  such as "nvme info" "nvme list".
+
 config CMD_SAVES
 	bool "saves - Save a file over serial in S-Record format"
 	help
@@ -1100,6 +1116,13 @@ endmenu
 
 menu "Misc commands"
 
+config CMD_BOOTIMGUP
+	depends on ARCH_OCTEONTX || ARCH_OCTEONTX2
+	depends on MMC_OCTEONTX || SPI_FLASH
+	bool "bootimgup"
+	help
+	  bootimgup command support
+
 config CMD_BMP
 	bool "Enable 'bmp' command"
 	depends on LCD || DM_VIDEO || VIDEO
@@ -1216,6 +1239,7 @@ config CMD_QFW
 	  via -kernel / -initrd
 
 source "cmd/mvebu/Kconfig"
+source "cmd/marvell/Kconfig"
 
 config CMD_TERMINAL
 	bool "terminal - provides a way to attach a serial terminal"
diff --git a/cmd/Makefile b/cmd/Makefile
index 9a358e4..b667b81 100644
--- a/cmd/Makefile
+++ b/cmd/Makefile
@@ -109,6 +109,7 @@ obj-$(CONFIG_CMD_SATA) += sata.o
 obj-$(CONFIG_CMD_NVME) += nvme.o
 obj-$(CONFIG_CMD_SF) += sf.o
 obj-$(CONFIG_CMD_SCSI) += scsi.o disk.o
+obj-$(CONFIG_CMD_BOOTIMGUP) += bootimgup.o
 obj-$(CONFIG_CMD_SHA1SUM) += sha1sum.o
 obj-$(CONFIG_CMD_SETEXPR) += setexpr.o
 obj-$(CONFIG_CMD_SPI) += spi.o
@@ -151,12 +152,16 @@ obj-$(CONFIG_CMD_REGULATOR) += regulator.o
 obj-$(CONFIG_CMD_BLOB) += blob.o
 
 obj-$(CONFIG_X86) += x86/
+
+obj-$(CONFIG_ARCH_MVEBU) += mvebu/
+
+obj-$(CONFIG_ARCH_OCTEONTX2) += marvell/
+
 endif # !CONFIG_SPL_BUILD
 
 # core command
 obj-y += nvedit.o
 
-obj-$(CONFIG_ARCH_MVEBU) += mvebu/
 obj-$(CONFIG_TI_COMMON_CMD_OPTIONS) += ti/
 
 filechk_data_gz = (echo "static const char data_gz[] ="; cat $< | scripts/bin2c; echo ";")
diff --git a/cmd/bootimgup.c b/cmd/bootimgup.c
new file mode 100644
index 0000000..d42a4bf
--- /dev/null
+++ b/cmd/bootimgup.c
@@ -0,0 +1,549 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <div64.h>
+#include <dm.h>
+#include <dm/device-internal.h>
+#include <malloc.h>
+#include <mapmem.h>
+#include <memalign.h>
+#include <mmc.h>
+#include <spi.h>
+#include <spi_flash.h>
+#include <jffs2/jffs2.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+
+struct dos_partition {
+	unsigned char boot_ind;		/* 0x80 - active			*/
+	unsigned char head;		/* starting head			*/
+	unsigned char sector;		/* starting sector			*/
+	unsigned char cyl;		/* starting cylinder			*/
+	unsigned char sys_ind;		/* What partition type			*/
+	unsigned char end_head;		/* end head				*/
+	unsigned char end_sector;	/* end sector				*/
+	unsigned char end_cyl;		/* end cylinder				*/
+	unsigned int  start4;		/* starting sector counting from 0	*/
+	unsigned int  size4;		/* nr of sectors in partition		*/
+};
+
+static struct spi_flash *flash;
+
+static int validate_bootimg_header(unsigned long addr)
+{
+	char flash_hdr[] = {"CVM_CLIB"};
+	char bdk_magic[] = {"OCTEONTX"};
+	char *buf1 = (char *)(addr + 0x10000); /* flash hdr offset */
+	char *buf2 = (char *)(addr + 0x20008); /* bdk magic offset */
+	char *buf3 = (char *)(addr + 0x50008); /* sec bdk magic offset */
+
+	if (strncmp(buf1, flash_hdr, 8) == 0)
+		if (strncmp(buf2, bdk_magic, 8) == 0)
+			if (strncmp(buf3, bdk_magic, 8) == 0)
+				return 0;
+	return 1;
+}
+
+/**
+ * This function takes a byte length and a delta unit of time to compute the
+ * approximate bytes per second
+ *
+ * @param len		amount of bytes currently processed
+ * @param start_ms	start time of processing in ms
+ * @return bytes per second if OK, 0 on error
+ */
+static ulong bytes_per_second(unsigned int len, ulong start_ms)
+{
+	/* less accurate but avoids overflow */
+	if (len >= ((unsigned int)-1) / 1024)
+		return len / (max(get_timer(start_ms) / 1024, 1UL));
+	else
+		return 1024 * len / max(get_timer(start_ms), 1UL);
+}
+
+/**
+ * Write a block of data to SPI flash, first checking if it is different from
+ * what is already there.
+ *
+ * If the data being written is the same, then *skipped is incremented by len.
+ *
+ * @param flash		flash context pointer
+ * @param offset	flash offset to write
+ * @param len		number of bytes to write
+ * @param buf		buffer to write from
+ * @param cmp_buf	read buffer to use to compare data
+ * @return NULL if OK, else a string containing the stage which failed
+ */
+static const char *spi_flash_update_block(struct spi_flash *flash, u32 offset,
+					  size_t len, const char *buf)
+{
+	char *ret = NULL;
+	char *ptr = (char *)buf;
+	char *rbuf = memalign(ARCH_DMA_MINALIGN, len);
+
+	debug("\n offset=%#x, sector_size=%#x, len=%#zx\n",
+	      offset, flash->sector_size, len);
+
+	/* Erase the entire sector */
+	if (spi_flash_erase(flash, offset, flash->sector_size))
+		ret = "erase";
+
+	/* Write one complete sector */
+	if (spi_flash_write(flash, offset, len, ptr))
+		ret = "write";
+
+	if (spi_flash_read(flash, offset, len, rbuf))
+		ret = "read";
+
+	if (memcmp(ptr, rbuf, len))
+		ret = "compare";
+
+	free(rbuf);
+	return ret;
+}
+
+/**
+ * Update an area of SPI flash by erasing and writing any blocks which need
+ * to change. Existing blocks with the correct data are left unchanged.
+ *
+ * @param flash		flash context pointer
+ * @param offset	flash offset to write
+ * @param len		number of bytes to write
+ * @param buf		buffer to write from
+ * @return 0 if ok, 1 on error
+ */
+static int spi_flash_update(struct spi_flash *flash, u32 offset,
+			    size_t len, const char *buf)
+{
+	const char *err_oper = NULL;
+	const char *end = buf + len;
+	size_t todo;		/* number of bytes to do in this pass */
+	const ulong start_time = get_timer(0);
+	size_t scale = 1;
+	const char *start_buf = buf;
+	ulong delta;
+
+	if (end - buf >= 200)
+		scale = (end - buf) / 100;
+	ulong last_update = get_timer(0);
+
+	for (; (buf < end) && (!err_oper); buf += todo, offset += todo) {
+		todo = min_t(size_t, end - buf, flash->sector_size);
+		if (get_timer(last_update) > 100) {
+			printf("   \rUpdating, %zu%% %lu B/s",
+			       100 - (end - buf) / scale,
+				bytes_per_second(buf - start_buf,
+						 start_time));
+			last_update = get_timer(0);
+		}
+		err_oper = spi_flash_update_block(flash, offset, todo, buf);
+		if (err_oper)
+			break;
+	}
+	putc('\r');
+	if (err_oper) {
+		printf("SPI flash failed in %s step\n", err_oper);
+		return 1;
+	}
+
+	delta = get_timer(start_time);
+	printf("%zu bytes written", len);
+	printf(" in %ld.%lds, speed %ld B/s\n",
+	       delta / 1000, delta % 1000, bytes_per_second(len, start_time));
+
+	return 0;
+}
+
+static int do_spi_flash_probe(unsigned int bus, unsigned int cs)
+{
+	unsigned int speed = CONFIG_SF_DEFAULT_SPEED;
+	unsigned int mode = CONFIG_SF_DEFAULT_MODE;
+	struct udevice *new, *bus_dev;
+	int ret;
+
+	/* Remove the old device, otherwise probe will just be a nop */
+	ret = spi_find_bus_and_cs(bus, cs, &bus_dev, &new);
+	if (!ret) {
+		device_remove(new, DM_REMOVE_NORMAL);
+		device_unbind(new);
+	}
+	flash = NULL;
+	ret = spi_flash_probe_bus_cs(bus, cs, speed, mode, &new);
+	if (ret) {
+		printf("Failed to initialize SPI flash at %u:%u (error %d)\n",
+		       bus, cs, ret);
+		return 1;
+	}
+
+	flash = dev_get_uclass_priv(new);
+
+	return 0;
+}
+
+static int do_bootu_spi(int argc, char * const argv[])
+{
+	unsigned long addr, offset, len;
+	void *buf;
+	char *env1, *env2;
+	char *endp;
+	int ret = 1;
+	unsigned int bus = 0, cs;
+
+	if ((argc < 1) || (argc > 4))
+		return -1;
+
+	if (argc == 1) {
+		bus = cs = 0;
+		env1 = env_get("loadaddr");
+		env2 = env_get("filesize");
+		if (!env1 || !env2) {
+			printf("Missing env variables loadaddr/filesize\n");
+			return -1;
+		}
+	} else if (argc == 2) {
+		cs = simple_strtoul(argv[1], &endp, 0);
+		if (*argv[1] == 0 || (*endp != 0 && *endp != ':'))
+			return -1;
+		if (*endp == ':') {
+			if (endp[1] == 0)
+				return -1;
+
+			bus = cs;
+			cs = simple_strtoul(endp + 1, &endp, 0);
+			if (*endp != 0)
+				return -1;
+		}
+		env1 = env_get("loadaddr");
+		env2 = env_get("filesize");
+		if (!env1 || !env2) {
+			printf("Missing env variables loadaddr/filesize\n");
+			return -1;
+		}
+	} else if (argc == 4) {
+		cs = simple_strtoul(argv[1], &endp, 0);
+		if (*argv[1] == 0 || (*endp != 0 && *endp != ':'))
+			return -1;
+		if (*endp == ':') {
+			if (endp[1] == 0)
+				return -1;
+
+			bus = cs;
+			cs = simple_strtoul(endp + 1, &endp, 0);
+			if (*endp != 0)
+				return -1;
+		}
+		debug("%s argv0 %s argv1 %s\n", __func__, argv[0], argv[1]);
+		debug("%s argv2 %s argv3 %s\n", __func__, argv[2], argv[3]);
+		env1 = argv[2];
+		env2 = argv[3];
+	} else {
+		printf("Missing args\n");
+		return -1;
+	}
+	debug("%s loadaddr %s filesize %s\n", __func__, env1, env2);
+	debug("%s bus %d cs %d\n", __func__, bus, cs);
+
+	offset = 0;
+
+	ret = strict_strtoul(env1, 16, &addr);
+	if (ret)
+		return -1;
+	debug("%s addr %ld\n", __func__, addr);
+
+	ret = strict_strtoul(env2, 16, &len);
+	if (ret)
+		return -1;
+	debug("%s len %ld\n", __func__, len);
+
+	if( !addr || !len) {
+		printf("image address or length is 0\n");
+		return -1;
+	}
+
+	if (validate_bootimg_header(addr)) {
+		printf("\n No valid boot image header found \n");
+		return 1;
+	}
+
+	/* The remaining commands require a selected device */
+	if (!flash) {
+		debug("No SPI flash selected.  Executing 'sf probe'\n");
+		ret = do_spi_flash_probe(bus, cs);
+		if (ret)
+			return 1;
+	}
+	/* Consistency checking */
+	if (offset + len > flash->size) {
+		printf("ERROR: attempting %s past flash size (%#x)\n",
+		       argv[0], flash->size);
+		return 1;
+	}
+
+	buf = map_physmem(addr, len, MAP_WRBACK);
+	if (!buf) {
+		puts("Failed to map physical memory\n");
+		return 1;
+	}
+
+	ret = spi_flash_update(flash, offset, len, buf);
+
+	printf("bootu SPI : %zu bytes @ %#x Written ", (size_t)len, (u32)offset);
+	if (ret)
+		printf("ERROR %d\n", ret);
+	else
+		printf("OK\n");
+
+	unmap_physmem(buf, len);
+
+	return ret == 0 ? 0 : 1;
+}
+
+static int validate_partition_table(unsigned char *buf)
+{
+	struct dos_partition *p;
+
+	if ((buf[510] != 0x55) || (buf[511] != 0xaa)) {
+		printf("No valid MBR signature in first sector\n");
+		return 1; /* no DOS Signature at all */
+	}
+
+	/* checks for FAT12 as partition 1 */
+	p = (struct dos_partition *)&buf[446];
+	if (p->sys_ind != 0x01) {
+		printf("%s Invalid first partition type %x"
+			 " expected FAT12 \n", __func__, p->sys_ind);
+		return 1;
+	}
+	/* check for second partition start <16MB */
+	p = (struct dos_partition *)&buf[446 + 16];
+	if (p->sys_ind != 0)
+		if (p->start4 < 0x8000) {
+			printf("%s partition type %x start sector at %d "
+				"below 16MB(reserved for boot image)\n",
+				 __func__, p->sys_ind, p->start4);
+			return 1;
+		}
+
+	// FIXME below checks really needed?
+	/* check for third partition start <16MB */
+	p = (struct dos_partition *)&buf[446 + 16 * 2];
+	if (p->sys_ind != 0)
+		if (p->start4 < 0x8000) {
+			printf("%s partition type %x start sector at %d "
+				"below 16MB(reserved for boot image)\n",
+				 __func__, p->sys_ind, p->start4);
+			return 1;
+		}
+	/* check for fourth partition start <16MB */
+	p = (struct dos_partition *)&buf[446 + 16 * 3];
+	if (p->sys_ind != 0)
+		if (p->start4 < 0x8000) {
+			printf("%s partition type %x start sector at %d "
+				"below 16MB(reserved for boot image)\n",
+				 __func__, p->sys_ind, p->start4);
+			return 1;
+		}
+	return 0;
+}
+
+static struct mmc *init_mmc_device(int dev, bool force_init)
+{
+	struct mmc *mmc;
+
+	mmc = find_mmc_device(dev);
+	if (!mmc) {
+		printf("no mmc device at slot %x\n", dev);
+		return NULL;
+	}
+	if (force_init)
+		mmc->has_init = 0;
+	if (mmc_init(mmc))
+		return NULL;
+	return mmc;
+}
+
+static int do_bootu_mmc(int argc, char * const argv[])
+{
+	static int curr_device = -1;
+	struct mmc *mmc;
+	struct blk_desc *desc;
+	char *env1, *env2, *endp;
+	unsigned long blk, len, n;
+	unsigned long addr;
+	int ret;
+
+	if ((argc < 1) || (argc > 4)) {
+		printf("Invalid # args \n");
+		return -1;
+	}
+
+	if (argc == 1) {
+		curr_device = 0;
+		env1 = env_get("loadaddr");
+		env2 = env_get("filesize");
+		if (!env1 || !env2) {
+			printf("Missing env variables loadaddr/filesize\n");
+			return -1;
+		}
+	} else if (argc == 2) {
+		curr_device = simple_strtoul(argv[1], &endp, 0);
+		env1 = env_get("loadaddr");
+		env2 = env_get("filesize");
+		if (!env1 || !env2) {
+			printf("Missing env variables loadaddr/filesize\n");
+			return -1;
+		}
+	} else if (argc == 3) {
+			printf("Missing args - image addr or image size\n");
+			return -1;
+	} else if (argc == 4) {
+		curr_device = simple_strtoul(argv[1], &endp, 0);
+		debug("%s argv0 %s argv1 %s\n", __func__, argv[0], argv[1]);
+		env1 = argv[2];
+		env2 = argv[3];
+	}
+	debug("%s loadaddr %s filesize %s\n", __func__, env1, env2);
+	debug("%s curr_device %d\n", __func__, curr_device);
+	blk = 0;
+
+	ret = strict_strtoul(env1, 16, &addr);
+	if (ret)
+		return -1;
+	debug("%s addr %ld\n", __func__, addr);
+
+	ret = strict_strtoul(env2, 16, &len);
+	if (ret)
+		return -1;
+	debug("%s len %ld\n", __func__, len);
+	if( !addr || !len) {
+		printf("image address or length is 0\n");
+		return -1;
+	}
+	if (len % 512)
+		len = len / 512 + 1;
+	else
+		len /= 512;
+	debug("%s len %ld\n", __func__, len);
+
+	if ((blk + 512 * len) > 0x1000000) {
+		printf("\nBoot Image size exceeding 16MB\n");
+		return 1;
+	}
+
+	if (validate_bootimg_header(addr)) {
+		printf("\nNo valid boot image header found\n");
+		return 1;
+	}
+
+	if (get_mmc_num() < curr_device) {
+		puts("No MMC device available\n");
+		return CMD_RET_FAILURE;
+	}
+
+	mmc = init_mmc_device(curr_device, false);
+	if (!mmc)
+		return CMD_RET_FAILURE;
+
+	desc = mmc_get_blk_desc(mmc);
+	if (!desc)
+		return CMD_RET_FAILURE;
+
+	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, desc->blksz);
+	n = blk_dread(desc, 0, 1, buffer);
+	/* flush cache after read */
+	flush_cache((ulong)addr, 512);
+	if (n != 1) {
+		printf("ERROR: read partition table failed\n");
+		return 1;
+	}
+
+	if (validate_partition_table(buffer)) {
+		printf("Invalid partition setup, can't write bootimg\n");
+		return 1;
+	}
+
+	printf("\nMMC write: dev # %d, block # %ld, count %ld ... ",
+	       curr_device, blk, len);
+
+	if (mmc_getwp(mmc) == 1) {
+		printf("Error: card is write protected!\n");
+		return CMD_RET_FAILURE;
+	}
+
+	n = blk_dwrite(desc, blk, len, (void *)addr);
+	printf("%ld blocks written: %s\n", n, (n == len) ? "OK" : "ERROR");
+	if (n != len)
+		return CMD_RET_FAILURE;
+
+	/* Update partition table with FAT entry of boot image */
+	memcpy(&buffer[446], (void *) (addr + 446), 16);
+
+	/* Update partition table with read boot sector */
+	n = blk_dwrite(desc, 0, 1, (void *)buffer);
+	printf("%ld blocks written: %s\n", n, (n == 1) ? "OK" : "ERROR");
+	if (n != 1)
+		return CMD_RET_FAILURE;
+
+	return 0;
+}
+
+static int do_bootimgup(cmd_tbl_t *cmdtp, int flag, int argc,
+			char * const argv[])
+{
+	const char *cmd;
+	int ret;
+
+	/* need at least two arguments */
+	if (argc < 2)
+		goto usage;
+
+	cmd = argv[1];
+	--argc;
+	++argv;
+
+	if (strcmp(cmd, "spi") == 0)
+		ret = do_bootu_spi(argc, argv);
+	else if (strcmp(cmd, "mmc") == 0)
+		ret = do_bootu_mmc(argc, argv);
+	else
+		ret = -1;
+
+	if (ret != -1)
+		return ret;
+
+usage:
+	return CMD_RET_USAGE;
+}
+
+U_BOOT_CMD(
+	bootimgup, 5, 1, do_bootimgup, "Updates Boot Image",
+	" <mmc | spi> <[devid] | [bus:cs]> [image_address image_size] \n"
+	" where: \n"
+	" spi - updates boot image on spi flash \n"
+	" bus and cs should be passed together, passing only one \n"
+	" of them treated as invalid. If [bus:cs] not given, 0:0 is used \n"
+	" image_address - address at which image is located in RAM \n"
+	" image_size    - size of image in hex \n"
+	" eg. to load on spi0 chipselect 0 \n"
+	" bootimgup spi 0:0 $loadaddr $filesize \n"
+	" eg. to load on spi1 chipselect 1 \n"
+	" bootimgup spi 1:1 $loadaddr $filesize \n"
+	" \n"
+	" mmc - updates boot image on mmc card/chip \n"
+	" eg. to load on device 0 \n"
+	" bootimgup mmc 0 $loadaddr $filesize \n"
+	" eg. to load on device 1. If device id not given, 0 is used \n"
+	" bootimgup mmc 1 $loadaddr $filesize \n"
+	" image_address - address at which image is located in RAM \n"
+	" image_size    - size of image in hex \n"
+	" image_address, image_size should be passed together, \n"
+	" passing only one of them treated as invalid. \n"
+	" \n"
+	" If not given, then $loadaddr and $filesize values in \n"
+	" environment are used, otherwise fail to update. \n"
+);
diff --git a/cmd/bootm.c b/cmd/bootm.c
index df0bbe1..995fef4 100644
--- a/cmd/bootm.c
+++ b/cmd/bootm.c
@@ -19,6 +19,7 @@
 #include <asm/byteorder.h>
 #include <linux/ctype.h>
 #include <linux/err.h>
+#include <linux/sizes.h>
 #include <u-boot/zlib.h>
 
 DECLARE_GLOBAL_DATA_PTR;
diff --git a/cmd/elf.c b/cmd/elf.c
index 5b59fc6..ea86984 100644
--- a/cmd/elf.c
+++ b/cmd/elf.c
@@ -27,7 +27,7 @@
  * A very simple elf loader, assumes the image is valid, returns the
  * entry point address.
  */
-static unsigned long load_elf_image_phdr(unsigned long addr)
+static unsigned long load_elf32_image_phdr(unsigned long addr)
 {
 	Elf32_Ehdr *ehdr; /* Elf header structure pointer */
 	Elf32_Phdr *phdr; /* Program header structure pointer */
@@ -54,7 +54,45 @@ static unsigned long load_elf_image_phdr(unsigned long addr)
 	return ehdr->e_entry;
 }
 
-static unsigned long load_elf_image_shdr(unsigned long addr)
+static unsigned long load_elf64_image_phdr(unsigned long addr)
+{
+	Elf64_Ehdr *ehdr; /* Elf header structure pointer */
+	Elf64_Phdr *phdr; /* Program header structure pointer */
+	int i;
+
+	ehdr = (Elf64_Ehdr *)addr;
+	phdr = (Elf64_Phdr *)(addr + ehdr->e_phoff);
+
+	/* Load each program header */
+	for (i = 0; i < ehdr->e_phnum; ++i) {
+		void *dst = (void *)(uintptr_t)phdr->p_paddr;
+		void *src = (void *)addr + phdr->p_offset;
+		debug("Loading phdr %i to 0x%p (%lli bytes)\n",
+		      i, dst, phdr->p_filesz);
+		if (phdr->p_filesz)
+			memcpy(dst, src, phdr->p_filesz);
+		if (phdr->p_filesz != phdr->p_memsz)
+			memset(dst + phdr->p_filesz, 0x00,
+			       phdr->p_memsz - phdr->p_filesz);
+		flush_cache((unsigned long)dst, phdr->p_filesz);
+		++phdr;
+	}
+
+	return ehdr->e_entry;
+}
+
+static unsigned long load_elf_image_phdr(unsigned long addr)
+{
+	char elfclass = ((char*)addr)[EI_CLASS];
+	if (elfclass == ELFCLASS32)
+		return load_elf32_image_phdr(addr);
+	if (elfclass == ELFCLASS64)
+		return load_elf64_image_phdr(addr);
+	return -1;
+  
+}
+
+static unsigned long load_elf32_image_shdr(unsigned long addr)
 {
 	Elf32_Ehdr *ehdr; /* Elf header structure pointer */
 	Elf32_Shdr *shdr; /* Section header structure pointer */
@@ -103,6 +141,65 @@ static unsigned long load_elf_image_shdr(unsigned long addr)
 	return ehdr->e_entry;
 }
 
+static unsigned long load_elf64_image_shdr(unsigned long addr)
+{
+	Elf64_Ehdr *ehdr; /* Elf header structure pointer */
+	Elf64_Shdr *shdr; /* Section header structure pointer */
+	unsigned char *strtab = 0; /* String table pointer */
+	unsigned char *image; /* Binary image pointer */
+	int i; /* Loop counter */
+
+	ehdr = (Elf64_Ehdr *)addr;
+
+	/* Find the section header string table for output info */
+	shdr = (Elf64_Shdr *)(addr + ehdr->e_shoff +
+			     (ehdr->e_shstrndx * sizeof(Elf64_Shdr)));
+
+	if (shdr->sh_type == SHT_STRTAB)
+		strtab = (unsigned char *)(addr + shdr->sh_offset);
+
+	/* Load each appropriate section */
+	for (i = 0; i < ehdr->e_shnum; ++i) {
+		shdr = (Elf64_Shdr *)(addr + ehdr->e_shoff +
+				     (i * sizeof(Elf64_Shdr)));
+
+		if (!(shdr->sh_flags & SHF_ALLOC) ||
+		    shdr->sh_addr == 0 || shdr->sh_size == 0) {
+			continue;
+		}
+
+		if (strtab) {
+			debug("%sing %s @ 0x%08lx (%ld bytes)\n",
+			      (shdr->sh_type == SHT_NOBITS) ? "Clear" : "Load",
+			       &strtab[shdr->sh_name],
+			       (unsigned long)shdr->sh_addr,
+			       (long)shdr->sh_size);
+		}
+
+		if (shdr->sh_type == SHT_NOBITS) {
+			memset((void *)(uintptr_t)shdr->sh_addr, 0,
+			       shdr->sh_size);
+		} else {
+			image = (unsigned char *)addr + shdr->sh_offset;
+			memcpy((void *)(uintptr_t)shdr->sh_addr,
+			       (const void *)image, shdr->sh_size);
+		}
+		flush_cache(shdr->sh_addr, shdr->sh_size);
+	}
+
+	return ehdr->e_entry;
+}
+
+static unsigned long load_elf_image_shdr(unsigned long addr)
+{
+	char elfclass = ((char*)addr)[EI_CLASS];
+	if (elfclass == ELFCLASS32)
+		return load_elf32_image_shdr(addr);
+	if (elfclass == ELFCLASS64)
+		return load_elf64_image_shdr(addr);
+	return -1;
+}
+  
 /* Allow ports to override the default behavior */
 static unsigned long do_bootelf_exec(ulong (*entry)(int, char * const[]),
 				     int argc, char * const argv[])
@@ -176,9 +273,14 @@ int do_bootelf(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	else
 		addr = load_elf_image_shdr(addr);
 
+	if (addr == -1)
+		return 1;
+
 	if (ep && !strcmp(ep, "no"))
 		return rcode;
 
+	board_quiesce_devices();
+
 	printf("## Starting application at 0x%08lx ...\n", addr);
 
 	/*
@@ -365,6 +467,9 @@ int do_bootvx(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	else
 		puts("## Not an ELF image, assuming binary\n");
 
+	if (addr == -1)
+		return 1;
+
 	printf("## Starting vxWorks at 0x%08lx ...\n", addr);
 
 	dcache_disable();
diff --git a/cmd/fdt.c b/cmd/fdt.c
index 65661fa..7360260 100644
--- a/cmd/fdt.c
+++ b/cmd/fdt.c
@@ -1050,7 +1050,8 @@ static int fdt_print(const char *pathp, char *prop, int depth)
 			}
 			break;
 		case FDT_NOP:
-			printf("%s/* NOP */\n", &tabs[MAX_LEVEL - level]);
+			if (!env_get("fdt_hide_nop"))
+				printf("%s/* NOP */\n", &tabs[MAX_LEVEL - level]);
 			break;
 		case FDT_END:
 			return 1;
diff --git a/cmd/marvell/Kconfig b/cmd/marvell/Kconfig
new file mode 100644
index 0000000..fd1e597
--- /dev/null
+++ b/cmd/marvell/Kconfig
@@ -0,0 +1,26 @@
+menu "Marvell specific command line interface"
+depends on ARCH_OCTEONTX2
+
+config CMD_FAILSAFE
+	bool "Command for supporting fail safe boot"
+	help
+	   Support for fail safe boot on Marvell's OcteonTX2 platforms.
+	   Disables forced secondary boot and reports if boot from
+	   primary device was successful.
+
+config CMD_ETH
+	depends on NET_OCTEONTX2
+	bool "Command to change fec and phy-mod type"
+	help
+	   Support for change of fec and phy-mod type for some specific
+	   LMAC modes on RVU PF [CGX] network interfaces on Marvell
+	   OcteonTX2 platforms.
+
+config CMD_MDIO_DBG
+	bool "PHY registers read/write support on mdio bus"
+	help
+	   Support to debug phy registers over MDIO bus using SMC interface
+	   to ATF for RVU PF [CGX] network interfaces on Marvell OcteonTX2
+	   platforms.
+
+endmenu
diff --git a/cmd/marvell/Makefile b/cmd/marvell/Makefile
new file mode 100644
index 0000000..dacf768
--- /dev/null
+++ b/cmd/marvell/Makefile
@@ -0,0 +1,10 @@
+# Copyright (C) 2017 Texas Instruments Incorporated - http://www.ti.com/
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+ifdef CONFIG_ARCH_OCTEONTX2
+obj-$(CONFIG_CMD_FAILSAFE) += octeontx2_cmds.o
+obj-$(CONFIG_CMD_ETH) += eth_cmds.o
+obj-$(CONFIG_CMD_MDIO_DBG) += mdio_dbg.o
+endif
diff --git a/cmd/marvell/eth_cmds.c b/cmd/marvell/eth_cmds.c
new file mode 100644
index 0000000..79f45b8
--- /dev/null
+++ b/cmd/marvell/eth_cmds.c
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <command.h>
+#include <dm.h>
+#include <dm/uclass-internal.h>
+#include <net.h>
+
+extern int cgx_intf_set_fec(struct udevice *ethdev, int type);
+extern int cgx_intf_get_fec(struct udevice *ethdev);
+extern int cgx_intf_get_phy_mod_type(struct udevice *ethdev);
+extern int cgx_intf_set_phy_mod_type(struct udevice *ethdev, int type);
+extern void nix_print_mac_info(struct udevice *dev);
+
+static int do_ethlist(cmd_tbl_t *cmdtp, int flag, int argc,
+		      char *const argv[])
+{
+	struct udevice *dev;
+
+	for (uclass_find_first_device(UCLASS_ETH, &dev); dev;
+	     uclass_find_next_device(&dev)) {
+		printf("eth%d [%s]", dev->seq, dev->name);
+		if (!strncmp(dev->name, "rvu_", 4))
+			nix_print_mac_info(dev);
+		printf("\n");
+	}
+	return 0;
+}
+
+U_BOOT_CMD(
+	ethlist, 1, 1, do_ethlist, "Display ethernet interface list",
+	"Prints all detected ethernet interfaces with below format\n"
+	"ethX [device name] [LMAC info for RVU PF devices]\n"
+);
+
+static int do_ethparam_common(cmd_tbl_t *cmdtp, int flag, int argc,
+			      char *const argv[])
+{
+	const char *cmd;
+	char *endp;
+	const char *devname;
+	int ret = -1, type;
+	struct udevice *dev;
+
+	if (argc < 2)
+		return CMD_RET_USAGE;
+
+	cmd = argv[0];
+	devname = argv[1];
+
+	dev = eth_get_dev_by_name(devname);
+	if (!dev) {
+		printf("device interface %s not found\n", devname);
+		return CMD_RET_FAILURE;
+	}
+	if (strncmp(dev->name, "rvu_", 4)) {
+		printf("Invalid eth interface, choose RVU PF device\n");
+		return CMD_RET_FAILURE;
+	}
+	if (strcmp(cmd, "set_fec") == 0) {
+		if (argc < 3)
+			return CMD_RET_FAILURE;
+		type = simple_strtol(argv[2], &endp, 0);
+		if (type < 0 || type > 2)
+			return CMD_RET_USAGE;
+		ret = cgx_intf_set_fec(dev, type);
+	} else if (strcmp(cmd, "get_fec") == 0) {
+		ret = cgx_intf_get_fec(dev);
+	} else if (strcmp(cmd, "set_phymod") == 0) {
+		if (argc < 3)
+			return CMD_RET_FAILURE;
+		type = simple_strtol(argv[2], &endp, 0);
+		if (type < 0 || type > 1)
+			return CMD_RET_USAGE;
+		ret = cgx_intf_set_phy_mod_type(dev, type);
+	} else if (strcmp(cmd, "get_phymod") == 0) {
+		ret = cgx_intf_get_phy_mod_type(dev);
+	}
+	return (ret == 0) ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
+}
+
+U_BOOT_CMD(
+	set_fec, 3, 1, do_ethparam_common,
+	"Modify fec type for selected ethernet interface",
+	"Example - set_fec <ethX> [type]\n"
+	"Set FEC type for any of RVU PF based network interfaces\n"
+	"- where type - 0 [NO FEC] 1 [BASER_FEC] 2 [RS_FEC]\n"
+	"Use 'ethlist' command to display network interface names\n"
+);
+
+U_BOOT_CMD(
+	get_fec, 2, 1, do_ethparam_common,
+	"Display fec type for selected ethernet interface",
+	"Example - get_fec <ethX>\n"
+	"Get FEC type for any of RVU PF based network interfaces\n"
+	"Use 'ethlist' command to display network interface names\n"
+);
+
+U_BOOT_CMD(
+	set_phymod, 3, 1, do_ethparam_common,
+	"Modify line side phy-mod type for selected ethernet interface",
+	"Example - set_phymod <ethX> [type]\n"
+	"Set PHY MOD type for any of RVU PF based network interfaces\n"
+	"Currently, only 50G_R mode supports type 0 [NRZ] or 1 [PAM4]\n"
+	"Use 'ethlist' command to display network interface names\n"
+);
+
+U_BOOT_CMD(
+	get_phymod, 2, 1, do_ethparam_common,
+	"Display line side phy-mod type for selected ethernet interface",
+	"Example - get_phymod <ethX>\n"
+	"Get PHY MOD type for any of RVU PF based network interfaces\n"
+	"Use 'ethlist' command to display network interface names\n"
+);
+
diff --git a/cmd/marvell/mdio_dbg.c b/cmd/marvell/mdio_dbg.c
new file mode 100644
index 0000000..194912a
--- /dev/null
+++ b/cmd/marvell/mdio_dbg.c
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <command.h>
+#include <dm.h>
+#include <asm/arch/atf.h>
+
+extern void nix_get_cgx_lmac_id(struct udevice *dev, int *cgxid, int *lmacid);
+
+static int do_mdio_dbg(cmd_tbl_t *cmdtp, int flag, int argc,
+		       char *const argv[])
+{
+	const char *cmd;
+	char *endp;
+	const char *devname;
+	int ret = -1;
+	int mode, phyaddr, devaddr, regaddr, data, cgx, lmac, cgx_lmac;
+	struct udevice *dev;
+
+	if (argc < 7)
+		return CMD_RET_USAGE;
+
+	devaddr = -1;
+	cmd = argv[1];
+	devname = argv[2];
+
+	dev = eth_get_dev_by_name(devname);
+	if (!dev) {
+		printf("device interface %s not found\n", devname);
+		return CMD_RET_FAILURE;
+	}
+	if (strncmp(dev->name, "rvu_", 4)) {
+		printf("Invalid eth interface, choose RVU PF device\n");
+		return CMD_RET_FAILURE;
+	}
+	nix_get_cgx_lmac_id(dev, &cgx, &lmac);
+	cgx_lmac = (lmac & 0xF) | ((cgx & 0xF) << 4);
+
+	mode = simple_strtol(argv[3], &endp, 0);
+	if (mode < 0 || mode > 1) {
+		printf("Invalid clause selection\n");
+		return CMD_RET_FAILURE;
+	}
+	phyaddr = simple_strtol(argv[4], &endp, 0);
+
+	if (strcmp(cmd, "read") == 0) {
+		if (mode)
+			devaddr = simple_strtol(argv[5], &endp, 0);
+		regaddr = simple_strtol(argv[6], &endp, 0);
+		ret = atf_mdio_dbg_read(cgx_lmac, mode, phyaddr, devaddr,
+					regaddr);
+		printf("Read register 0x%x devad[%d] of PHY@0x%x => 0x%x\n",
+		       regaddr, devaddr, phyaddr, ret);
+	} else if (strcmp(cmd, "write") == 0) {
+		if (mode)
+			devaddr = simple_strtol(argv[5], &endp, 0);
+		regaddr = simple_strtol(argv[6], &endp, 0);
+		data = simple_strtol(argv[7], &endp, 0);
+		ret = atf_mdio_dbg_write(cgx_lmac, mode, phyaddr, devaddr,
+					 regaddr, data);
+		printf("Write register 0x%x devad[%d] of PHY@0x%x <= 0x%x\n",
+		       regaddr, devaddr, phyaddr, data);
+	}
+	return (ret == 0) ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
+}
+
+U_BOOT_CMD(
+	mdio_dbg,	8,	1,	do_mdio_dbg,
+	"MDIO Debug utility commands",
+	"mdio_dbg read <ethX> <mode> <addr> <devad> <reg>\n"
+	" - read register of PHY@addr using <mode> at <devad>.<reg>\n"
+	"mdio_dbg write <ethX> <mode> <addr> <devad> <reg> <data>\n"
+	" - write register of PHY@addr using <mode> at <devad>.<reg>\n"
+	"\n"
+	" - mode 0 [CLAUSE22] and 1 [CLAUSE45]\n"
+	" - devad should be -1 for clause22 and device address for clause45\n"
+	"Use 'ethlist' command to display network interface names\n"
+);
diff --git a/cmd/marvell/octeontx2_cmds.c b/cmd/marvell/octeontx2_cmds.c
new file mode 100644
index 0000000..1f184b3
--- /dev/null
+++ b/cmd/marvell/octeontx2_cmds.c
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <command.h>
+#include <asm/arch/atf.h>
+
+static int do_fsafe_clr(
+	cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	(void)atf_flsf_clr_force_2ndry();
+	return CMD_RET_SUCCESS;
+}
+
+U_BOOT_CMD(
+	fsafe_clr, 1, 0, do_fsafe_clr,
+	"Marvell OcteonTX2 Fail Safe: clear secondary boot", ""
+);
diff --git a/cmd/mem.c b/cmd/mem.c
index 6775ab7..7083eb8 100644
--- a/cmd/mem.c
+++ b/cmd/mem.c
@@ -1085,6 +1085,89 @@ static int do_mem_crc(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 
 #endif
 
+#ifdef CONFIG_ARCH_MVEBU
+int do_ir(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	u32 offset = 0x0;
+	u32 reg, tmp_val, residue;
+	char binary[40];
+	char cmd[40];
+	int i, j = 0;
+	int is_modified = 0;
+	u8 *regs_base = (u8 *)INTREG_BASE;
+
+	/* using base command, the u-boot can change the base address */
+	if (base_address != 0)
+		regs_base = (u8 *)base_address;
+
+	if (argc == 2) {
+		offset = simple_strtoul(argv[1], NULL, 16);
+	} else {
+		printf("Usage:\n%s\n", cmdtp->usage);
+		return 0;
+	}
+
+	reg = readl(regs_base + offset);
+	tmp_val = reg;
+	printf("Internal register 0x%x value : 0x%x\n", offset, reg);
+	printf("\n    31      24        16         8         0");
+	printf("\n     |       |         |         |         |\nOLD: ");
+
+	/* Convert the value to binary string */
+	/* Be endianes safe so don't use shifts */
+	for (i = 31; i >= 0; i--) {
+		if (tmp_val > 0) {
+			residue = tmp_val % 2;
+			tmp_val = (tmp_val - residue) / 2;
+			if (residue == 0)
+				binary[i] = '0';
+			else
+				binary[i] = '1';
+		} else {
+			binary[i] = '0';
+		}
+	}
+
+	/* Print the binary string */
+	for (i = 0; i < 32; i++) {
+		printf("%c", binary[i]);
+		if ((((i+1) % 4) == 0) && (i > 1) && (i < 31))
+			printf("-");
+	}
+
+	cli_readline("\nNEW: ");
+	strcpy(cmd, console_buffer);
+	if ((cmd[0] == '0') && (cmd[1] == 'x')) {
+		reg = simple_strtoul(cmd, NULL, 16);
+		is_modified = 1;
+	} else {
+		/* Read binary input */
+		for (i = 0; i < 40; i++) {
+			if (cmd[i] == '\0')
+				break;
+			if (i == 4 || i == 9 || i == 14 || i == 19 ||
+			    i == 24 || i == 29 || i == 34)
+				continue;
+			if (cmd[i] == '1') {
+				reg = reg | (0x80000000 >> j);
+				is_modified = 1;
+			} else if (cmd[i] == '0') {
+				reg = reg & (~(0x80000000 >> j));
+				is_modified = 1;
+			}
+			j++;
+		}
+	}
+
+	/* Update the register value if modified */
+	if (is_modified == 1) {
+		writel(reg, regs_base + offset);
+		printf("\nNew value = 0x%x\n\n", readl(regs_base + offset));
+	}
+	return 0;
+}
+#endif
+
 /**************************************************/
 U_BOOT_CMD(
 	md,	3,	1,	do_mem_md,
@@ -1253,3 +1336,15 @@ U_BOOT_CMD(
 	""
 );
 #endif
+
+#ifdef CONFIG_ARCH_MVEBU
+U_BOOT_CMD(
+	ir,      2,     1,      do_ir,
+	"ir	- Reading and changing internal register values.\n",
+	" Address - offset inside internal registers space\n"
+	"\tDisplays the contents of the internal register in 2 forms, hex and binary.\n"
+	"\tIt's possible to change the value by writing a hex value beginning with 0x\n"
+	"\tor by writing 0 or 1 in the required place.\n"
+	"\tPressing enter without any value keeps the value unchanged.\n"
+);
+#endif
diff --git a/cmd/mii.c b/cmd/mii.c
index 7ef7532..2bf665e 100644
--- a/cmd/mii.c
+++ b/cmd/mii.c
@@ -468,3 +468,23 @@ U_BOOT_CMD(
 	"mii dump   <addr> <reg>               - pretty-print <addr> <reg> (0-5 only)\n"
 	"Addr and/or reg may be ranges, e.g. 2-7."
 );
+
+#ifdef CONFIG_CMD_MVEBU_PHY_FW_DOWNLOAD
+int phy_fw_down_cmd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	return mvebu_phy_firmware_download(
+			(u8)simple_strtoul(argv[5], NULL, 10),
+			(u8 *)simple_strtoul(argv[1], NULL, 16),
+			(u32)simple_strtoul(argv[2], NULL, 10),
+			(u8 *)simple_strtoul(argv[3], NULL, 16),
+			(u32)simple_strtoul(argv[4], NULL, 10));
+}
+
+U_BOOT_CMD(
+	phy_fw_down,      6,     0,      phy_fw_down_cmd,
+	"phy_fw_down - Downloads x3220/3310 Ethernet transceiver PHY firmware.\n",
+	"\t<FW Image Addr, Hex> <FW Image Size, Bytes> <Slave Image Addr, Hex> <Slave Image Size, Bytes> <XSMI Port Number>\n"
+	"\t(Marvell>> phy_fw_down 0x2010000 167972 0x2000000 9948 8\n"
+);
+#endif
+
diff --git a/cmd/mmc.c b/cmd/mmc.c
index 58fdc36..1f6306e 100644
--- a/cmd/mmc.c
+++ b/cmd/mmc.c
@@ -91,6 +91,7 @@ static void print_mmcinfo(struct mmc *mmc)
 		}
 	}
 }
+
 static struct mmc *init_mmc_device(int dev, bool force_init)
 {
 	struct mmc *mmc;
@@ -435,7 +436,8 @@ static int do_mmc_dev(cmd_tbl_t *cmdtp, int flag,
 		printf("mmc%d is current device\n", curr_device);
 	else
 		printf("mmc%d(part %d) is current device\n",
-		       curr_device, mmc_get_blk_desc(mmc)->hwpart);
+		       curr_device,
+		       mmc_get_blk_desc(mmc)->hwpart);
 
 	return CMD_RET_SUCCESS;
 }
diff --git a/cmd/mtdparts.c b/cmd/mtdparts.c
index 9bc9774..0411bab 100644
--- a/cmd/mtdparts.c
+++ b/cmd/mtdparts.c
@@ -1550,7 +1550,7 @@ static const char *env_get_mtdparts(char *buf)
 static int parse_mtdparts(const char *const mtdparts)
 {
 	const char *p;
-	struct mtd_device *dev;
+	struct mtd_device *dev = NULL;
 	int err = 1;
 	char tmp_parts[MTDPARTS_MAXLEN];
 
diff --git a/cmd/mvebu/Kconfig b/cmd/mvebu/Kconfig
index ad10a57..349803c 100644
--- a/cmd/mvebu/Kconfig
+++ b/cmd/mvebu/Kconfig
@@ -9,6 +9,42 @@ config CMD_MVEBU_BUBT
 	  For details about bubt command please see the documentation
 	  in doc/mvebu/cmd/bubt.txt
 
+config CMD_MVEBU_MV_FW_INFO
+	bool "mv_fw_info"
+	depends on TARGET_MVEBU_ARMADA_8K || TARGET_OCTEONTX2_CN913x
+	default y
+	help
+	  mv_fw_info command prints FreeRTOS version and firmware information
+	  for the FW running on CM3 CPUs of AP and connected CPs.
+
+config CMD_MVEBU_PHY_FW_DOWNLOAD
+	bool "phy_fw_down"
+	depends on MVMDIO
+	default n
+	help
+	  phy_fw_down - This command download
+	  PHY firmware header to the PHY flash.
+	  This command is used for Marvell PHYs
+	  88X3220/88X3310
+
+config CMD_MVEBU_TSEN
+	bool "tsen"
+	depends on MVEBU_THERMAL_SENSOR
+	default y
+	help
+	  tsen - Display the SoC temperature
+	  as read from the on chip thermal sensor
+
+config CMD_MVEBU_HW_INFO
+	bool "hw_info"
+	select BOARD_CONFIG_EEPROM
+	default n
+	help
+	  hw_info - load HW information such as board ID, PCB SLM number,
+	  MAC addresses from EEPROM and apply them to environment variables.
+	  And update the MAC address in FDT file for Linux.
+	  When save the box information, it will be saved to EEPROM.
+
 choice
 	prompt "Flash for image"
 	default MVEBU_SPI_BOOT
@@ -33,7 +69,7 @@ config MVEBU_SPI_BOOT
 
 config MVEBU_MMC_BOOT
 	bool "eMMC flash boot"
-	depends on MVEBU_MMC
+	depends on (MVEBU_MMC || MMC_SDHCI_XENON)
 	help
 	  Enable boot from eMMC boot partition
 	  Allow usage of eMMC/SD device as a target for "bubt" command
@@ -42,6 +78,21 @@ config MVEBU_MMC_BOOT
 
 endchoice
 
+config MVEBU_BOOT_PART
+	int "boot partition"
+	default 0
+	help
+	  sets boot partition, and sets a specific
+	  partition as a target for "bubt" command.
+	  For details about bubt command please see the documentation
+	  in doc/mvebu/cmd/bubt.txt
+
+config MVEBU_BOOT_DEVICE
+	int "boot device id"
+	default 0
+	help
+	  Used for setting boot device id.
+
 config MVEBU_UBOOT_DFLT_NAME
 	string "Default image name for bubt command"
 	default "flash-image.bin"
@@ -49,4 +100,70 @@ config MVEBU_UBOOT_DFLT_NAME
 	  This option should contain a default file name to be used with
 	  MVEBU "bubt" command if the source file name is omitted
 
+config CMD_MVEBU_RX_TRAINING
+	bool "rx_training"
+	depends on TARGET_MVEBU_ARMADA_8K || TARGET_OCTEONTX2_CN913x
+	default n
+	help
+	  Perform RX training sequence
+
+config CMD_MVEBU_AVS
+	bool "avs"
+	depends on TARGET_MVEBU_ARMADA_8K || TARGET_MVEBU_ARMADA_8K_PLUS || TARGET_OCTEONTX2_CN913x
+	default y
+	help
+	  Set/Get the Adaptive Voltage Scaling (AVS) value
+
+config CMD_MVEBU_MAP
+	bool "map"
+	depends on TARGET_MVEBU_ARMADA_8K || TARGET_MVEBU_ARMADA_8K_PLUS || TARGET_OCTEONTX2_CN913x
+	default y
+	help
+	  Dump address translation tables
+config CMD_MVEBU_NAND_OEM
+	bool "nand"
+	depends on (TARGET_MVEBU_ARMADA_8K || TARGET_MVEBU_ARMADA_8K_PLUS || TARGET_DB_88F6820_AP || TARGET_OCTEONTX2_CN913x) && CMD_NAND
+	default y
+	help
+	  Introduction: NAND vendors conducts tests to verify if all blocks are
+	  OK. In case of failure block, the NAND manufacturer will mark this
+	  block as bad (BBM) by setting 0x00 somewhere in the spare area.
+	  Moreover NAND manufacturer can pre-programmed the chip with provided
+	  image using external burner.
+
+	  Issue: Marvell NFC employ optimized cost/performance ECC mechanism.
+	  This results in an unique ECC layout implementation. Marvell NFC sets
+	  different layouts according to page size/ECC strength combinations.
+
+	  Therefore after preparing image for the NAND manufacturer for board
+	  with Marvell NFC, due to the layout differences used by Marvell NFC
+	  and physical NAND chip layout, some valid data will be put on BBM
+	  position.  This will result on false bad block indicator and will
+	  affect the BBT which is created automatically (by U-Boot or Linux)
+	  during first run.
+
+	  To prevent from that kind of situations, the NAND oem command was
+	  introduced.
+
+	  The "prepare" part of the command runs once per device data partition
+	  in NAND and prepares image which is next send to manufacturer. It
+	  checks if under BBM position there is no data which could be then
+	  mistakenly taken as a BBM. If so the data together with tracking
+	  information is copied to "meta-data" partition and BBM position is
+	  overwritten with good indicator.
+
+	  The "restore" part of the command runs once per "prepared" partition
+	  and restores its original data. It supposed to run on new boards, on
+	  which the NAND manufacturer pre-programmed earlier prepared image.
+
+config CMD_MVEBU_MV_GET_COUNTERS
+	bool "mv_get_counters"
+	depends on TARGET_MVEBU_ARMADA_8K || TARGET_OCTEONTX2_CN913x
+	default y
+	help
+	  mv_get_counters print MIB Counters.
+	  First argument select eth port to print.
+	  When no argument is given default port is Ethact.
+	  Wrong port being selected could cause crash.
+
 endmenu
diff --git a/cmd/mvebu/Makefile b/cmd/mvebu/Makefile
index 03de53e..4cc1982 100644
--- a/cmd/mvebu/Makefile
+++ b/cmd/mvebu/Makefile
@@ -4,5 +4,15 @@
 # SPDX-License-Identifier:	GPL-2.0
 # https://spdx.org/licenses
 
+ccflags-y += -Idrivers/mtd/nand/
 
 obj-$(CONFIG_CMD_MVEBU_BUBT) += bubt.o
+obj-$(CONFIG_CMD_MVEBU_RX_TRAINING) += rx_training.o
+obj-$(CONFIG_CMD_MVEBU_AVS) += avs.o
+obj-$(CONFIG_CMD_MVEBU_MAP) += map.o
+obj-$(CONFIG_CMD_MVEBU_TSEN) += thermal.o
+obj-$(CONFIG_CMD_MVEBU_HW_INFO) += hw_info.o
+obj-$(CONFIG_CMD_MVEBU_NAND_OEM) += pxa3xx_nand_oem.o
+obj-$(CONFIG_CMD_MVEBU_SAR) += sar.o
+obj-$(CONFIG_CMD_MVEBU_MV_FW_INFO) += mv_fw_info.o
+obj-$(CONFIG_CMD_MVEBU_MV_GET_COUNTERS) += mv_get_counters.o
diff --git a/cmd/mvebu/avs.c b/cmd/mvebu/avs.c
new file mode 100644
index 0000000..c19c4f9
--- /dev/null
+++ b/cmd/mvebu/avs.c
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ * https://spdx.org/licenses
+ */
+
+#include <config.h>
+#include <common.h>
+#include <command.h>
+#include <asm/io.h>
+#include <linux/sizes.h>
+#include <mach/soc.h>
+
+#define MV_TO_AVS_VAL(mv)	((mv) * 1024 / 1189)
+#define AVS_VAL_TO_MV(avs)	((avs) * 1189 / 1024)
+
+#define MIN_AVS_VAL_MV		600
+#define MAX_AVS_VAL_MV		1000
+
+#define AVS_VAL_MASK		(0x3ff)
+#define AVS_LOW_LIMIT_SHIFT	(3)
+#define AVS_HIGH_LIMIT_SHIFT	(13)
+#define AVS_ENABLE_MASK		BIT(0)
+#define AVS_SOFT_RESET_MASK	BIT(2)
+#define AVS_CFG_DEBUG_SELECT	BIT(29)
+
+#define MVEBU_AR_RFU_BASE(ap)		(MVEBU_REGS_BASE_AP(ap) + 0x6F0000)
+#define MVEBU_AVS_SRV_CTRL_REG(ap)	(MVEBU_AR_RFU_BASE(ap) + 0x8120)
+#define MVEBU_AVS_CTRL_REG(ap)		(MVEBU_AR_RFU_BASE(ap) + 0x8130)
+#define MVEBU_AVS_STAT_REG(ap)		(MVEBU_AR_RFU_BASE(ap) + 0x8134)
+
+static void do_get_avs(void)
+{
+	int ap, ap_num, cp_num;
+
+	soc_get_ap_cp_num(&ap_num, &cp_num);
+	for (ap = 0; ap < ap_num; ap++) {
+		u32 reg_val;
+
+		/* Cause the AVS configuration to be
+		 * reflected by AV status register
+		 */
+		writel(AVS_CFG_DEBUG_SELECT, MVEBU_AVS_SRV_CTRL_REG(ap));
+		/* Read and format the result */
+		reg_val = readl(MVEBU_AVS_STAT_REG(ap));
+		reg_val &= AVS_VAL_MASK;
+		printf("AP-%d: returned AVS value is %d mV\n",
+		       ap, AVS_VAL_TO_MV(reg_val));
+	}
+}
+
+static void do_set_avs(unsigned long val_mv)
+{
+	unsigned int avs_val = MV_TO_AVS_VAL(val_mv) & AVS_VAL_MASK;
+	int ap, ap_num, cp_num;
+
+	soc_get_ap_cp_num(&ap_num, &cp_num);
+	for (ap = 0; ap < ap_num; ap++) {
+		u32 reg_val;
+
+		printf("AP-%d: setting the AVS to %ld mV (0x%x)\n",
+		       ap, val_mv, avs_val);
+		reg_val = avs_val << AVS_LOW_LIMIT_SHIFT;
+		reg_val |= avs_val << AVS_HIGH_LIMIT_SHIFT;
+		reg_val |= AVS_SOFT_RESET_MASK | AVS_ENABLE_MASK;
+		writel(reg_val, MVEBU_AVS_CTRL_REG(ap));
+	}
+	mdelay(1000);
+	do_get_avs();
+}
+
+int do_avs_cmd(cmd_tbl_t *cmdtp, int flag, int argc,
+	       char * const argv[])
+{
+	if (strncmp(argv[1], "get", 3) == 0) {
+		do_get_avs();
+	} else if ((argc == 3) && (strncmp(argv[1], "set", 3) == 0)) {
+		unsigned long val_mv = simple_strtoul(argv[2], NULL, 10);
+
+		if ((val_mv < MIN_AVS_VAL_MV) || (val_mv > MAX_AVS_VAL_MV)) {
+			printf("Requested value %ldmV is ",  val_mv);
+			printf("out of the supported range\n");
+			return 0;
+		}
+		do_set_avs(val_mv);
+	} else {
+		printf("Bad format. Use \"help avs\" for more info");
+		printf("about this command\n");
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	avs,      3,     1,      do_avs_cmd,
+	"Set/Get Adaptive Voltage Scaling (AVS) value\n",
+	"[operation] [value]\n"
+	"\t-operation     Either \"set\" or \"get\"\n"
+	"\t-value         AVS value in mV. Valid only for \"set\" operation\n"
+	"\t               Valid AVS range is 600mV - 1000mV\n"
+);
diff --git a/cmd/mvebu/bubt.c b/cmd/mvebu/bubt.c
index 23fb8cd..72c58f5 100644
--- a/cmd/mvebu/bubt.c
+++ b/cmd/mvebu/bubt.c
@@ -25,8 +25,12 @@
 #include <u-boot/sha256.h>
 
 #ifndef CONFIG_SYS_MMC_ENV_DEV
+#ifdef CONFIG_TARGET_MVEBU_ARMADA_37XX
+#define CONFIG_SYS_MMC_ENV_DEV	1
+#else
 #define CONFIG_SYS_MMC_ENV_DEV	0
 #endif
+#endif
 
 #if defined(CONFIG_ARMADA_8K)
 #define MAIN_HDR_MAGIC		0xB105B002
@@ -84,6 +88,33 @@ struct mvebu_image_info {
 	u32	encrypt_start_offset;
 	u32	encrypt_size;
 };
+
+#else /* Older Armada SoCs - A38x, A39x, ... */
+
+#define	LEGACY_HDR_VERSION	1
+
+struct legacy_image_header {
+/*	type	name			byte order */
+	u8	block_id;		/*   0   */
+	u8	flags;			/*   1   */
+	u16	nand_pge_size;		/*  2-3  */
+	u32	block_size;		/*  4-7  */
+	u8	version;		/*   8   */
+	u8	hdr_size_msb;		/*   9   */
+	u16	hdr_size_lsb;		/* 10-11 */
+	u32	source_addr;		/* 12-15 */
+	u32	destination_addr;	/* 16-19 */
+	u32	execution_addr;		/* 20-23 */
+	u8	options;		/*  24   */
+	u8	nand_block_size;	/*  25   */
+	u8	nand_technology;	/*  26   */
+	u8	rsvd4;			/*  27   */
+	u16	rsvd2;			/* 28-29 */
+	u8	ext;			/*  30   */
+	u8	checksum;		/*  31   */
+
+};
+
 #endif /* CONFIG_ARMADA_XXX */
 
 struct bubt_dev {
@@ -136,8 +167,8 @@ static int mmc_burn_image(size_t image_size)
 	}
 
 #ifdef CONFIG_SYS_MMC_ENV_PART
-	if (mmc->part_num != CONFIG_SYS_MMC_ENV_PART) {
-		err = mmc_switch_part(mmc_dev_num, CONFIG_SYS_MMC_ENV_PART);
+	if (mmc_get_blk_desc(mmc)->hwpart != CONFIG_SYS_MMC_ENV_PART) {
+		err = mmc_switch_part(mmc, CONFIG_SYS_MMC_ENV_PART);
 		if (err) {
 			printf("MMC partition switch failed\n");
 			return err;
@@ -177,8 +208,8 @@ static int mmc_burn_image(size_t image_size)
 	printf("Done!\n");
 
 #ifdef CONFIG_SYS_MMC_ENV_PART
-	if (mmc->part_num != CONFIG_SYS_MMC_ENV_PART)
-		mmc_switch_part(mmc_dev_num, mmc->part_num);
+	if (mmc_get_blk_desc(mmc)->hwpart != CONFIG_SYS_MMC_ENV_PART)
+		mmc_switch_part(mmc, mmc_get_blk_desc(mmc)->hwpart);
 #endif
 
 	return 0;
@@ -619,11 +650,53 @@ static int check_image_header(void)
 	return 0;
 }
 
-#else /* Not ARMADA? */
+#else /* Legacy SoCs */
+u8 do_checksum8(u8 *start, u32 len)
+{
+	u8 sum = 0;
+	u8 *startp = start;
+
+	do {
+		sum += *startp;
+		startp++;
+	} while (--len);
+
+	return sum;
+}
+
 static int check_image_header(void)
 {
-	printf("bubt cmd does not support this SoC device or family!\n");
-	return -ENOEXEC;
+	struct legacy_image_header *hdr =
+			(struct legacy_image_header *)get_load_addr();
+	u32 header_len = hdr->hdr_size_lsb + (hdr->hdr_size_msb << 16);
+	u8 checksum;
+	u8 checksum_ref = hdr->checksum;
+
+	/*
+	 * For now compare checksum, and header version. Later we can
+	 * verify more stuff on the header like interface type, etc
+	 */
+	if (hdr->version != LEGACY_HDR_VERSION) {
+		printf("ERROR: Bad HDR Version 0x%x != 0x%x\n",
+		       hdr->version, LEGACY_HDR_VERSION);
+		return -ENOEXEC;
+	}
+
+	/* The checksum value is discarded from checksum calculation */
+	hdr->checksum = 0;
+
+	checksum = do_checksum8((u8 *)hdr, header_len);
+	if (checksum != checksum_ref) {
+		printf("Error: Bad Image checksum. 0x%x != 0x%x\n",
+		       checksum, checksum_ref);
+		return -ENOEXEC;
+	}
+
+	/* Restore the checksum before writing */
+	hdr->checksum = checksum_ref;
+	printf("Image checksum...OK!\n");
+
+	return 0;
 }
 #endif
 
@@ -698,7 +771,7 @@ struct bubt_dev *find_bubt_dev(char *dev_name)
 #define DEFAULT_BUBT_DST "nand"
 #elif defined(CONFIG_MVEBU_MMC_BOOT)
 #define DEFAULT_BUBT_DST "mmc"
-else
+#else
 #define DEFAULT_BUBT_DST "error"
 #endif
 #endif /* DEFAULT_BUBT_DST */
diff --git a/cmd/mvebu/hw_info.c b/cmd/mvebu/hw_info.c
new file mode 100644
index 0000000..ee09e22
--- /dev/null
+++ b/cmd/mvebu/hw_info.c
@@ -0,0 +1,297 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include <config.h>
+#include <command.h>
+#include <common.h>
+#include <errno.h>
+#include <console.h>
+#include <environment.h>
+#include <mvebu/cfg_eeprom.h>
+
+/* load the HW configuration from cfg_eeprom module and dump them */
+static int cmd_hw_info_dump(char *name)
+{
+	int idx;
+	int hw_param_num;
+	struct hw_info_data_struct hw_info_data_array[HW_INFO_MAX_PARAM_NUM];
+
+	hw_param_num = cfg_eeprom_parse_hw_info(hw_info_data_array);
+
+	/* it is possible the HW configuration is empty */
+	if (hw_param_num == 0)
+		return 0;
+
+	if (hw_param_num > MVEBU_HW_INFO_LEN) {
+		pr_err("hw_info internal error, counter should not exceed %d\n",
+		       MVEBU_HW_INFO_LEN);
+		return -EINVAL;
+	}
+
+	printf("\nname               value\n");
+	printf("------------------------------------\n");
+	for (idx = 0; idx < hw_param_num; idx++) {
+		if (name) {
+			if (strcmp(name, hw_info_data_array[idx].name) == 0) {
+				printf("%-16s   %-s\n",
+				       hw_info_data_array[idx].name,
+				       hw_info_data_array[idx].value);
+				break;
+			}
+		} else {
+			printf("%-16s   %-s\n",
+			       hw_info_data_array[idx].name,
+			       hw_info_data_array[idx].value);
+		}
+	}
+
+	return 0;
+}
+
+int cmd_hw_info_load(char *name, int silence)
+{
+	int idx;
+	int hw_param_num;
+	struct hw_info_data_struct hw_info_data_array[HW_INFO_MAX_PARAM_NUM];
+
+	/* get hw_info from system
+	 * need to memset the hw_info to 0 for later string operation
+	 */
+	hw_param_num = cfg_eeprom_parse_hw_info(hw_info_data_array);
+
+	/* it is possible the HW configuration is empty */
+	if (hw_param_num == 0)
+		return 0;
+
+	if (hw_param_num > MVEBU_HW_INFO_LEN) {
+		pr_err("HW info: variables from EEPROM can not exceed %d\n",
+		       MVEBU_HW_INFO_LEN);
+		return -EINVAL;
+	}
+
+	/* save the HW parameter to env varibles one by one */
+	for (idx = 0; idx < hw_param_num; idx++) {
+		/* if customer input a specific and valid HW parameter name,
+		 * only save this HW parameter from EEPROM to env variables.
+		 * otherwise save all the HW parameters from EEPROM to env.
+		 */
+		if (name) {
+			if (strcmp(name, hw_info_data_array[idx].name) == 0) {
+				env_set(hw_info_data_array[idx].name,
+					hw_info_data_array[idx].value);
+				break;
+			}
+		} else {
+			env_set(hw_info_data_array[idx].name,
+				hw_info_data_array[idx].value);
+		}
+	}
+
+	printf("HW information is loaded to environment variables\n");
+	cmd_hw_info_dump(name);
+
+	/* just print indication to ask user to perform saveenv manually in
+	 * silence mode, which is used when restore the HW configuration to env
+	 * variables with env reset. to ask confirmation that if need to save
+	 * env in non-silence mode, which is used by hw_info cmd.
+	 */
+	if (silence) {
+		printf("To save the changes, please run the command saveenv\n");
+	} else {
+		printf("Do you want to save environment variables? <y/N> ");
+		if (confirm_yesno())
+			env_save();
+		else
+			printf("To save changes, please run command saveenv\n");
+	}
+
+	return 0;
+}
+
+static int cmd_hw_info_store(char *name)
+{
+	int idx;
+	int str_len = 0;
+	int total_str_len = 0;
+	int ret;
+	int hw_param_num;
+	int name_in_eeprom_flag = 0;
+	char *target_value;
+	uchar hw_info_str[MVEBU_HW_INFO_LEN];
+	struct hw_info_data_struct hw_info_data_arry[HW_INFO_MAX_PARAM_NUM];
+
+	printf("Are you sure to override factory settings in EEPROM? <y/N>");
+	if (!confirm_yesno())
+		return 0;
+
+	/* need to memset the arry to 0 for later string operation */
+	memset(hw_info_data_arry, 0, sizeof(hw_info_data_arry));
+
+	if (!name) {
+		/* get hw_info from env */
+		hw_param_num = cfg_eeprom_parse_env(&hw_info_data_arry[0],
+						    sizeof(hw_info_data_arry));
+		/* return in case no valid env variables */
+		if (hw_param_num == 0) {
+			printf("There is no supported HW configuration ");
+			printf("in env\n");
+
+			return 0;
+		}
+	} else {
+		/* get hw_info from eeprom */
+		hw_param_num = cfg_eeprom_parse_hw_info(hw_info_data_arry);
+
+		/* name valid check */
+		ret = cfg_eeprom_validate_name(name);
+		if (ret) {
+			printf("The HW parameter is invalid\n");
+
+			return 0;
+		}
+		/* check the name in hw_info_data_arry */
+		for (idx = 0; idx < hw_param_num; idx++) {
+			if (strcmp(name, hw_info_data_arry[idx].name) == 0) {
+				target_value = env_get(name);
+				str_len = strlen(target_value);
+				/* clear value */
+				memset(hw_info_data_arry[idx].value, 0,
+				       sizeof(hw_info_data_arry[idx].value));
+				/* overwrite value */
+				memcpy(hw_info_data_arry[idx].value,
+				       target_value, str_len);
+				name_in_eeprom_flag = 1;
+			}
+		}
+		/* name is not in hw_info_data_arry */
+		if (!name_in_eeprom_flag) {
+			target_value = env_get(name);
+			str_len = strlen(name);
+			/* clear name */
+			memset(hw_info_data_arry[idx].name, 0,
+			       sizeof(hw_info_data_arry[idx].name));
+			/* add name */
+			memcpy(hw_info_data_arry[idx].name, name, str_len);
+
+			str_len = strlen(target_value);
+			/* clear value */
+			memset(hw_info_data_arry[idx].value, 0,
+			       sizeof(hw_info_data_arry[idx].value));
+			/* add value */
+			memcpy(hw_info_data_arry[idx].value, target_value,
+			       str_len);
+
+			hw_param_num++;
+		}
+	}
+
+	 /* need to memset the hw_info to 0 for later string operation */
+	memset(hw_info_str, 0, sizeof(hw_info_str));
+	for (idx = 0;
+	     (idx < hw_param_num) && (total_str_len < MVEBU_HW_INFO_LEN);
+	     idx++) {
+		str_len = strlen(hw_info_data_arry[idx].name);
+		if (str_len > HW_INFO_MAX_NAME_LEN)
+			str_len = HW_INFO_MAX_NAME_LEN;
+
+		if ((total_str_len + str_len) > MVEBU_HW_INFO_LEN) {
+			pr_err("HW info string from env exceeds %d\n",
+			       MVEBU_HW_INFO_LEN);
+			break;
+		}
+
+		memcpy(hw_info_str + total_str_len,
+		       hw_info_data_arry[idx].name, str_len);
+		total_str_len += str_len;
+
+		if ((total_str_len + 1) > MVEBU_HW_INFO_LEN) {
+			pr_err("HW information string from env exceeds %d\n",
+			       MVEBU_HW_INFO_LEN);
+			break;
+		}
+
+		hw_info_str[total_str_len++] = '=';
+
+		str_len = strlen(hw_info_data_arry[idx].value);
+		if (str_len > HW_INFO_MAX_VALUE_LEN)
+			str_len = HW_INFO_MAX_VALUE_LEN;
+
+		if ((total_str_len + str_len) > MVEBU_HW_INFO_LEN) {
+			pr_err("HW information string from env exceeds %d\n",
+			       MVEBU_HW_INFO_LEN);
+			break;
+		}
+
+		memcpy(hw_info_str + total_str_len,
+		       hw_info_data_arry[idx].value, str_len);
+		total_str_len += str_len;
+
+		if ((total_str_len + 1) > MVEBU_HW_INFO_LEN) {
+			pr_err("HW information string from env exceeds %d\n",
+			       MVEBU_HW_INFO_LEN);
+			break;
+		}
+		hw_info_str[total_str_len++] = ' ';
+	}
+
+	cfg_eeprom_set_hw_info_str(hw_info_str);
+	/* save hw_info to EEPROM, and also the rest without changing */
+	cfg_eeprom_save(EEPROM_STRUCT_SIZE);
+
+	printf("hw_info is saved to EEPROM\n");
+	cmd_hw_info_dump(name);
+
+	return 0;
+}
+
+int do_hw_info(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	const char *cmd = argv[1];
+
+	if (argc < 2)
+		return CMD_RET_USAGE;
+
+	if (!strcmp(cmd, "dump")) {
+		if (cmd_hw_info_dump(argv[2]))
+			return -EINVAL;
+	} else if (!strcmp(cmd, "load")) {
+		if (cmd_hw_info_load(argv[2], 0))
+			return -EINVAL;
+	} else if (!strcmp(cmd, "store")) {
+		if (cmd_hw_info_store(argv[2]))
+			return -EINVAL;
+	} else {
+		return CMD_RET_USAGE;
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	hw_info,      3,     0,      do_hw_info,
+	"hw_info\n",
+	"\n"
+	"Load/Store HW information environment variables from/to EEPROM\n"
+	"HW information includes predefined list of Env. variables (such as PCB SLM number, MAC addresses, etc).\n"
+	"\tdump  <evn_name>            - Dump all (or specific <env_name>) HW parameter from EEPROM\n"
+	"\tload  <env_name>            - Load all (or specific <env_name>) HW parameter from EEPROM to env variables\n"
+	"\tstore <env_name>            - Store all or specific HW parameter from env variables to EEPROM\n"
+	"\t				 usage of 'hw_info store' requires proper values to be set for the variables listed below\n"
+	"Supported HW information parameters\n"
+	"\tpcb_slm       PCB SLM number\n"
+	"\tpcb_rev       PCB revision number\n"
+	"\teco_rev       ECO revision number\n"
+	"\tpcb_sn        PCB SN\n"
+	"\tethaddr       first MAC address\n"
+	"\teth1addr      second MAC address\n"
+	"\teth2addr      third MAC address\n"
+	"\teth3addr      fourth MAC address\n"
+	"\teth4addr      fifth MAC address\n"
+	"\teth5addr      sixth MAC address\n"
+	"\teth6addr      seventh MAC address\n"
+	"\teth7addr      eighth MAC address\n"
+	"\teth8addr      ninth MAC address\n"
+	"\teth9addr      tenth MAC address\n"
+);
diff --git a/cmd/mvebu/map.c b/cmd/mvebu/map.c
new file mode 100644
index 0000000..4ffa2e3
--- /dev/null
+++ b/cmd/mvebu/map.c
@@ -0,0 +1,254 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <config.h>
+#include <common.h>
+#include <command.h>
+#include <asm/io.h>
+#include <linux/sizes.h>
+#include <mach/soc.h>
+
+#define ADDRESS_SHIFT			(20 - 4)
+#define WIN_ENABLE_BIT			(0x1)
+#define ADDRESS_RSHIFT			(26)
+#define ADDRESS_LSHIFT			(10)
+
+#define MVEBU_CCU_BASE(ap)		(MVEBU_REGS_BASE_AP(ap) + 0x4000)
+#define MVEBU_AR_RFU_BASE(ap)		(MVEBU_REGS_BASE_AP(ap) + 0x6F0000)
+#define MVEBU_IO_WIN_BASE(ap)		(MVEBU_AR_RFU_BASE(ap))
+#define MVEBU_GWIN_BASE(ap)		(MVEBU_REGS_BASE_AP(ap) + 0x5400)
+
+/* CCU registers definitions */
+#define CCU_WIN_CR_OFFSET(ap, win)	(MVEBU_CCU_BASE(ap) + \
+						0x0 + (0x10 * win))
+#define CCU_TARGET_ID_OFFSET		(8)
+#define CCU_TARGET_ID_MASK		(0x7F)
+
+#define CCU_WIN_ALR_OFFSET(ap, win)	(MVEBU_CCU_BASE(ap) + \
+						0x8 + (0x10 * win))
+#define CCU_WIN_AHR_OFFSET(ap, win)	(MVEBU_CCU_BASE(ap) + \
+						0xC + (0x10 * win))
+#define CCU_WIN_GCR_OFFSET(ap)		(MVEBU_CCU_BASE(ap) + 0xD0)
+#define CCU_GCR_TARGET_OFFSET		(8)
+#define CCU_GCR_TARGET_MASK		(0xFF)
+
+/* IO Win registers definitions */
+#define IO_WIN_ALR_OFFSET(ap, win)	(MVEBU_IO_WIN_BASE(ap) + \
+						0x0 + (0x10 * win))
+#define IO_WIN_AHR_OFFSET(ap, win)	(MVEBU_IO_WIN_BASE(ap) + \
+						0x8 + (0x10 * win))
+#define IO_WIN_CR_OFFSET(ap, win)	(MVEBU_IO_WIN_BASE(ap) + \
+						0xC + (0x10 * win))
+
+/* GWin registers definitions */
+#define GWIN_CR_OFFSET(ap, win)		(MVEBU_GWIN_BASE(ap) + \
+						0x0 + (0x10 * (win)))
+#define GWIN_ALR_OFFSET(ap, win)	(MVEBU_GWIN_BASE(ap) + \
+						0x8 + (0x10 * (win)))
+#define GWIN_AHR_OFFSET(ap, win)	(MVEBU_GWIN_BASE(ap) + \
+						0xc + (0x10 * (win)))
+/* IOB registers definitions */
+#define MVEBU_IOB_OFFSET		(0x190000)
+#define MVEBU_IOB_BASE(ap, cp)		(MVEBU_REGS_BASE_CP(ap, cp) + \
+						MVEBU_IOB_OFFSET)
+#define MVEBU_IOB_MAX_WINS		(16)
+
+#define IOB_WIN_CR_OFFSET(ap, cp, win)	(MVEBU_IOB_BASE(ap, cp) + \
+						0x0 + (0x20 * win))
+#define IOB_TARGET_ID_OFFSET		(8)
+#define IOB_TARGET_ID_MASK		(0xF)
+#define IOB_WIN_ALR_OFFSET(ap, cp, win)	(MVEBU_IOB_BASE(ap, cp) + \
+						0x8 + (0x20 * win))
+#define IOB_WIN_AHR_OFFSET(ap, cp, win)	(MVEBU_IOB_BASE(ap, cp) + \
+						0xC + (0x20 * win))
+
+/* AMB address decoding registers definitions */
+#define MVEBU_AMB_ADEC_OFFSET		(0x70ff00)
+#define MVEBU_AMB_ADEC_BASE(ap, cp)	(MVEBU_REGS_BASE_CP(ap, cp) + \
+						MVEBU_AMB_ADEC_OFFSET)
+#define AMB_MAX_WIN_ID			(7)
+#define AMB_WIN_CR_OFFSET(ap, cp, win)	(MVEBU_AMB_ADEC_BASE(ap, cp) \
+						+ 0x0 + (0x8 * win))
+#define AMB_ATTR_OFFSET			8
+#define AMB_ATTR_MASK			0xFF
+#define AMB_SIZE_OFFSET			16
+#define AMB_SIZE_MASK			0xFF
+
+#define AMB_WIN_BASE_OFFSET(ap, cp, win) (MVEBU_AMB_ADEC_BASE(ap, cp) + \
+						0x4 + 0x8 * (win))
+#define AMB_BASE_OFFSET			(16)
+#define AMB_BASE_ADDR_MASK		((1 << (32 - AMB_BASE_OFFSET)) - 1)
+
+static void dump_ccu(int ap)
+{
+	u32 win_id, win_cr, alr, ahr;
+	u8 target_id;
+	u64 start, end;
+
+	/* Dump all CCU windows */
+	printf("-----------\n");
+	printf("AP-%d CCU:\n", ap);
+	printf("bank  id target   start		     end\n");
+	printf("----------------------------------------------------\n");
+	for (win_id = 0; win_id < MVEBU_CCU_MAX_WINS; win_id++) {
+		win_cr = readl(CCU_WIN_CR_OFFSET(ap, win_id));
+		if (win_cr & WIN_ENABLE_BIT) {
+			printf("ccu   %02x", win_id);
+			target_id = (win_cr >> CCU_TARGET_ID_OFFSET) &
+						CCU_TARGET_ID_MASK;
+			alr = readl(CCU_WIN_ALR_OFFSET(ap, win_id));
+			ahr = readl(CCU_WIN_AHR_OFFSET(ap, win_id));
+			start = ((u64)alr << ADDRESS_SHIFT);
+			end = (((u64)ahr + 0x10) << ADDRESS_SHIFT);
+			printf(" %02x  0x%016llx 0x%016llx\n",
+			       target_id, start, end);
+		}
+	}
+	win_cr = readl(CCU_WIN_GCR_OFFSET(ap));
+	target_id = (win_cr >> CCU_GCR_TARGET_OFFSET) & CCU_GCR_TARGET_MASK;
+	printf("ccu   GCR 0x%x\n", target_id);
+}
+
+static void dump_io_win(int ap)
+{
+	u32 trgt_id, win_id;
+	u32 alr, ahr;
+	u64 start, end;
+
+	/* Dump all IO windows */
+	printf("-----------\n");
+	printf("AP-%d IOW:\n", ap);
+	printf("bank  target     start              end\n");
+	printf("----------------------------------------------------\n");
+	for (win_id = 0; win_id < MVEBU_IO_WIN_MAX_WINS; win_id++) {
+		alr = readl(IO_WIN_ALR_OFFSET(ap, win_id));
+		if (alr & WIN_ENABLE_BIT) {
+			alr &= ~WIN_ENABLE_BIT;
+			ahr = readl(IO_WIN_AHR_OFFSET(ap, win_id));
+			trgt_id = readl(IO_WIN_CR_OFFSET(ap, win_id));
+			start = ((u64)alr << ADDRESS_SHIFT);
+			end = (((u64)ahr + 0x10) << ADDRESS_SHIFT);
+			printf("io-win %d  0x%016llx 0x%016llx\n",
+			       trgt_id, start, end);
+		}
+	}
+	printf("io-win GCR - 0x%x\n",
+	       readl(MVEBU_IO_WIN_BASE(ap) + MVEBU_IO_WIN_GCR_OFFSET));
+}
+
+static void dump_gwin(int ap)
+{
+#if defined(CONFIG_ARMADA_8K_PLUS)
+	u32 win_num;
+
+	/* Dump all GWIN windows */
+	printf("-----------\n");
+	printf("AP-%d GWIN:\n", ap);
+	printf("win\ttarget\tstart\t\t\tend\n");
+	printf("----------------------------------------------------\n");
+	for (win_num = 0; win_num < MVEBU_GWIN_MAX_WINS; win_num++) {
+		u32 cr;
+		u64 alr, ahr;
+
+		cr  = readl(GWIN_CR_OFFSET(ap, win_num));
+		/* Window enabled */
+		if (cr & WIN_ENABLE_BIT) {
+			printf("%02d\t %02d\t ", win_num, (cr >> 8) & 0xF);
+			alr = readl(GWIN_ALR_OFFSET(ap, win_num));
+			alr = (alr >> ADDRESS_LSHIFT) << ADDRESS_RSHIFT;
+			ahr = readl(GWIN_AHR_OFFSET(ap, win_num));
+			ahr = (ahr >> ADDRESS_LSHIFT) << ADDRESS_RSHIFT;
+			printf("0x%016llx 0x%016llx\n", alr, ahr);
+		}
+	}
+#endif
+}
+
+static void dump_iob(int ap, int cp)
+{
+	u32 win_id, win_cr, alr, ahr;
+	u8 target_id;
+	u64 start, end;
+
+	static const char * const iob_target_name[] = {"CFG  ", "MCI0 ",
+			"PEX1 ", "PEX2 ", "PEX0 ", "NAND ", "RUNIT", "MCI1 "};
+
+	/* Dump all IOB windows */
+	printf("AP-%d CP-%d IOB:\n", ap, cp);
+	printf("bank  id target  start              end\n");
+	printf("----------------------------------------------------\n");
+	for (win_id = 0; win_id < MVEBU_IOB_MAX_WINS; win_id++) {
+		win_cr = readl(IOB_WIN_CR_OFFSET(ap, cp, win_id));
+		if (win_cr & WIN_ENABLE_BIT) {
+			target_id = (win_cr >> IOB_TARGET_ID_OFFSET) &
+						IOB_TARGET_ID_MASK;
+			alr = readl(IOB_WIN_ALR_OFFSET(ap, cp, win_id));
+			start = ((u64)alr << ADDRESS_SHIFT);
+			if (win_id != 0) {
+				ahr = readl(IOB_WIN_AHR_OFFSET(ap, cp, win_id));
+				end = (((u64)ahr + 0x10) << ADDRESS_SHIFT);
+			} else {
+				/* Window #0 size is hardcoded to 16MB, as it's
+				 * reserved for CP configuration space.
+				 */
+				end = start + (16 << 20);
+			}
+			printf("iob   %02d %s   0x%016llx 0x%016llx\n",
+			       win_id, iob_target_name[target_id], start, end);
+		}
+	}
+}
+
+static void dump_amb_adec(int ap, int cp)
+{
+	u32 ctrl, base, win_id, attr;
+	u32 size, size_count;
+
+	/* Dump all AMB windows */
+	printf("AP-%d CP-%d AMB addr.decode:\n", ap, cp);
+	printf("bank  attribute     base          size\n");
+	printf("--------------------------------------------\n");
+	for (win_id = 0; win_id < AMB_MAX_WIN_ID; win_id++) {
+		ctrl = readl(AMB_WIN_CR_OFFSET(ap, cp, win_id));
+		if (ctrl & WIN_ENABLE_BIT) {
+			base = readl(AMB_WIN_BASE_OFFSET(ap, cp, win_id));
+			attr = (ctrl >> AMB_ATTR_OFFSET) & AMB_ATTR_MASK;
+			size_count = (ctrl >> AMB_SIZE_OFFSET) & AMB_SIZE_MASK;
+			size = (size_count + 1) * SZ_64K;
+			printf("amb   0x%04x        0x%08x    0x%08x\n",
+			       attr, base, size);
+		}
+	}
+}
+
+int do_map_cmd(cmd_tbl_t *cmdtp, int flag, int argc,
+	       char * const argv[])
+{
+	int ap, cp, ap_num, cp_num;
+
+	soc_get_ap_cp_num(&ap_num, &cp_num);
+
+	for (ap = 0; ap < ap_num; ap++) {
+		printf("AP-%d address decoding:\n", ap);
+		dump_ccu(ap);
+		dump_io_win(ap);
+		dump_gwin(ap);
+		for (cp = 0; cp < (cp_num / ap_num); cp++) {
+			printf("\nAP-%d CP-%d address decoding:\n", ap, cp);
+			dump_iob(ap, cp);
+			dump_amb_adec(ap, cp);
+		}
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	map,      1,     1,      do_map_cmd,
+	"Display address decode windows\n",
+	"\tDisplay address decode windows\n"
+);
diff --git a/cmd/mvebu/mv_fw_info.c b/cmd/mvebu/mv_fw_info.c
new file mode 100644
index 0000000..b4d211f
--- /dev/null
+++ b/cmd/mvebu/mv_fw_info.c
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <asm/io.h>
+#include <command.h>
+#include <common.h>
+#include <config.h>
+#include <mach/soc.h>
+
+#define MSS_CP_CM3_SRAM_BASE		0x220000
+#define RTOS_VERS_OFSSET		0x1000
+#define	FW_INFO_OFFS			(MVEBU_REGS_BASE_CP(0, 0) + \
+	MSS_CP_CM3_SRAM_BASE + RTOS_VERS_OFSSET)
+#define	UNIT_FW_INFO(n_cp)		(FW_INFO_OFFS + (n_cp) * 0x40)
+
+typedef struct{
+	u8 unit_name[4];
+	u32 mss_pm;
+	u32 mci_link_mgmt;
+	u32 fca;
+	u8 rtos_version[32];
+	u8 rtos_kernel_version[12];
+} FW_INFO;
+
+void mv_print_fw_info(const FW_INFO * const info)
+{
+	u32 first_flag = true;
+
+	printf("Unit: %s\n FreeROTS release: %s\n Kernel: %s\n Flags:",
+	       info->unit_name, info->rtos_version, info->rtos_kernel_version);
+
+	if (info->mci_link_mgmt) {
+		printf(" MCI link management");
+		first_flag = false;
+	}
+
+	if (info->fca) {
+		if (!first_flag)
+			printf(",");
+		printf(" PPv2 Flow Control");
+		first_flag = false;
+	}
+
+	if (info->mss_pm) {
+		if (!first_flag)
+			printf(",");
+		printf(" MSS Power Management");
+	}
+	printf("\n------------------------------------\n");
+}
+
+int mv_do_fw_info_cmd(cmd_tbl_t *cmdtp, int flag, int argc, char *const argv[])
+{
+	FW_INFO info;
+	u32 num_of_cps;
+	u32 num_of_aps;
+	u32 num_of_units;
+	u32 i;
+
+	soc_get_ap_cp_num(&num_of_aps, &num_of_cps);
+	num_of_units = num_of_aps + num_of_cps;
+
+	for (i = 0; i < num_of_units; ++i) {
+		memcpy(&info, (void *)UNIT_FW_INFO(i), sizeof(FW_INFO));
+		mv_print_fw_info(&info);
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	mv_fw_info, 1, 0, mv_do_fw_info_cmd,
+	"Prints service CPU firmware information",
+	"");
diff --git a/cmd/mvebu/mv_get_counters.c b/cmd/mvebu/mv_get_counters.c
new file mode 100644
index 0000000..579bb9f
--- /dev/null
+++ b/cmd/mvebu/mv_get_counters.c
@@ -0,0 +1,184 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <asm/io.h>
+#include <command.h>
+#include <common.h>
+#include <config.h>
+#include <linux/ctype.h>
+#include <mach/soc.h>
+#include <stddef.h>
+#include <stdlib.h>
+
+/* GMAC_MIB Counters register definitions */
+#define MV_MIB_GOOD_OCTETS_RECEIVED_LOW		0x0
+#define MV_MIB_GOOD_OCTETS_RECEIVED_HIGH	0x4
+#define MV_MIB_BAD_OCTETS_RECEIVED		0x8
+#define MV_MIB_CRC_ERRORS_SENT			0xc
+#define MV_MIB_UNICAST_FRAMES_RECEIVED		0x10
+/* Reserved					0x14 */
+#define MV_MIB_BROADCAST_FRAMES_RECEIVED	0x18
+#define MV_MIB_MULTICAST_FRAMES_RECEIVED	0x1c
+#define MV_MIB_FRAMES_64_OCTETS			0x20
+#define MV_MIB_FRAMES_65_TO_127_OCTETS		0x24
+#define MV_MIB_FRAMES_128_TO_255_OCTETS		0x28
+#define MV_MIB_FRAMES_256_TO_511_OCTETS		0x2c
+#define MV_MIB_FRAMES_512_TO_1023_OCTETS	0x30
+#define MV_MIB_FRAMES_1024_TO_MAX_OCTETS	0x34
+#define MV_MIB_GOOD_OCTETS_SENT_LOW		0x38
+#define MV_MIB_GOOD_OCTETS_SENT_HIGH		0x3c
+#define MV_MIB_UNICAST_FRAMES_SENT		0x40
+/* Reserved					0x44 */
+#define MV_MIB_MULTICAST_FRAMES_SENT		0x48
+#define MV_MIB_BROADCAST_FRAMES_SENT		0x4c
+/* Reserved					0x50 */
+#define MV_MIB_FC_SENT				0x54
+#define MV_MIB_FC_RECEIVED			0x58
+#define MV_MIB_RX_FIFO_OVERRUN			0x5c
+#define MV_MIB_UNDERSIZE_RECEIVED		0x60
+#define MV_MIB_FRAGMENTS_RECEIVED		0x64
+#define MV_MIB_OVERSIZE_RECEIVED		0x68
+#define MV_MIB_JABBER_RECEIVED			0x6c
+#define MV_MIB_MAC_RECEIVE_ERROR		0x70
+#define MV_MIB_BAD_CRC_EVENT			0x74
+#define MV_MIB_COLLISION			0x78
+#define MV_MIB_LATE_COLLISION			0x7c
+
+#define COUNTERS_BASE		0x129000
+#define GOP_OFFSET		(((gop) + ((gop) != 0)) * 0x100)
+#define COUNTERS_ADDRESS(cp, gop_p) \
+	(COUNTERS_BASE + MVEBU_REGS_BASE_CP(0, (cp)) + GOP_OFFSET)
+#define PORT_NUM_STR		(sizeof("mvpp2-") - 1)
+#define IS_MVPP2		((memcmp(name, "mvpp2-", PORT_NUM_STR) == 0) &&\
+	(isdigit(name[PORT_NUM_STR])))
+
+u64 mv_gop110_mib_read64(u64 counters_address, unsigned int offset)
+{
+	u64 val, val2;
+
+	val = readl(counters_address + offset);
+	if (offset == MV_MIB_GOOD_OCTETS_RECEIVED_LOW ||
+	    offset == MV_MIB_GOOD_OCTETS_SENT_LOW) {
+		val2 = readl(counters_address + offset + 4);
+		val += (val2 << 32);
+	}
+
+	return val;
+}
+
+static void mv_gop110_mib_print(u64 counters_address, u32 offset,
+				char *mib_name)
+{
+	u64 val;
+
+	val = mv_gop110_mib_read64(counters_address, offset);
+	printf("  %-32s: 0x%02x = %lld\n", mib_name, offset, val);
+}
+
+void mv_print_counter_regs(char *port_name, u64 addr)
+{
+	printf("%s MiB Counters:\n", port_name);
+	printf("\n[Rx]\n");
+	mv_gop110_mib_print(addr, MV_MIB_GOOD_OCTETS_RECEIVED_LOW,
+			    "GOOD_OCTETS_RECEIVED");
+	mv_gop110_mib_print(addr, MV_MIB_BAD_OCTETS_RECEIVED,
+			    "BAD_OCTETS_RECEIVED");
+
+	mv_gop110_mib_print(addr, MV_MIB_UNICAST_FRAMES_RECEIVED,
+			    "UNCAST_FRAMES_RECEIVED");
+	mv_gop110_mib_print(addr, MV_MIB_BROADCAST_FRAMES_RECEIVED,
+			    "BROADCAST_FRAMES_RECEIVED");
+	mv_gop110_mib_print(addr, MV_MIB_MULTICAST_FRAMES_RECEIVED,
+			    "MULTICAST_FRAMES_RECEIVED");
+
+	printf("\n[RMON]\n");
+	mv_gop110_mib_print(addr, MV_MIB_FRAMES_64_OCTETS,
+			    "FRAMES_64_OCTETS");
+	mv_gop110_mib_print(addr, MV_MIB_FRAMES_65_TO_127_OCTETS,
+			    "FRAMES_65_TO_127_OCTETS");
+	mv_gop110_mib_print(addr, MV_MIB_FRAMES_128_TO_255_OCTETS,
+			    "FRAMES_128_TO_255_OCTETS");
+	mv_gop110_mib_print(addr, MV_MIB_FRAMES_256_TO_511_OCTETS,
+			    "FRAMES_256_TO_511_OCTETS");
+	mv_gop110_mib_print(addr, MV_MIB_FRAMES_512_TO_1023_OCTETS,
+			    "FRAMES_512_TO_1023_OCTETS");
+	mv_gop110_mib_print(addr, MV_MIB_FRAMES_1024_TO_MAX_OCTETS,
+			    "FRAMES_1024_TO_MAX_OCTETS");
+
+	printf("\n[Tx]\n");
+	mv_gop110_mib_print(addr, MV_MIB_GOOD_OCTETS_SENT_LOW,
+			    "GOOD_OCTETS_SENT");
+	mv_gop110_mib_print(addr, MV_MIB_UNICAST_FRAMES_SENT,
+			    "UNICAST_FRAMES_SENT");
+	mv_gop110_mib_print(addr, MV_MIB_MULTICAST_FRAMES_SENT,
+			    "MULTICAST_FRAMES_SENT");
+	mv_gop110_mib_print(addr, MV_MIB_BROADCAST_FRAMES_SENT,
+			    "BROADCAST_FRAMES_SENT");
+	mv_gop110_mib_print(addr, MV_MIB_CRC_ERRORS_SENT,
+			    "CRC_ERRORS_SENT");
+
+	printf("\n[FC control]\n");
+	mv_gop110_mib_print(addr, MV_MIB_FC_RECEIVED,
+			    "FC_RECEIVED");
+	mv_gop110_mib_print(addr, MV_MIB_FC_SENT,
+			    "FC_SENT");
+
+	printf("\n[Errors]\n");
+	mv_gop110_mib_print(addr, MV_MIB_RX_FIFO_OVERRUN,
+			    "RX_FIFO_OVERRUN");
+	mv_gop110_mib_print(addr, MV_MIB_UNDERSIZE_RECEIVED,
+			    "UNDERSIZE_RECEIVED");
+	mv_gop110_mib_print(addr, MV_MIB_FRAGMENTS_RECEIVED,
+			    "FRAGMENTS_RECEIVED");
+	mv_gop110_mib_print(addr, MV_MIB_OVERSIZE_RECEIVED,
+			    "OVERSIZE_RECEIVED");
+	mv_gop110_mib_print(addr, MV_MIB_JABBER_RECEIVED,
+			    "JABBER_RECEIVED");
+	mv_gop110_mib_print(addr, MV_MIB_MAC_RECEIVE_ERROR,
+			    "MAC_RECEIVE_ERROR");
+	mv_gop110_mib_print(addr, MV_MIB_BAD_CRC_EVENT,
+			    "BAD_CRC_EVENT");
+	mv_gop110_mib_print(addr, MV_MIB_COLLISION,
+			    "COLLISION");
+	/* This counter must be read last. Read it clear all the counters */
+	mv_gop110_mib_print(addr, MV_MIB_LATE_COLLISION,
+			    "LATE_COLLISION");
+}
+
+int mv_do_get_counters_cmd(cmd_tbl_t *cmdtp, int flag,
+			   int argc, char *const argv[])
+{
+	char *name = NULL;
+
+	if (argc == 2)
+		name = argv[1];
+	else
+		name = env_get("ethact");
+	if (name && IS_MVPP2) {
+		u32 num = simple_strtoul(&name[PORT_NUM_STR],
+					 NULL, 0);
+		u32 cp_max;
+		u32 ap_max;
+		u32 cp = num / 3;
+		u32 gop = num % 3;
+
+		soc_get_ap_cp_num(&ap_max, &cp_max);
+		if (cp_max <= cp) {
+			pr_err("Error: Port: %s does not exist\n", name);
+			return 0;
+		}
+		mv_print_counter_regs(name, COUNTERS_ADDRESS(cp, gop));
+	} else {
+		pr_err("Error: Bad port name: %s\n", name);
+	}
+	return 0;
+}
+
+U_BOOT_CMD(
+	mv_get_counters, 2, 1, mv_do_get_counters_cmd,
+	"Get gop counters",
+	"mv_get_counters <port_name:default=ethact>\n");
diff --git a/cmd/mvebu/pxa3xx_nand_oem.c b/cmd/mvebu/pxa3xx_nand_oem.c
new file mode 100644
index 0000000..61762d4
--- /dev/null
+++ b/cmd/mvebu/pxa3xx_nand_oem.c
@@ -0,0 +1,587 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <linux/mtd/mtd.h>
+#include <command.h>
+#include <nand.h>
+#include <pxa3xx_nand.h>
+
+#define NDCR_SPARE_EN		(0x1 << 31)
+
+static char nand_oem_help_text[] =
+	"use \"nand_oem prepare m-offs m-size p-offs p-size\" to prepare oem image\n"
+	"use \"nand_oem restore m-offs m-size\" to restore original data\n"
+	"\tm-offs - meta-data partition offset in bytes\n"
+	"\tm-size - meta-data partition size in bytes\n"
+	"\tp-offs - device data partition offset in bytes\n"
+	"\tp-size - device data partition size in bytes\n"
+	"";
+
+	/*
+	 * Consider to add optional parameter to get a type of non-empty/-blank
+	 * block to skip such a block during "prepare" stage.
+	 */
+
+#define AUX_TBL_MAGIC_LEN	8
+struct aux_tbl_header {
+	char magic[AUX_TBL_MAGIC_LEN];
+	loff_t off;
+	loff_t sz;
+	size_t blk_cnt;
+};
+
+enum blank_block_type {
+	NAND_EMPTY_BLOCK,
+	NAND_UBI_BLANK_BLOCK
+};
+
+static int is_block_blank(const uchar *nand_blk, const uchar *blank_blk,
+			  size_t blk_sz, enum blank_block_type type)
+{
+	int rval = 0;
+
+	switch (type) {
+	case NAND_EMPTY_BLOCK:
+		if (!memcmp(nand_blk, blank_blk, blk_sz))
+			rval = 1;
+		break;
+	case NAND_UBI_BLANK_BLOCK:
+		/* add ubi blank block skipping logic here */
+		break;
+	default:
+		printf("found unsupported blank block type\n");
+	}
+
+	return rval;
+}
+
+static int nand_prepare(struct mtd_info *nand, char * const argv[],
+			loff_t meta_off, loff_t meta_sz, size_t bb_pos,
+			loff_t bb_pg_off)
+{
+	struct aux_tbl_header *aux_tbl_hdr_rd, aux_tbl_hdr = {
+		.magic = {'l', 'l', 'e', 'v', 'r', 'a', 'm', '@'},
+		.off = 0,
+		.sz = 0,
+		.blk_cnt = 0
+	};
+	size_t rw_sz;
+	size_t pg_sz = nand->writesize;
+	size_t blk_sz = nand->erasesize;
+	size_t aux_tbl_idx = 0;
+	size_t aux_tbl_delta = 0;
+	size_t aux_tbl_pg = 0;
+	loff_t off, part_off = 0;
+	loff_t part_sz = 0;
+	loff_t aux_tbl_off = -1;
+	u_char *aux_tbl, *rw_blk, *r_pg, *e_blk;
+	nand_erase_options_t opts;
+	int ret = 1;
+
+	/* allocate memory for an empty block */
+	e_blk = memalign(ARCH_DMA_MINALIGN, blk_sz);
+	/* initialize the empty block */
+	memset(e_blk, 0xff, blk_sz);
+	/* allocate memory for page handling */
+	r_pg = memalign(ARCH_DMA_MINALIGN, pg_sz);
+	/* allocate memory for block handling */
+	rw_blk = memalign(ARCH_DMA_MINALIGN, blk_sz);
+	/* allocate memory for oem image meta-data handling */
+	aux_tbl = memalign(ARCH_DMA_MINALIGN, blk_sz);
+	/* initialize the meta-data */
+	memset(aux_tbl, 0xff, blk_sz);
+
+	/* device data partition size in bytes */
+	part_sz = simple_strtoul(argv[5], NULL, 0);
+	if (part_sz >= nand->size || part_sz < blk_sz) {
+		printf("%s: incorrect device data partition size: 0x%llx\n",
+		       __func__, part_sz);
+		goto oem_prepare_fail;
+	}
+	aux_tbl_hdr.sz = part_sz;
+
+	/* device data partition offset in bytes */
+	part_off = simple_strtoul(argv[4], NULL, 0);
+	if (part_off + part_sz >= nand->size) {
+		printf("%s: partition exceeding nand size: 0x%llx\n", __func__,
+		       part_off + part_sz);
+		goto oem_prepare_fail;
+	}
+	if ((u64)part_off % blk_sz) {
+		printf("%s: partition offset should be block-aligned\n",
+		       __func__);
+		goto oem_prepare_fail;
+	}
+	aux_tbl_hdr.off = part_off;
+
+	printf("device data partition offset = %llu bytes\n", part_off);
+	printf("device data partition size = %llu bytes\n", part_sz);
+	printf("device data partition blocks number = %llu blocks\n",
+	       ((u64)part_sz - 1) / blk_sz + 1);
+
+	/*
+	 * Consider to add optional parameter to get a type of non-empty/-blank
+	 * block to skip such a block during "prepare" stage.
+	 */
+
+	/* pass through meta-data partition in nand */
+	for (off = meta_off; off < meta_off + meta_sz; off += blk_sz) {
+		/* skip bad blocks */
+		if (nand_block_isbad(nand, off))
+			continue;
+
+		/* read the first page */
+		rw_sz = pg_sz;
+		if (nand_read_skip_bad(nand, off, &rw_sz, NULL, pg_sz, r_pg)) {
+			printf("failed to read page at offset 0x%llx\n", off);
+			goto oem_prepare_fail;
+		}
+
+		/* cast the meta-data header */
+		aux_tbl_hdr_rd = (struct aux_tbl_header *)r_pg;
+
+		/* look for the meta-data signature */
+		if (!strncmp(aux_tbl_hdr_rd->magic, aux_tbl_hdr.magic,
+			     sizeof(aux_tbl_hdr.magic))) {
+			/* found allocated meta-data block */
+			/* check for overlapping partitions */
+			if ((part_off < aux_tbl_hdr_rd->off &&
+			     part_off + part_sz <= aux_tbl_hdr_rd->off) ||
+			    (part_off >= aux_tbl_hdr_rd->off +
+					 aux_tbl_hdr_rd->sz &&
+			     part_off + part_sz > aux_tbl_hdr_rd->off +
+						  aux_tbl_hdr_rd->sz)) {
+				/* no overlapping; continue looking for free
+				 * meta-data block
+				 */
+				continue;
+			} else { /* overlapping */
+				printf("%s: partition overlaps at off 0x%llx\n",
+				       __func__, part_off);
+				goto oem_prepare_fail;
+			}
+		} else { /* found free meta-data block */
+			aux_tbl_off = off;
+			break;
+		} /* free or allocated block? */
+	}  /* partition's passthrough */
+
+	if (aux_tbl_off == -1) {
+		printf("free meta-data block wasn't found\n");
+		goto oem_prepare_fail;
+	}
+
+	/* pass through device data partition in nand */
+	for (off = part_off; off < part_off + part_sz; off += blk_sz) {
+		/* skip bad blocks */
+		if (nand_block_isbad(nand, off))
+			continue;
+
+		/* found a good block; read it */
+		rw_sz = blk_sz;
+		if (nand_read_skip_bad(nand, off, &rw_sz, NULL, blk_sz,
+				       rw_blk)) {
+			printf("failed to read block at offset 0x%llx\n", off);
+			goto oem_prepare_fail;
+		}
+
+		/* skip empty block */
+		if (is_block_blank(rw_blk, e_blk, blk_sz, NAND_EMPTY_BLOCK))
+			continue;
+
+		/* skip ubi blank block */
+		if (is_block_blank(rw_blk, e_blk, blk_sz, NAND_UBI_BLANK_BLOCK))
+			continue;
+
+		/* check two bytes at bbm locations in the bbm page */
+		if (rw_blk[bb_pg_off + bb_pos] != 0xff ||
+		    rw_blk[bb_pg_off + bb_pos + 1] != 0xff) {
+			/* found the bbm to mask in a good block */
+			printf("found falsy bad block marks (0x%x), (0x%x) ",
+			       rw_blk[bb_pg_off + bb_pos],
+			       rw_blk[bb_pg_off + bb_pos + 1]);
+			printf("in block[%llu]\n", ((u64)off / blk_sz));
+
+			/* Save the two bbm bytes in the buffer with the
+			 * meta-data
+			 */
+			aux_tbl_idx = aux_tbl_hdr.blk_cnt  * 2 +
+				      sizeof(aux_tbl_hdr);
+			aux_tbl_pg = (aux_tbl_idx + aux_tbl_delta) / pg_sz;
+			/* calculate delta to skip bbm location in meta-data */
+			if (aux_tbl_idx && !((aux_tbl_idx + aux_tbl_delta) %
+					     (aux_tbl_pg * pg_sz + bb_pos)))
+				aux_tbl_delta += 2;
+			aux_tbl[aux_tbl_idx + aux_tbl_delta] =
+						     rw_blk[bb_pg_off + bb_pos];
+			aux_tbl[aux_tbl_idx + aux_tbl_delta + 1] =
+						 rw_blk[bb_pg_off + bb_pos + 1];
+
+			/* mask the data indicating the bad block mark */
+			rw_blk[bb_pg_off + bb_pos] = 0xff;
+			rw_blk[bb_pg_off + bb_pos + 1] = 0xff;
+
+			/* erase the block to write its modified version */
+			memset(&opts, 0, sizeof(opts));
+			opts.offset = off;
+			opts.length = blk_sz;
+			opts.quiet  = 1;
+			if (nand_erase_opts(nand, &opts)) {
+				printf("failed to erase block at off 0x%llx\n",
+				       off);
+				goto oem_prepare_fail;
+			}
+
+			/* write the modified block to nand */
+			rw_sz = blk_sz;
+			if (nand_write_skip_bad(nand, off, &rw_sz, NULL,
+						blk_sz, rw_blk, 0)) {
+				printf("failed to write block to off 0x%llx\n",
+				       off);
+				goto oem_prepare_fail;
+			}
+		} /* falsy bb mark? */
+
+		/*
+		 * update the meta-data header for the found good
+		 * non-empty/-blank block
+		 */
+		aux_tbl_hdr.blk_cnt++;
+	} /* partition's passthrough */
+
+	/* erase the block to write the meta-data */
+	memset(&opts, 0, sizeof(opts));
+	opts.offset = aux_tbl_off;
+	opts.length = blk_sz;
+	opts.quiet  = 1;
+	if (nand_erase_opts(nand, &opts)) {
+		printf("failed to erase block at offset 0x%llx\n", aux_tbl_off);
+		goto oem_prepare_fail;
+	}
+
+	/* copy the meta-data signature to the buffer */
+	memcpy(aux_tbl, &aux_tbl_hdr, sizeof(aux_tbl_hdr));
+
+	/* write the buffer with the meta-data to nand */
+	rw_sz = blk_sz;
+	if (nand_write_skip_bad(nand, aux_tbl_off, &rw_sz, NULL, blk_sz,
+				aux_tbl, 0)) {
+		printf("failed to write block to offset 0x%llx\n", aux_tbl_off);
+		goto oem_prepare_fail;
+	}
+
+	ret = 0;
+
+oem_prepare_fail:
+	free(e_blk);
+	free(aux_tbl);
+	free(r_pg);
+	free(rw_blk);
+
+	if (ret == 0)
+		printf("\"nand oem\" command completed successfully\n");
+	else
+		printf("\"nand oem\" command failed\n");
+
+	return ret;
+}
+
+static int nand_restore(struct mtd_info *nand, char * const argv[],
+			loff_t meta_off, loff_t meta_sz, size_t bb_pos,
+			loff_t bb_pg_off)
+{
+	struct aux_tbl_header *aux_tbl_hdr_rd, aux_tbl_hdr = {
+		.magic = {'l', 'l', 'e', 'v', 'r', 'a', 'm', '@'},
+		.off = 0,
+		.sz = 0,
+		.blk_cnt = 0
+	};
+	size_t rw_sz;
+	size_t pg_sz = nand->writesize;
+	size_t blk_sz = nand->erasesize;
+	size_t gd_blk_cnt = 0;
+	size_t aux_tbl_idx = 0;
+	size_t aux_tbl_delta = 0;
+	size_t aux_tbl_pg = 0;
+	loff_t off, aux_tbl_off = -1;
+	u_char *aux_tbl, *rw_blk, *r_pg;
+	nand_erase_options_t opts;
+	int ret = 1;
+
+	/* allocate memory for page handling */
+	r_pg = memalign(ARCH_DMA_MINALIGN, pg_sz);
+	/* allocate memory for block handling */
+	rw_blk = memalign(ARCH_DMA_MINALIGN, blk_sz);
+	/* allocate memory for oem image meta-data handling */
+	aux_tbl = memalign(ARCH_DMA_MINALIGN, blk_sz);
+	/* initialize the meta-data */
+	memset(aux_tbl, 0xff, blk_sz);
+
+	/* pass through meta-data partition in nand */
+	for (off = meta_off; off < meta_off + meta_sz; off += blk_sz) {
+		/* skip bad blocks */
+		if (nand_block_isbad(nand, off))
+			continue;
+		/* read the first page */
+		rw_sz = pg_sz;
+		if (nand_read_skip_bad(nand, off, &rw_sz, NULL, pg_sz, r_pg)) {
+			printf("failed to read page at offset 0x%llx\n", off);
+			goto oem_restore_fail;
+		}
+
+		/* cast the meta-data header */
+		aux_tbl_hdr_rd = (struct aux_tbl_header *)r_pg;
+
+		/* look for the meta-data signature */
+		if (!strncmp(aux_tbl_hdr_rd->magic, aux_tbl_hdr.magic,
+			     sizeof(aux_tbl_hdr.magic))) {
+			aux_tbl_off = off;
+			break;
+		}
+		/* continue looking for allocated meta-data block */
+	}  /* partition's passthrough */
+
+	if (aux_tbl_off == -1) {
+		printf("allocated meta-data block wasn't found\n");
+		goto oem_restore_fail;
+	}
+
+	/* the meta-data block is found; read it */
+	rw_sz = blk_sz;
+	if (nand_read_skip_bad(nand, aux_tbl_off, &rw_sz, NULL, blk_sz,
+			       rw_blk)) {
+		printf("failed to read block at offset 0x%llx\n", off);
+		goto oem_restore_fail;
+	}
+
+	/* copy the meta-data to the buffer */
+	memcpy(aux_tbl, rw_blk, blk_sz);
+
+	/* cast the meta-data header */
+	aux_tbl_hdr_rd = (struct aux_tbl_header *)aux_tbl;
+
+	/* pass through device data partition in nand */
+	for (off = aux_tbl_hdr_rd->off;
+	     off < aux_tbl_hdr_rd->off + aux_tbl_hdr_rd->sz; off += blk_sz) {
+		/* skip bad blocks */
+		if (nand_block_isbad(nand, off))
+			continue;
+
+		/* check if restore is completed */
+		if (gd_blk_cnt >= aux_tbl_hdr_rd->blk_cnt) {
+			printf("scanned %zu partition blocks",
+			       aux_tbl_hdr_rd->blk_cnt);
+			break;
+		}
+		/* a good block is found; check if to restore */
+		aux_tbl_idx = gd_blk_cnt * 2 + sizeof(struct aux_tbl_header);
+		aux_tbl_pg = (aux_tbl_idx + aux_tbl_delta) / pg_sz;
+		/* calculate delta to skip bbm location in meta-data */
+		if (aux_tbl_idx && !((aux_tbl_idx + aux_tbl_delta) %
+				     (aux_tbl_pg * pg_sz + bb_pos)))
+			aux_tbl_delta += 2;
+		if (aux_tbl[aux_tbl_idx + aux_tbl_delta] != 0xff ||
+		    aux_tbl[aux_tbl_idx + aux_tbl_delta + 1] != 0xff) {
+			/* read the entire block to be restored */
+			rw_sz = blk_sz;
+			if (nand_read_skip_bad(nand, off, &rw_sz, NULL, blk_sz,
+					       rw_blk)) {
+				printf("failed to read block at off 0x%llx\n",
+				       off);
+				goto oem_restore_fail;
+			}
+
+			/* simple check prior to restore */
+			if (rw_blk[bb_pg_off + bb_pos] != 0xff ||
+			    rw_blk[bb_pg_off + bb_pos + 1] != 0xff) {
+				printf("bb marks: expected 0xff, 0xff, ");
+				printf("got 0x%x, 0x%x at offset 0x%llx\n",
+				       rw_blk[bb_pg_off + bb_pos],
+				       rw_blk[bb_pg_off + bb_pos + 1],
+				       off + bb_pg_off + bb_pos);
+				goto oem_restore_fail;
+			}
+
+			/* restore the original data at the bbm position */
+			rw_blk[bb_pg_off + bb_pos] =
+					   aux_tbl[aux_tbl_idx + aux_tbl_delta];
+			rw_blk[bb_pg_off + bb_pos + 1] =
+				       aux_tbl[aux_tbl_idx + 1 + aux_tbl_delta];
+
+			printf("restored data %x at pos %llu in block[%llu]\n",
+			       rw_blk[bb_pg_off + bb_pos],
+			       bb_pg_off + bb_pos,
+			       ((u64)off / blk_sz));
+			printf("restored data %x at pos %llu in block[%llu]\n",
+			       rw_blk[bb_pg_off + bb_pos + 1],
+			       bb_pg_off + bb_pos + 1,
+			       ((u64)off / blk_sz));
+
+			/* erase the block to write its original version */
+			memset(&opts, 0, sizeof(opts));
+			opts.offset = off;
+			opts.length = blk_sz;
+			opts.quiet  = 1;
+			if (nand_erase_opts(nand, &opts)) {
+				printf("failed to erase block at off 0x%llx\n",
+				       off);
+				goto oem_restore_fail;
+			}
+
+			/* write the restored block to nand */
+			rw_sz = blk_sz;
+			if (nand_write_skip_bad(nand, off, &rw_sz, NULL, blk_sz,
+						rw_blk, 0)) {
+				printf("failed to write block to off 0x%llx\n",
+				       off);
+				goto oem_restore_fail;
+			}
+		} /* to restore? */
+		gd_blk_cnt++;
+	} /* partition's passthrough */
+
+	/* erase the block with the meta-data */
+	memset(&opts, 0, sizeof(opts));
+	opts.offset = aux_tbl_off;
+	opts.length = blk_sz;
+	opts.quiet  = 1;
+	if (nand_erase_opts(nand, &opts)) {
+		printf("failed to erase block at offset 0x%llx\n", aux_tbl_off);
+		goto oem_restore_fail;
+	}
+
+	ret = 0;
+
+oem_restore_fail:
+	free(aux_tbl);
+	free(r_pg);
+	free(rw_blk);
+
+	if (ret == 0)
+		printf("\"nand oem\" command completed successfully\n");
+	else
+		printf("\"nand oem\" command failed\n");
+
+	return ret;
+}
+
+static int do_nand_oem(cmd_tbl_t *cmdtp, int flag, int argc,
+		       char * const argv[])
+{
+	int dev = nand_curr_device;
+	struct mtd_info *nand = get_nand_dev_by_index(dev);
+	char *cmd = argv[1];
+	struct nand_chip *chip = mtd_to_nand(nand);
+	struct pxa3xx_nand_host *host = nand_get_controller_data(chip);
+	struct pxa3xx_nand_info *info = host->info_data;
+	size_t pg_sz = nand->writesize;
+	size_t blk_sz = nand->erasesize;
+	size_t bb_pos;
+	loff_t bb_pg_off, meta_off, meta_sz;
+	unsigned int spare_size = 0;
+
+	/*
+	 * Since the pxa nfc uses different page layout (logical layout) than
+	 * chip has (physical layout), the bad block marker logical offset is
+	 * different than physical one and need to be calculated. It is
+	 * different when spare area (NDCR_SPARE_EN) is enabled.
+	 */
+	if (info->reg_ndcr & (NDCR_SPARE_EN))
+		spare_size = info->spare_size;
+
+	bb_pos = pg_sz - ((pg_sz / info->chunk_size - 1) * (30 + spare_size));
+
+	/*
+	 * Bad block marking page can be placed on first, second or last
+	 * page, depending on the manufacturer. Calculate the offset
+	 * based on proper flag set by generic nand_decode_bbm_options.
+	 *
+	 * It seems that for some nand chip id. u-boot may have
+	 * incorrect information since different patterns are used by
+	 * one vendor.  E.g. in Toshiba chips it can be stored in first,
+	 * second or last (0x98DE948276560420 it is "first or last"),
+	 * while currently u-boot never set NAND_BBT_SCANLASTPAGE flag
+	 * for THOSIBA maf_id. More info can be found in:
+	 * http://www.linux-mtd.infradead.org/nand-data/nanddata.html
+	 *
+	 * In case of any problems the chip->badblockpos should be
+	 * fixed. Other solution is to align with new Linux framework
+	 * which registers nand_manufacturer_ops for each manufacturer,
+	 * where bbt_options (_SCANLASTPAGE, _SCAN2NDPAGE) is determined
+	 * in per chip .init
+	 */
+	if (chip->bbt_options & NAND_BBT_SCANLASTPAGE)
+		bb_pg_off = blk_sz - pg_sz;
+	else if (chip->options & NAND_BBT_SCAN2NDPAGE)
+		bb_pg_off = 2 * pg_sz;
+	else /* first page */
+		bb_pg_off = 0;
+
+	if (!bb_pos) {
+		printf("bbm location can't be zero\n");
+		return 1;
+	}
+
+	if (!pg_sz) {
+		printf("page size can't be zero\n");
+		return 1;
+	}
+
+	if (!blk_sz) {
+		printf("block size can't be zero\n");
+		return 1;
+	}
+
+	/* meta-data partition size in bytes */
+	meta_sz = simple_strtoul(argv[3], NULL, 0);
+	if (meta_sz >= nand->size || meta_sz < blk_sz) {
+		printf("found incorrect meta-data partition size: 0x%llx\n",
+		       meta_sz);
+		return 1;
+	}
+
+	/* meta-data partition offset in bytes */
+	meta_off = simple_strtoul(argv[2], NULL, 0);
+	if (meta_off + meta_sz >= nand->size) {
+		printf("meta-data partition exceeding nand size: 0x%llx\n",
+		       meta_off + meta_sz);
+		return 1;
+	}
+	if ((u64)meta_off % blk_sz) {
+		printf("meta-data partition offset should be block-aligned\n");
+		return 0;
+	}
+
+	printf("meta-data partition offset = %llu bytes\n", meta_off);
+	printf("meta-data partition size = %llu bytes\n", meta_sz);
+	printf("meta-data partition blocks number = %llu blocks\n",
+	       ((u64)meta_sz - 1) / blk_sz + 1);
+
+	/* read suffix of "oem" command */
+	if (!strncmp(cmd, "prepare", 7)) {  /* prepare oem image */
+		if (argc < 6) {
+			printf("%s", nand_oem_help_text);
+			return 1;
+		}
+		nand_prepare(nand, argv, meta_off, meta_sz, bb_pos, bb_pg_off);
+	} else if (!strncmp(cmd, "restore", 7)) { /* restore original data */
+		if (argc < 4) {
+			printf("%s", nand_oem_help_text);
+			return 1;
+		}
+		nand_restore(nand, argv, meta_off, meta_sz, bb_pos, bb_pg_off);
+	} else { /* nand oem cmd provided with incorrect or without suffix */
+		printf("%s", nand_oem_help_text);
+		return 1;
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(nand_oem, 6, 0, do_nand_oem,
+	   "NAND oem cmd", nand_oem_help_text);
diff --git a/cmd/mvebu/rx_training.c b/cmd/mvebu/rx_training.c
new file mode 100644
index 0000000..913ad32
--- /dev/null
+++ b/cmd/mvebu/rx_training.c
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2017 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <command.h>
+#include <console.h>
+#include <dm.h>
+#include <fdtdec.h>
+#include <dm/device-internal.h>
+#include <mvebu/comphy.h>
+
+int rx_training_cmd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	struct udevice *dev;
+	struct uclass *uc;
+	int ret, cp_index, comphy_index, i = 0;
+
+	if (argc != 3) {
+		printf("missing arguments\n");
+		return -1;
+	}
+
+	cp_index = simple_strtoul(argv[1], NULL, 16);
+	comphy_index = simple_strtoul(argv[2], NULL, 16);
+
+	ret = uclass_get(UCLASS_MISC, &uc);
+	if (ret) {
+		printf("Couldn't find UCLASS_MISC\n");
+		return ret;
+	}
+
+	uclass_foreach_dev(dev, uc) {
+		if (!(memcmp(dev->name, "comphy", 5))) {
+			if (i == cp_index) {
+				comphy_rx_training(dev, comphy_index);
+				return 0;
+			}
+
+			i++;
+		}
+	}
+
+	printf("Coudn't find comphy %d\n", cp_index);
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	rx_training, 3, 0, rx_training_cmd,
+	"rx_training <cp id> <comphy id>\n",
+	"\n\tRun RX training sequence, the user must state CP index (0/1) and comphy ID (0/5)"
+);
+
diff --git a/cmd/mvebu/sar.c b/cmd/mvebu/sar.c
new file mode 100644
index 0000000..d7707fc
--- /dev/null
+++ b/cmd/mvebu/sar.c
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:       GPL-2.0+
+ * https://spdx.org/licenses
+ */
+
+#include <config.h>
+#include <common.h>
+#include <command.h>
+#include <vsprintf.h>
+#include <errno.h>
+#include <i2c.h>
+#include <mvebu/sar.h>
+
+static int sar_initialized;
+
+int do_sar_cmd(cmd_tbl_t *cmdtp, int flag, int argc,
+	       char * const argv[])
+{
+	const char *cmd = argv[1];
+	const char *key = NULL;
+	int value = 0;
+
+	/* initialize sar driver variables from the device tree */
+	if (!sar_initialized) {
+		sar_init();
+		sar_initialized = 1;
+	}
+
+	if (sar_is_available() == 0) {
+		printf("Error: SAR variables not available for this board\n");
+		return 1;
+	}
+
+	if ((strcmp(cmd, "read") == 0) && (argc < 2)) {
+		printf("Error: Please specify SAR key\n");
+		return 1;
+	}
+
+	if ((strcmp(cmd, "write") == 0) && (argc < 4)) {
+		printf("Error: Please specify SAR key and value\n");
+		return 1;
+	}
+
+	if (argc > 2)
+		key = argv[2];
+	if (argc > 3)
+		value = (int)simple_strtoul(argv[3], NULL, 16);
+
+	if (strcmp(cmd, "list") == 0) {
+		if (argc < 3) {
+			sar_list_keys();
+		} else {
+			if (sar_list_key_opts(key))
+				return -EINVAL;
+		}
+	} else if (strcmp(cmd, "default") == 0) {
+		if (argc < 3) {
+			sar_default_all();
+		} else {
+			if (sar_default_key(key))
+				return -EINVAL;
+		}
+	} else if (strcmp(cmd, "read") == 0) {
+		if (!key)
+			sar_read_all();
+		else
+			if (sar_print_key(key))
+				return -EINVAL;
+	} else if (strcmp(cmd, "write") == 0) {
+		if (sar_write_key(key, value))
+			return -EINVAL;
+	} else {
+		printf("ERROR: unknown command to sar: \"%s\"\n", cmd);
+		return CMD_RET_USAGE;
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	sar,      6,     1,      do_sar_cmd,
+	"sar - Modify SOC's sample at reset (SAR) values",
+	"\n"
+	"Modify SOC's sample at reset values\n"
+	"\tlist		- Display all available SAR variables\n"
+	"\tlist <x>	- Display options for SAR variable x\n"
+	"\tdefault	- Set all SAR variable to default value\n"
+	"\tdefault <x>	- Set SAR variable x default value\n"
+	"\twrite x y	- Write y to SAR variable x\n"
+	"\tread		- Read all SAR variables\n"
+	"\tread <x>	- Read SAR variable x\n"
+);
+
+U_BOOT_CMD(
+	SatR,      6,     1,      do_sar_cmd,
+	"SatR - Modify SOC's sample at reset (SAR) values",
+	"\n"
+	"Modify SOC's sample at reset values\n"
+	"\tlist		- Display all available SAR variables\n"
+	"\tlist <x>	- Display options for SAR variable x\n"
+	"\tdefault	- Set all SAR variable to default value\n"
+	"\tdefault <x>	- Set SAR variable x default value\n"
+	"\twrite x y	- Write y to SAR variable x\n"
+	"\tread		- Read all SAR variables\n"
+	"\tread <x>	- Read SAR variable x\n"
+);
diff --git a/cmd/mvebu/thermal.c b/cmd/mvebu/thermal.c
new file mode 100644
index 0000000..f2d38da
--- /dev/null
+++ b/cmd/mvebu/thermal.c
@@ -0,0 +1,47 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include <common.h>
+#include <command.h>
+#include <console.h>
+#include <dm.h>
+#include <asm/arch-mvebu/thermal.h>
+#include <fdtdec.h>
+#include <thermal.h>
+#include <dm/device-internal.h>
+
+int thermal_sensor_cmd(cmd_tbl_t *cmdtp, int flag, int argc,
+		       char * const argv[])
+{
+	struct udevice *dev;
+	struct uclass *uc;
+	int ret, temperature;
+
+	ret = uclass_get(UCLASS_THERMAL, &uc);
+
+	if (ret)
+		return ret;
+
+	uclass_foreach_dev(dev, uc) {
+		struct thermal_unit_config *thermal_cfg;
+
+		ret = device_probe(dev);
+		if (ret)
+			continue;
+
+		thermal_cfg = dev_get_priv(dev);
+		thermal_get_temp(dev, &temperature);
+		printf("Thermal.%8p = %d\n", thermal_cfg->regs_base,
+		       temperature);
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	tsen, 1, 1, thermal_sensor_cmd,
+	"tsen - Display the SoC temperature.\n",
+	"\n\tDisplay the SoC temperature as read from the on chip thermal sensor.\n"
+);
diff --git a/cmd/nvedit.c b/cmd/nvedit.c
index 4cb25b8..8c82b4d 100644
--- a/cmd/nvedit.c
+++ b/cmd/nvedit.c
@@ -296,6 +296,20 @@ int env_set(const char *varname, const char *varvalue)
 		return _do_env_set(0, 3, (char * const *)argv, H_PROGRAMMATIC);
 }
 
+int env_set_force(const char *varname, const char *varvalue)
+{
+	const char * const argv[5] = { "setenv", "-f", varname, varvalue, NULL };
+
+	/* before import into hashtable */
+	if (!(gd->flags & GD_FLG_ENV_READY))
+		return 1;
+
+	if (varvalue == NULL || varvalue[0] == '\0')
+		return _do_env_set(0, 3, (char * const *)argv, H_FORCE);
+	else
+		return _do_env_set(0, 4, (char * const *)argv, H_FORCE);
+}
+
 /**
  * Set an environment variable to an integer value
  *
diff --git a/cmd/nvme.c b/cmd/nvme.c
index 63a8e5a..b797f51 100644
--- a/cmd/nvme.c
+++ b/cmd/nvme.c
@@ -21,7 +21,6 @@ static int do_nvme(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 			ret = nvme_scan_namespace();
 			if (ret)
 				return CMD_RET_FAILURE;
-
 			return ret;
 		}
 		if (strncmp(argv[1], "deta", 4) == 0) {
diff --git a/cmd/scsi.c b/cmd/scsi.c
index b9d086f..acb1e2e 100644
--- a/cmd/scsi.c
+++ b/cmd/scsi.c
@@ -65,6 +65,22 @@ U_BOOT_CMD(
 	"     `blk#' from memory address `addr'"
 );
 
+#if !defined(CONFIG_CMD_SATA) && defined(CONFIG_SCSI_AHCI)
+U_BOOT_CMD(
+	sata, 5, 1, do_scsi,
+	"SATA sub-system",
+	"reset - reset SATA controller\n"
+	"sata info  - show available SATA devices\n"
+	"sata init  - (re-)scan SATA bus\n"
+	"sata device [dev] - show or set current device\n"
+	"sata part [dev] - print partition table of one or all SATA devices\n"
+	"sata read addr blk# cnt - read `cnt' blocks starting at block `blk#'\n"
+	"     to memory address `addr'\n"
+	"sata write addr blk# cnt - write `cnt' blocks starting at block\n"
+	"     `blk#' from memory address `addr'"
+);
+#endif
+
 U_BOOT_CMD(
 	scsiboot, 3, 1, do_scsiboot,
 	"boot from SCSI device",
diff --git a/common/Kconfig b/common/Kconfig
index b92d0e3..99e3fae 100644
--- a/common/Kconfig
+++ b/common/Kconfig
@@ -595,6 +595,13 @@ config BOARD_EARLY_INIT_F
 	  Note that the normal serial console is not yet set up, but the
 	  debug UART will be available if enabled.
 
+config BOARD_EARLY_INIT_R
+	bool "Call board-specific init soon after relocation"
+	help
+	  With this option U-Boot will call board_early_init_r() soon after
+	  relocation. Driver model is running by this point, and the cache
+	  is on. This can be used to call board-specific routines.
+
 endmenu
 
 menu "Security support"
diff --git a/common/board_f.c b/common/board_f.c
index c6bc53e..db9637d 100644
--- a/common/board_f.c
+++ b/common/board_f.c
@@ -790,15 +790,15 @@ static const init_fnc_t init_sequence_f[] = {
 #if defined(CONFIG_PPC) || defined(CONFIG_SH) || defined(CONFIG_X86)
 	checkcpu,
 #endif
-#if defined(CONFIG_DISPLAY_CPUINFO)
-	print_cpuinfo,		/* display cpu info (and speed) */
-#endif
 #if defined(CONFIG_DTB_RESELECT)
 	embedded_dtb_select,
 #endif
 #if defined(CONFIG_DISPLAY_BOARDINFO)
 	show_board_info,
 #endif
+#if defined(CONFIG_DISPLAY_BOARDINFO) && defined(CONFIG_ARCH_MVEBU)
+	print_cpuinfo,		/* display cpu info (and speed) */
+#endif
 	INIT_FUNC_WATCHDOG_INIT
 #if defined(CONFIG_MISC_INIT_F)
 	misc_init_f,
diff --git a/common/board_r.c b/common/board_r.c
index 482f506..57612f1 100644
--- a/common/board_r.c
+++ b/common/board_r.c
@@ -422,7 +422,7 @@ static int initr_onenand(void)
 }
 #endif
 
-#ifdef CONFIG_MMC
+#if defined(CONFIG_MMC) || defined(CONFIG_DM_MMC)
 static int initr_mmc(void)
 {
 	puts("MMC:   ");
@@ -463,7 +463,6 @@ static int initr_env(void)
 #ifdef CONFIG_OF_CONTROL
 	env_set_addr("fdtcontroladdr", gd->fdt_blob);
 #endif
-
 	/* Initialize from environment */
 	load_addr = env_get_ulong("loadaddr", 16, load_addr);
 
@@ -584,6 +583,14 @@ static int initr_net(void)
 }
 #endif
 
+#ifdef CONFIG_MV88E6XXX_SWITCH
+static int initr_mv88e6xxx(void)
+{
+	mv88e6xxx_initialize(gd->fdt_blob);
+	return 0;
+}
+#endif
+
 #ifdef CONFIG_POST
 static int initr_post(void)
 {
@@ -767,7 +774,7 @@ static init_fnc_t init_sequence_r[] = {
 #ifdef CONFIG_CMD_ONENAND
 	initr_onenand,
 #endif
-#ifdef CONFIG_MMC
+#if defined(CONFIG_MMC) || defined(CONFIG_DM_MMC)
 	initr_mmc,
 #endif
 	initr_env,
@@ -834,6 +841,11 @@ static init_fnc_t init_sequence_r[] = {
 	INIT_FUNC_WATCHDOG_RESET
 	initr_net,
 #endif
+
+#ifdef CONFIG_MV88E6XXX_SWITCH
+	initr_mv88e6xxx,
+#endif
+
 #ifdef CONFIG_POST
 	initr_post,
 #endif
diff --git a/common/bootm.c b/common/bootm.c
index adb1213..cd67196 100644
--- a/common/bootm.c
+++ b/common/bootm.c
@@ -32,7 +32,7 @@
 
 #ifndef CONFIG_SYS_BOOTM_LEN
 /* use 8MByte as default max gunzip size */
-#define CONFIG_SYS_BOOTM_LEN	0x800000
+#define CONFIG_SYS_BOOTM_LEN	0x1000000
 #endif
 
 #define IH_INITRD_ARCH IH_ARCH_DEFAULT
diff --git a/common/ddr_spd.c b/common/ddr_spd.c
index 0aa1cbf..83e3058 100644
--- a/common/ddr_spd.c
+++ b/common/ddr_spd.c
@@ -83,6 +83,40 @@ crc16(char *ptr, int count)
 	return crc & 0xffff;
 }
 
+const char *ddr3_modtype_str(const ddr3_spd_eeprom_t *spd)
+{
+	switch(spd->module_type) {
+	case DDR3_SPD_MODULETYPE_RDIMM:
+		return "Registered DIMM";
+	case DDR3_SPD_MODULETYPE_UDIMM:
+		return "Unbuffered DIMM";
+	case DDR3_SPD_MODULETYPE_SO_DIMM:
+		return "SODIMM";
+	case DDR3_SPD_MODULETYPE_MICRO_DIMM:
+		return "Micro DIMM";
+	case DDR3_SPD_MODULETYPE_MINI_RDIMM:
+		return "Mini RDIMM";
+	case DDR3_SPD_MODULETYPE_MINI_UDIMM:
+		return "Mini UDIMM";
+	case DDR3_SPD_MODULETYPE_MINI_CDIMM:
+		return "Mini CDIMM";
+	case DDR3_SPD_MODULETYPE_72B_SO_UDIMM:
+		return "ECC Unbuffered SODIMM";
+	case DDR3_SPD_MODULETYPE_72B_SO_RDIMM:
+		return "ECC Registered SODIMM";
+	case DDR3_SPD_MODULETYPE_72B_SO_CDIMM:
+		return "ECC CDIMM";
+	case DDR3_SPD_MODULETYPE_LRDIMM:
+		return "LRDIMM";
+	case DDR3_SPD_MODULETYPE_16B_SO_DIMM:
+		return "16B SODIMM";
+	case DDR3_SPD_MODULETYPE_32B_SO_DIMM:
+		return "32B SODIMM";
+	}
+
+	return "Unknown module";
+}
+
 unsigned int
 ddr3_spd_check(const ddr3_spd_eeprom_t *spd)
 {
diff --git a/common/fdt_support.c b/common/fdt_support.c
index 66a313e..7c0a510 100644
--- a/common/fdt_support.c
+++ b/common/fdt_support.c
@@ -940,7 +940,9 @@ void fdt_del_node_and_alias(void *blob, const char *alias)
 
 /* Max address size we deal with */
 #define OF_MAX_ADDR_CELLS	4
+#ifndef OF_BAD_ADDR
 #define OF_BAD_ADDR	FDT_ADDR_T_NONE
+#endif
 #define OF_CHECK_COUNTS(na, ns)	((na) > 0 && (na) <= OF_MAX_ADDR_CELLS && \
 			(ns) > 0)
 
diff --git a/common/spl/Kconfig b/common/spl/Kconfig
index 9609fce..194415c 100644
--- a/common/spl/Kconfig
+++ b/common/spl/Kconfig
@@ -543,7 +543,17 @@ config SYS_OS_BASE
 
 endif # SPL_OS_BOOT
 
-config SPL_PCI_SUPPORT
+config SPL_PAYLOAD
+	string "SPL payload"
+	default "tpl/u-boot-with-tpl.bin" if TPL
+	default "u-boot.bin"
+	help
+	  Payload for SPL boot. For backward compability, default to
+	  u-boot.bin, i.e. RAW image without any header. In case of
+	  TPL, tpl/u-boot-with-tpl.bin. For new boards, suggest to
+	  use u-boot.img.
+
+config SPL_PCI
 	bool "Support PCI drivers"
 	help
 	  Enable support for PCI in SPL. For platforms that need PCI to boot,
diff --git a/common/usb_hub.c b/common/usb_hub.c
index b46dfa1..8ee3c4d 100644
--- a/common/usb_hub.c
+++ b/common/usb_hub.c
@@ -43,7 +43,7 @@ DECLARE_GLOBAL_DATA_PTR;
 
 #define USB_BUFSIZ	512
 
-#define HUB_SHORT_RESET_TIME	20
+#define HUB_SHORT_RESET_TIME	100
 #define HUB_LONG_RESET_TIME	200
 
 #define PORT_OVERCURRENT_MAX_SCAN_COUNT		3
@@ -210,6 +210,7 @@ static void usb_hub_power_on(struct usb_hub_device *hub)
 	debug("devnum=%d poweron: query_delay=%d connect_timeout=%d\n",
 	      dev->devnum, max(100, (int)pgood_delay),
 	      max(100, (int)pgood_delay) + 1000);
+	mdelay(pgood_delay + 2000);
 }
 
 #ifndef CONFIG_DM_USB
diff --git a/configs/chromebook_link64_defconfig b/configs/chromebook_link64_defconfig
index e84e571..5786ed0 100644
--- a/configs/chromebook_link64_defconfig
+++ b/configs/chromebook_link64_defconfig
@@ -26,7 +26,7 @@ CONFIG_SPL_CPU_SUPPORT=y
 CONFIG_SPL_ENV_SUPPORT=y
 CONFIG_SPL_I2C_SUPPORT=y
 CONFIG_SPL_NET_SUPPORT=y
-CONFIG_SPL_PCI_SUPPORT=y
+CONFIG_SPL_PCI=y
 CONFIG_SPL_PCH_SUPPORT=y
 CONFIG_SPL_RTC_SUPPORT=y
 CONFIG_HUSH_PARSER=y
diff --git a/configs/clearfog_defconfig b/configs/clearfog_defconfig
index 2359ad2..6e03b4e 100644
--- a/configs/clearfog_defconfig
+++ b/configs/clearfog_defconfig
@@ -25,7 +25,6 @@ CONFIG_CMD_SF=y
 CONFIG_CMD_SPI=y
 CONFIG_CMD_USB=y
 # CONFIG_CMD_SETEXPR is not set
-CONFIG_CMD_TFTPPUT=y
 CONFIG_CMD_CACHE=y
 CONFIG_CMD_TIME=y
 # CONFIG_SPL_PARTITION_UUIDS is not set
@@ -43,6 +42,7 @@ CONFIG_MVNETA=y
 CONFIG_PCI=y
 CONFIG_DEBUG_UART_BASE=0xd0012000
 CONFIG_DEBUG_UART_CLOCK=250000000
+CONFIG_PCI_MVEBU=y
 CONFIG_DEBUG_UART_SHIFT=2
 CONFIG_SYS_NS16550=y
 CONFIG_KIRKWOOD_SPI=y
diff --git a/configs/controlcenterdc_defconfig b/configs/controlcenterdc_defconfig
index 893dc68..80fa23d 100644
--- a/configs/controlcenterdc_defconfig
+++ b/configs/controlcenterdc_defconfig
@@ -49,6 +49,9 @@ CONFIG_SPI_FLASH=y
 CONFIG_SPI_FLASH_STMICRO=y
 CONFIG_PHY_GIGE=y
 CONFIG_MVNETA=y
+CONFIG_PCI=y
+CONFIG_DM_PCI_COMPAT=y
+CONFIG_PCI_MVEBU=y
 CONFIG_SCSI=y
 CONFIG_DEBUG_UART_BASE=0xd0012000
 CONFIG_DEBUG_UART_CLOCK=250000000
diff --git a/configs/db-88f6720_defconfig b/configs/db-88f6720_defconfig
index b3d06ae..a61ec02 100644
--- a/configs/db-88f6720_defconfig
+++ b/configs/db-88f6720_defconfig
@@ -16,13 +16,13 @@ CONFIG_SYS_CONSOLE_INFO_QUIET=y
 # CONFIG_DISPLAY_BOARDINFO is not set
 CONFIG_SPL=y
 CONFIG_SPL_I2C_SUPPORT=y
+CONFIG_SYS_PROMPT="Marvell>> "
 # CONFIG_CMD_FLASH is not set
 CONFIG_CMD_I2C=y
 CONFIG_CMD_SF=y
 CONFIG_CMD_SPI=y
 CONFIG_CMD_USB=y
 # CONFIG_CMD_SETEXPR is not set
-CONFIG_CMD_TFTPPUT=y
 CONFIG_CMD_DHCP=y
 CONFIG_CMD_MII=y
 CONFIG_CMD_PING=y
diff --git a/configs/db-88f6820-amc_defconfig b/configs/db-88f6820-amc_defconfig
index 29c9a39..d5a43c9 100644
--- a/configs/db-88f6820-amc_defconfig
+++ b/configs/db-88f6820-amc_defconfig
@@ -16,6 +16,7 @@ CONFIG_SYS_CONSOLE_INFO_QUIET=y
 # CONFIG_DISPLAY_BOARDINFO is not set
 CONFIG_SPL=y
 CONFIG_SPL_I2C_SUPPORT=y
+CONFIG_SYS_PROMPT="Marvell>> "
 # CONFIG_CMD_FLASH is not set
 CONFIG_CMD_I2C=y
 CONFIG_CMD_PCI=y
@@ -23,7 +24,6 @@ CONFIG_CMD_SF=y
 CONFIG_CMD_SPI=y
 CONFIG_CMD_USB=y
 # CONFIG_CMD_SETEXPR is not set
-CONFIG_CMD_TFTPPUT=y
 CONFIG_CMD_DHCP=y
 CONFIG_CMD_MII=y
 CONFIG_CMD_PING=y
@@ -52,6 +52,7 @@ CONFIG_MVNETA=y
 CONFIG_PCI=y
 CONFIG_DEBUG_UART_BASE=0xd0012000
 CONFIG_DEBUG_UART_CLOCK=200000000
+CONFIG_PCI_MVEBU=y
 CONFIG_DEBUG_UART_SHIFT=2
 CONFIG_SYS_NS16550=y
 CONFIG_KIRKWOOD_SPI=y
diff --git a/configs/db-88f6820-gp_defconfig b/configs/db-88f6820-gp_defconfig
index 2beacdb..0341f19 100644
--- a/configs/db-88f6820-gp_defconfig
+++ b/configs/db-88f6820-gp_defconfig
@@ -10,12 +10,16 @@ CONFIG_SPL_SPI_FLASH_SUPPORT=y
 CONFIG_SPL_SPI_SUPPORT=y
 CONFIG_DEFAULT_DEVICE_TREE="armada-388-gp"
 CONFIG_DEBUG_UART=y
+CONFIG_DISTRO_DEFAULTS=y
 CONFIG_BOOTDELAY=3
+# CONFIG_USE_BOOTCOMMAND is not set
 CONFIG_SYS_CONSOLE_INFO_QUIET=y
 # CONFIG_DISPLAY_BOARDINFO is not set
+CONFIG_ARCH_EARLY_INIT_R=y
 CONFIG_SPL=y
 CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_PARTITION=y
 CONFIG_SPL_I2C_SUPPORT=y
+CONFIG_SYS_PROMPT="Marvell>> "
 # CONFIG_CMD_FLASH is not set
 CONFIG_CMD_I2C=y
 CONFIG_CMD_MMC=y
@@ -24,22 +28,15 @@ CONFIG_CMD_SF=y
 CONFIG_CMD_SPI=y
 CONFIG_CMD_USB=y
 # CONFIG_CMD_SETEXPR is not set
-CONFIG_CMD_TFTPPUT=y
-CONFIG_CMD_DHCP=y
-CONFIG_CMD_MII=y
-CONFIG_CMD_PING=y
 CONFIG_CMD_CACHE=y
 CONFIG_CMD_TIME=y
-CONFIG_CMD_EXT2=y
-CONFIG_CMD_EXT4=y
-CONFIG_CMD_FAT=y
-CONFIG_CMD_FS_GENERIC=y
-CONFIG_EFI_PARTITION=y
-# CONFIG_PARTITION_UUIDS is not set
+CONFIG_CMD_MVEBU_BUBT=y
+# CONFIG_ISO_PARTITION is not set
 # CONFIG_SPL_PARTITION_UUIDS is not set
 CONFIG_ENV_IS_IN_SPI_FLASH=y
 CONFIG_SPL_OF_TRANSLATE=y
 CONFIG_SCSI_AHCI=y
+CONFIG_MISC=y
 CONFIG_MMC_SDHCI=y
 CONFIG_MMC_SDHCI_SDMA=y
 CONFIG_MMC_SDHCI_MV=y
@@ -47,8 +44,10 @@ CONFIG_SPI_FLASH=y
 CONFIG_SPI_FLASH_MACRONIX=y
 CONFIG_SPI_FLASH_STMICRO=y
 CONFIG_PHY_GIGE=y
+CONFIG_E1000=y
 CONFIG_MVNETA=y
 CONFIG_PCI=y
+CONFIG_PCI_MVEBU=y
 CONFIG_SCSI=y
 CONFIG_DEBUG_UART_BASE=0xd0012000
 CONFIG_DEBUG_UART_CLOCK=250000000
diff --git a/configs/db-mv784mp-gp_defconfig b/configs/db-mv784mp-gp_defconfig
index cfe852f..97996a1 100644
--- a/configs/db-mv784mp-gp_defconfig
+++ b/configs/db-mv784mp-gp_defconfig
@@ -24,7 +24,6 @@ CONFIG_CMD_SF=y
 CONFIG_CMD_SPI=y
 CONFIG_CMD_USB=y
 # CONFIG_CMD_SETEXPR is not set
-CONFIG_CMD_TFTPPUT=y
 CONFIG_CMD_DHCP=y
 CONFIG_CMD_MII=y
 CONFIG_CMD_PING=y
@@ -50,6 +49,7 @@ CONFIG_MVNETA=y
 CONFIG_PCI=y
 CONFIG_DEBUG_UART_BASE=0xd0012000
 CONFIG_DEBUG_UART_CLOCK=250000000
+CONFIG_PCI_MVEBU=y
 CONFIG_DEBUG_UART_SHIFT=2
 CONFIG_SYS_NS16550=y
 CONFIG_KIRKWOOD_SPI=y
diff --git a/configs/ds414_defconfig b/configs/ds414_defconfig
index 5d1d6ab..e2ce3f6 100644
--- a/configs/ds414_defconfig
+++ b/configs/ds414_defconfig
@@ -44,6 +44,7 @@ CONFIG_MVNETA=y
 CONFIG_PCI=y
 CONFIG_DEBUG_UART_BASE=0xd0012000
 CONFIG_DEBUG_UART_CLOCK=250000000
+CONFIG_PCI_MVEBU=y
 CONFIG_DEBUG_UART_SHIFT=2
 CONFIG_SYS_NS16550=y
 CONFIG_KIRKWOOD_SPI=y
diff --git a/configs/mvebu_db-88f3720_defconfig b/configs/mvebu_db-88f3720_defconfig
index 1d6233a..51aeaa2 100644
--- a/configs/mvebu_db-88f3720_defconfig
+++ b/configs/mvebu_db-88f3720_defconfig
@@ -3,50 +3,61 @@ CONFIG_ARCH_MVEBU=y
 CONFIG_SYS_TEXT_BASE=0x00000000
 CONFIG_SYS_MALLOC_F_LEN=0x2000
 CONFIG_TARGET_MVEBU_ARMADA_37XX=y
-CONFIG_DEFAULT_DEVICE_TREE="armada-3720-db"
 CONFIG_DEBUG_UART=y
 CONFIG_AHCI=y
 CONFIG_DISTRO_DEFAULTS=y
 # CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
+CONFIG_BOOTCOMMAND="run get_images; run set_bootargs; booti $kernel_addr $ramfs_addr $fdt_addr"
+CONFIG_SYS_CONSOLE_ENV_OVERWRITE=y
 CONFIG_SYS_CONSOLE_INFO_QUIET=y
 # CONFIG_DISPLAY_CPUINFO is not set
-# CONFIG_DISPLAY_BOARDINFO is not set
 CONFIG_ARCH_EARLY_INIT_R=y
 CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_SYS_PROMPT="Marvell>> "
 # CONFIG_CMD_FLASH is not set
 CONFIG_CMD_GPIO=y
 CONFIG_CMD_I2C=y
 CONFIG_CMD_MMC=y
+CONFIG_CMD_PCI=y
 CONFIG_CMD_SF=y
 CONFIG_CMD_SPI=y
 CONFIG_CMD_USB=y
 # CONFIG_CMD_SETEXPR is not set
-CONFIG_CMD_TFTPPUT=y
 CONFIG_CMD_CACHE=y
 CONFIG_CMD_TIME=y
 CONFIG_CMD_MVEBU_BUBT=y
+CONFIG_CMD_MVEBU_HW_INFO=y
 CONFIG_CMD_EXT4_WRITE=y
 CONFIG_MAC_PARTITION=y
 CONFIG_ENV_IS_IN_SPI_FLASH=y
 CONFIG_SCSI_AHCI=y
+CONFIG_AHCI_MVEBU=y
 CONFIG_BLOCK_CACHE=y
 CONFIG_DM_GPIO=y
 # CONFIG_MVEBU_GPIO is not set
+CONFIG_DM_PCA953X=y
 CONFIG_DM_I2C=y
 CONFIG_MISC=y
 CONFIG_DM_MMC=y
 CONFIG_MMC_SDHCI=y
 CONFIG_MMC_SDHCI_SDMA=y
 CONFIG_MMC_SDHCI_XENON=y
+CONFIG_MMC_HS200_SUPPORT=y
 CONFIG_SPI_FLASH=y
 CONFIG_SPI_FLASH_MACRONIX=y
 CONFIG_SPI_FLASH_SPANSION=y
 CONFIG_SPI_FLASH_STMICRO=y
-CONFIG_PHYLIB=y
 CONFIG_PHY_GIGE=y
+CONFIG_E1000=y
+CONFIG_MVNETA=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_PCI_AARDVARK=y
 CONFIG_MVEBU_COMPHY_SUPPORT=y
 CONFIG_PINCTRL=y
 CONFIG_PINCTRL_ARMADA_37XX=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
 # CONFIG_SPL_SERIAL_PRESENT is not set
 CONFIG_DEBUG_MVEBU_A3700_UART=y
 CONFIG_DEBUG_UART_BASE=0xd0012000
diff --git a/configs/mvebu_db_armada8k_defconfig b/configs/mvebu_db_armada8k_defconfig
index da67aad..ba2cb3e 100644
--- a/configs/mvebu_db_armada8k_defconfig
+++ b/configs/mvebu_db_armada8k_defconfig
@@ -1,70 +1,1263 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# U-Boot 2018.03 Configuration
+#
+CONFIG_CREATE_ARCH_SYMLINK=y
+# CONFIG_ARC is not set
 CONFIG_ARM=y
+# CONFIG_M68K is not set
+# CONFIG_MICROBLAZE is not set
+# CONFIG_MIPS is not set
+# CONFIG_NDS32 is not set
+# CONFIG_NIOS2 is not set
+# CONFIG_PPC is not set
+# CONFIG_RISCV is not set
+# CONFIG_SANDBOX is not set
+# CONFIG_SH is not set
+# CONFIG_X86 is not set
+# CONFIG_XTENSA is not set
+CONFIG_SYS_ARCH="arm"
+CONFIG_SYS_CPU="armv8"
+CONFIG_SYS_SOC="mvebu"
+CONFIG_SYS_VENDOR="Marvell"
+CONFIG_SYS_BOARD="mvebu_armada-8k"
+CONFIG_SYS_CONFIG_NAME="mvebu_armada-8k"
+
+#
+# ARM architecture
+#
+CONFIG_ARM64=y
+# CONFIG_POSITION_INDEPENDENT is not set
+CONFIG_STATIC_RELA=y
+CONFIG_DMA_ADDR_T_64BIT=y
+CONFIG_ARM_ASM_UNIFIED=y
+CONFIG_SYS_ARM_ARCH=8
+CONFIG_SYS_CACHE_SHIFT_6=y
+CONFIG_SYS_CACHELINE_SIZE=64
+# CONFIG_ARM_SMCCC is not set
+# CONFIG_SEMIHOSTING is not set
+# CONFIG_SYS_L2CACHE_OFF is not set
+# CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK is not set
+# CONFIG_ARM_CORTEX_CPU_IS_UP is not set
+CONFIG_ARM64_SUPPORT_AARCH32=y
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_TARGET_EDB93XX is not set
+# CONFIG_TARGET_ASPENITE is not set
+# CONFIG_TARGET_GPLUGD is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_KIRKWOOD is not set
 CONFIG_ARCH_MVEBU=y
+# CONFIG_TARGET_DEVKIT3250 is not set
+# CONFIG_TARGET_WORK_92105 is not set
+# CONFIG_TARGET_APF27 is not set
+# CONFIG_ORION5X is not set
+# CONFIG_TARGET_SPEAR300 is not set
+# CONFIG_TARGET_SPEAR310 is not set
+# CONFIG_TARGET_SPEAR320 is not set
+# CONFIG_TARGET_SPEAR600 is not set
+# CONFIG_TARGET_STV0991 is not set
+# CONFIG_TARGET_X600 is not set
+# CONFIG_TARGET_IMX31_PHYCORE is not set
+# CONFIG_TARGET_IMX31_PHYCORE_EET is not set
+# CONFIG_TARGET_MX31ADS is not set
+# CONFIG_TARGET_MX31PDK is not set
+# CONFIG_TARGET_WOODBURN is not set
+# CONFIG_TARGET_WOODBURN_SD is not set
+# CONFIG_TARGET_FLEA3 is not set
+# CONFIG_TARGET_MX35PDK is not set
+# CONFIG_ARCH_BCM283X is not set
+# CONFIG_TARGET_VEXPRESS_CA15_TC2 is not set
+# CONFIG_TARGET_VEXPRESS_CA5X2 is not set
+# CONFIG_TARGET_VEXPRESS_CA9X4 is not set
+# CONFIG_TARGET_BCM23550_W1D is not set
+# CONFIG_TARGET_BCM28155_AP is not set
+# CONFIG_TARGET_BCMCYGNUS is not set
+# CONFIG_TARGET_BCMNSP is not set
+# CONFIG_TARGET_BCMNS2 is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_S5PC1XX is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_KEYSTONE is not set
+# CONFIG_ARCH_OMAP2PLUS is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MX8M is not set
+# CONFIG_ARCH_MX23 is not set
+# CONFIG_ARCH_MX25 is not set
+# CONFIG_ARCH_MX28 is not set
+# CONFIG_ARCH_MX7ULP is not set
+# CONFIG_ARCH_MX7 is not set
+# CONFIG_ARCH_MX6 is not set
+CONFIG_SPL_LDSCRIPT="arch/arm/cpu/armv8/u-boot-spl.lds"
+# CONFIG_ARCH_MX5 is not set
+# CONFIG_ARCH_QEMU is not set
+# CONFIG_ARCH_RMOBILE is not set
+# CONFIG_TARGET_S32V234EVB is not set
+# CONFIG_ARCH_SNAPDRAGON is not set
+# CONFIG_ARCH_SOCFPGA is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_ARCH_VF610 is not set
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_ARCH_ZYNQMP is not set
+# CONFIG_TEGRA is not set
+# CONFIG_TARGET_VEXPRESS64_AEMV8A is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP_DRAM is not set
+# CONFIG_TARGET_VEXPRESS64_JUNO is not set
+# CONFIG_TARGET_LS2080A_EMU is not set
+# CONFIG_TARGET_LS2080A_SIMU is not set
+# CONFIG_TARGET_LS1088AQDS is not set
+# CONFIG_TARGET_LS2080AQDS is not set
+# CONFIG_TARGET_LS2080ARDB is not set
+# CONFIG_TARGET_LS2081ARDB is not set
+# CONFIG_TARGET_HIKEY is not set
+# CONFIG_TARGET_POPLAR is not set
+# CONFIG_TARGET_LS1012AQDS is not set
+# CONFIG_TARGET_LS1012ARDB is not set
+# CONFIG_TARGET_LS1012A2G5RDB is not set
+# CONFIG_TARGET_LS1012AFRDM is not set
+# CONFIG_TARGET_LS1088ARDB is not set
+# CONFIG_TARGET_LS1021AQDS is not set
+# CONFIG_TARGET_LS1021ATWR is not set
+# CONFIG_TARGET_LS1021AIOT is not set
+# CONFIG_TARGET_LS1043AQDS is not set
+# CONFIG_TARGET_LS1043ARDB is not set
+# CONFIG_TARGET_LS1046AQDS is not set
+# CONFIG_TARGET_LS1046ARDB is not set
+# CONFIG_TARGET_H2200 is not set
+# CONFIG_TARGET_ZIPITZ2 is not set
+# CONFIG_TARGET_COLIBRI_PXA270 is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_STM32 is not set
+# CONFIG_ARCH_STI is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_ARCH_OCTEONTX is not set
+# CONFIG_ARCH_OCTEONTX2 is not set
+# CONFIG_ARCH_ASPEED is not set
 CONFIG_SYS_TEXT_BASE=0x00000000
 CONFIG_SYS_MALLOC_F_LEN=0x2000
+CONFIG_HAVE_MVEBU_EFUSE=y
+CONFIG_ARMADA_8K=y
+CONFIG_SYS_MVEBU_PLL_CLOCK=2000000000
+# CONFIG_TARGET_CLEARFOG is not set
+# CONFIG_TARGET_MVEBU_ARMADA_37XX is not set
+# CONFIG_TARGET_DB_88F6720 is not set
+# CONFIG_TARGET_DB_88F6820_GP is not set
+# CONFIG_TARGET_DB_88F6820_AMC is not set
+# CONFIG_TARGET_TURRIS_OMNIA is not set
 CONFIG_TARGET_MVEBU_ARMADA_8K=y
-CONFIG_DEFAULT_DEVICE_TREE="armada-8040-db"
+# CONFIG_TARGET_OCTEONTX2_CN913x is not set
+# CONFIG_TARGET_DB_MV784MP_GP is not set
+# CONFIG_TARGET_DS414 is not set
+# CONFIG_TARGET_MAXBCM is not set
+# CONFIG_TARGET_THEADORABLE is not set
+# CONFIG_TARGET_CONTROLCENTERDC is not set
+CONFIG_IDENT_STRING=""
+# CONFIG_ARMV8_MULTIENTRY is not set
+# CONFIG_ARMV8_SET_SMPEN is not set
+
+#
+# ARMv8 secure monitor firmware
+#
+# CONFIG_ARMV8_SEC_FIRMWARE_SUPPORT is not set
+# CONFIG_SPL_ARMV8_SEC_FIRMWARE_SUPPORT is not set
+CONFIG_PSCI_RESET=y
+# CONFIG_ARMV8_PSCI is not set
+# CONFIG_CMD_DEKBLOB is not set
+# CONFIG_CMD_HDMIDETECT is not set
+
+#
+# MVEBU Development Board Utilities
+#
+CONFIG_BOARD_CONFIG_EEPROM=y
+CONFIG_MVEBU_SAR=y
+
+#
+# ARM debug
+#
+CONFIG_DEFAULT_DEVICE_TREE="armada-7020-comexp"
 CONFIG_SMBIOS_PRODUCT_NAME=""
 CONFIG_DEBUG_UART=y
 CONFIG_AHCI=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
 CONFIG_DISTRO_DEFAULTS=y
+CONFIG_ENV_VARS_UBOOT_CONFIG=y
+# CONFIG_SYS_BOOT_GET_CMDLINE is not set
+# CONFIG_SYS_BOOT_GET_KBD is not set
+CONFIG_SYS_MALLOC_F=y
+CONFIG_SPL_SYS_MALLOC_F_LEN=0x2000
+CONFIG_TPL_SYS_MALLOC_F_LEN=0x2000
+CONFIG_EXPERT=y
 # CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
+# CONFIG_TOOLS_DEBUG is not set
+CONFIG_PHYS_64BIT=y
+
+#
+# Boot images
+#
+# CONFIG_ANDROID_BOOT_IMAGE is not set
+CONFIG_FIT=y
+CONFIG_FIT_ENABLE_SHA256_SUPPORT=y
+CONFIG_FIT_SIGNATURE=y
+CONFIG_FIT_VERBOSE=y
+CONFIG_FIT_BEST_MATCH=y
+# CONFIG_OF_BOARD_SETUP is not set
+# CONFIG_OF_SYSTEM_SETUP is not set
+# CONFIG_OF_STDOUT_VIA_ALIAS is not set
+CONFIG_SYS_EXTRA_OPTIONS=""
+CONFIG_ARCH_FIXUP_FDT_MEMORY=y
+
+#
+# API
+#
+# CONFIG_API is not set
+
+#
+# Boot timing
+#
+# CONFIG_BOOTSTAGE is not set
+CONFIG_BOOTSTAGE_RECORD_COUNT=30
+CONFIG_SPL_BOOTSTAGE_RECORD_COUNT=5
+CONFIG_BOOTSTAGE_STASH_ADDR=0
+CONFIG_BOOTSTAGE_STASH_SIZE=0x1000
+
+#
+# Boot media
+#
+# CONFIG_NAND_BOOT is not set
+# CONFIG_ONENAND_BOOT is not set
+# CONFIG_QSPI_BOOT is not set
+# CONFIG_SATA_BOOT is not set
+# CONFIG_SD_BOOT is not set
+# CONFIG_SPI_BOOT is not set
+CONFIG_BOOTDELAY=2
+# CONFIG_USE_BOOTARGS is not set
+CONFIG_USE_BOOTCOMMAND=y
+CONFIG_BOOTCOMMAND="run get_images; run set_bootargs; booti $kernel_addr $ramfs_addr $fdt_addr"
+
+#
+# Console
+#
+CONFIG_MENU=y
+# CONFIG_CONSOLE_RECORD is not set
+CONFIG_LOGLEVEL=4
+CONFIG_SPL_LOGLEVEL=4
+# CONFIG_SILENT_CONSOLE is not set
+# CONFIG_PRE_CONSOLE_BUFFER is not set
+# CONFIG_CONSOLE_MUX is not set
+# CONFIG_SYS_CONSOLE_IS_IN_ENV is not set
+# CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE is not set
+CONFIG_SYS_CONSOLE_ENV_OVERWRITE=y
 CONFIG_SYS_CONSOLE_INFO_QUIET=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+
+#
+# Logging
+#
+# CONFIG_LOG is not set
+# CONFIG_SPL_LOG is not set
+CONFIG_SUPPORT_RAW_INITRD=y
+CONFIG_DEFAULT_FDT_FILE=""
+# CONFIG_VERSION_VARIABLE is not set
+CONFIG_BOARD_LATE_INIT=y
 # CONFIG_DISPLAY_CPUINFO is not set
-# CONFIG_DISPLAY_BOARDINFO is not set
+CONFIG_DISPLAY_BOARDINFO=y
+
+#
+# Start-up hooks
+#
 CONFIG_ARCH_EARLY_INIT_R=y
+CONFIG_ARCH_MISC_INIT=y
 CONFIG_BOARD_EARLY_INIT_F=y
+# CONFIG_BOARD_EARLY_INIT_R is not set
+
+#
+# Security support
+#
+CONFIG_HASH=y
+
+#
+# Update support
+#
+# CONFIG_UPDATE_TFTP is not set
+
+#
+# SPL / TPL
+#
+
+#
+# Command line interface
+#
+CONFIG_CMDLINE=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMDLINE_EDITING=y
+CONFIG_AUTO_COMPLETE=y
+CONFIG_SYS_LONGHELP=y
+CONFIG_SYS_PROMPT="Marvell>> "
+
+#
+# Autoboot options
+#
+CONFIG_AUTOBOOT=y
+# CONFIG_AUTOBOOT_KEYED is not set
+
+#
+# FASTBOOT
+#
+
+#
+# Commands
+#
+
+#
+# Info commands
+#
+CONFIG_CMD_MVEBU_SAR=y
+CONFIG_CMD_BDI=y
+# CONFIG_CMD_CONFIG is not set
+CONFIG_CMD_CONSOLE=y
+# CONFIG_CMD_CPU is not set
+# CONFIG_CMD_LICENSE is not set
+
+#
+# Boot commands
+#
+CONFIG_CMD_BOOTD=y
+CONFIG_CMD_BOOTM=y
+# CONFIG_CMD_BOOTZ is not set
+CONFIG_CMD_BOOTI=y
+CONFIG_CMD_BOOTEFI=y
+CONFIG_CMD_BOOTEFI_HELLO_COMPILE=y
+# CONFIG_CMD_BOOTEFI_HELLO is not set
+# CONFIG_CMD_BOOTEFI_SELFTEST is not set
+# CONFIG_CMD_BOOTMENU is not set
+CONFIG_CMD_ELF=y
+CONFIG_CMD_FDT=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_RUN=y
+CONFIG_CMD_IMI=y
+# CONFIG_CMD_IMLS is not set
+CONFIG_CMD_XIMG=y
+# CONFIG_CMD_POWEROFF is not set
+# CONFIG_CMD_FITUPD is not set
+# CONFIG_CMD_THOR_DOWNLOAD is not set
+# CONFIG_CMD_ZBOOT is not set
+
+#
+# Environment commands
+#
+# CONFIG_CMD_ASKENV is not set
+CONFIG_CMD_EXPORTENV=y
+CONFIG_CMD_IMPORTENV=y
+CONFIG_CMD_EDITENV=y
+# CONFIG_CMD_GREPENV is not set
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_ENV_EXISTS=y
+# CONFIG_CMD_ENV_CALLBACK is not set
+# CONFIG_CMD_ENV_FLAGS is not set
+
+#
+# Memory commands
+#
+CONFIG_CMD_CRC32=y
+# CONFIG_CRC32_VERIFY is not set
+# CONFIG_CMD_EEPROM is not set
+# CONFIG_LOOPW is not set
+# CONFIG_CMD_MD5SUM is not set
+# CONFIG_CMD_MEMINFO is not set
+CONFIG_CMD_MEMORY=y
+# CONFIG_CMD_MEMTEST is not set
+# CONFIG_CMD_MX_CYCLIC is not set
+# CONFIG_CMD_SHA1SUM is not set
+# CONFIG_CMD_STRINGS is not set
+
+#
+# Compression commands
+#
+CONFIG_CMD_LZMADEC=y
+CONFIG_CMD_UNZIP=y
+# CONFIG_CMD_ZIP is not set
+
+#
+# Device access commands
+#
+# CONFIG_CMD_ARMFLASH is not set
+# CONFIG_CMD_CLK is not set
+# CONFIG_CMD_DEMO is not set
+# CONFIG_CMD_DFU is not set
+CONFIG_CMD_DM=y
+# CONFIG_CMD_FDC is not set
 # CONFIG_CMD_FLASH is not set
+# CONFIG_CMD_FPGAD is not set
+CONFIG_CMD_FUSE=y
+CONFIG_CMD_GPIO=y
+# CONFIG_CMD_GPT is not set
+# CONFIG_RANDOM_UUID is not set
+# CONFIG_CMD_IDE is not set
+# CONFIG_CMD_IO is not set
+# CONFIG_CMD_IOTRACE is not set
 CONFIG_CMD_I2C=y
+CONFIG_CMD_LOADB=y
+CONFIG_CMD_LOADS=y
 CONFIG_CMD_MMC=y
+CONFIG_CMD_NAND=y
+# CONFIG_CMD_NAND_TRIMFFS is not set
+# CONFIG_CMD_NAND_LOCK_UNLOCK is not set
+# CONFIG_CMD_NAND_TORTURE is not set
+# CONFIG_CMD_MMC_SPI is not set
+# CONFIG_CMD_ONENAND is not set
+CONFIG_CMD_PART=y
 CONFIG_CMD_PCI=y
+# CONFIG_CMD_PCMCIA is not set
+# CONFIG_CMD_READ is not set
+# CONFIG_CMD_SATA is not set
+# CONFIG_CMD_SAVES is not set
+CONFIG_CMD_SCSI=y
+# CONFIG_CMD_SDRAM is not set
 CONFIG_CMD_SF=y
+# CONFIG_CMD_SF_TEST is not set
 CONFIG_CMD_SPI=y
+# CONFIG_CMD_TSI148 is not set
+# CONFIG_CMD_UNIVERSE is not set
 CONFIG_CMD_USB=y
+# CONFIG_CMD_USB_SDP is not set
+# CONFIG_CMD_USB_MASS_STORAGE is not set
+
+#
+# Shell scripting commands
+#
+CONFIG_CMD_ECHO=y
+CONFIG_CMD_ITEST=y
+CONFIG_CMD_SOURCE=y
 # CONFIG_CMD_SETEXPR is not set
-CONFIG_CMD_TFTPPUT=y
+
+#
+# Network commands
+#
+CONFIG_CMD_NET=y
+# CONFIG_CMD_TFTPPUT is not set
+# CONFIG_CMD_TFTPSRV is not set
+# CONFIG_CMD_RARP is not set
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PXE=y
+CONFIG_CMD_NFS=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+# CONFIG_CMD_CDP is not set
+# CONFIG_CMD_SNTP is not set
+# CONFIG_CMD_DNS is not set
+# CONFIG_CMD_LINK_LOCAL is not set
+# CONFIG_CMD_ETHSW is not set
+
+#
+# Misc commands
+#
+# CONFIG_CMD_BSP is not set
+# CONFIG_CMD_BKOPS_ENABLE is not set
+CONFIG_CMD_BLOCK_CACHE=y
 CONFIG_CMD_CACHE=y
+# CONFIG_CMD_DISPLAY is not set
+# CONFIG_CMD_LED is not set
+CONFIG_CMD_DATE=y
 CONFIG_CMD_TIME=y
+# CONFIG_CMD_GETTIME is not set
+CONFIG_CMD_MISC=y
+# CONFIG_CMD_TIMER is not set
+# CONFIG_CMD_QFW is not set
+
+#
+# MVEBU commands
+#
 CONFIG_CMD_MVEBU_BUBT=y
+CONFIG_CMD_MVEBU_MV_FW_INFO=y
+CONFIG_CMD_MVEBU_PHY_FW_DOWNLOAD=y
+CONFIG_CMD_MVEBU_TSEN=y
+CONFIG_CMD_MVEBU_HW_INFO=y
+CONFIG_MVEBU_NAND_BOOT=y
+# CONFIG_MVEBU_SPI_BOOT is not set
+# CONFIG_MVEBU_MMC_BOOT is not set
+CONFIG_MVEBU_BOOT_PART=0
+CONFIG_MVEBU_BOOT_DEVICE=0
+CONFIG_MVEBU_UBOOT_DFLT_NAME="flash-image.bin"
+CONFIG_CMD_MVEBU_RX_TRAINING=y
+CONFIG_CMD_MVEBU_AVS=y
+CONFIG_CMD_MVEBU_MAP=y
+CONFIG_CMD_MVEBU_NAND_OEM=y
+CONFIG_CMD_MVEBU_MV_GET_COUNTERS=y
+# CONFIG_CMD_TERMINAL is not set
+# CONFIG_CMD_UUID is not set
+
+#
+# TI specific command line interface
+#
+# CONFIG_CMD_DDR3 is not set
+
+#
+# Power commands
+#
+CONFIG_CMD_REGULATOR=y
+
+#
+# Security commands
+#
+# CONFIG_CMD_AES is not set
+# CONFIG_CMD_BLOB is not set
+# CONFIG_CMD_HASH is not set
+
+#
+# Firmware commands
+#
+
+#
+# Filesystem commands
+#
+# CONFIG_CMD_BTRFS is not set
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
 CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+# CONFIG_CMD_FS_UUID is not set
+# CONFIG_CMD_JFFS2 is not set
+CONFIG_CMD_MTDPARTS=y
+CONFIG_MTDIDS_DEFAULT=""
+CONFIG_MTDPARTS_DEFAULT=""
+# CONFIG_CMD_MTDPARTS_SPREAD is not set
+# CONFIG_CMD_REISER is not set
+# CONFIG_CMD_ZFS is not set
+
+#
+# Debug commands
+#
+# CONFIG_CMD_BEDBUG is not set
+# CONFIG_CMD_DIAG is not set
+# CONFIG_CMD_KGDB is not set
+# CONFIG_CMD_LOG is not set
+# CONFIG_CMD_TRACE is not set
+# CONFIG_CMD_UBI is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITIONS=y
 CONFIG_MAC_PARTITION=y
-CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_DOS_PARTITION=y
+CONFIG_ISO_PARTITION=y
+# CONFIG_AMIGA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+CONFIG_EFI_PARTITION_ENTRIES_NUMBERS=128
+CONFIG_EFI_PARTITION_ENTRIES_OFF=0
+CONFIG_PARTITION_UUIDS=y
+# CONFIG_PARTITION_TYPE_GUID is not set
+CONFIG_SUPPORT_OF_CONTROL=y
+CONFIG_DTC=y
+
+#
+# Device Tree Control
+#
+CONFIG_OF_CONTROL=y
+# CONFIG_OF_BOARD_FIXUP is not set
+# CONFIG_OF_LIVE is not set
+CONFIG_OF_SEPARATE=y
+# CONFIG_OF_EMBED is not set
+# CONFIG_OF_BOARD is not set
+# CONFIG_MULTI_DTB_FIT is not set
+CONFIG_MKIMAGE_DTC_PATH="dtc"
+
+#
+# Environment
+#
+# CONFIG_ENV_IS_IN_EEPROM is not set
+# CONFIG_ENV_IS_IN_FAT is not set
+# CONFIG_ENV_IS_IN_EXT4 is not set
+# CONFIG_ENV_IS_IN_FLASH is not set
+# CONFIG_ENV_IS_IN_MMC is not set
+CONFIG_ENV_IS_IN_NAND=y
+# CONFIG_ENV_IS_IN_NVRAM is not set
+# CONFIG_ENV_IS_IN_ONENAND is not set
+# CONFIG_ENV_IS_IN_REMOTE is not set
+# CONFIG_ENV_IS_IN_SPI_FLASH is not set
+# CONFIG_ENV_IS_IN_UBI is not set
+CONFIG_NET=y
+# CONFIG_NET_RANDOM_ETHADDR is not set
+# CONFIG_NETCONSOLE is not set
+CONFIG_NET_TFTP_VARS=y
+CONFIG_BOOTP_BOOTPATH=y
+CONFIG_BOOTP_DNS=y
+CONFIG_BOOTP_GATEWAY=y
+CONFIG_BOOTP_HOSTNAME=y
+CONFIG_BOOTP_PXE=y
+CONFIG_BOOTP_SUBNETMASK=y
+# CONFIG_BOOTP_TFTP_SERVERIP is not set
+CONFIG_BOOTP_PXE_CLIENTARCH=0x16
+CONFIG_BOOTP_VCI_STRING="U-Boot.armv8"
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_DM=y
+CONFIG_DM_WARN=y
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_DEVICE_REMOVE=y
+CONFIG_DM_STDIO=y
+CONFIG_DM_SEQ_ALIAS=y
+# CONFIG_SPL_DM_SEQ_ALIAS is not set
+# CONFIG_REGMAP is not set
+# CONFIG_DEVRES is not set
+CONFIG_SIMPLE_BUS=y
+CONFIG_OF_TRANSLATE=y
+CONFIG_DM_DEV_READ_INLINE=y
+# CONFIG_ADC is not set
+# CONFIG_ADC_EXYNOS is not set
+# CONFIG_ADC_SANDBOX is not set
+# CONFIG_SARADC_ROCKCHIP is not set
+# CONFIG_SATA is not set
+CONFIG_LIBATA=y
 CONFIG_SCSI_AHCI=y
+
+#
+# SATA/SCSI device support
+#
+# CONFIG_AHCI_PCI is not set
+# CONFIG_SATA_CEVA is not set
+# CONFIG_DWC_AHCI is not set
+# CONFIG_DWC_AHSATA is not set
+# CONFIG_FSL_SATA is not set
+# CONFIG_MVSATA_IDE is not set
+# CONFIG_SATA_MV is not set
+# CONFIG_SATA_SIL is not set
+# CONFIG_SATA_SIL3114 is not set
+CONFIG_AHCI_MVEBU=y
+CONFIG_BLK=y
+CONFIG_HAVE_BLOCK_DEVICE=y
 CONFIG_BLOCK_CACHE=y
+# CONFIG_NVME is not set
+# CONFIG_IDE is not set
+# CONFIG_BOOTCOUNT_LIMIT is not set
+
+#
+# Clock
+#
+# CONFIG_CLK is not set
+# CONFIG_CPU is not set
+
+#
+# Hardware crypto devices
+#
+# CONFIG_FSL_CAAM is not set
+# CONFIG_SYS_FSL_SEC_BE is not set
+# CONFIG_SYS_FSL_SEC_LE is not set
+
+#
+# Demo for driver model
+#
+# CONFIG_DM_DEMO is not set
+
+#
+# DFU support
+#
+
+#
+# DMA Support
+#
+# CONFIG_DMA is not set
+# CONFIG_TI_EDMA3 is not set
+
+#
+# FPGA support
+#
+# CONFIG_FPGA_ALTERA is not set
+# CONFIG_FPGA_SOCFPGA is not set
+# CONFIG_FPGA_XILINX is not set
+# CONFIG_FPGA_SPARTAN3 is not set
+
+#
+# EFUSE Support
+#
+CONFIG_MVEBU_EFUSE=y
+CONFIG_MVEBU_EFUSE_READ_ONLY=y
+
+#
+# GPIO Support
+#
+CONFIG_DM_GPIO=y
+# CONFIG_ALTERA_PIO is not set
+# CONFIG_DWAPB_GPIO is not set
+# CONFIG_AT91_GPIO is not set
+# CONFIG_ATMEL_PIO4 is not set
+# CONFIG_INTEL_BROADWELL_GPIO is not set
+# CONFIG_INTEL_ICH6_GPIO is not set
+# CONFIG_IMX_RGPIO2P is not set
+# CONFIG_HSDK_CREG_GPIO is not set
+# CONFIG_LPC32XX_GPIO is not set
+# CONFIG_MSM_GPIO is not set
+# CONFIG_MXC_GPIO is not set
+# CONFIG_CMD_PCA953X is not set
+# CONFIG_PCF8575_GPIO is not set
+# CONFIG_ROCKCHIP_GPIO is not set
+# CONFIG_XILINX_GPIO is not set
+# CONFIG_CMD_TCA642X is not set
+# CONFIG_TEGRA_GPIO is not set
+# CONFIG_TEGRA186_GPIO is not set
+# CONFIG_VYBRID_GPIO is not set
+CONFIG_MVEBU_GPIO=y
+# CONFIG_DM_74X164 is not set
+CONFIG_DM_PCA953X=y
+# CONFIG_MPC8XXX_GPIO is not set
+# CONFIG_I2C_GPIO is not set
+
+#
+# I2C support
+#
 CONFIG_DM_I2C=y
+# CONFIG_DM_I2C_COMPAT is not set
+# CONFIG_I2C_SET_DEFAULT_BUS_NUM is not set
+# CONFIG_DM_I2C_GPIO is not set
+# CONFIG_SYS_I2C_FSL is not set
+# CONFIG_SYS_I2C_CADENCE is not set
+# CONFIG_SYS_I2C_DW is not set
+# CONFIG_SYS_I2C_INTEL is not set
+# CONFIG_SYS_I2C_IMX_LPI2C is not set
+# CONFIG_SYS_I2C_ROCKCHIP is not set
 CONFIG_SYS_I2C_MVTWSI=y
+# CONFIG_SYS_I2C_IHS is not set
+# CONFIG_I2C_MUX is not set
+# CONFIG_DM_KEYBOARD is not set
+# CONFIG_CROS_EC_KEYB is not set
+
+#
+# LED Support
+#
+# CONFIG_LED is not set
+# CONFIG_LED_STATUS is not set
+
+#
+# Mailbox Controller Support
+#
+# CONFIG_DM_MAILBOX is not set
+
+#
+# MDIO Support
+#
+CONFIG_DM_MDIO=y
+CONFIG_MVMDIO=y
+
+#
+# Memory Controller drivers
+#
+
+#
+# Multifunction device drivers
+#
 CONFIG_MISC=y
+# CONFIG_ALTERA_SYSID is not set
+# CONFIG_ATSHA204A is not set
+# CONFIG_ROCKCHIP_EFUSE is not set
+# CONFIG_CROS_EC is not set
+# CONFIG_DS4510 is not set
+# CONFIG_FSL_SEC_MON is not set
+# CONFIG_MXC_OCOTP is not set
+# CONFIG_NUVOTON_NCT6102D is not set
+# CONFIG_PWRSEQ is not set
+# CONFIG_PCA9551_LED is not set
+# CONFIG_WINBOND_W83627 is not set
+# CONFIG_I2C_EEPROM is not set
+CONFIG_ZYNQ_GEM_I2C_MAC_OFFSET=0x0
+
+#
+# MMC Host controller Support
+#
+CONFIG_MMC=y
+CONFIG_MMC_WRITE=y
 CONFIG_DM_MMC=y
+CONFIG_MMC_HW_PARTITIONING=y
+# CONFIG_ARM_PL180_MMCI is not set
+CONFIG_MMC_QUIRKS=y
+# CONFIG_MMC_IO_VOLTAGE is not set
+# CONFIG_SPL_MMC_IO_VOLTAGE is not set
+# CONFIG_MMC_HS400_SUPPORT is not set
+# CONFIG_SPL_MMC_HS400_SUPPORT is not set
+# CONFIG_MMC_HS200_SUPPORT is not set
+# CONFIG_SPL_MMC_HS200_SUPPORT is not set
+CONFIG_MMC_VERBOSE=y
+# CONFIG_SPL_MMC_TINY is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_MXC is not set
+# CONFIG_MMC_PCI is not set
+# CONFIG_MMC_OMAP_HS is not set
 CONFIG_MMC_SDHCI=y
+# CONFIG_MMC_SDHCI_SDMA is not set
+# CONFIG_MMC_SDHCI_CADENCE is not set
+# CONFIG_MMC_SDHCI_KONA is not set
+# CONFIG_MMC_SDHCI_MSM is not set
+# CONFIG_MMC_SDHCI_MV is not set
+# CONFIG_MMC_SDHCI_S5P is not set
+# CONFIG_MMC_SDHCI_SPEAR is not set
+# CONFIG_MMC_SDHCI_STI is not set
 CONFIG_MMC_SDHCI_XENON=y
+# CONFIG_MMC_SDHCI_TANGIER is not set
+# CONFIG_STM32_SDMMC2 is not set
+# CONFIG_FTSDC010 is not set
+
+#
+# MTD Support
+#
+CONFIG_MTD=y
+# CONFIG_MTD_NOR_FLASH is not set
+# CONFIG_CFI_FLASH is not set
+# CONFIG_ALTERA_QSPI is not set
+CONFIG_NAND=y
+CONFIG_SYS_NAND_SELF_INIT=y
+# CONFIG_NAND_DENALI_DT is not set
+# CONFIG_NAND_VF610_NFC is not set
+CONFIG_NAND_PXA3XX=y
+# CONFIG_NAND_ARASAN is not set
+# CONFIG_NAND_ZYNQ is not set
+# CONFIG_NAND_OCTEONTX is not set
+
+#
+# Generic NAND options
+#
+
+#
+# SPI Flash Support
+#
+CONFIG_DM_SPI_FLASH=y
 CONFIG_SPI_FLASH=y
+# CONFIG_SF_DUAL_FLASH is not set
+# CONFIG_SPI_FLASH_ATMEL is not set
+# CONFIG_SPI_FLASH_EON is not set
+# CONFIG_SPI_FLASH_GIGADEVICE is not set
 CONFIG_SPI_FLASH_MACRONIX=y
 CONFIG_SPI_FLASH_SPANSION=y
 CONFIG_SPI_FLASH_STMICRO=y
+# CONFIG_SPI_FLASH_SST is not set
+# CONFIG_SPI_FLASH_WINBOND is not set
+# CONFIG_SPI_FLASH_ISSI is not set
+CONFIG_SPI_FLASH_USE_4K_SECTORS=y
+# CONFIG_SPI_FLASH_DATAFLASH is not set
+# CONFIG_SPI_FLASH_MTD is not set
+
+#
+# UBI support
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_BITBANGMII is not set
+# CONFIG_MV88E6352_SWITCH is not set
+# CONFIG_MV88E6XXX_SWITCH is not set
+CONFIG_PHYLIB=y
+# CONFIG_B53_SWITCH is not set
+# CONFIG_MV88E61XX_SWITCH is not set
+# CONFIG_PHYLIB_10G is not set
+# CONFIG_PHY_AQUANTIA is not set
+# CONFIG_PHY_ATHEROS is not set
+# CONFIG_PHY_BROADCOM is not set
+# CONFIG_PHY_CORTINA is not set
+# CONFIG_PHY_DAVICOM is not set
+# CONFIG_PHY_ET1011C is not set
+# CONFIG_PHY_LXT is not set
 CONFIG_PHY_MARVELL=y
+# CONFIG_PHY_MESON_GXL is not set
+# CONFIG_PHY_MICREL is not set
+# CONFIG_PHY_MSCC is not set
+# CONFIG_PHY_NATSEMI is not set
+# CONFIG_PHY_REALTEK is not set
+# CONFIG_PHY_SMSC is not set
+# CONFIG_PHY_TERANETICS is not set
+# CONFIG_PHY_TI is not set
+# CONFIG_PHY_VITESSE is not set
+# CONFIG_PHY_XILINX is not set
+# CONFIG_PHY_FIXED is not set
+CONFIG_DM_ETH=y
+CONFIG_NETDEVICES=y
 CONFIG_PHY_GIGE=y
+# CONFIG_ALTERA_TSE is not set
+# CONFIG_BCM_SF2_ETH is not set
+# CONFIG_DWC_ETH_QOS is not set
+CONFIG_E1000=y
+# CONFIG_E1000_SPI_GENERIC is not set
+# CONFIG_E1000_SPI is not set
+# CONFIG_CMD_E1000 is not set
+# CONFIG_ETH_DESIGNWARE is not set
+# CONFIG_ETHOC is not set
+# CONFIG_FTMAC100 is not set
 CONFIG_MVPP2=y
+# CONFIG_MACB is not set
+# CONFIG_PCH_GBE is not set
+# CONFIG_RGMII is not set
+# CONFIG_RTL8139 is not set
+# CONFIG_RTL8169 is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SUN7I_GMAC is not set
+# CONFIG_SUN4I_EMAC is not set
+# CONFIG_SUN8I_EMAC is not set
+# CONFIG_SH_ETHER is not set
+# CONFIG_SYS_DPAA_QBMAN is not set
 CONFIG_PCI=y
 CONFIG_DM_PCI=y
+# CONFIG_DM_PCI_COMPAT is not set
+CONFIG_PCI_PNP=y
+# CONFIG_PCIE_ECAM_GENERIC is not set
 CONFIG_PCIE_DW_MVEBU=y
+# CONFIG_PCI_XILINX is not set
+# CONFIG_PCIE_LAYERSCAPE is not set
+# CONFIG_PCI_MVEBU is not set
+
+#
+# PHY Subsystem
+#
+# CONFIG_PHY is not set
+# CONFIG_SPL_PHY is not set
 CONFIG_MVEBU_COMPHY_SUPPORT=y
+
+#
+# Pin controllers
+#
 CONFIG_PINCTRL=y
+CONFIG_PINCTRL_FULL=y
+CONFIG_PINCTRL_GENERIC=y
+CONFIG_PINMUX=y
+# CONFIG_PINCONF is not set
+# CONFIG_PINCTRL_AT91 is not set
+# CONFIG_PINCTRL_AT91PIO4 is not set
+# CONFIG_PINCTRL_ROCKCHIP_RK3036 is not set
+# CONFIG_PINCTRL_ROCKCHIP_RK3128 is not set
+# CONFIG_PINCTRL_ROCKCHIP_RK3188 is not set
+# CONFIG_PINCTRL_ROCKCHIP_RK322X is not set
+# CONFIG_PINCTRL_ROCKCHIP_RK3288 is not set
+# CONFIG_PINCTRL_ROCKCHIP_RK3328 is not set
+# CONFIG_PINCTRL_ROCKCHIP_RK3368 is not set
+# CONFIG_PINCTRL_ROCKCHIP_RK3399 is not set
+# CONFIG_PINCTRL_ROCKCHIP_RV1108 is not set
+# CONFIG_PINCTRL_SINGLE is not set
+# CONFIG_PINCTRL_STM32 is not set
 CONFIG_PINCTRL_ARMADA_8K=y
+
+#
+# Power
+#
+
+#
+# Power Domain Support
+#
+# CONFIG_POWER_DOMAIN is not set
+# CONFIG_DM_PMIC is not set
+# CONFIG_PMIC_AS3722 is not set
+# CONFIG_POWER_MC34VR500 is not set
+CONFIG_DM_REGULATOR=y
+# CONFIG_SPL_DM_REGULATOR is not set
+# CONFIG_REGULATOR_PWM is not set
+CONFIG_DM_REGULATOR_FIXED=y
+# CONFIG_SPL_DM_REGULATOR_FIXED is not set
+CONFIG_DM_REGULATOR_GPIO=y
+# CONFIG_DM_REGULATOR_PBIAS is not set
+# CONFIG_DM_PWM is not set
+# CONFIG_PWM_SANDBOX is not set
+# CONFIG_RAM is not set
+
+#
+# Remote Processor drivers
+#
+
+#
+# Reset Controller Support
+#
+# CONFIG_DM_RESET is not set
+
+#
+# Real Time Clock
+#
+CONFIG_DM_RTC=y
+CONFIG_MARVELL_RTC=y
+# CONFIG_RTC_PCF2127 is not set
+# CONFIG_RTC_DS1307 is not set
+# CONFIG_RTC_RX8010SJ is not set
+# CONFIG_RTC_DS1337 is not set
+# CONFIG_RTC_S35392A is not set
+CONFIG_SCSI=y
+CONFIG_DM_SCSI=y
+
+#
+# Serial drivers
+#
+CONFIG_BAUDRATE=115200
+CONFIG_REQUIRE_SERIAL_CONSOLE=y
+CONFIG_SERIAL_PRESENT=y
 # CONFIG_SPL_SERIAL_PRESENT is not set
+CONFIG_DM_SERIAL=y
+# CONFIG_SERIAL_RX_BUFFER is not set
+# CONFIG_SERIAL_SEARCH_ALL is not set
+# CONFIG_SPL_DM_SERIAL is not set
+# CONFIG_TPL_DM_SERIAL is not set
+# CONFIG_DEBUG_UART_ALTERA_JTAGUART is not set
+# CONFIG_DEBUG_UART_ALTERA_UART is not set
+# CONFIG_DEBUG_UART_ATMEL is not set
+CONFIG_DEBUG_UART_NS16550=y
+# CONFIG_DEBUG_UART_S5P is not set
+# CONFIG_DEBUG_UART_UARTLITE is not set
+# CONFIG_DEBUG_UART_ARM_DCC is not set
+# CONFIG_DEBUG_MVEBU_A3700_UART is not set
+# CONFIG_DEBUG_UART_ZYNQ is not set
+# CONFIG_DEBUG_UART_PL010 is not set
+# CONFIG_DEBUG_UART_PL011 is not set
+# CONFIG_DEBUG_UART_OMAP is not set
 CONFIG_DEBUG_UART_BASE=0xf0512000
 CONFIG_DEBUG_UART_CLOCK=200000000
 CONFIG_DEBUG_UART_SHIFT=2
+# CONFIG_DEBUG_UART_BOARD_INIT is not set
 CONFIG_DEBUG_UART_ANNOUNCE=y
+# CONFIG_DEBUG_UART_SKIP_INIT is not set
+# CONFIG_ALTERA_JTAG_UART is not set
+# CONFIG_ALTERA_UART is not set
+# CONFIG_ATMEL_USART is not set
+# CONFIG_FSL_LPUART is not set
+# CONFIG_MVEBU_A3700_UART is not set
+# CONFIG_NULLDEV_SERIAL is not set
 CONFIG_SYS_NS16550=y
+# CONFIG_PL01X_SERIAL is not set
+# CONFIG_MSM_SERIAL is not set
+# CONFIG_PXA_SERIAL is not set
+
+#
+# Sound support
+#
+# CONFIG_SOUND is not set
+
+#
+# SPI Support
+#
+CONFIG_DM_SPI=y
+# CONFIG_ALTERA_SPI is not set
+# CONFIG_CADENCE_QSPI is not set
+# CONFIG_OCTEONTX_SPI is not set
+# CONFIG_DESIGNWARE_SPI is not set
+# CONFIG_EXYNOS_SPI is not set
+# CONFIG_FSL_DSPI is not set
+# CONFIG_ICH_SPI is not set
+# CONFIG_MVEBU_A3700_SPI is not set
+# CONFIG_ROCKCHIP_SPI is not set
+# CONFIG_TEGRA114_SPI is not set
+# CONFIG_TEGRA20_SFLASH is not set
+# CONFIG_TEGRA20_SLINK is not set
+# CONFIG_TEGRA210_QSPI is not set
+# CONFIG_XILINX_SPI is not set
+# CONFIG_SOFT_SPI is not set
+# CONFIG_CF_SPI is not set
+# CONFIG_FSL_ESPI is not set
+# CONFIG_FSL_QSPI is not set
+# CONFIG_ATCSPI200_SPI is not set
+# CONFIG_SH_SPI is not set
+# CONFIG_SH_QSPI is not set
+# CONFIG_TI_QSPI is not set
 CONFIG_KIRKWOOD_SPI=y
+# CONFIG_LPC32XX_SSP is not set
+# CONFIG_MPC8XXX_SPI is not set
+# CONFIG_MXC_SPI is not set
+# CONFIG_MXS_SPI is not set
+# CONFIG_OMAP3_SPI is not set
+
+#
+# SPMI support
+#
+# CONFIG_SPMI is not set
+
+#
+# System reset device drivers
+#
+# CONFIG_SYSRESET is not set
+# CONFIG_SYSRESET_SYSCON is not set
+# CONFIG_SYSRESET_WATCHDOG is not set
+CONFIG_DM_THERMAL=y
+
+#
+# Thermal Sensor driver
+#
+CONFIG_MVEBU_THERMAL_SENSOR=y
+CONFIG_MVEBU_THERMAL_SENSOR_28NM=y
+CONFIG_MVEBU_THERMAL_EXT_SENSOR_28NM=y
+# CONFIG_TI_DRA7_THERMAL is not set
+
+#
+# Timer Support
+#
+# CONFIG_TIMER is not set
+
+#
+# TPM support
+#
 CONFIG_USB=y
 CONFIG_DM_USB=y
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_HOST=y
 CONFIG_USB_XHCI_HCD=y
+# CONFIG_USB_XHCI_DWC3 is not set
+CONFIG_USB_XHCI_MVEBU=y
+# CONFIG_USB_XHCI_PCI is not set
+# CONFIG_USB_XHCI_FSL is not set
 CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_MARVELL=y
+# CONFIG_USB_EHCI_MSM is not set
+# CONFIG_USB_EHCI_PCI is not set
+# CONFIG_USB_EHCI_GENERIC is not set
+# CONFIG_USB_EHCI_FSL is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_DWC2 is not set
+# CONFIG_USB_DWC3 is not set
+
+#
+# Legacy MUSB Support
+#
+# CONFIG_USB_MUSB_HCD is not set
+# CONFIG_USB_MUSB_UDC is not set
+# CONFIG_USB_DAVINCI is not set
+
+#
+# MUSB Controller Driver
+#
+# CONFIG_USB_MUSB_HOST is not set
+# CONFIG_USB_MUSB_GADGET is not set
+# CONFIG_USB_MUSB_TI is not set
+# CONFIG_USB_MUSB_AM35X is not set
+# CONFIG_USB_MUSB_DSPS is not set
+# CONFIG_USB_MUSB_PIO_ONLY is not set
+
+#
+# USB Phy
+#
+# CONFIG_TWL4030_USB is not set
+# CONFIG_OMAP_USB_PHY is not set
+# CONFIG_ROCKCHIP_USB2_PHY is not set
+
+#
+# ULPI drivers
+#
+
+#
+# USB peripherals
+#
 CONFIG_USB_STORAGE=y
+# CONFIG_USB_KEYBOARD is not set
+# CONFIG_USB_GADGET is not set
 CONFIG_USB_HOST_ETHER=y
 CONFIG_USB_ETHER_ASIX=y
+# CONFIG_USB_ETHER_ASIX88179 is not set
+# CONFIG_USB_ETHER_LAN75XX is not set
+# CONFIG_USB_ETHER_LAN78XX is not set
 CONFIG_USB_ETHER_MCS7830=y
 CONFIG_USB_ETHER_RTL8152=y
 CONFIG_USB_ETHER_SMSC95XX=y
+
+#
+# Graphics support
+#
+# CONFIG_DM_VIDEO is not set
+# CONFIG_SYS_WHITE_ON_BLACK is not set
+# CONFIG_NO_FB_CLEAR is not set
+
+#
+# TrueType Fonts
+#
+# CONFIG_VIDEO_VESA is not set
+# CONFIG_VIDEO_LCD_ANX9804 is not set
+# CONFIG_VIDEO_LCD_SSD2828 is not set
+# CONFIG_VIDEO_MVEBU is not set
+# CONFIG_I2C_EDID is not set
+# CONFIG_DISPLAY is not set
+# CONFIG_VIDEO_TEGRA20 is not set
+# CONFIG_VIDEO_BRIDGE is not set
+# CONFIG_VIDEO is not set
+# CONFIG_LCD is not set
+# CONFIG_VIDEO_SIMPLE is not set
+# CONFIG_VIDEO_DT_SIMPLEFB is not set
+
+#
+# Watchdog Timer Support
+#
+# CONFIG_BCM2835_WDT is not set
+# CONFIG_ULP_WATCHDOG is not set
+# CONFIG_WDT is not set
+# CONFIG_PHYS_TO_BUS is not set
+
+#
+# File systems
+#
+# CONFIG_FS_BTRFS is not set
+# CONFIG_FS_CBFS is not set
+CONFIG_FS_EXT4=y
+CONFIG_EXT4_WRITE=y
+CONFIG_FS_FAT=y
+# CONFIG_FAT_WRITE is not set
+CONFIG_FS_FAT_MAX_CLUSTSIZE=65536
+# CONFIG_FS_JFFS2 is not set
+# CONFIG_FS_CRAMFS is not set
+# CONFIG_YAFFS2 is not set
+
+#
+# Library routines
+#
+# CONFIG_BCH is not set
+# CONFIG_CC_OPTIMIZE_LIBS_FOR_SPEED is not set
+# CONFIG_DYNAMIC_CRC_TABLE is not set
+CONFIG_LIB_UUID=y
+CONFIG_SYS_HZ=1000
+# CONFIG_USE_TINY_PRINTF is not set
+# CONFIG_PANIC_HANG is not set
+CONFIG_REGEX=y
+# CONFIG_SPL_TINY_MEMSET is not set
+# CONFIG_TPL_TINY_MEMSET is not set
+# CONFIG_BITREVERSE is not set
+# CONFIG_CMD_DHRYSTONE is not set
+
+#
+# Security support
+#
+# CONFIG_AES is not set
+CONFIG_RSA=y
+# CONFIG_SPL_RSA is not set
+CONFIG_RSA_SOFTWARE_EXP=y
+# CONFIG_TPM is not set
+
+#
+# Hashing Support
+#
+CONFIG_SHA1=y
+CONFIG_SHA256=y
+# CONFIG_SHA_HW_ACCEL is not set
+CONFIG_MD5=y
+
+#
+# Compression Support
+#
+# CONFIG_LZ4 is not set
+CONFIG_LZMA=y
+# CONFIG_LZO is not set
+# CONFIG_SPL_LZO is not set
+# CONFIG_SPL_GZIP is not set
+# CONFIG_ERRNO_STR is not set
+CONFIG_OF_LIBFDT=y
+# CONFIG_OF_LIBFDT_OVERLAY is not set
+# CONFIG_SPL_OF_LIBFDT is not set
+# CONFIG_FDT_FIXUP_PARTITIONS is not set
+
+#
+# System tables
+#
+CONFIG_GENERATE_SMBIOS_TABLE=y
 CONFIG_SMBIOS_MANUFACTURER=""
+CONFIG_EFI_LOADER=y
+# CONFIG_EFI_LOADER_BOUNCE_BUFFER is not set
+# CONFIG_UNIT_TEST is not set
diff --git a/configs/mvebu_db_cn91xx_defconfig b/configs/mvebu_db_cn91xx_defconfig
new file mode 100644
index 0000000..119da4c
--- /dev/null
+++ b/configs/mvebu_db_cn91xx_defconfig
@@ -0,0 +1,95 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MVEBU=y
+CONFIG_SYS_TEXT_BASE=0x00000000
+CONFIG_SYS_MALLOC_F_LEN=0x2000
+CONFIG_TARGET_OCTEONTX2_CN913x=y
+CONFIG_MVEBU_SAR=y
+CONFIG_SMBIOS_PRODUCT_NAME=""
+CONFIG_DEBUG_UART=y
+CONFIG_AHCI=y
+CONFIG_DISTRO_DEFAULTS=y
+# CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
+CONFIG_BOOTCOMMAND="run get_images; run set_bootargs; booti $kernel_addr $ramfs_addr $fdt_addr"
+CONFIG_SYS_CONSOLE_ENV_OVERWRITE=y
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+# CONFIG_DISPLAY_CPUINFO is not set
+CONFIG_ARCH_EARLY_INIT_R=y
+CONFIG_ARCH_MISC_INIT=y
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_SYS_PROMPT="Marvell>> "
+CONFIG_CMD_MVEBU_SAR=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_FUSE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_USB=y
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_MVEBU_BUBT=y
+CONFIG_CMD_MVEBU_PHY_FW_DOWNLOAD=y
+CONFIG_CMD_MVEBU_HW_INFO=y
+CONFIG_CMD_MVEBU_RX_TRAINING=y
+CONFIG_CMD_REGULATOR=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_MAC_PARTITION=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_SCSI_AHCI=y
+CONFIG_AHCI_MVEBU=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_MVEBU_EFUSE=y
+CONFIG_MVEBU_EFUSE_READ_ONLY=y
+CONFIG_DM_GPIO=y
+CONFIG_DM_PCA953X=y
+CONFIG_DM_I2C=y
+CONFIG_SYS_I2C_MVTWSI=y
+CONFIG_MISC=y
+CONFIG_DM_MMC=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_XENON=y
+CONFIG_NAND=y
+CONFIG_NAND_PXA3XX=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_PHY_MARVELL=y
+CONFIG_PHY_GIGE=y
+CONFIG_E1000=y
+CONFIG_MVPP2=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_PCIE_DW_MVEBU=y
+CONFIG_MVEBU_COMPHY_SUPPORT=y
+CONFIG_PINCTRL=y
+CONFIG_PINCTRL_ARMADA_8K=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_DM_RTC=y
+CONFIG_MARVELL_RTC=y
+# CONFIG_SPL_SERIAL_PRESENT is not set
+CONFIG_DEBUG_UART_BASE=0xf0512000
+CONFIG_DEBUG_UART_CLOCK=200000000
+CONFIG_DEBUG_UART_SHIFT=2
+CONFIG_DEBUG_UART_ANNOUNCE=y
+CONFIG_SYS_NS16550=y
+CONFIG_KIRKWOOD_SPI=y
+CONFIG_DM_THERMAL=y
+CONFIG_MVEBU_THERMAL_SENSOR_28NM=y
+CONFIG_MVEBU_THERMAL_EXT_SENSOR_28NM=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_HOST_ETHER=y
+CONFIG_USB_ETHER_ASIX=y
+CONFIG_USB_ETHER_MCS7830=y
+CONFIG_USB_ETHER_RTL8152=y
+CONFIG_USB_ETHER_SMSC95XX=y
+CONFIG_SMBIOS_MANUFACTURER=""
diff --git a/configs/mvebu_espressobin-88f3720_defconfig b/configs/mvebu_espressobin-88f3720_defconfig
index 314d405..c2b6138 100644
--- a/configs/mvebu_espressobin-88f3720_defconfig
+++ b/configs/mvebu_espressobin-88f3720_defconfig
@@ -3,24 +3,26 @@ CONFIG_ARCH_MVEBU=y
 CONFIG_SYS_TEXT_BASE=0x00000000
 CONFIG_SYS_MALLOC_F_LEN=0x2000
 CONFIG_TARGET_MVEBU_ARMADA_37XX=y
-CONFIG_DEFAULT_DEVICE_TREE="armada-3720-espressobin"
 CONFIG_DEBUG_UART=y
 CONFIG_AHCI=y
 CONFIG_DISTRO_DEFAULTS=y
 # CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
+CONFIG_BOOTCOMMAND="run get_images; run set_bootargs; booti $kernel_addr $ramfs_addr $fdt_addr"
+CONFIG_SYS_CONSOLE_ENV_OVERWRITE=y
 CONFIG_SYS_CONSOLE_INFO_QUIET=y
 # CONFIG_DISPLAY_CPUINFO is not set
-# CONFIG_DISPLAY_BOARDINFO is not set
 CONFIG_ARCH_EARLY_INIT_R=y
 CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_SYS_PROMPT="Marvell>> "
 # CONFIG_CMD_FLASH is not set
+CONFIG_CMD_GPIO=y
 CONFIG_CMD_I2C=y
 CONFIG_CMD_MMC=y
+CONFIG_CMD_PCI=y
 CONFIG_CMD_SF=y
 CONFIG_CMD_SPI=y
 CONFIG_CMD_USB=y
 # CONFIG_CMD_SETEXPR is not set
-CONFIG_CMD_TFTPPUT=y
 CONFIG_CMD_CACHE=y
 CONFIG_CMD_TIME=y
 CONFIG_CMD_MVEBU_BUBT=y
@@ -28,7 +30,9 @@ CONFIG_CMD_EXT4_WRITE=y
 CONFIG_MAC_PARTITION=y
 CONFIG_ENV_IS_IN_SPI_FLASH=y
 CONFIG_SCSI_AHCI=y
+CONFIG_AHCI_MVEBU=y
 CONFIG_BLOCK_CACHE=y
+CONFIG_DM_GPIO=y
 CONFIG_DM_I2C=y
 CONFIG_MISC=y
 CONFIG_DM_MMC=y
@@ -40,9 +44,19 @@ CONFIG_SPI_FLASH_MACRONIX=y
 CONFIG_SPI_FLASH_SPANSION=y
 CONFIG_SPI_FLASH_STMICRO=y
 CONFIG_SPI_FLASH_WINBOND=y
-CONFIG_PHYLIB=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_ISSI=y
+CONFIG_MV88E6XXX_SWITCH=y
 CONFIG_PHY_GIGE=y
+CONFIG_E1000=y
+CONFIG_MVNETA=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_PCI_AARDVARK=y
 CONFIG_MVEBU_COMPHY_SUPPORT=y
+CONFIG_PINCTRL=y
+CONFIG_PINCTRL_ARMADA_37XX=y
+CONFIG_DM_REGULATOR_GPIO=y
 # CONFIG_SPL_SERIAL_PRESENT is not set
 CONFIG_DEBUG_MVEBU_A3700_UART=y
 CONFIG_DEBUG_UART_BASE=0xd0012000
diff --git a/configs/mvebu_mcbin-88f8040_defconfig b/configs/mvebu_mcbin-88f8040_defconfig
index e16a56e..23aa257 100644
--- a/configs/mvebu_mcbin-88f8040_defconfig
+++ b/configs/mvebu_mcbin-88f8040_defconfig
@@ -3,17 +3,20 @@ CONFIG_ARCH_MVEBU=y
 CONFIG_SYS_TEXT_BASE=0x00000000
 CONFIG_SYS_MALLOC_F_LEN=0x2000
 CONFIG_TARGET_MVEBU_ARMADA_8K=y
-CONFIG_DEFAULT_DEVICE_TREE="armada-8040-mcbin"
+CONFIG_MVEBU_SAR=y
 CONFIG_SMBIOS_PRODUCT_NAME=""
 CONFIG_DEBUG_UART=y
 CONFIG_AHCI=y
 CONFIG_DISTRO_DEFAULTS=y
 # CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
+CONFIG_BOOTCOMMAND="run get_images; run set_bootargs; booti $kernel_addr $ramfs_addr $fdt_addr"
+CONFIG_SYS_CONSOLE_ENV_OVERWRITE=y
 CONFIG_SYS_CONSOLE_INFO_QUIET=y
 # CONFIG_DISPLAY_CPUINFO is not set
-# CONFIG_DISPLAY_BOARDINFO is not set
 CONFIG_ARCH_EARLY_INIT_R=y
+CONFIG_ARCH_MISC_INIT=y
 CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_SYS_PROMPT="Marvell>> "
 # CONFIG_CMD_FLASH is not set
 CONFIG_CMD_GPIO=y
 CONFIG_CMD_I2C=y
@@ -23,15 +26,16 @@ CONFIG_CMD_SF=y
 CONFIG_CMD_SPI=y
 CONFIG_CMD_USB=y
 # CONFIG_CMD_SETEXPR is not set
-CONFIG_CMD_TFTPPUT=y
 CONFIG_CMD_CACHE=y
 CONFIG_CMD_TIME=y
 CONFIG_CMD_MVEBU_BUBT=y
+CONFIG_CMD_MVEBU_PHY_FW_DOWNLOAD=y
 CONFIG_CMD_REGULATOR=y
 CONFIG_CMD_EXT4_WRITE=y
 CONFIG_MAC_PARTITION=y
 CONFIG_ENV_IS_IN_SPI_FLASH=y
 CONFIG_SCSI_AHCI=y
+CONFIG_AHCI_MVEBU=y
 CONFIG_BLOCK_CACHE=y
 CONFIG_DM_GPIO=y
 CONFIG_DM_I2C=y
@@ -45,8 +49,10 @@ CONFIG_SPI_FLASH_MACRONIX=y
 CONFIG_SPI_FLASH_SPANSION=y
 CONFIG_SPI_FLASH_STMICRO=y
 CONFIG_SPI_FLASH_WINBOND=y
-CONFIG_PHYLIB=y
+CONFIG_PHY_MARVELL=y
 CONFIG_PHY_GIGE=y
+CONFIG_E1000=y
+CONFIG_MVPP2=y
 CONFIG_PCI=y
 CONFIG_DM_PCI=y
 CONFIG_PCIE_DW_MVEBU=y
@@ -54,6 +60,8 @@ CONFIG_MVEBU_COMPHY_SUPPORT=y
 CONFIG_PINCTRL=y
 CONFIG_PINCTRL_ARMADA_8K=y
 CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_RTC=y
+CONFIG_MARVELL_RTC=y
 # CONFIG_SPL_SERIAL_PRESENT is not set
 CONFIG_DEBUG_UART_BASE=0xf0512000
 CONFIG_DEBUG_UART_CLOCK=200000000
@@ -61,6 +69,9 @@ CONFIG_DEBUG_UART_SHIFT=2
 CONFIG_DEBUG_UART_ANNOUNCE=y
 CONFIG_SYS_NS16550=y
 CONFIG_KIRKWOOD_SPI=y
+CONFIG_DM_THERMAL=y
+CONFIG_MVEBU_THERMAL_SENSOR_28NM=y
+CONFIG_MVEBU_THERMAL_EXT_SENSOR_28NM=y
 CONFIG_USB=y
 CONFIG_DM_USB=y
 CONFIG_USB_XHCI_HCD=y
diff --git a/configs/mvebu_ocp-88f8040_defconfig b/configs/mvebu_ocp-88f8040_defconfig
new file mode 100644
index 0000000..ac17b40
--- /dev/null
+++ b/configs/mvebu_ocp-88f8040_defconfig
@@ -0,0 +1,70 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MVEBU=y
+CONFIG_SYS_TEXT_BASE=0x0
+CONFIG_SYS_MALLOC_F_LEN=0x2000
+CONFIG_TARGET_MVEBU_ARMADA_8K=y
+CONFIG_DEFAULT_DEVICE_TREE="armada-solidnet-ocp-8k"
+CONFIG_SMBIOS_PRODUCT_NAME=""
+CONFIG_DEBUG_UART=y
+CONFIG_AHCI=y
+CONFIG_DISTRO_DEFAULTS=y
+# CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
+CONFIG_BOOTCOMMAND="run get_images; run set_bootargs; booti $kernel_addr $ramfs_addr $fdt_addr"
+CONFIG_SYS_CONSOLE_ENV_OVERWRITE=y
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+# CONFIG_DISPLAY_CPUINFO is not set
+CONFIG_ARCH_EARLY_INIT_R=y
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_SYS_PROMPT="Marvell>> "
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_USB=y
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_MVEBU_BUBT=y
+CONFIG_CMD_REGULATOR=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_MAC_PARTITION=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_SCSI_AHCI=y
+CONFIG_AHCI_MVEBU=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_DM_GPIO=y
+CONFIG_DM_I2C=y
+CONFIG_SYS_I2C_MVTWSI=y
+CONFIG_MISC=y
+CONFIG_DM_MMC=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_XENON=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_PHY_MARVELL=y
+CONFIG_E1000=y
+CONFIG_MVPP2=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_PCIE_DW_MVEBU=y
+CONFIG_MVEBU_COMPHY_SUPPORT=y
+CONFIG_PINCTRL=y
+CONFIG_PINCTRL_ARMADA_8K=y
+CONFIG_DM_REGULATOR_FIXED=y
+# CONFIG_SPL_SERIAL_PRESENT is not set
+CONFIG_DEBUG_UART_BASE=0xf0512000
+CONFIG_DEBUG_UART_CLOCK=200000000
+CONFIG_DEBUG_UART_SHIFT=2
+CONFIG_DEBUG_UART_ANNOUNCE=y
+CONFIG_SYS_NS16550=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_SMBIOS_MANUFACTURER=""
diff --git a/configs/mvebu_ucpe-88f8040_defconfig b/configs/mvebu_ucpe-88f8040_defconfig
new file mode 100644
index 0000000..0cc507b
--- /dev/null
+++ b/configs/mvebu_ucpe-88f8040_defconfig
@@ -0,0 +1,104 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MVEBU=y
+CONFIG_SYS_TEXT_BASE=0x00000000
+CONFIG_SYS_MALLOC_F_LEN=0x2000
+CONFIG_TARGET_MVEBU_ARMADA_8K=y
+CONFIG_MVEBU_SYS_INFO=y
+CONFIG_MVEBU_SAR=y
+CONFIG_DEFAULT_DEVICE_TREE="armada-8040-ucpe"
+CONFIG_SMBIOS_PRODUCT_NAME=""
+CONFIG_DISTRO_DEFAULTS=y
+CONFIG_AHCI=y
+
+# CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+# CONFIG_DISPLAY_CPUINFO is not set
+CONFIG_ARCH_EARLY_INIT_R=y
+CONFIG_ARCH_MISC_INIT=y
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="Marvell>> "
+# CONFIG_CMD_IMLS is not set
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PART=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+# CONFIG_CMD_FPGA is not set
+CONFIG_CMD_GPIO=y
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_MVEBU_BUBT=y
+CONFIG_CMD_MVEBU_HW_INFO=y
+CONFIG_CMD_REGULATOR=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_MAC_PARTITION=y
+CONFIG_ISO_PARTITION=y
+CONFIG_EFI_PARTITION=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_DEVRES=y
+CONFIG_DM_SCSI=y
+CONFIG_MVEBU_SCSI=y
+CONFIG_SCSI_AHCI=y
+CONFIG_AHCI_MVEBU=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_DM_GPIO=y
+CONFIG_DM_I2C=y
+CONFIG_SYS_I2C_MVTWSI=y
+CONFIG_MISC=y
+CONFIG_MVEBU_MCI_INDIRECT_ACCESS=y
+CONFIG_DM_MMC=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_XENON=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_MV88E6XXX_SWITCH=y
+CONFIG_PHY_MARVELL=y
+CONFIG_PHY_GIGE=y
+CONFIG_E1000=y
+CONFIG_MVPP2=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_PCIE_DW_MVEBU=y
+CONFIG_MVEBU_COMPHY_SUPPORT=y
+CONFIG_PINCTRL=y
+CONFIG_PINCTRL_ARMADA_8K=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_RTC=y
+CONFIG_MVEBU_RTC=y
+# CONFIG_SPL_SERIAL_PRESENT is not set
+CONFIG_DEBUG_UART=y
+CONFIG_DEBUG_UART_BASE=0xf0512000
+CONFIG_DEBUG_UART_CLOCK=200000000
+CONFIG_DEBUG_UART_SHIFT=2
+CONFIG_DEBUG_UART_ANNOUNCE=y
+CONFIG_SYS_NS16550=y
+CONFIG_KIRKWOOD_SPI=y
+CONFIG_DM_THERMAL=y
+CONFIG_MVEBU_THERMAL_SENSOR_28NM=y
+CONFIG_MVEBU_THERMAL_EXT_SENSOR_28NM=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_HOST_ETHER=y
+CONFIG_USB_ETHER_ASIX=y
+CONFIG_USB_ETHER_MCS7830=y
+CONFIG_USB_ETHER_RTL8152=y
+CONFIG_USB_ETHER_SMSC95XX=y
+CONFIG_SMBIOS_MANUFACTURER=""
+
diff --git a/configs/octeontx2_95xx_defconfig b/configs/octeontx2_95xx_defconfig
new file mode 100644
index 0000000..c63d727
--- /dev/null
+++ b/configs/octeontx2_95xx_defconfig
@@ -0,0 +1,96 @@
+CONFIG_ARM=y
+# CONFIG_ARM64_SUPPORT_AARCH32 is not set
+CONFIG_ARCH_OCTEONTX2=y
+CONFIG_SYS_TEXT_BASE=0x04000000
+CONFIG_TARGET_OCTEONTX2_95XX=y
+CONFIG_DEBUG_UART=y
+CONFIG_FIT=y
+CONFIG_FIT_SIGNATURE=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_BOOTDELAY=5
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="console=ttyAMA0,115200n8 earlycon=pl011,0x87e028000000 maxcpus=6 rootwait rw root=/dev/mmcblk0p2 coherent_pool=16M"
+CONFIG_VERSION_VARIABLE=y
+# CONFIG_DISPLAY_CPUINFO is not set
+CONFIG_BOARD_EARLY_INIT_R=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="Marvell> "
+# CONFIG_CMD_BOOTEFI_HELLO_COMPILE is not set
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_MX_CYCLIC=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PART=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_TFTPPUT=y
+CONFIG_CMD_TFTPSRV=y
+CONFIG_CMD_RARP=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PXE=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CDP=y
+CONFIG_CMD_SNTP=y
+CONFIG_CMD_DNS=y
+CONFIG_CMD_LINK_LOCAL=y
+CONFIG_CMD_BOOTIMGUP=y
+CONFIG_CMD_ETH=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_OF_BOARD=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_DM_GPIO=y
+CONFIG_I2C_GPIO=y
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_MMC=y
+CONFIG_MMC_HS200_SUPPORT=y
+CONFIG_MMC_HS400_SUPPORT=y
+CONFIG_MMC_WRITE=y
+CONFIG_MMC_SUPPORTS_TUNING=y
+CONFIG_DM_MMC=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_DM_RTC=y
+CONFIG_RTC_DS1337=y
+CONFIG_MTD=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_4BAIS=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_DM_ETH=y
+CONFIG_NET_OCTEONTX2=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_DM_PCI_COMPAT=y
+CONFIG_PCI_OCTEONTX_ECAM=y
+CONFIG_DM_SERIAL=y
+CONFIG_DEBUG_UART_PL011=y
+CONFIG_DEBUG_UART_BASE=0x87e028000000
+CONFIG_DEBUG_UART_CLOCK=24000000
+CONFIG_DEBUG_UART_SKIP_INIT=y
+CONFIG_PL01X_SERIAL=y
+CONFIG_DM_SPI=y
+CONFIG_OCTEONTX_SPI=y
+CONFIG_FAT_WRITE=y
+CONFIG_ERRNO_STR=y
+CONFIG_CMD_SHA1SUM=y
+CONFIG_SHA1SUM_VERIFY=y
+CONFIG_CMD_MD5SUM=y
+CONFIG_MD5SUM_VERIFY=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_FAILSAFE=y
diff --git a/configs/octeontx2_96xx_defconfig b/configs/octeontx2_96xx_defconfig
new file mode 100644
index 0000000..3145740
--- /dev/null
+++ b/configs/octeontx2_96xx_defconfig
@@ -0,0 +1,126 @@
+CONFIG_ARM=y
+# CONFIG_ARM64_SUPPORT_AARCH32 is not set
+CONFIG_ARCH_OCTEONTX2=y
+CONFIG_SYS_TEXT_BASE=0x04000000
+CONFIG_TARGET_OCTEONTX2_96XX=y
+CONFIG_DEBUG_UART=y
+CONFIG_AHCI=y
+# CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
+CONFIG_FIT=y
+CONFIG_FIT_SIGNATURE=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_BOOTDELAY=5
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="console=ttyAMA0,115200n8 earlycon=pl011,0x87e028000000 maxcpus=24 rootwait rw root=/dev/mmcblk0p2 coherent_pool=16M"
+CONFIG_VERSION_VARIABLE=y
+# CONFIG_DISPLAY_CPUINFO is not set
+CONFIG_BOARD_EARLY_INIT_R=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="Marvell> "
+# CONFIG_CMD_BOOTEFI_HELLO_COMPILE is not set
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_MX_CYCLIC=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_MMC_HS200_SUPPORT=y
+CONFIG_MMC_HS400_SUPPORT=y
+CONFIG_MMC_WRITE=y
+CONFIG_MMC_SUPPORTS_TUNING=y
+CONFIG_MMC=y
+CONFIG_CMD_PART=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_TFTPPUT=y
+CONFIG_CMD_TFTPSRV=y
+CONFIG_CMD_RARP=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PXE=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CDP=y
+CONFIG_CMD_SNTP=y
+CONFIG_CMD_DNS=y
+CONFIG_CMD_LINK_LOCAL=y
+CONFIG_CMD_BOOTIMGUP=y
+CONFIG_CMD_ETH=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_OF_BOARD=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_SCSI_AHCI=y
+CONFIG_AHCI_PCI=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_NVME=y
+CONFIG_DM_GPIO=y
+CONFIG_I2C_GPIO=y
+CONFIG_DM_I2C=y
+CONFIG_I2C_SET_DEFAULT_BUS_NUM=y
+CONFIG_I2C_MUX=y
+CONFIG_I2C_MUX_PCA954x=y
+CONFIG_MISC=y
+CONFIG_MMC=y
+CONFIG_DM_MMC=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_MTD=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_4BAIS=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_PHYLIB=y
+CONFIG_PHY_MARVELL=y
+CONFIG_PHY_VITESSE=y
+CONFIG_DM_ETH=y
+CONFIG_E1000=y
+CONFIG_E1000_SPI=y
+CONFIG_CMD_E1000=y
+CONFIG_NET_OCTEONTX2=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_DM_PCI_COMPAT=y
+CONFIG_PCI_OCTEONTX_ECAM=y
+CONFIG_DM_RTC=y
+CONFIG_RTC_DS1337=y
+CONFIG_SCSI=y
+CONFIG_DM_SCSI=y
+CONFIG_DM_SERIAL=y
+CONFIG_DEBUG_UART_PL011=y
+CONFIG_DEBUG_UART_BASE=0x87e028000000
+CONFIG_DEBUG_UART_CLOCK=24000000
+CONFIG_DEBUG_UART_SKIP_INIT=y
+CONFIG_PL01X_SERIAL=y
+CONFIG_OCTEONTX_SERIAL_BOOTCMD=y
+CONFIG_DM_SPI=y
+CONFIG_OCTEONTX_SPI=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_PCI=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_HOST_ETHER=y
+CONFIG_USB_ETHER_ASIX=y
+CONFIG_USB_ETHER_ASIX88179=y
+CONFIG_USB_ETHER_RTL8152=y
+CONFIG_FAT_WRITE=y
+CONFIG_ERRNO_STR=y
+CONFIG_CMD_SHA1SUM=y
+CONFIG_SHA1SUM_VERIFY=y
+CONFIG_CMD_MD5SUM=y
+CONFIG_MD5SUM_VERIFY=y
+CONFIG_CMD_TIME=y
+CONFIG_CONSOLE_MUX=y
+CONFIG_SYS_CONSOLE_IS_IN_ENV=y
+CONFIG_CMD_FAILSAFE=y
diff --git a/configs/octeontx2_98xx_defconfig b/configs/octeontx2_98xx_defconfig
new file mode 100644
index 0000000..6bd0f05
--- /dev/null
+++ b/configs/octeontx2_98xx_defconfig
@@ -0,0 +1,121 @@
+CONFIG_ARM=y
+# CONFIG_ARM64_SUPPORT_AARCH32 is not set
+CONFIG_ARCH_OCTEONTX2=y
+CONFIG_SYS_TEXT_BASE=0x04000000
+CONFIG_TARGET_OCTEONTX2_98XX=y
+CONFIG_DEBUG_UART=y
+CONFIG_AHCI=y
+# CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
+CONFIG_FIT=y
+CONFIG_FIT_SIGNATURE=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_BOOTDELAY=5
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="console=ttyAMA0,115200n8 earlycon=pl011,0x87e028000000 maxcpus=36 rootwait rw root=/dev/mmcblk0p2 coherent_pool=16M"
+CONFIG_VERSION_VARIABLE=y
+# CONFIG_DISPLAY_CPUINFO is not set
+CONFIG_BOARD_EARLY_INIT_R=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="Marvell> "
+# CONFIG_CMD_BOOTEFI_HELLO_COMPILE is not set
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_MX_CYCLIC=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_MMC_HS200_SUPPORT=y
+CONFIG_MMC_HS400_SUPPORT=y
+CONFIG_MMC_WRITE=y
+CONFIG_MMC_SUPPORTS_TUNING=y
+CONFIG_MMC=y
+CONFIG_CMD_PART=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_TFTPPUT=y
+CONFIG_CMD_TFTPSRV=y
+CONFIG_CMD_RARP=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PXE=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CDP=y
+CONFIG_CMD_SNTP=y
+CONFIG_CMD_DNS=y
+CONFIG_CMD_LINK_LOCAL=y
+CONFIG_CMD_BOOTIMGUP=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_OF_BOARD=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_SCSI_AHCI=y
+CONFIG_AHCI_PCI=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_NVME=y
+CONFIG_DM_GPIO=y
+CONFIG_I2C_GPIO=y
+CONFIG_DM_I2C=y
+CONFIG_I2C_SET_DEFAULT_BUS_NUM=y
+CONFIG_I2C_MUX=y
+CONFIG_I2C_MUX_PCA954x=y
+CONFIG_MISC=y
+CONFIG_MMC=y
+CONFIG_DM_MMC=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_MTD=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_4BAIS=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_PHYLIB=y
+CONFIG_PHY_MARVELL=y
+CONFIG_PHY_VITESSE=y
+CONFIG_DM_ETH=y
+CONFIG_E1000=y
+CONFIG_E1000_SPI=y
+CONFIG_CMD_E1000=y
+CONFIG_NET_OCTEONTX2=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_DM_PCI_COMPAT=y
+CONFIG_PCI_OCTEONTX_ECAM=y
+CONFIG_DM_RTC=y
+CONFIG_RTC_DS1337=y
+CONFIG_SCSI=y
+CONFIG_DM_SCSI=y
+CONFIG_DM_SERIAL=y
+CONFIG_DEBUG_UART_PL011=y
+CONFIG_DEBUG_UART_BASE=0x87e028000000
+CONFIG_DEBUG_UART_CLOCK=24000000
+CONFIG_DEBUG_UART_SKIP_INIT=y
+CONFIG_PL01X_SERIAL=y
+CONFIG_DM_SPI=y
+CONFIG_OCTEONTX_SPI=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_PCI=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_HOST_ETHER=y
+CONFIG_USB_ETHER_ASIX=y
+CONFIG_USB_ETHER_ASIX88179=y
+CONFIG_USB_ETHER_RTL8152=y
+CONFIG_FAT_WRITE=y
+CONFIG_ERRNO_STR=y
+CONFIG_CMD_SHA1SUM=y
+CONFIG_SHA1SUM_VERIFY=y
+CONFIG_CMD_MD5SUM=y
+CONFIG_MD5SUM_VERIFY=y
+CONFIG_CMD_TIME=y
diff --git a/configs/octeontx2_loki_defconfig b/configs/octeontx2_loki_defconfig
new file mode 100644
index 0000000..25e33e7
--- /dev/null
+++ b/configs/octeontx2_loki_defconfig
@@ -0,0 +1,94 @@
+CONFIG_ARM=y
+# CONFIG_ARM64_SUPPORT_AARCH32 is not set
+CONFIG_ARCH_OCTEONTX2=y
+CONFIG_SYS_TEXT_BASE=0x04000000
+CONFIG_TARGET_OCTEONTX2_LOKI=y
+CONFIG_DEBUG_UART=y
+CONFIG_FIT=y
+CONFIG_FIT_SIGNATURE=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_BOOTDELAY=5
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="console=ttyAMA0,115200n8 earlycon=pl011,0x87e028000000 maxcpus=6 rootwait rw root=/dev/mmcblk0p2 coherent_pool=16M"
+CONFIG_VERSION_VARIABLE=y
+# CONFIG_DISPLAY_CPUINFO is not set
+CONFIG_BOARD_EARLY_INIT_R=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="Marvell> "
+# CONFIG_CMD_BOOTEFI_HELLO_COMPILE is not set
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_MX_CYCLIC=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PART=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_TFTPPUT=y
+CONFIG_CMD_TFTPSRV=y
+CONFIG_CMD_RARP=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PXE=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CDP=y
+CONFIG_CMD_SNTP=y
+CONFIG_CMD_DNS=y
+CONFIG_CMD_LINK_LOCAL=y
+CONFIG_CMD_BOOTIMGUP=y
+CONFIG_CMD_ETH=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_OF_BOARD=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_DM_GPIO=y
+CONFIG_I2C_GPIO=y
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_MMC=y
+CONFIG_MMC_HS200_SUPPORT=y
+CONFIG_MMC_HS400_SUPPORT=y
+CONFIG_MMC_WRITE=y
+CONFIG_MMC_SUPPORTS_TUNING=y
+CONFIG_DM_MMC=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_MTD=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_4BAIS=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_DM_ETH=y
+CONFIG_NET_OCTEONTX2=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_DM_PCI_COMPAT=y
+CONFIG_PCI_OCTEONTX_ECAM=y
+CONFIG_DM_SERIAL=y
+CONFIG_DEBUG_UART_PL011=y
+CONFIG_DEBUG_UART_BASE=0x87e028000000
+CONFIG_DEBUG_UART_CLOCK=24000000
+CONFIG_DEBUG_UART_SKIP_INIT=y
+CONFIG_PL01X_SERIAL=y
+CONFIG_DM_SPI=y
+CONFIG_OCTEONTX_SPI=y
+CONFIG_FAT_WRITE=y
+CONFIG_ERRNO_STR=y
+CONFIG_CMD_SHA1SUM=y
+CONFIG_SHA1SUM_VERIFY=y
+CONFIG_CMD_MD5SUM=y
+CONFIG_MD5SUM_VERIFY=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_FAILSAFE=y
diff --git a/configs/octeontx_81xx_defconfig b/configs/octeontx_81xx_defconfig
new file mode 100644
index 0000000..b119953
--- /dev/null
+++ b/configs/octeontx_81xx_defconfig
@@ -0,0 +1,127 @@
+CONFIG_ARM=y
+# CONFIG_ARM64_SUPPORT_AARCH32 is not set
+CONFIG_ARCH_OCTEONTX=y
+CONFIG_SYS_TEXT_BASE=0x500000
+CONFIG_TARGET_OCTEONTX_81XX=y
+CONFIG_DEBUG_UART=y
+CONFIG_AHCI=y
+CONFIG_FIT=y
+CONFIG_FIT_SIGNATURE=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_BOOTDELAY=5
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="console=ttyAMA0,115200n8 earlycon=pl011,0x87e028000000 maxcpus=4 rootwait rw root=/dev/sda2 coherent_pool=16M"
+CONFIG_VERSION_VARIABLE=y
+# CONFIG_DISPLAY_CPUINFO is not set
+CONFIG_BOARD_EARLY_INIT_R=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="Marvell> "
+# CONFIG_CMD_BOOTEFI_HELLO_COMPILE is not set
+CONFIG_CMD_MD5SUM=y
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_MX_CYCLIC=y
+CONFIG_CMD_SHA1SUM=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PART=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_TFTPPUT=y
+CONFIG_CMD_TFTPSRV=y
+CONFIG_CMD_RARP=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PXE=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CDP=y
+CONFIG_CMD_SNTP=y
+CONFIG_CMD_DNS=y
+CONFIG_CMD_LINK_LOCAL=y
+CONFIG_CMD_BOOTIMGUP=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_OF_BOARD=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_SCSI_AHCI=y
+CONFIG_AHCI_PCI=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_NVME=y
+CONFIG_DM_GPIO=y
+CONFIG_I2C_GPIO=y
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_MMC=y
+CONFIG_DM_MMC=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+# CONFIG_MMC_HS200_SUPPORT is not set
+# CONFIG_MMC_HS400_SUPPORT is not set
+CONFIG_MMC_WRITE=y
+# CONFIG_MMC_SUPPORTS_TUNING is not set
+CONFIG_MTD=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_4BAIS=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_SPI_FLASH_MTD=y
+CONFIG_PHYLIB=y
+CONFIG_PHYLIB_10G=y
+CONFIG_PHY_AQUANTIA=y
+CONFIG_PHY_BROADCOM=y
+CONFIG_PHY_MARVELL=y
+CONFIG_PHY_MICREL=y
+CONFIG_PHY_REALTEK=y
+CONFIG_PHY_VITESSE=y
+CONFIG_DM_ETH=y
+CONFIG_E1000=y
+CONFIG_E1000_SPI=y
+CONFIG_CMD_E1000=y
+CONFIG_NET_OCTEONTX=y
+CONFIG_OCTEONTX_SMI=y
+CONFIG_RTL8169=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_DM_PCI_COMPAT=y
+CONFIG_PCI_OCTEONTX_ECAM=y
+CONFIG_DM_RTC=y
+CONFIG_RTC_DS1307=y
+CONFIG_RTC_DS1337=y
+CONFIG_SCSI=y
+CONFIG_DM_SCSI=y
+CONFIG_DM_SERIAL=y
+CONFIG_DEBUG_UART_PL011=y
+CONFIG_DEBUG_UART_BASE=0x87e028000000
+CONFIG_DEBUG_UART_CLOCK=24000000
+CONFIG_DEBUG_UART_SKIP_INIT=y
+CONFIG_PL01X_SERIAL=y
+CONFIG_DM_SPI=y
+CONFIG_OCTEONTX_SPI=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_PCI=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_HOST_ETHER=y
+CONFIG_USB_ETHER_ASIX=y
+CONFIG_USB_ETHER_ASIX88179=y
+CONFIG_USB_ETHER_RTL8152=y
+CONFIG_FAT_WRITE=y
+CONFIG_ERRNO_STR=y
+CONFIG_CMD_SHA1SUM=y
+CONFIG_SHA1SUM_VERIFY=y
+CONFIG_CMD_MD5SUM=y
+CONFIG_MD5SUM_VERIFY=y
+CONFIG_CMD_TIME=y
diff --git a/configs/octeontx_83xx_defconfig b/configs/octeontx_83xx_defconfig
new file mode 100644
index 0000000..d7256b6
--- /dev/null
+++ b/configs/octeontx_83xx_defconfig
@@ -0,0 +1,124 @@
+CONFIG_ARM=y
+# CONFIG_ARM64_SUPPORT_AARCH32 is not set
+CONFIG_ARCH_OCTEONTX=y
+CONFIG_SYS_TEXT_BASE=0x2800000
+CONFIG_TARGET_OCTEONTX_83XX=y
+CONFIG_DEBUG_UART=y
+CONFIG_AHCI=y
+CONFIG_FIT=y
+CONFIG_FIT_SIGNATURE=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_BOOTDELAY=5
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="console=ttyAMA0,115200n8 earlycon=pl011,0x87e028000000 maxcpus=24 rootwait rw root=/dev/sda2 coherent_pool=16M"
+CONFIG_VERSION_VARIABLE=y
+# CONFIG_DISPLAY_CPUINFO is not set
+CONFIG_BOARD_EARLY_INIT_R=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="Marvell> "
+# CONFIG_CMD_BOOTEFI_HELLO_COMPILE is not set
+CONFIG_CMD_MD5SUM=y
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_MX_CYCLIC=y
+CONFIG_CMD_SHA1SUM=y
+# CONFIG_CMD_FLASH is not set
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PART=y
+CONFIG_CMD_PCI=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_TFTPPUT=y
+CONFIG_CMD_TFTPSRV=y
+CONFIG_CMD_RARP=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PXE=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CDP=y
+CONFIG_CMD_SNTP=y
+CONFIG_CMD_DNS=y
+CONFIG_CMD_LINK_LOCAL=y
+CONFIG_CMD_BOOTIMGUP=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_PARTITION_TYPE_GUID=y
+CONFIG_OF_BOARD=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_SCSI_AHCI=y
+CONFIG_AHCI_PCI=y
+CONFIG_BLOCK_CACHE=y
+CONFIG_NVME=y
+CONFIG_DM_GPIO=y
+CONFIG_I2C_GPIO=y
+CONFIG_DM_I2C=y
+CONFIG_MISC=y
+CONFIG_MMC=y
+CONFIG_DM_MMC=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+# CONFIG_MMC_HS200_SUPPORT is not set
+# CONFIG_MMC_HS400_SUPPORT is not set
+CONFIG_MMC_WRITE=y
+# CONFIG_MMC_SUPPORTS_TUNING is not set
+CONFIG_MTD=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_4BAIS=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_PHYLIB=y
+CONFIG_PHYLIB_10G=y
+CONFIG_PHY_AQUANTIA=y
+CONFIG_PHY_BROADCOM=y
+CONFIG_PHY_MARVELL=y
+CONFIG_PHY_MICREL=y
+CONFIG_PHY_REALTEK=y
+CONFIG_PHY_VITESSE=y
+CONFIG_DM_ETH=y
+CONFIG_E1000=y
+CONFIG_E1000_SPI=y
+CONFIG_CMD_E1000=y
+CONFIG_NET_OCTEONTX=y
+CONFIG_OCTEONTX_SMI=y
+CONFIG_RTL8169=y
+CONFIG_PCI=y
+CONFIG_DM_PCI=y
+CONFIG_DM_PCI_COMPAT=y
+CONFIG_PCI_OCTEONTX_ECAM=y
+CONFIG_DM_RTC=y
+CONFIG_RTC_DS1337=y
+CONFIG_SCSI=y
+CONFIG_DM_SCSI=y
+CONFIG_DM_SERIAL=y
+CONFIG_DEBUG_UART_PL011=y
+CONFIG_DEBUG_UART_BASE=0x87e028000000
+CONFIG_DEBUG_UART_CLOCK=24000000
+CONFIG_DEBUG_UART_SKIP_INIT=y
+CONFIG_PL01X_SERIAL=y
+CONFIG_DM_SPI=y
+CONFIG_OCTEONTX_SPI=y
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_PCI=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_HOST_ETHER=y
+CONFIG_USB_ETHER_ASIX=y
+CONFIG_USB_ETHER_ASIX88179=y
+CONFIG_USB_ETHER_RTL8152=y
+CONFIG_FAT_WRITE=y
+CONFIG_ERRNO_STR=y
+CONFIG_CMD_SHA1SUM=y
+CONFIG_SHA1SUM_VERIFY=y
+CONFIG_CMD_MD5SUM=y
+CONFIG_MD5SUM_VERIFY=y
diff --git a/configs/qemu-x86_64_defconfig b/configs/qemu-x86_64_defconfig
index d1ad802..2823583 100644
--- a/configs/qemu-x86_64_defconfig
+++ b/configs/qemu-x86_64_defconfig
@@ -27,7 +27,7 @@ CONFIG_SPL_SYS_MALLOC_SIMPLE=y
 CONFIG_SPL_CPU_SUPPORT=y
 CONFIG_SPL_ENV_SUPPORT=y
 CONFIG_SPL_NET_SUPPORT=y
-CONFIG_SPL_PCI_SUPPORT=y
+CONFIG_SPL_PCI=y
 CONFIG_SPL_PCH_SUPPORT=y
 CONFIG_SPL_RTC_SUPPORT=y
 CONFIG_HUSH_PARSER=y
diff --git a/configs/theadorable_debug_defconfig b/configs/theadorable_debug_defconfig
index 918447a..edecc42 100644
--- a/configs/theadorable_debug_defconfig
+++ b/configs/theadorable_debug_defconfig
@@ -57,6 +57,8 @@ CONFIG_MVNETA=y
 CONFIG_PCI=y
 CONFIG_DEBUG_UART_BASE=0xd0012000
 CONFIG_DEBUG_UART_CLOCK=250000000
+CONFIG_DM_PCI_COMPAT=y
+CONFIG_PCI_MVEBU=y
 CONFIG_DEBUG_UART_SHIFT=2
 CONFIG_SYS_NS16550=y
 CONFIG_KIRKWOOD_SPI=y
diff --git a/configs/thunderx_88xx_defconfig b/configs/thunderx_88xx_defconfig
deleted file mode 100644
index 891a417..0000000
--- a/configs/thunderx_88xx_defconfig
+++ /dev/null
@@ -1,29 +0,0 @@
-CONFIG_ARM=y
-CONFIG_TARGET_THUNDERX_88XX=y
-CONFIG_SYS_TEXT_BASE=0x00500000
-CONFIG_IDENT_STRING=" for Cavium Thunder CN88XX ARM v8 Multi-Core"
-CONFIG_DEFAULT_DEVICE_TREE="thunderx-88xx"
-CONFIG_DEBUG_UART=y
-CONFIG_BOOTDELAY=5
-CONFIG_USE_BOOTARGS=y
-CONFIG_BOOTARGS="console=ttyAMA0,115200n8 earlycon=pl011,0x87e024000000 debug maxcpus=48 rootwait rw root=/dev/sda2 coherent_pool=16M"
-# CONFIG_DISPLAY_CPUINFO is not set
-# CONFIG_DISPLAY_BOARDINFO is not set
-CONFIG_HUSH_PARSER=y
-# CONFIG_AUTO_COMPLETE is not set
-CONFIG_SYS_PROMPT="ThunderX_88XX> "
-# CONFIG_CMD_EXPORTENV is not set
-# CONFIG_CMD_IMPORTENV is not set
-# CONFIG_CMD_EDITENV is not set
-# CONFIG_CMD_SAVEENV is not set
-# CONFIG_CMD_ENV_EXISTS is not set
-# CONFIG_CMD_FLASH is not set
-# CONFIG_CMD_NET is not set
-# CONFIG_CMD_NFS is not set
-CONFIG_DM=y
-# CONFIG_MMC is not set
-CONFIG_DM_SERIAL=y
-CONFIG_DEBUG_UART_PL011=y
-CONFIG_DEBUG_UART_BASE=0x87e024000000
-CONFIG_DEBUG_UART_CLOCK=24000000
-CONFIG_DEBUG_UART_SKIP_INIT=y
diff --git a/configs/turris_omnia_defconfig b/configs/turris_omnia_defconfig
index 1c2eef0..0edb101 100644
--- a/configs/turris_omnia_defconfig
+++ b/configs/turris_omnia_defconfig
@@ -31,7 +31,6 @@ CONFIG_CMD_BTRFS=y
 CONFIG_ENV_IS_IN_SPI_FLASH=y
 CONFIG_SPL_OF_TRANSLATE=y
 CONFIG_SCSI_AHCI=y
-CONFIG_MISC=y
 CONFIG_ATSHA204A=y
 CONFIG_MMC_SDHCI=y
 CONFIG_MMC_SDHCI_MV=y
@@ -39,6 +38,8 @@ CONFIG_PHY_GIGE=y
 CONFIG_MVNETA=y
 CONFIG_DEBUG_UART_BASE=0xd0012000
 CONFIG_DEBUG_UART_CLOCK=250000000
+CONFIG_PCI=y
+CONFIG_PCI_MVEBU=y
 CONFIG_DEBUG_UART_SHIFT=2
 CONFIG_SYS_NS16550=y
 CONFIG_KIRKWOOD_SPI=y
diff --git a/doc/device-tree-bindings/mdio/marvell-mdio.txt b/doc/device-tree-bindings/mdio/marvell-mdio.txt
new file mode 100644
index 0000000..55db435
--- /dev/null
+++ b/doc/device-tree-bindings/mdio/marvell-mdio.txt
@@ -0,0 +1,18 @@
+* Marvell MDIO Ethernet Controller interface
+
+The Ethernet controllers of the Marvel Armada 3700 and Armada 7k/8k
+have an identical unit that provides an interface with the MDIO bus.
+This driver handles this MDIO interface.
+
+Mandatory properties:
+SoC specific:
+	- #address-cells: Must be <1>.
+	- #size-cells: Must be <0>.
+	- compatible: Should be "marvell,orion-mdio" (for SMI)
+				"marvell,xmdio"	     (for XSMI)
+	- reg: Base address and size SMI/XMSI bus.
+
+Optional properties:
+	- mdio-name       - MDIO bus name
+
+For example, please refer to "mdio-bus.txt".
diff --git a/doc/device-tree-bindings/mdio/mdio-bus.txt b/doc/device-tree-bindings/mdio/mdio-bus.txt
new file mode 100644
index 0000000..68d8b25
--- /dev/null
+++ b/doc/device-tree-bindings/mdio/mdio-bus.txt
@@ -0,0 +1,54 @@
+MDIO (Management Data Input/Output) busses
+
+MDIO busses can be described with a node for the MDIO master device
+and a set of child nodes for each phy on the bus.
+
+The MDIO node requires the following properties:
+- #address-cells  - number of cells required to define phy address on
+                    the MDIO bus.
+- #size-cells     - should be zero.
+- compatible      - name of MDIO bus controller following generic names
+                    recommended practice.
+- reg	          - address and length of the MDIO register.
+
+Optional property:
+- mdio-name       - MDIO bus name
+
+The child nodes of the MDIO driver are the individual PHY devices
+connected to this MDIO bus. They must have a "reg" property given the
+PHY address on the MDIO bus.
+- reg             - (required) phy address in MDIO bus.
+
+Example for cp110 MDIO node at the SoC level:
+	cp0_mdio: mdio@12a200 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "marvell,orion-mdio";
+		reg = <0x12a200 0x10>;
+		mdio-name = "cp0-mdio";
+	};
+
+	cp0_xmdio: mdio@12a600 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "marvell,xmdio";
+		reg = <0x12a600 0x200>;
+		mdio-name = "cp0-xmdio";
+	};
+
+And at the board level, example for armada-8040-mcbin board:
+	&cp0_mdio {
+		ge_phy: ethernet-phy@0 {
+			reg = <0>;
+		};
+	};
+
+	&cp0_xmdio {
+		phy0: ethernet-phy@0 {
+			reg = <0>;
+		};
+
+		phy8: ethernet-phy@8 {
+			reg = <8>;
+		};
+	};
diff --git a/doc/device-tree-bindings/mmc/xenon-mmc.txt b/doc/device-tree-bindings/mmc/xenon-mmc.txt
new file mode 100644
index 0000000..a5559b3
--- /dev/null
+++ b/doc/device-tree-bindings/mmc/xenon-mmc.txt
@@ -0,0 +1,46 @@
+* Marvell Xenon MMC controller
+This file documents the properties used by the sdhci-xenon drivers.
+
+Required properties:
+- compatible: Should be "marvell,armada-3700-sdhci".
+- reg: Base register offset for the SDHCI registers and pad control registers.
+- status: Enable or disable this node
+
+Optional properties:
+- bus-width: Number of data lines, can be <1>, <4>, or <8>.  The default
+  will be <1> if the property is absent.
+- vqmmc-supply: The signal voltage supplier for SDIO if needed. For example,
+  on port0 it needs a gpio regulator to supply signal voltage.
+- marvell,pad-type: The property indicates the pad tye for sdio port, for example,
+  the port1 is emmc and the pad type is fixed with voltage of 1.8V.
+
+Example:
+sdhci0: sdhci@d0000 {
+       compatible = "marvell,armada-3700-sdhci",
+       reg = <0xd0000 0x300
+              0x1e808 0x4>;
+       bus-width = <4>;
+       vqmmc-supply = <&vcc_sd_reg0>;
+       status = "disabled";
+};
+
+sdhci1: sdhci@d8000 {
+       compatible = "marvell,armada-3700-sdhci",
+       reg = <0xd8000 0x300
+              0x17808 0x4>;
+       bus-width = <8>;
+       marvell,pad-type = "fixed-1-8v";
+       status = "disabled";
+};
+
+The vqmmc-supply example on sdio port0:
+vcc_sd_reg0: regulator@0 {
+       compatible = "regulator-gpio";
+       regulator-name = "vcc_sd0";
+       regulator-min-microvolt = <1800000>;
+       regulator-max-microvolt = <3300000>;
+       regulator-type = "voltage";
+       states = <1800000 0x1
+                 3300000 0x0>;
+       gpios = <&gpio1 23 GPIO_ACTIVE_HIGH>;
+};
diff --git a/doc/device-tree-bindings/net/ethernet.txt b/doc/device-tree-bindings/net/ethernet.txt
index 3fc3605..ecea8f2 100644
--- a/doc/device-tree-bindings/net/ethernet.txt
+++ b/doc/device-tree-bindings/net/ethernet.txt
@@ -11,8 +11,8 @@ The following properties are common to the Ethernet controllers:
   the maximum frame size (there's contradiction in ePAPR).
 - phy-mode: string, operation mode of the PHY interface; supported values are
   "mii", "gmii", "sgmii", "qsgmii", "tbi", "rev-mii", "rmii", "rgmii", "rgmii-id",
-  "rgmii-rxid", "rgmii-txid", "rtbi", "smii", "xgmii"; this is now a de-facto
-  standard property;
+  "rgmii-rxid", "rgmii-txid", "rtbi", "smii", "xgmii", "sfi", "ap"; this is now
+  a de-facto standard property;
 - phy-connection-type: the same as "phy-mode" property but described in ePAPR;
 - phy-handle: phandle, specifies a reference to a node representing a PHY
   device; this property is described in ePAPR and so preferred;
diff --git a/doc/device-tree-bindings/phy/mvebu_comphy.txt b/doc/device-tree-bindings/phy/mvebu_comphy.txt
new file mode 100644
index 0000000..36ad013
--- /dev/null
+++ b/doc/device-tree-bindings/phy/mvebu_comphy.txt
@@ -0,0 +1,69 @@
+Marvell COMPHY SerDes lane bindings
+=====================================
+
+The COMPHY node includes a description of the COMPHY SerDes lane configuration.
+The COMPHY driver initializes the MUX of the SerDes lanes, and powers up the SerDes
+by dependencies on the FDT blob configurations
+
+Mandatory properties:
+SoC specific:
+	- compatible:
+		The compatible should include "marvell,mvebu-comphy"
+		and the COMPHY per chip compatible:
+		"marvell,comphy-cp110" for CP110 available in Aramda70x0/80x0.
+		The COMPHY per chip used to set which MUX configuration to use, and COMPHY power-up revision.
+	- reg: Base address and size of the COMPHY and hpipe units.
+	- max-lanes: Maximum number of comphy lanes.
+	- mux-bitcount: Number of bits that are allocated for every MUX in the COMPHY-selector register.
+Board specific:
+	- PHY: Entry that include the configuration of the PHY.
+	  Every PHY should have the below parameters:
+	  - phy-type: the mode of the PHY
+	    Possible modes located in include/dt-bindings/comphy/comphy_data.h
+	Optional properties:
+	  - phy-speed: the speed of the PHY
+	    Possible speeds values located in include/dt-bindings/comphy/comphy_data.h
+	  - phy-invert: Polarity invert (COMPHY_POLARITY_TXD_INVERT/COMPHY_POLARITY_RXD_INVERT)
+	    the possible bits under include/dt-bindings/comphy/comphy_data.h
+	  - clk-src: Set the clock source of PCIe, if configured to PCIe clock output
+	    This relevant for SerDes lane 5 only (by default, lane 4 is the clock source)
+	    for Armada-7040 boards.
+	  - endpoint: Optional boolean specifying this SerDes should be configured as PCIe endpoint.
+
+Example:
+	cpm_comphy: comphy@441000 {
+		compatible = "marvell,mvebu-comphy", "marvell,comphy-cp110";
+		reg = <0x441000 0x8>, <0x120000 0x8>;
+		mux-bitcount = <4>;
+		max-lanes = <6>;
+
+		/*
+		 * CP110 Serdes Configuration:
+		 * Lane 0: SGMII1
+		 * Lane 1: SATA 0
+		 * Lane 2: USB HOST 0
+		 * Lane 3: SATA1
+		 * Lane 4: SFI (10G)
+		 * Lane 5: SGMII2
+		 */
+		phy0 {
+			phy-type = <COMPHY_TYPE_SGMII1>;
+			phy-speed = <COMPHY_SPEED_1_25G>;
+		};
+		phy1 {
+			phy-type = <COMPHY_TYPE_SATA0>;
+		};
+		phy2 {
+			phy-type = <COMPHY_TYPE_USB3_HOST0>;
+		};
+		phy3 {
+			phy-type = <COMPHY_TYPE_SATA1>;
+		};
+		phy4 {
+			phy-type = <COMPHY_TYPE_SFI>;
+		};
+		phy5 {
+			phy-type = <COMPHY_TYPE_SGMII2>;
+		};
+	};
+
diff --git a/doc/device-tree-bindings/pinctrl/marvell,armada-37xx-pinctrl.txt b/doc/device-tree-bindings/pinctrl/marvell,armada-37xx-pinctrl.txt
new file mode 100644
index 0000000..86ec113
--- /dev/null
+++ b/doc/device-tree-bindings/pinctrl/marvell,armada-37xx-pinctrl.txt
@@ -0,0 +1,186 @@
+* Marvell Armada 37xx SoC pin and GPIO controller
+
+Each Armada 37xx SoC comes with two pin and GPIO controllers, one for the
+South Bridge and the other for the North Bridge.
+
+GPIO and pin controller:
+------------------------
+
+Main node:
+
+Refer to pinctrl-bindings.txt in this directory for details of the
+common pinctrl bindings used by client devices, including the meaning
+of the phrase "pin configuration node".
+
+Required properties for pinctrl driver:
+
+- compatible:	"marvell,armada3710-sb-pinctrl", "syscon, "simple-mfd"
+		for the South Bridge
+		"marvell,armada3710-nb-pinctrl", "syscon, "simple-mfd"
+		for the North Bridge
+- reg: The first set of registers is for pinctrl/GPIO and the second
+  set is for the interrupt controller
+- interrupts: list of interrupts used by the GPIO
+
+Available groups and functions for the North Bridge:
+
+group: jtag
+ - pins 20-24
+ - functions jtag, gpio
+
+group sdio0
+ - pins 8-10
+ - functions sdio, gpio
+
+group emmc_nb
+ - pins 27-35
+ - functions emmc, gpio
+
+group pwm0
+ - pin 11 (GPIO1-11)
+ - functions pwm, gpio
+
+group pwm1
+ - pin 12
+ - functions pwm, gpio
+
+group pwm2
+ - pin 13
+ - functions pwm, gpio
+
+group pwm3
+ - pin 14
+ - functions pwm, gpio
+
+group pmic1
+ - pin 7
+ - functions pmic, gpio
+
+group pmic0
+ - pin 6
+ - functions pmic, gpio
+
+group i2c2
+ - pins 2-3
+ - functions i2c, gpio
+
+group i2c1
+ - pins 0-1
+ - functions i2c, gpio
+
+group spi_cs1
+ - pin 17
+ - functions spi, gpio
+
+group spi_cs2
+ - pin 18
+ - functions spi, gpio
+
+group spi_cs3
+ - pin 19
+ - functions spi, gpio
+
+group onewire
+ - pin 4
+ - functions onewire, gpio
+
+group uart1
+ - pins 25-26
+ - functions uart, gpio
+
+group spi_quad
+ - pins 15-16
+ - functions spi, gpio
+
+group uart_2
+ - pins 9-10
+ - functions uart, gpio
+
+Available groups and functions for the South Bridge:
+
+group usb32_drvvbus0
+ - pin 36
+ - functions drvbus, gpio
+
+group usb2_drvvbus1
+ - pin 37
+ - functions drvbus, gpio
+
+group sdio_sb
+ - pins 60-65
+ - functions sdio, gpio
+
+group rgmii
+ - pins 42-53
+ - functions mii, gpio
+
+group pcie1
+ - pins 39-41
+ - functions pcie, gpio
+
+group smi
+ - pins 54-55
+ - functions smi, gpio
+
+group ptp
+ - pins 56-58
+ - functions ptp, gpio
+
+group ptp_clk
+ - pin 57
+ - functions ptp, mii
+
+group ptp_trig
+ - pin 58
+ - functions ptp, mii
+
+group mii_col
+ - pin 59
+ - functions mii, mii_err
+
+GPIO subnode:
+
+Please refer to gpio.txt in "gpio" directory for details of gpio-ranges property
+and the common GPIO bindings used by client devices.
+
+Required properties for the GPIO driver under the gpio subnode:
+- interrupts: List of interrupt specifiers for the controllers interrupt.
+- gpio-controller: Marks the device node as a GPIO controller.
+- #gpio-cells: Should be 2. The first cell is the GPIO number and the
+   second cell specifies GPIO flags, as defined in
+   <dt-bindings/gpio/gpio.h>. Only the GPIO_ACTIVE_HIGH and
+   GPIO_ACTIVE_LOW flags are supported.
+- gpio-ranges: Range of pins managed by the GPIO controller.
+
+Example:
+pinctrl_sb: pinctrl-sb@18800 {
+	compatible = "marvell,armada3710-sb-pinctrl",
+	"syscon", "simple-mfd";
+	reg = <0x18800 0x100>, <0x18C00 0x20>;
+	gpiosb: gpiosb {
+		#gpio-cells = <2>;
+		gpio-ranges = <&pinctrl_sb 0 0 30>;
+		gpio-controller;
+		interrupts =
+		<GIC_SPI 160 IRQ_TYPE_LEVEL_HIGH>,
+		<GIC_SPI 159 IRQ_TYPE_LEVEL_HIGH>,
+		<GIC_SPI 158 IRQ_TYPE_LEVEL_HIGH>,
+		<GIC_SPI 157 IRQ_TYPE_LEVEL_HIGH>,
+		<GIC_SPI 156 IRQ_TYPE_LEVEL_HIGH>;
+	};
+
+	rgmii_pins: mii-pins {
+		groups = "rgmii";
+		function = "mii";
+	};
+
+	sdio_pins: sdio-pins {
+		groups = "sdio_sb";
+		function = "sdio";
+	};
+
+	pcie_pins: pcie-pins {
+		groups = "pcie1";
+		function = "pcie";
+	};
+};
\ No newline at end of file
diff --git a/doc/device-tree-bindings/pinctrl/marvell,mvebu-pinctrl.txt b/doc/device-tree-bindings/pinctrl/marvell,mvebu-pinctrl.txt
index 5f86c0a..1fc1bc6 100644
--- a/doc/device-tree-bindings/pinctrl/marvell,mvebu-pinctrl.txt
+++ b/doc/device-tree-bindings/pinctrl/marvell,mvebu-pinctrl.txt
@@ -6,10 +6,10 @@ mpp pins or group of pins and a mpp function common to all pins.
 
 Required properties for the pinctrl driver:
 - compatible:	"marvell,mvebu-pinctrl",
-		"marvell,armada-ap806-pinctrl",
-		"marvell,a70x0-pinctrl",
-		"marvell,a80x0-cp0-pinctrl",
-		"marvell,a80x0-cp1-pinctrl"
+		"marvell,ap806-pinctrl",
+		"marvell,armada-7k-pinctrl",
+		"marvell,armada-8k-cpm-pinctrl",
+		"marvell,armada-8k-cps-pinctrl"
 - bank-name:	A string defining the pinc controller bank name
 - reg: 		A pair of values defining the pin controller base address
 		and the address space
@@ -31,7 +31,7 @@ Example:
 		config-space {
 			pinctl: pinctl@6F4000 {
 				compatible = "marvell,mvebu-pinctrl",
-					     "marvell,armada-ap806-pinctrl";
+					     "marvell,ap806-pinctrl";
 				bank-name ="apn-806";
 				reg = <0x6F4000 0x10>;
 				pin-count = <20>;
@@ -52,8 +52,8 @@ Example:
 		config-space {
 			cpm_pinctl: pinctl@44000 {
 				compatible = "marvell,mvebu-pinctrl",
-					     "marvell,a70x0-pinctrl",
-					     "marvell,a80x0-cp0-pinctrl";
+					     "marvell,armada-7k-pinctrl",
+					     "marvell,armada-8k-cpm-pinctrl";
 				bank-name ="cp0-110";
 				reg = <0x440000 0x20>;
 				pin-count = <63>;
@@ -89,7 +89,7 @@ Example:
 		config-space {
 			cps_pinctl: pinctl@44000 {
 				compatible = "marvell,mvebu-pinctrl",
-					     "marvell,a80x0-cp1-pinctrl";
+					     "marvell,armada-8k-cps-pinctrl";
 				bank-name ="cp1-110";
 				reg = <0x440000 0x20>;
 				pin-count = <63>;
diff --git a/doc/device-tree-bindings/regulator/regulator.txt b/doc/device-tree-bindings/regulator/regulator.txt
index 65b69c4..e86eb9c 100644
--- a/doc/device-tree-bindings/regulator/regulator.txt
+++ b/doc/device-tree-bindings/regulator/regulator.txt
@@ -35,6 +35,7 @@ Optional properties:
 - regulator-max-microamp: a maximum allowed Current value
 - regulator-always-on: regulator should never be disabled
 - regulator-boot-on: enabled by bootloader/firmware
+- regulator-force-boot-off: disabled during the boot stage
 
 Note
 The "regulator-name" constraint is used for setting the device's uclass
diff --git a/doc/device-tree-bindings/rtc/marvell-rtc.txt b/doc/device-tree-bindings/rtc/marvell-rtc.txt
new file mode 100644
index 0000000..cdc0d57
--- /dev/null
+++ b/doc/device-tree-bindings/rtc/marvell-rtc.txt
@@ -0,0 +1,23 @@
+* Real Time Clock of the Armada 7K/8K/3900 SoCs
+
+RTC controller for the Armada 7K/8K/3900 SoCs
+
+Required properties:
+- compatible : Should be one of the following:
+	"marvell,armada-8k-rtc" for Aramda 7K/8K/3900 SoCs
+- reg: a list of base address and size pairs, one for each entry in
+  reg-names
+- reg names: should contain:
+  * "rtc" for the RTC registers
+  * "rtc-soc" for the SoC related registers and among them the one
+    related to the interrupt.
+- interrupts: IRQ line for the RTC.
+
+Example:
+
+rtc@a8040 {
+	compatible = "marvell,armada-8k-rtc";
+	reg = <0xa8040 0x20>, <0x184a0 0x0c>;
+	reg-names = "rtc", "rtc-soc";
+	interrupts = <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>;
+};
diff --git a/doc/device-tree-bindings/spi/mvebu-spi.txt b/doc/device-tree-bindings/spi/mvebu-spi.txt
new file mode 100644
index 0000000..95840fd
--- /dev/null
+++ b/doc/device-tree-bindings/spi/mvebu-spi.txt
@@ -0,0 +1,73 @@
+Marvell SPI binding
+===================
+
+Binding for SPI Driver Marvell's Armada familiy SoCs (Apart from A37x0).
+
+Mandatory properties:
+SoC specific:
+- compatible: 		Should be one of the following options:
+				"marvell,armada-375-spi"
+				"marvell,armada-380-spi"
+				"marvell,armada-xp-spi"
+- reg:			Base address of SPI host controllers
+- reg : 		offset and length of the register set for the device.
+			This property can optionally have additional entries to configure
+			the SPI direct access mode that some of the Marvell SoCs support
+			additionally to the normal indirect access (PIO) mode. The values
+			for the MBus "target" and "attribute" are defined in the Marvell
+			SoC "Functional Specifications" Manual in the chapter "Marvell
+			Core Processor Address Decoding".
+			The register sets following the control registers refer to
+			chip-select lines 0 through n(n<=7) respectively.
+- clocks:		This property points to the used clock for the SPI interface.
+- cell-index:		SPI unit id.
+- #address-cells: 	Must be <1>, as required by generic SPI binding.
+- #size-cells:		Must be <0>, also as required by generic SPI binding.
+
+
+Board specific:
+- spi-max-frequency:	SPI max bus frequency.
+
+Example: For SPI-0 node:
+	cpm_spi0: spi@700600 {
+		compatible = "marvell,armada-380-spi";
+			reg = <0x700600 0x50>;
+			#address-cells = <0x1>;
+			#size-cells = <0x0>;
+			cell-index = <1>;
+			clocks = <&cpm_syscon0 0 3>;
+	};
+
+Example with SPI direct mode support in armada 7040 DB boards(optionally):
+	&cp0_spi1: spi@700680 {
+		compatible = "marvell,armada-380-spi";
+		pinctrl-names = "default";
+		pinctrl-0 = <&cp0_spi0_pins>;
+		reg = <0x700680 0x50>,		/* control */
+		      <0x2000000 0x1000000>,	/* CS0 */
+		      <0 0xffffffff>,		/* CS1 */
+		      <0 0xffffffff>,		/* CS2 */
+		      <0 0xffffffff>;		/* CS3 */
+		#address-cells = <1>;
+		#size-cells = <0>;
+		cell-index = <2>;
+	};
+
+To enable the direct mode, the board specific 'ranges' property needs
+to add the entries for the desired SPI controllers and its chip-selects
+that are used in the direct mode instead of PIO mode. Here an example
+for this (SPI controller 1, device 0 is used in direct mode. All other
+SPI device are used in the default indirect (PIO) mode):
+
+#define SPI_DIRECT_BASE                                (0xf9000000)
+
+	cp0 {
+		config-space {
+			/*
+			* Enable the SPI direct access by configuring an entry
+			* here in the board-specific ranges property
+			*/
+			ranges = <0x0 U64_TO_U32_H(CP110_BASE) U64_TO_U32_L(CP110_BASE) 0x2000000>,			/* internal regs */
+				 <0x2000000 U64_TO_U32_H(SPI_DIRECT_BASE) U64_TO_U32_L(SPI_DIRECT_BASE) 0x1000000>;	/* SPI1-DEV0 */
+		}
+	};
diff --git a/doc/device-tree-bindings/thermal/mvebu-thermal.txt b/doc/device-tree-bindings/thermal/mvebu-thermal.txt
new file mode 100644
index 0000000..ffa98e3
--- /dev/null
+++ b/doc/device-tree-bindings/thermal/mvebu-thermal.txt
@@ -0,0 +1,63 @@
+Marvell Thermal Sensor binding
+==============================
+
+The thermal node includes a description of the Thermal Sensor External Unit.
+The thernal sensor is an on-chip temperature sensor that reads the temperature of
+every core and returns the average or the maximum between them.
+
+Mandatory properties:
+SoC specific:
+	- compatible: should contain two compatibles:
+		- first: "marvell,mvebu-thermal"
+		- second: indicate the thermal sensor type
+		"marvell,thermal-sensor" or "marvell,thermal-ext-sensor"
+	- reg: the base address of thermal unit
+	- gain, offset: parameters of the temperature equation
+		which are:
+		T(in Celsius) = T(read value) * gain + offset
+
+	- divisor: the value that multiply with gain and offset; see Note.
+		Note: in the Tsen spec the default value of gain equals 0.425
+		In the u-boot we cannot calculate a real number (no floating point).
+		For this reason, set the gain and offset by multiplying them by divisor
+		value (usually 1000 or 10000).
+		This helps to calculate the equation; see example below.
+
+
+- In Armada80x0/70x0 there are 2 types of thermal sensor:
+	- regular sensor (integrated in CP)
+	- external sensor (integrated in AP)
+
+Example for external sensor (integrated in AP):
+
+The required calculation:
+T(in Celsius) = T(read value) * 0.425 + 153.4
+The calculation in u-boot:
+T(in Celsius) = (T(read value) * 425 + 153400) / 1000
+
+Example:
+	thermal: thermal@6f8084 {
+		compatible = "marvell,mvebu-thermal", "marvell,thermal-ext-sensor";
+		reg = <0x6f8084 0x12>;
+		gain = <425>;
+		offset = <153400>;
+		divisor = <1000>;
+		status = "okay";
+	};
+
+Example for regular sensor (integrated in CP):
+
+The required calculation:
+T(in Celsius) = T(read value) * 0.4761 - 279.1
+The calculation in u-boot:
+T(in Celsius) = (T(read value) * 4761 - 2791000) / 10000
+
+Example:
+	thermal@400070 {
+		compatible = "marvell,mvebu-thermal", "marvell,thermal-sensor";
+		reg = <0x400070 0x12>;
+		gain = <4761>;
+		offset = <2791000>;
+		divisor = <10000>;
+		status = "okay";
+	};
diff --git a/doc/device-tree-bindings/usb/marvell.ehci-usb.txt b/doc/device-tree-bindings/usb/marvell.ehci-usb.txt
new file mode 100644
index 0000000..3c26403
--- /dev/null
+++ b/doc/device-tree-bindings/usb/marvell.ehci-usb.txt
@@ -0,0 +1,22 @@
+Marvell SOC USB controllers
+
+This controller is integrated in Armada 3700.
+It uses the same properties as a generic EHCI host controller
+
+Required properties :
+ - compatible: should be one or more of:
+   - "marvell,armada3700-ehci", "marvell,orion-ehci"
+ - reg: should contain address and length of the standard EHCI
+   register set for the device.
+
+Optional properties:
+ - vbus-supply : If present, specifies the fixed regulator to be turned on
+   for providing power to the USB VBUS rail.
+
+Example:
+	usb2: usb@5e000 {
+		compatible = "marvell,armada3700-ehci";
+		reg = <0x5e000 0x450>;
+		vbus-supply = <&reg_usb2_vbus>;
+		status = "disabled";
+	};
\ No newline at end of file
diff --git a/doc/device-tree-bindings/usb/marvell.xhci-usb.txt b/doc/device-tree-bindings/usb/marvell.xhci-usb.txt
index e042d1b..6173404 100644
--- a/doc/device-tree-bindings/usb/marvell.xhci-usb.txt
+++ b/doc/device-tree-bindings/usb/marvell.xhci-usb.txt
@@ -15,6 +15,8 @@ Optional properties:
  - clocks: phandle to system controller clock driving this unit
  - vbus-supply : If present, specifies the fixed regulator to be turned on
    for providing power to the USB VBUS rail.
+ - current-limiter : If present, specifies the fixed regulator to be turned on
+   for providing current limitation to the USB.
 
 Example:
 	cpm_usb3_0: usb3@500000 {
@@ -24,5 +26,6 @@ Example:
 		interrupts = <GIC_SPI 62 IRQ_TYPE_LEVEL_HIGH>;
 		clocks = <&cpm_syscon0 1 22>;
 		vbus-supply = <&reg_usb3h0_vbus>;
+		current-limiter = <&reg_usb3h0_current_limiter>;
 		status = "disabled";
 	};
diff --git a/doc/mvebu/a3700/armada-3700-db-setup.txt b/doc/mvebu/a3700/armada-3700-db-setup.txt
new file mode 100644
index 0000000..5f82e32
--- /dev/null
+++ b/doc/mvebu/a3700/armada-3700-db-setup.txt
@@ -0,0 +1,76 @@
+Armada-3700 Development Board
+=============================
+
+The Armada-3700 Development Board (DB) is a configurable board designed to test
+several combinations of SOC configurations. U-BOOT supports a predefined set of
+those configurations via device tree files.
+
+.. _fig_a3700-ddr3-db:
+
+.. figure:: /images/a3700-ddr3-db.*
+   :align: center
+
+   DB-88F3720-DDR3-Modular Board (Rev2.x)
+
+.. _fig_a3700-ddr4-db:
+
+.. figure:: /images/a3700-ddr4-db.*
+   :align: center
+
+   DB-88F3720-DDR4-Modular Board (Rev3.x)
+
+There are two kinds of DBs, DB-88F3720-DDR3-Modular and DB-88F3720-DDR4-Modular, the only
+difference is DDR type: one is DDR3, the other is DDR4. They are identical concerning the
+following Board Physical Setups.
+
+This document describes the board modifications required to setup each configuration and the
+interfaces supported (or disabled in each one).
+
+To switch to a different configuration, follow the instructions in the "board setup" section.
+Once completed, build u-boot image with dts file of target configuration.
+
+Board Setup Options
+-------------------
+
++---------------+---------------------------------------+---------------------------------------+---------------------------------------+
+| Connector	| Setup-1: Default			| Setup-2: SGMII1			| Setup-3: SGMII1-SFP2.5G		|
++===============+=======================================+=======================================+=======================================+
+| CON14		| SDcard module		(SLM1505-v1)	| SDcard module		(SLM1505-v1)	| SDcard module		(SLM1505-v1)	|
++---------------+---------------------------------------+---------------------------------------+---------------------------------------+
+| CON15(PCIe)	| PCIe-mPCIe-Jumper: SLM-1496(Optional*)| PCIe-mPCIe-Jumper: SLM-1496(Optional*)| PCIe-mPCIe-Jumper: SLM-1496(Optional*)|
++---------------+---------------------------------------+---------------------------------------+---------------------------------------+
+| CON17		| SerDes-Jumper 	(SLM1502-v1)	| 88E1512 Module 	(SLM-1496-v1)	| 88F3720-2xSFP Module 	(SLM-1504-v1)	|
++---------------+---------------------------------------+---------------------------------------+---------------------------------------+
+| CON19		| 88E1512 Module 	(SLM-1496-v1)	| 88E1512 Module 	(SLM-1496-v1)	| 88E1512 Module 	(SLM-1496-v1)	|
++---------------+---------------------------------------+---------------------------------------+---------------------------------------+
+
+  * PCIe-mPCIe-Jumper is used to enable mini PCIe0 port (CON11)
+
+The table below summarizes the interface configuration of each setup.
+
++---------------+-------------------------------+-----------------------+-------------------------------+
+| DB File	| armada-3720-db-v(x)-A		| armada-3720-db-v(x)-B	| armada-3720-db-v(x)-C		|
++===============+===============================+=======================+===============================+
+| Interface	| Setup-1: Default		| Setup-2: SGMII1	| Setup-3: SGMII1-SFP2.5G	|
++---------------+-------------------------------+-----------------------+-------------------------------+
+| SerDes PHY0	| USB3_H0			| SGMII1		| SGMII1-SFP2.5G		|
++---------------+-------------------------------+-----------------------+-------------------------------+
+| SerDes PHY1	| PCIe0				| PCIe0			| PCIe0				|
++---------------+-------------------------------+-----------------------+-------------------------------+
+| SerDes PHY2	| SATA				| SATA			| SATA				|
++---------------+-------------------------------+-----------------------+-------------------------------+
+| SATA		| CON3				| CON3			| CON3				|
++---------------+-------------------------------+-----------------------+-------------------------------+
+| PCIe		| CON15				| CON15			| CON15				|
++---------------+-------------------------------+-----------------------+-------------------------------+
+| USB3		| CON29				| N/A			| N/A				|
++---------------+-------------------------------+-----------------------+-------------------------------+
+| SGMII1	| N/A				| PHY1 (CON17)		| PHY1 (CON17)			|
++---------------+-------------------------------+-----------------------+-------------------------------+
+| RGMII		| PHY0 (CON19)			| PHY0 (CON19)		| PHY0 (CON19)			|
++---------------+-------------------------------+-----------------------+-------------------------------+
+
+
+.. Note::
+	The armada-3720-ddr3-db-v2-A.dts is still named armada-3720-db.dts.
+	Because the armada-3720-db.dts is mainlined, the name must be kept.
diff --git a/doc/mvebu/a7k-a8k/armada3900-db-setup.txt b/doc/mvebu/a7k-a8k/armada3900-db-setup.txt
new file mode 100644
index 0000000..d9c16ed
--- /dev/null
+++ b/doc/mvebu/a7k-a8k/armada3900-db-setup.txt
@@ -0,0 +1,128 @@
+Armada-3900 Development Board Setup
+===================================
+
+The Armada 3900 Development Board are a series of configurable boards with different
+configuations for different purposes
+U-Boot supports a defined set of those configurations via different device tree files.
+
+This document describes the board modifications required to setup each configuration and the
+interfaces supported (or disabled in each one).
+
+To switch board configuration:
+1. Modify HW board settings according to the instructions in the "Board Setup" section below.
+2. Modify the Device tree file used by U-BOOT during compilation:
+   mvebu_db_armada8k_defconfig           - Choose Armada80x0/70x0 general defconfig
+   export DEVICE_TREE=<device_tree_name> - Choose specific device-tree
+
+Note:
+Booting Linux requires using the same Device Tree configuration as used in U-Boot.
+
+Board Setup Options
+~~~~~~~~~~~~~~~~~~~
+
++---------------+-----------------------+-----------------------+
+|		| 4: VD-A		| 4: VD-B		|
++===============+=======================+=======================+
+|Device tree	| armada-3900-vd-A.dts  | armada-3900-vd-B.dts	|
++---------------+-----------------------+-----------------------+
+
+The tables below summarize the interface configuration of each setup.
+
+SerDes Configuration
+~~~~~~~~~~~~~~~~~~~~
+
++---------------+---------------+---------------+
+| CP0 Lane	| 3: VD-A	| 4: VD-B	|
++===============+===============+===============+
+| 0		| PCIE0 (x1)    | PCIE0 (x1)    |
++---------------+---------------+---------------+
+| 1		| USB3_HOST0	| USB3_HOST0	|
++---------------+---------------+---------------+
+| 2		| SFI0 (5G)     | SFI0 (5G)	|
++---------------+---------------+---------------+
+| 3		| UNCONNECTED	| UNCONNECTED	|
++---------------+---------------+---------------+
+| 4		| SFI1 (5G)	| SGMII1 (1G)	|
++---------------+---------------+---------------+
+| 5		| PCIE2 (x1)    | PCIE2 (x1)    |
++---------------+---------------+---------------+
+
+Multi-purpose pin configurations
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
++---------------+---------------+---------------+
+|AP807 pin	| 1: VD-A	| 2: VD-B	|
++===============+===============+===============+
+|	AP-SDIO | N/C           | N/C           |
++---------------+---------------+---------------+
+|	AP-SPI0 | [0-3]         | [0-3]         |
++---------------+---------------+---------------+
+|	AP-I2C	| [4-5]		| [4-5]		|
++---------------+---------------+---------------+
+|	AP-UART0| [11,19]	| [11,19]	|
++---------------+---------------+---------------+
+
++---------------+---------------+---------------+
+|CP0 pin:	| 4: VD-A	| 5: VD-B	|
++===============+===============+===============+
+| CP-SPI1	| N/C		| N/C		|
++---------------+---------------+---------------+
+| NAND		| [13,15-27]	| [13,15-27]	|
++---------------+---------------+---------------+
+| SMI		| [32,34]	| [32,34]	|
++---------------+---------------+---------------+
+| XSMI		| [35-36]	| [35-36]	|
++---------------+---------------+---------------+
+| CP-I2C0	| N/C		| N/C		|
++---------------+---------------+---------------+
+| CP-I2C1	| [37-38]	| [37-38]	|
++---------------+---------------+---------------+
+| USB0_VDD	| [44]		| [44]		|
++---------------+---------------+---------------+
+| USB1_VDD	| [45]		| [45]		|
++---------------+---------------+---------------+
+| IHB_ENABLE	| [56]		| [56]		|
++---------------+---------------+---------------+
+| IHB_RESET	| [57]		| [57]		|
++---------------+---------------+---------------+
+| IOT_RESET	| N/C		| N/C		|
++---------------+---------------+---------------+
+| ETH-PHY-RESET	| N/C		| N/C		|
++---------------+---------------+---------------+
+| PPS-RESET	| N/C		| N/C		|
++---------------+---------------+---------------+
+| CP-UART1	| [46-47,49,58]	| [46-47,49,58]	|
++---------------+---------------+---------------+
+| CP-UART0	| [59-62]	| [59-62]	|
++---------------+---------------+---------------+
+
+Network configuration
+~~~~~~~~~~~~~~~~~~~~~
+
+Setup 4 (VD-A):
+
++---------------+-------+---------------+---------------+-------------------------------+
+| Interface	| CP#   | PPv2 Port     | GMAC Port     | Board Interface               |
++===============+=======+===============+===============+===============================+
+| eth0		| CP0   | eth0          | 0             | SFI (5G)             		|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth1		| CP0   | eth1          | 2             | SFI (5G)			|
++---------------+-------+---------------+---------------+-------------------------------+
+
+Setup 5 (VD-B):
+
++---------------+-------+---------------+---------------+-------------------------------+
+| Interface	| CP#   | PPv2 Port     | GMAC Port     | Board Interface               |
++===============+=======+===============+===============+===============================+
+| eth0		| CP0   | eth0          | 0             | SFI (5G)                      |
++---------------+-------+---------------+---------------+-------------------------------+
+| eth1		| CP0   | eth1          | 2             | SGMII1 (1G)                   |
++---------------+-------+---------------+---------------+-------------------------------+
+
+Notes:
+	- (*) eth0/serdes2 are expected to run with 5G speed but u-boot can't dynammically change the
+              serdes speed. It is configured with 1G and let Linux handle 5G task.
+	- Equivalent of this configuration can be viewed in arch/arm64/boot/dts/mvebu/armada-cpn110.dtsi
+	- eth0/1/2/3 may in fact be higher numbers, if prior eth_x interfaces already exist.
+
+
diff --git a/doc/mvebu/a7k-a8k/armada70x0-db-setup.txt b/doc/mvebu/a7k-a8k/armada70x0-db-setup.txt
new file mode 100644
index 0000000..fc306fa
--- /dev/null
+++ b/doc/mvebu/a7k-a8k/armada70x0-db-setup.txt
@@ -0,0 +1,229 @@
+Armada-70x0 Development Board Setup
+===================================
+
+The Armada 7040 Development Board (PCB: DB-88F7040-Modular) is a configurable board,
+designed to test several combinations of SoC configurations.
+U-Boot supports a defined set of those configurations via different device tree files.
+
+.. _fig_a70x0-db:
+
+.. figure:: /images/a70x0-db.*
+   :align: center
+
+   Armada-7040 Development Board
+
+This document describes the board modifications required to setup each configuration and the
+interfaces supported (or disabled in each one).
+
+To switch board configuration:
+1. Modify HW board settings according to the instructions in the "Board Setup" section below.
+2. Modify the Device tree file used by U-BOOT during compilation:
+   mvebu_db-88f8040_defconfig            - Choose Armada80x0/70x0 general defconfig
+   export DEVICE_TREE=<device_tree_name> - Choose specific device-tree
+
+Note:
+Booting Linux requires using the same Device Tree configuration as used in U-Boot.
+
+Board Setup Options
+~~~~~~~~~~~~~~~~~~~
+
++---------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|		| 1: A			| 2: B			| 3: C			| 4: D			| 4: E			|
++===============+=======================+=======================+=======================+=======================+=======================+
+|Device tree	| armada-7040-db.dts	| armada-7040-db-B.dts	| armada-7040-db-C.dts	| armada-7040-db-D.dts  |armada-7040-db-E.dts	|
++-----+---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+| CP0 | SW1:1	| ON			| OFF			| ON			| ON			| OFF                   |
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:2	| OFF			| ON			| OFF			| OFF			| OFF                   |
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:3	| ON			| ON			| ON			| ON			| ON                    |
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:4	| OFF			| ON			| OFF			| OFF			| OFF                   |
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:5	| OFF			| OFF			| OFF			| OFF			| OFF                   |
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:6	| ON			| ON			| ON			| ON			| ON                    |
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:7	| ON			| ON			| ON			| ON			| ON                    |
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:8	| OFF			| OFF			| OFF			| OFF			| OFF                   |
++-----+---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+
+DPR Setting
+~~~~~~~~~~~
+
++-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|			| 1: A			| 2: B			| 3: C			| 4: D			| 5: E			|
++=======================+=======================+=======================+=======================+=======================+=======================+
+| Mpp Jumper Module	| DPR all = 1-2		| DPR all = 1-2		| DPR 133-143:		| DPR 133,135,136,137:	| DPR133-143:		|
+| (SLM1548)		|			|			|   2-3 position	|   N/C			|   1-2 position	|
+|			|			|			|			| DPR 134:		| DPR144-147:		|
+|			|			|			|			|   2-3 postion		|   2-3 position	|
+|			|			|			|			| DPR 138-143:		|			|
+|			|			|			|			|   2-3 postion		|			|
++-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+| Serdess Jumper Module	| DPR152,153,154,155:	| DPR152,153,154,155:	| DPR152,153,154,155:	| DPR152,153,154,155:	| DPR152,153,154,155:	|
+| (SLM1547)		|   1-2 position	|   1-2 position	|   1-2 position	|   1-2 position	|   1-2 position	|
+|			| DPR148,149,150,151:	| DPR148,149,150,151:	| DPR148,149,150,151:	| DPR148,149,150,151:	| DPR148,149,150,151:	|
+|			|   2-3 position	|   1-2 position	|   1-2 position	|   1-2 position	|   1-2 position	|
++-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+| CP0 Serdess module	| SW1:			| SW1:			|  SW1:			| sW1:			| SW1:			|
+| (SLM1521)		|   (1,3,6,7)= ON	|   (2,3,4,5,6,7)= ON	|    (1,3,6,7)= ON	|   (1,3,6,7)= ON	|   (3,6,7)= ON		|
+|			|   (2,4,5,8)= OFF	|   (1,8)=OFF		|    (2,4,5,8)=OFF	|   (2,4,5,8)= OFF	|   (1,2,4,5,8)=OFF	|
+|			| DPR2,3,4,5:		| DPR2,3,4,5:		| DPR2,3,4,5:		| DPR2,3,4,5:		| DPR2,3,4,5:		|
+|			|   1-2 position	|    2-3 position	|     1-2 position	|   1-2 position	|   1-2 position	|
+|			|			|			|			| Disconnect CON9 (USB3 |			|
+|			|			|			|			| host plug type A)	|			|
+|			|			|			|			| Connect CON11 (marvell|			|
+|			|			|			|			| pn CON641)		|			|
+|			|			|			|			| Connect R126,127,119,	|			|
+|			|			|			|			| 122, 121, 117		|			|
++-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+| Install TDM Module	|			|			| on DB-7040 CON46	|			|			|
+| (SLM1448)		|			|			|			|			|			|
++-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+| Install Audio Module	|			|			|			| on DB-7040 CON46	|			|
+| (SLM1449)		|			|			|			|			|			|
++-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+| DB7040		|			|			|			| wire:			| DPR53-54: 1-2 position|
+|			|			|			|			|  from U36-1 to con47-2| DPR61: 2-3 position	|
+|			|			|			|			| DPR23 - NC		| DPR10-11 position 1-2	|
+|			|			|			|			|			| DPR12-15 position 1-2 |
++-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+
+The tables below summarizes the interface configuration of each setup
+
+SerDes Configuration
+~~~~~~~~~~~~~~~~~~~~
+
++---------------+---------------+---------------+---------------+---------------+---------------+
+| CP0 Lane	| 1: A		| 2: B		| 3: C		| 4: D		| 5: E		|
++===============+===============+===============+===============+===============+===============+
+| 0		| SGMII1	| PICE0 (x4)	| PCIE0 (x1)    | PCIE0 (x1)    | PCIE0 (x1)	|
++---------------+---------------+---------------+---------------+---------------+---------------+
+| 1		| USB3_HOST0	| PCIE0 (x4)	| SATA0		| USB3_DEVICE0  | SATA0		|
++---------------+---------------+---------------+---------------+---------------+---------------+
+| 2		| SFI0 (10G)	| PCIE0 (x4)	| SFI0 (10G)    | SFI0 (10G)	| SGMII0 (1G)	|
++---------------+---------------+---------------+---------------+---------------+---------------+
+| 3		| SATA1		| PCIE0 (x4)	| SATA1		| SATA1         | SATA1		|
++---------------+---------------+---------------+---------------+---------------+---------------+
+| 4		| USB3_HOST1	| USB3_HOST1	| USB3_HOST1    | USB3_HOST1    | USB_HOST1	|
++---------------+---------------+---------------+---------------+---------------+---------------+
+| 5		| PCIE2 (x1)	| PCIE2 (x1)	| PCIE2 (x1)    | PCIE2 (x1)    | PCIE2 (x1)	|
++---------------+---------------+---------------+---------------+---------------+---------------+
+
+- USB2_H0 (UTMI only)
+- USB2_H1 (UTMI & USB3 SerDes)
+
+
+Multi-purpose pin configurations
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
++---------------+---------------+---------------+---------------+---------------+---------------+
+|AP806 pin	| 1: A		| 2: B		| 3: C		| 4: D		| 5: E		|
++===============+===============+===============+===============+===============+===============+
+|	AP-SDIO | [0-5]		| [0-5]		| [0-5]         | [0-5]		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+
+|	AP-SPI0 | N/C		| N/C		| N/C		| N/C		| [0-3]		|
++---------------+---------------+---------------+---------------+---------------+---------------+
+|	AP-I2C	| N/C		| N/C		| N/C		| N/C		| [4,5]		|
++---------------+---------------+---------------+---------------+---------------+---------------+
+|	AP-UART0| [11,19]	| [11,19]	| [11,19]       | [11,19]	| [11,19]	|
++---------------+---------------+---------------+---------------+---------------+---------------+
+
++---------------+---------------+---------------+---------------+---------------+---------------+
+|CP0 pin:	| 1: A		| 3: B		| 3: C		| 4: D		| 5: E		|
++===============+===============+===============+===============+===============+===============+
+| CP-SPI0	| N/C		| N/C		| [6-11]	| N/C		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+
+| CP-SPI1	| [13-16]	| [13-16]	| [13-16]	| N/C		| [13-16]	|
++---------------+---------------+---------------+---------------+---------------+---------------+
+| NAND		| N/C		| N/C		| N/C		| [15-27]	| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+
+| RGMII1	| [0-11]	| [0-11]	| N/C		| N/C		| [0-11]	|
++---------------+---------------+---------------+---------------+---------------+---------------+
+| RGMII2	| N/C		| [44-55]	| [44-55]	| [44-55]	| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+
+| CP-UART0	| [29-30]	| [29-30]	| [29-30]	| [29-30]	| [29-30]	|
++---------------+---------------+---------------+---------------+---------------+---------------+
+| CP-UART1	| N/C		| N/C		| N/C		| N/C		| [47,49-51]	|
++---------------+---------------+---------------+---------------+---------------+---------------+
+| SD		| [56-61]	| [56-61]	| [56-61]	| [56-61]	| [54,56-61]	|
++---------------+---------------+---------------+---------------+---------------+---------------+
+| GPIO		| [62]		| [62]		| [62]		| [62]		| [62]		|
++---------------+---------------+---------------+---------------+---------------+---------------+
+| TDM		| N/C		| N/C		| [0-5]		| N/C		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+
+| TWSI		| [37-38]	| [37-38]	| [37-38]	| [37-38]	| [37-38]	|
++---------------+---------------+---------------+---------------+---------------+---------------+
+| SATA0		| N/C		| N/C		| N/C		| N/C		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+
+| SATA1		| [28]		| [28]		| [28]		| [28]		| [28]		|
++---------------+---------------+---------------+---------------+---------------+---------------+
+| SMI		| [32,34]	| [32,34]	| [32,34]	| [32,34]	| [32,34]	|
++---------------+---------------+---------------+---------------+---------------+---------------+
+| XSMI		| [35-36]	| [35-36]	| [35-36]	| [35-36]	| [35-36]	|
++---------------+---------------+---------------+---------------+---------------+---------------+
+| USB_DEV	| N/C		| N/C		| N/C		| [7]		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+
+
+Network configuration
+~~~~~~~~~~~~~~~~~~~~~
+
+Setup 1 (A):
+
++---------------+-------+---------------+---------------+-------------------------------+
+| Interface	| CP#	| PPv2 Port	| GMAC Port	| Board Interface		|
++===============+=======+===============+===============+===============================+
+| eth0		| CP0	| eth0		| 0		| 10G (Lane 2 connected to SFP) |
++---------------+-------+---------------+---------------+-------------------------------+
+| eth1		| CP0	| eth1		| 2		| SGMII1			|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth2		| CP0	| eth2		| 3		| RGMII2			|
++---------------+-------+---------------+---------------+-------------------------------+
+
+Setup 2 (B):
+
++---------------+-------+---------------+---------------+-------------------------------+
+| Interface	| CP#   | PPv2 Port     | GMAC Port     | Board Interface               |
++===============+=======+===============+===============+===============================+
+| eth0		| CP0   | eth0          | 2             | RGMII1                        |
++---------------+-------+---------------+---------------+-------------------------------+
+| eth1		| CP0   | eth1          | 3             | RGMII2                        |
++---------------+-------+---------------+---------------+-------------------------------+
+
+Setup 3 (C):
+
++---------------+-------+---------------+---------------+-------------------------------+
+| Interface	| CP#   | PPv2 Port     | GMAC Port     | Board Interface               |
++===============+=======+===============+===============+===============================+
+| eth0		| CP0   | eth0          | 0             | 10G (Lane 2 connected to SFP) |
++---------------+-------+---------------+---------------+-------------------------------+
+| eth1		| CP0   | eth1          | 3             | RGMII2                        |
++---------------+-------+---------------+---------------+-------------------------------+
+
+Setup 4 (D):
+
++---------------+-------+---------------+---------------+-------------------------------+
+| Interface	| CP#   | PPv2 Port     | GMAC Port     | Board Interface               |
++===============+=======+===============+===============+===============================+
+| eth0		| CP0   | eth0          | 0             | 10G (Lane 2 connected to SFP) |
++---------------+-------+---------------+---------------+-------------------------------+
+| eth1		| CP0   | eth1          | 3             | RGMII2                        |
++---------------+-------+---------------+---------------+-------------------------------+
+
+Setup 5 (E)
+
++---------------+-------+---------------+---------------+-------------------------------+
+| Interface	| CP#   | PPv2 Port     | GMAC Port     | Board Interface               |
++===============+=======+===============+===============+===============================+
+| eth0		| CP0   | eth0          | 0             | SGMII0 (1G)                   |
++---------------+-------+---------------+---------------+-------------------------------+
+| eth1		| CP0   | eth1          | 2             | RGMII1                        |
++---------------+-------+---------------+---------------+-------------------------------+
+
+Notes:
+	- Equivalent of this configuration can be viewed in arch/arm64/boot/dts/mvebu/armada-cpn110.dtsi
+	- eth0/1/2/3 may in fact be higher numbers, if prior eth_x interfaces already exist.
+
+
diff --git a/doc/mvebu/a7k-a8k/armada80x0-db-setup.txt b/doc/mvebu/a7k-a8k/armada80x0-db-setup.txt
new file mode 100644
index 0000000..38a5f50
--- /dev/null
+++ b/doc/mvebu/a7k-a8k/armada80x0-db-setup.txt
@@ -0,0 +1,307 @@
+Armada-80x0 Development Board Setup
+===================================
+
+The Armada 8040 Development Board (PCB: DB-88F8040-Modular) is a configurable board,
+designed to test several combinations of SoC configurations.
+U-Boot supports a defined set of those configurations via different device tree files.
+
+.. _fig_a80x0-db:
+
+.. figure:: /images/a80x0-db.*
+   :align: center
+
+   Armada-8040 Development Board
+
+This document describes the board modifications required to setup each configuration and the
+interfaces supported (or disabled in each one).
+
+To switch board configuration:
+1. Modify HW board settings according to the instructions in the "Board Setup" section below.
+2. Modify the Device tree file used by U-BOOT during compilation:
+   mvebu_db-88f8040_defconfig		 - Choose Armada80x0/70x0 general defconfig
+   export DEVICE_TREE=<device_tree_name> - Choose specific device-tree
+
+Note:
+Booting Linux requires using the same Device Tree configuration as used in U-Boot.
+
+Warning:
+The PCIe x4 + SFI 10G configuration (H) requires usage of IO card SLM-1521-v2.
+
+Board Setup Options
+-------------------
+
++---------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|		| 1: A			| 2: B			| 3: C			| 4: D			| 5: E			| 6: F			| 7: G			| 8: H (SLM-1521-v2)	|
++===============+=======================+=======================+=======================+=======================+=======================+=======================+=======================+=======================+
+|Device tree	|armada-8040-db.dtb	|armada-8040-db-B.dtb	|armada-8040-db-C.dtb	|armada-8040-db-D.dtb	|armada-8040-db-E.dtb	|armada-8040-db-F.dtb	|armada-8040-db-G.dtb	|armada-8040-db-H.dtb	|
++-----+---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+| CP0 | SW1:1	| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| ON			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:2	| OFF			| ON			| OFF			| OFF			| OFF			| OFF			| ON			| ON			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:3	| OFF			| ON			| OFF			| OFF			| OFF			| OFF			| ON			| OFF			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:4	| OFF			| ON			| OFF			| OFF			| OFF			| OFF			| ON			| ON			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:5	| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| ON			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:6	| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| ON			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:7	| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| ON			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:8	| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			|
++-----+---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+| CP1 | SW1:1	| OFF			| ON			| OFF			| OFF			| OFF			| OFF			| OFF			| ON			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:2	| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| ON			| ON			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:3	| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| ON			| OFF			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:4	| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| ON			| ON			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:5	| ON			| ON			| ON			| ON			| ON			| ON			| OFF			| ON			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:6	| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| ON			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:7	| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| ON			|
+|     +---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+|     | SW1:8	| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			| OFF			|
++-----+---------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+-----------------------+
+
+DPR Setting
+~~~~~~~~~~~
+
++-----------------------------------------------+---------------+---------------+-----------------------+-----------------------+-------------------------------+---------------+---------------+---------------+
+|						| 1: A		| 2: B		| 3: C			| 4: D			| 5: E				| 6: F		| 7: G		| 8: H		|
++===============================================+===============+===============+=======================+=======================+===============================+===============+===============+===============+
+| Jumper-module (CON44): SLM1564		| DPR all = 1-2	| DPR all = 1-2	| DPR 96-101 = 2-3,	| DPR 96-101 = 2-3,	| DPR 109-112 = 2-3,		| DPR all = 1-2	|DPR all = 1-2	|DPR all = 1-2	|
+|						|		|		| DPR 103-108 = 2-3,	| DPR 103-108 = 2-3,	| others = 1-2			|		|		|		|
+|						|		|		| DPR 102 = 1-2		| DPR 102 = 1-2		|				|		|		|		|
++-----------------------------------------------+---------------+---------------+-----------------------+-----------------------+-------------------------------+---------------+---------------+---------------+
+| Serdes CP0 site module (CON42): SLM1521	| DPR 2-5 = 1-2	| DPR 2-5 = 2-3	| DPR 2-5 = 1-2		|DPR 2-5 = 1-2		| DPR 2-5 = 1-2			| DPR 2-5 = 1-2	| DPR 2-5 = 2-3	| DPR 2-5 = 1-2	|
++-----------------------------------------------+---------------+---------------+-----------------------+-----------------------+-------------------------------+---------------+---------------+---------------+
+| Serdes CP1 site module (CON41): SLM1521	| DPR 2-5 = 1-2	| DPR 2-5 = 1-2	| DPR 2-5 = 1-2		|DPR 2-5 = 1-2		| DPR 2-5 = 1-2			| DPR 2-5 = 1-2	| DPR 2-5 = 1-2	| DPR 2-5 = 1-2	|
++-----------------------------------------------+---------------+---------------+-----------------------+-----------------------+-------------------------------+---------------+---------------+---------------+
+| DB8040					|		|		| DPR 84 = 2-3		| DPR 76 = 1-2,		| DPR 81 = 2-3,			|		|		|		|
+|						|		|		| TDM module (CON51):	| DPR 87-88 = 2-3	| DPR 23-26,119,121 =1-2	|		|		|		|
+|						|		|		| SLM1448		| Audio module (CON51):	|				|		|		|		|
+|						|		|		|			| SLM1449		|				|		|		|		|
++-----------------------------------------------+---------------+---------------+-----------------------+-----------------------+-------------------------------+---------------+---------------+---------------+
+
+The tables below summarizes the interface configuration of each setup
+
+
+SerDes Configurations
+~~~~~~~~~~~~~~~~~~~~~
+
++---------------+---------------+---------------+---------------+---------------+---------------+-----------------------+---------------+---------------+
+| CP0 Lane	| 1: A		| 2: B		| 3: C		| 4: D		| 5: E		| 6: F			| 7: G		| 8: H		|
++===============+===============+===============+===============+===============+===============+=======================+===============+===============+
+| 0		| PCIe0 (x1)	| PCIe0 (x4)	| PCIe0 (x1)	| PCIe0 (x1)	| PCIe0 (x1)	| PCIe0 (x1)		| PCIe0 (x4)	| PCIe0 (x4)	|
++---------------+---------------+---------------+---------------+---------------+---------------+-----------------------+---------------+---------------+
+| 1		| SATA0		| PCIe0 (x4)	| SATA0		| SATA0		| SATA0		| SATA0			| PCIe0 (x4)	| PCIe0 (x4)	|
++---------------+---------------+---------------+---------------+---------------+---------------+-----------------------+---------------+---------------+
+| 2		| SFI0 (10G)	| PCIe0 (x4)	| SFI0 (10G)	| SFI0 (10G)	| SFI0 (10G)	| AP (802.3 auto-neg)	| PCIe0 (x4)	| PCIe0 (x4)	|
++---------------+---------------+---------------+---------------+---------------+---------------+-----------------------+---------------+---------------+
+| 3		| SATA1		| PCIe0 (x4)	| SATA1		| SATA1		| SATA1		| SATA1			| PCIe0 (x4)	| PCIe0 (x4)	|
++---------------+---------------+---------------+---------------+---------------+---------------+-----------------------+---------------+---------------+
+| 4		| USB3_HOST1	| USB3_HOST1	| USB3_HOST1	| USB3_HOST1	| USB3_HOST1	| USB3_HOST1		| USB3_HOST1	| SFI1 (10G)	|
++---------------+---------------+---------------+---------------+---------------+---------------+-----------------------+---------------+---------------+
+| 5		| PCIe2 (x1)	| PCIe2 (x1)	| PCIe2 (x1)	| PCIe2 (x1)	| PCIe2 (x1)	| PCIe2 (x1)		| PCIe2 (x1)	|PCIe2 (x1)	|
++---------------+---------------+---------------+---------------+---------------+---------------+-----------------------+---------------+---------------+
+
+- USB2_H0 (UTMI only)
+- USB2_H1 (UTMI & USB3 SerDes)
+
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| CP1 Lane	| 1: A		| 2: B		| 3: C		| 4: D		| 5: E		| 6: F		| 7: G		| 8: H		|
++===============+===============+===============+===============+===============+===============+===============+===============+===============+
+| 0		| PCIe0 (x1)	| PCIe0 (x1)	| PCIe0 (x1)	| PCIe0 (x1)	| PCIe0 (x1)	| PCIe0 (x1)	| PCIe0 (x4)	| PCIe0 (x4)	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| 1		| SATA0		| USB3_HOST0	| SATA0		| SATA0		| SATA0		| SATA0		| PCIe0 (x4)	| PCIe0 (x4)	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| 2		| SFI0 (10G)	| SFI0 (10G)	| SFI0 (10G)	| SGMII0	| SGMII0 (2.5G)	| SFI0 (10G)	| PCIe0 (x4)	| PCIe0 (x4)	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| 3		| SATA1		| SATA1		| SATA1		| SATA1		| SATA1		| SATA1		| PCIe0 (x4)	| PCIe0 (x4)	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| 4		| PCIe1 (x1)	| PCIe1 (x1)	| PCIe1 (x1)	| PCIe1 (x1)	| PCIe1 (x1)	| PCIe1 (x1)	| USB3_HOST1	| SFI1 (10G)	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| 5		| PCIe2 (x1)	| PCIe2 (x1)	| PCIe2 (x1)	| PCIe2 (x1)	| PCIe2 (x1)	| PCIe2 (x1)	| PCIe2 (x1)	| PCIe2 (x1)	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+
+- USB2_H0 (UTMI only)
+
+
+Multi-purpose pin configurations
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| AP806 pin	| 1: A		| 2: B		| 3: C		| 4: D		| 5: E		| 6: F		| 7: G		| 8: H		|
++===============+===============+===============+===============+===============+===============+===============+===============+===============+
+|    AP-SDIO	| [0-10]	| [0-10]	| [0-10]	| [0-10]	| N/C		| [0-10]	| [0-10]	| [0-10]	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|    I2C0	| N/C		| N/C		| N/C		| N/C		| N/C		| N/C		| N/C		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|    AP-SPI0	| N/C		| N/C		| N/C		| N/C		| [0,3]		| N/C		| N/C		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|    AP-UART0	| [11,19]	| [11,19]	| [11,19]	| [11,19]	| [11,19]	| [11,19]	| [11,19]	| [11,19]	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| CP0 pin	| 1: A		| 2: B		| 3: C		| 4: D		| 5: E		| 6: F		| 7: G		| 8: H		|
++===============+===============+===============+===============+===============+===============+===============+===============+===============+
+|   CP0-SMI	| [32,34]	| [32,34]	| [32,34]	| [32,34]	| N/C		| [32,34]	| [32,34]	| [32,34]	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP0-XSMI	| [42-43]	| [42-43]	| [42-43]	| [42-43]	| [42-43]	| [42-43]	| [42-43]	| [42-43]	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP0-TWSI	| [37-38]	| [37-38]	| [37-38]	| [37-38]	| [37-38]	| [37-38]	| [37-38]	| [37-38]	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP0-SATA1	| [40]		| [40]		| [40]		| [40]		| [40]		| [40]		| [40]		| [40]		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP0-SATA0	| [41]		| [41]		| [41]		| [41]		| [41]		| [41]		| [41]		| [41]		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP0-RGMII2	| [44-55]	| [44-55]	| [44-55]	| [44-55]	| N/C		| [44-55]	| [44-55]	| [44-55]	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP0-SD	| [56-62]	| [56-62]	| [56-62]	| [56-62]	| [56-62]	| [56-62]	| [56-62]	| [56-62]	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP0-PTP_CLK	| [39]		| [39]		| [39]		| [39]		| [39]		| [39]		| [39]		| [39]		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP0-TWSI1	| N/C		| N/C		| N/C		| N/C		| [35-36]	| N/C		| N/C		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP0-UART1	| N/C		| N/C		| N/C		| N/C		| [47,49]	| N/C		| N/C		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP0-UART2	| N/C		| N/C		| N/C		| N/C		| [50-51]	| N/C		| N/C		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+
+GPIOS:
+	- 33: GPIO: GE_INT#/push button/Wake
+	- 35: MSS_GPIO[3]: MSS_PWDN (only in configuration 1,3,4,5)
+	- 36: MSS_GPIO[5]: MSS_VTT_EN (only in configuration 1,3,4,5)
+
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+| CP1 pin	| 1: A		| 2: B		| 3: C		| 4: D		| 5: E		| 6: F		| 7: G		| 8: H		|
++===============+===============+===============+===============+===============+===============+===============+===============+===============+
+|   CP1-RGMII1	| [0-11]	| [0-11]	| N/C		| N/C		| [0-11]	| [0-11]	| [0-11]	| [0-11]	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP1-SMI	| [27,31]	| [27,31]	| N/C		| N/C		| [27,31]	| [27,31]	| [27,31]	| [27,31]	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP1-SPI1	| [13-16]	| [13-16]	| [13-16]	| N/C		| [13-16]	| [13-16]	| [13-16]	| [13-16]	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP1-UART0	| [29-30]	| [29-30]	| [29-30]	| [29-30]	| [29-30]	| [29-30]	| [29-30]	| [29-30]	|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP1-SATA1	| [28]		| [28]		| [28]		| [28]		| [28]		| [28]		| [28]		| [28]		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP1-SATA0	| N/C		| N/C		| [27]		| N/C		| N/C		| N/C		| N/C		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP1-AU	| N/C		| N/C		| N/C		| [0-5]		| N/C		| N/C		| N/C		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP1-NAND	| N/C		| N/C		| N/C		| [13,15-27]	| N/C		| N/C		| N/C		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+|   CP1-TDM	| N/C		| N/C		| [0-11]	| N/C		| N/C		| N/C		| N/C		| N/C		|
++---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
+
+Network configuration
+~~~~~~~~~~~~~~~~~~~~~
+
+Setup 1 (A):
+
++---------------+-------+---------------+---------------+-------------------------------+
+| Interface	| CP#	| PPv2 Port	| GMAC Port	| Board Interface		|
++===============+=======+===============+===============+===============================+
+| eth0		| 0	| 0		| 0		| 10G (Lane 2 connected to SFP)	|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth1		| 0	| 2		| 3		| RGMII2			|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth2		| 1	| 0		| 0		| 10G (Lane 2 connected to SFP)	|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth3		| 1	| 1		| 2		| RGMII1			|
++---------------+-------+---------------+---------------+-------------------------------+
+
+Setup 2 (B):
+
++---------------+-------+---------------+---------------+-------------------------------+
+| Interface	| CP#	| PPv2 Port	| GMAC Port	| Board Interface		|
++===============+=======+===============+===============+===============================+
+| eth0		| 0	| 2		| 3		| RGMII2			|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth1		| 1	| 0		| 0		| 10G (Lane 2 connected to SFP)	|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth2		| 1	| 1		| 2		| RGMII1			|
++---------------+-------+---------------+---------------+-------------------------------+
+
+Setup 3 (C):
+
++---------------+-------+---------------+---------------+-------------------------------+
+| Interface	| CP#	| PPv2 Port	| GMAC Port	| Board Interface		|
++===============+=======+===============+===============+===============================+
+| eth0		| 0	| 0		| 0		| 10G (Lane 2 connected to SFP)	|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth1		| 0	| 2		| 3		| RGMII2			|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth2		| 1	| 0		| 0		| 10G (Lane 2 connected to SFP)	|
++---------------+-------+---------------+---------------+-------------------------------+
+
+Setup 4 (D):
+
++---------------+-------+---------------+---------------+-------------------------------+
+| Interface	| CP#	| PPv2 Port	| GMAC Port	| Board Interface		|
++===============+=======+===============+===============+===============================+
+| eth0		| 0	| 0		| 0		| 10G (Lane 2 connected to SFP)	|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth1		| 0	| 2		| 3		| RGMII2			|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth2		| 1	| 0		| 0		| SGMII0			|
++---------------+-------+---------------+---------------+-------------------------------+
+
+Setup 5 (E):
+
++---------------+-------+---------------+---------------+-------------------------------+
+| Interface	| CP#	| PPv2 Port	| GMAC Port	| Board Interface		|
++===============+=======+===============+===============+===============================+
+| eth0		| 0	| 0		| 0		| 10G (Lane 2 connected to SFP)	|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth1		| 1	| 0		| 0		| 2.5G SGMII0			|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth2		| 1	| 1		| 2		| RGMII1			|
++---------------+-------+---------------+---------------+-------------------------------+
+
+Setup 6 (F):
+
++---------------+-------+---------------+---------------+-----------------------------------------------+
+| Interface	| CP#	| PPv2 Port	| GMAC Port	| Board Interface				|
++===============+=======+===============+===============+===============================================+
+| eth0		| 0	| 0		| 0		| AP (Lane 2 left for 802.3 auto-negotiation)	|
++---------------+-------+---------------+---------------+-----------------------------------------------+
+| eth1		| 0	| 2		| 3		| RGMII2					|
++---------------+-------+---------------+---------------+-----------------------------------------------+
+| eth2		| 1	| 0		| 0		| 10G (Lane 2 connected to SFI)			|
++---------------+-------+---------------+---------------+-----------------------------------------------+
+| eth3		| 1	| 1		| 2		| RGMII1					|
++---------------+-------+---------------+---------------+-----------------------------------------------+
+
+Setup 7 (G):
+
++---------------+-------+---------------+---------------+-------------------------------+
+| Interface	| CP#	| PPv2 Port	| GMAC Port	| Board Interface		|
++===============+=======+===============+===============+===============================+
+| eth0		| 0	| 2		| 3		| RGMII2			|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth1		| 1	| 1		| 2		| RGMII1			|
++---------------+-------+---------------+---------------+-------------------------------+
+
+Setup 8 (H):
+
++---------------+-------+---------------+---------------+-------------------------------+
+| Interface	| CP#	| PPv2 Port	| GMAC Port	| Board Interface		|
++===============+=======+===============+===============+===============================+
+| eth0		| 0	| 0		| 0		| 10G (Lane 4 connected to SFP)	|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth1		| 0	| 2		| 3		| RGMII2			|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth2		| 1	| 0		| 0		| 10G (Lane 4 connected to SFP)	|
++---------------+-------+---------------+---------------+-------------------------------+
+| eth3		| 1	| 1		| 2		| RGMII1			|
++---------------+-------+---------------+---------------+-------------------------------+
+
+Notes:
+	- eth0/1/2/3 may in fact be higher numbers, if prior eth_x interfaces already exist.
diff --git a/doc/mvebu/build.txt b/doc/mvebu/build.txt
new file mode 100644
index 0000000..30b0388
--- /dev/null
+++ b/doc/mvebu/build.txt
@@ -0,0 +1,210 @@
+U-Boot Build Instructions
+=========================
+
+This document describes how to compile U-Boot and how to change U-Boot
+configuration. The are 2 methods to compile u-boot:
+
+1. Using prepared scripts
+
+2. Manual compilation
+
+Both methods will be described in this documents.
+
+System preparations (for both methods)
+--------------------------------------
+1. Install required packages::
+
+		> sudo apt-get install libssl-dev
+		> sudo apt-get install device-tree-compiler
+		> sudo apt-get install swig libpython-dev
+
+2. Set the cross compiler::
+
+		> export CROSS_COMPILE=/path/to/toolchain/aarch64-linux-gnu
+
+Build with scripts
+------------------
+The script is located in the u-boot tree **./scripts/ci/**
+
+Script usage::
+
+		> ./scripts/ci/compile.sh --help
+
+		Usage: compile [--no_configure] [--echo_only] BUILD_NAME
+		 or:   compile --list
+		 or:   compile --help
+
+		Compiles u-boot similar to the given CI build
+
+		 -N, --no_configure   Skip configuration steps (mrproper, make defconfig)
+		 -e, --echo_only      Print out the compilation sequence but do not execute it
+		 -l, --list           List all supported BUILD_NAME values and exit
+		 -h, --help           Display this help and exit
+
+		Prerequisites:       CROSS_COMPILE must point to the cross compiler
+
+Examples::
+
+		MacchiatoBin build: ./scripts/ci/compile.sh uboot_2018_a80x0_mcbin
+
+Manual build procedure
+----------------------
+1. Clean-up old residuals::
+
+		> make mrproper
+
+2. Configure the U-Boot::
+
+		> make <defconfig_file>
+
+   - For the ARMADA 70x0/80x0/3900 DB board and ARMADA 7020 AMC use
+     "make mvebu_db_armada8k_defconfig"
+   - For the ARMADA 80x0 MacchiatoBin use "make mvebu_mcbin-88f8040_defconfig"
+   - For the ARMADA 3700 DB board use "make mvebu_db-88f3720_defconfig"
+   - For the ARMADA 3700 EsspressoBin use "make mvebu_espressobin-88f3720_defconfig"
+   - For the OcteonTX2 CN913x DB board use "make mvebu_db_cn91xx_defconfig"
+
+3. Configure the device-tree and build the U-Boot image:
+
+	All device-tree files are located in ./arch/arm/dts/ folder.
+	Information about the different configuration available for the
+	development board is located in:
+
+	- For ARMADA 37x0: ./doc/mvebu/a3700/armada-3700-db-setup.txt
+	- For ARMADA 70x0: ./doc/mvebu/a7k-a8k/armada70x0-db-setup.txt
+	- For ARMADA 80x0: ./doc/mvebu/a7k-a8k/armada80x0-db-setup.txt
+	- For ARMADA 3900: ./doc/mvebu/a7k-a8k/armada3900-db-setup.txt
+
+	In order to compile u-boot with a specific device-tree,
+	use the following::
+
+		> make DEVICE_TREE=<name>
+
+	- For the ARMADA 3900 DB use "make DEVICE_TREE=armada-3900-vd[-X]"
+	- For the ARMADA 70x0 DB use "make DEVICE_TREE=armada-7040-db[-X]"
+	- For the ARMADA 7020 AMC use "make DEVICE_TREE=armada-7020-amc"
+	- For the ARMADA 80x0 DB use "make DEVICE_TREE=armada-8040-db[-X]"
+	- For the ARMADA 37x0 DB use "make DEVICE_TREE=armada-3720-ddrX-db[-X]"
+	  (X represents possible board configuration)
+	- For the EspressoBin board without soldered eMMC device use
+	  "make DEVICE_TREE=armada-3720-espressobin"
+	- For the EspressoBin board with populated eMMC device use
+	  "make DEVICE_TREE=armada-3720-espressobin-emmc"
+	- For the ARMADA 80x0 MacchiatoBin use
+	  "make DEVICE_TREE=armada-8040-mcbin"
+	- For the ARMADA 80x0 MacchiatoBin Single Shot use
+	  "make DEVICE_TREE=armada-8040-mcbin-single-shot"
+	- For the OcteonTX2 CN913x DB use "make DEVICE_TREE=cn913[X]-A"
+
+	The U-Boot compilation generates u-boot.bin - the U-Boot image
+
+	.. Note::
+		The u-boot.bin should not be used as a stand-alone image.
+		The ARM Trusted Firmware (ATF) build process uses this image to
+		generate the flash image.
+
+
+Configuration Update
+---------------------
+To update the U-Boot configuration, refer to doc/README.kconfig
+
+
+Boot Device Selection
+---------------------
+The following options are available:
+	- Boot from SPI boot
+	- Boot from eMMC boot
+
+eMMC Boot Device
+-----------------
+The ARMADA 3700, ARMADA 7K/8K/3900 and OcteonTX2 CN913x support eMMC as the boot
+device on the target.
+The default boot device on this platform is SPI NOR flash.
+In order to change the boot device to eMMC, set the following parameter
+the default configuration::
+
+	- CONFIG_MVEBU_MMC_BOOT=y
+	- CONFIG_ENV_IS_IN_MMC=y
+	- Remove any other CONFIG_ENV_IS_IN_* occurrences in defconfig file
+
+If "menuconfig" is used, navigate to the following location::
+
+	-> Command line interface
+	  -> Misc commands
+	    -> MVEBU commands
+	      -> Flash for image
+
+and select "eMMC flash boot" for the boot device, then select the device for the
+environment location):
+
+	-> Command line interface
+	  -> Environment
+	    -> Environment in an MMC device
+
+The eMMC has 2 boot partitions (BOOT0 and BOOT1) and a user data partition
+(DATA).
+The boot partitions are numbered as partition 1 and 2 in MMC driver.
+Number 0 is used for user data partition and should not be utilized for storing
+boot images and U-Boot environment in RAW mode since it will break file system
+structures usually located here.
+
+The default boot partition is BOOT0. It is selected by the following parameter:
+CONFIG_SYS_MMC_ENV_PART=1
+Valid values for this parameter are 1 for BOOT0 and 2 for BOOT1.
+Never use partition number 0 here!
+
+If select SD card as boot device, the Macro parameter should be::
+
+	#define CONFIG_SYS_MMC_ENV_PART		0
+
+If select eMMC as boot device, the Macro parameter should be::
+
+	#define CONFIG_SYS_MMC_ENV_PART		1
+or::
+
+	#define CONFIG_SYS_MMC_ENV_PART         2
+
+The parameter CONFIG_SYS_MMC_ENV_DEV depends on total number of enabled eMMC
+interfaces on board, the AP interface is enumerated first, then CP interface.
+
+For example on board with eMMC interface on both AP and CP::
+
+If select AP's SD card/eMMC as boot device, the Macro parameter should be::
+
+	#define CONFIG_SYS_MMC_ENV_DEV         0
+
+If select CP's SD card/eMMC as boot device, the Macro parameter should be::
+
+	#define CONFIG_SYS_MMC_ENV_DEV         1
+
+Both parameters can be changed in the "include/configs/mvebu_armadacommon.h".
+
+Note that this configuration is only available when "Flash for image"
+selects "eMMC flash boot" device as described above.
+The selected partition will be used by U-Boot "bubt" and "savenv" commands
+for flashing the boot image and saving U-Boot configuration.
+
+
+Boot Device Selection for ARMADA 7K/8K/3900 and OcteonTX2 CN913x Build
+----------------------------------------------------------------------
+The following options are available for A8K, A7K, A3900 and OcteonTX2 CN913x boot:
+
+	- Boot from SPI NAND
+
+SPI NAND Boot Device
+--------------------
+The ARMADA-7K/8K/3900 and OcteonTX2 CN913x support SPI NAND flash as the boot
+device on the target.
+In order to burn the image and save environment variables to SPI NAND flash,
+please enable SPI NAND driver at first by set the following parameter to <Y>::
+
+	CONFIG_MVEBU_NAND_BOOT=y
+
+If "menuconfig" is used, navigate to the following location::
+
+	-> Command line interface
+	  -> Misc commands
+	    -> MVEBU commands
+	      -> Flash for image
+
+and select "NAND flash boot".
diff --git a/doc/mvebu/linux_boot.txt b/doc/mvebu/linux_boot.txt
new file mode 100644
index 0000000..0f4f53c
--- /dev/null
+++ b/doc/mvebu/linux_boot.txt
@@ -0,0 +1,43 @@
+Booting Linux Kernel
+====================
+
+U-Boot supports loading the Linux kernel with the following images:
+- Linux image
+- Device Tree Blob (DTB) image
+- RAM File System (RAMFS) image - optional
+
+To load images from a TFTP server, set the TFTP server with the relevant image
+file.
+
+Run the following commands from the U-Boot prompt::
+
+	# setenv serverip <IP address of the TFTP server>
+	# setenv ipaddr <IP address of the board>
+	# setenv gatewayip <IP address of the Gateway>
+	# setenv image_name <Linux image name>
+	# setenv fdt_name <DTB image name>
+
+To mount the file-system via NFS:
+
+	- Set the NFS server with the appropriate file system.
+	- Run the following commands from the U-Boot prompt::
+
+		# setenv rootpath <path to filesystem in the NFS server>
+		# setenv netdev <NFS interface name, eth0 for example>
+		# setenv ramfs_name (optional)
+
+	Note:
+	  For the boards with Marvell SOHO switch, e.g., Espressobin,
+	  'netdev' should be set according to the port name defined by
+	  switch driver instead, i.e., lan0, lan1 or wan0.
+
+To load RAMFS:
+Run the following commands from the U-Boot prompt::
+
+	# setenv ramfs_name <RAMFS image name>
+	# setenv root <the ram device. for example, /dev/ram0 rw>
+
+To boot Linux Kerenl, run from U-Boot prompt::
+
+	# boot
+
diff --git a/doc/mvebu/porting_guide.txt b/doc/mvebu/porting_guide.txt
new file mode 100644
index 0000000..90536ff
--- /dev/null
+++ b/doc/mvebu/porting_guide.txt
@@ -0,0 +1,128 @@
+U-Boot Porting Guide
+====================
+
+This document provide instructions for porting the Marvell U-Boot package to a customer board.
+
+Relevant Devices
+----------------
+- ARMADA 80x0
+- ARMADA 70x0
+- ARMADA 37x0
+- ARMADA 3900
+- Octeon-TX2 CN913x
+
+Introduction
+------------
+	U-Boot configuration is based on three elements:
+
+	- defconfig file:
+	  This file includes compile-time options for U-Boot, and is used to
+	  enable / disable U-Boot device drivers and features.
+	- include/configs/mv-common.h, include/configs/mvebu_<soc-name>.h (e.g. armada8k.h)
+	  These files include low-level control over U-Boot definitions,
+	  and is likely not to be changed when porting to a new board.
+	- device-tree files
+	  These files are located under arch/arm/dts, and include the runtime
+	  configuration of U-Boot, and enables passing configuration parameters for
+	  each of the drivers/units in U-Boot.
+	  The majority of the porting should be done in the device-tree.
+	  For more information about device-tree syntax, refer to the various examples
+	  under arch/arm/dts/ or visit http://devicetree.org/Device_Tree_Usage
+
+	For the sake of simplicity, all examples below will use the armada-80x0-db board, and the new
+	board will be called "my_board".
+
+
+Customer Board Porting Procedure
+--------------------------------
+
+defconfig & DT file
+~~~~~~~~~~~~~~~~~~~
+
+   1. defconfig
+
+	- Find the defconfig file that matches the SoC flavor being used (e.g. armada-3700, armada-70x0...)
+	- Create a new defconfig to hold U-Boot compile time configuration::
+
+		> cp configs/mvebu_db_armada8k_defconfig configs/my_board_defconfig
+
+   2. device-tree
+
+	- Create a new DT file to hold U-Boot runtime configuration for your board.
+	- Some example DT files already exist in U-Boot, it's possible to use them as-is or
+	  rename to match your system's name::
+
+		> cp arch/arm/dts/armada-8040-db.dts arch/arm/dts/armada-70x0-my_board.dts
+
+	- Add new DT file to arch/arm/dts/Makefile under CONFIG_ARCH_MVEBU::
+
+		dtb-$(CONFIG_ARCH_MVEBU) +=                     \
+			armada-70x0-my_board.dtb                \
+			armada-3720-db.dtb                      \
+
+Basic defconfig setup
+~~~~~~~~~~~~~~~~~~~~~
+
+   1. Update my_board defconfig::
+
+		> make my_board_defconfig
+		> make menuconfig
+
+	- Update device tree file name:
+		-> Device Tree Control -> Default Device Tree for DT control -> "armada-80x0-my_board"
+
+	- Save and exit::
+
+		> make savedefconfig
+		> cp defconfig configs/my_board_defconfig
+
+   2. Compilation sanity
+
+      Compile U-Boot to make sure that everything was set properly.
+      (Refer to doc/mvebu/build.txt for detailed build instructions)::
+
+		> export CROSS_COMPILE=/path/to/toolchain/aarch64-linux-gnu
+		> make
+
+You are ready to start porting U-Boot to match "my_board" configuration.
+
+
+Device-tree porting
+~~~~~~~~~~~~~~~~~~~
+
+   This is the actual porting of U-Boot to make it work properly on "my_board":
+
+	- Edit the "my_board" dts file under arch/arm/dts/<name of dts given in section 2 above>
+	- For each of the (configurable) U-Boot drivers/units, a device tree binding
+	  description file exists, which explains the different configuration options
+	  for the relevant driver.
+
+   Below is a list of drivers/units, and their relevant DT binding description file:
+   (all file paths are relative to "doc/device-tree-bindings/")
+
+   1. Common for all SoCs:
+
+	- COMPHY - phy/mvebu_comphy.txt
+	- SATA - scsi/mvebu-ahci.txt & scsi/marvell,mvebu-scsi.txt
+	- USB3 - xHCI - usb/marvell.xhci-usb.txt
+	- MMC/SDIO - mmc/xenon-mmc.txt
+
+   2. ARMADA 7K/8K/3900 and OcteonTX2 CN913x SoC family:
+
+	- MPPs - pinctrl/marvell,mvebu-pinctrl.txt
+	- GPIO - gpio/mvebu-gpio.txt
+	- MDIO (SMI) - net/mvebu-mdio.txt
+	- NAND - nand/marvell-pxa3xx-nand.txt
+	- SPI - spi/mvebu-spi.txt
+	- Serial - serial/snps-dw-apb-uart.txt
+	- PCIe - pci/armada8k-pcie.txt
+	- I2C - i2c/mvebu-i2c.txt
+	- PPv2 - net/marvell-pp2x.txt
+	- Efuse - fuse/fuse-a7k.txt
+
+   3. ARMADA 3700 SoC family:
+
+	- Serial - serial/mvebu-serial.txt
+	- MPPs & GPIO - pinctrl/marvell,armada-37xx-pinctrl.txt
+	- SPI - spi/mvebu-a3700-spi.txt
+	- PCIe - pci/armada37xx-pcie.txt
diff --git a/doc/mvebu/trusted_boot.txt b/doc/mvebu/trusted_boot.txt
new file mode 100644
index 0000000..8c47c30
--- /dev/null
+++ b/doc/mvebu/trusted_boot.txt
@@ -0,0 +1,530 @@
+.. _uboot_trusted:
+
+Trusted Boot (Secure Mode)
+==========================
+
+This document describes how to build/burn and update Secure Trusted image with
+Key generating and updating, assuming that the SoC being used is already
+supported in U-Boot & ATF.
+
+The trusted boot document describes the following components:
+
+- eFuse module - Allows burning boot device, authentication key digest,
+  encryption key, etc.
+- Boot image format - Provides the trusted boot information to BootROM.
+- Work flow - Guide how to build and burn Secure Trusted images to target
+  board.
+- Authentication Keys Generation and selection - Provides method to generate
+  and select authentication keys.
+
+A38x platforms
+~~~~~~~~~~~~~~
+Please refer to Application Note
+- AN-383: ARMADA 38x/39x Families Secure Boot Mode Support
+
+eFuses
+-------
+The eFuse command module and driver provides RW access to SoC eFuses through
+the "efuse" command for A3700 platform or "fuse" command for A7K/8K platform.
+In order to enable this SW component, the following configuration entry should
+be set by using "make menuconfig"::
+
+A8K platforms
+~~~~~~~~~~~~~
+Command Location:
+	-> command line interface
+		-> Device access commands
+			-> fuse
+Driver Location:
+	-> Device Drivers
+		-> EFUSE Support
+
+A3700 platforms
+~~~~~~~~~~~~~~~
+Command Location:
+	-> Command line interface
+		-> MVEBU commands
+			-> efuse
+Driver Location:
+	-> ARM architecture
+		-> MVEBU Common SoC Utilities
+			-> eFuse support
+
+The above configuration enables the eFuse driver and eFuse command module.
+Refer to SoC and BootROM manuals for details about supported eFuses
+and their role in the trusted boot flow.
+Since the eFuse command module and driver are only used for simplified access
+to eFuse HW values, the presence of these components in the final trusted boot
+image is not required.
+
+A8K platforms
+~~~~~~~~~~~~~
+The AES-256 key is visible only during the efuse burn session. It will be hidden
+after reset and accessible only on early boot stages by the internal BootROM
+procedures.
+Trying to read efuse values of AES-256 key will return zeros.
+Note that if the JTAG is permanently enabled in A8K efuse, the AES-256 key
+becomes hidden for everyone, including the BootROM. Therefore when JTAG is
+enabled permanently by eFuse, the boot image should not be encrypted, since
+BootROM decryption will always fail unless a zero-key was used for image
+encryption.
+
+A3700 platforms
+~~~~~~~~~~~~~~~
+The AES-256 KEY can be hidden by setting the "DEV_DEPLOY" bits, these bits are
+set by the customer when deploying their products which will set the chip to
+trusted mode.
+
+Boot Image Format
+-----------------
+The boot image should be properly formatted for the trusted boot mode, so
+the BootROM extracts the required information from the image headers and uses it
+for authentication against eFuse values and digital signatures and for image
+decryption.
+Various platforms use different BootROMs and boot image formats.
+For specific details refer to the SoC functional specification, BootROM manual
+and to the section related to a selected platform below.
+Refer to ATF build documentation for enabling secure image output.
+
+A8K platforms
+~~~~~~~~~~~~~
+Refer to A8K functional specification for details about trusted boot image
+components.
+The secure image configuration is defined by a file sec_img_xx.cfg located in
+ATF folder "tools/doimage/secure". The xx in the configuration file name is
+either 7K or 8K for targeting Armada-80x0 or Aramda-70x0 platform setup
+accordingly.
+The configuration file has a standard INI file format and defines the following
+options:
+
+- kak_key_file - The string containing path to the Keys Authentication Key file
+		in PEM format. This parameter is mandatory.
+
+- csk_key_file	- Array of string containing paths to Code Signing Key files in
+		PEM format. This array has to include at least a single key used
+		for signing the boot image and prolog. The key index is defined
+		by the file location in this array.
+		Empty key paths should be coded as "*" strings to make the
+		entire array size of 16 strings. This parameter is mandatory.
+
+- csk_key_index - The integer value in range of 0 to 15 defining the CSK file
+		from the above array to be used for creating image and prolog
+		signatures.
+		This parameter is optional and if omitted defaults to 0.
+
+- aes_key_file	- The string containing the path to the AES-256 symmetric key
+		file in ASCII text format.
+ 		The boot image will be encrypted if this parameter is included
+		in the configuration or left unencrypted if the parameter is
+		omitted.
+		This parameter is optional.
+
+- efuse_disable - Boolean parameter defining whether to disable access to efuses
+		in secure boot mode or not.
+		Can be either "true" or "false". The efuse access policy is
+		enforced by the BootROM.
+		This parameter is optional and if omitted defaults to "true".
+
+- jtag		- Parameters defining the JTAG behavior in trusted boot mode.
+		There are two parameters enclosed in curly brackets - "enable"
+		and "delay".
+		The "jtag.enable" boolean parameter allows to enable the JTAG
+		support in trusted boot mode (valid values "true" and "false").
+		The second parameter - "jtag.delay" (integer) defines delay
+		in milliseconds the BootROM waits before enabling the JTAG
+		connection in the HW. These parameters are optional and if
+		omitted default to "false" and 0 respectfully.
+
+- box_id	- 4 byte hexadecimal number to be used as box ID.
+		This value will be part of the secure extension in the trusted
+		boot image and should match the value burned in the appropriate
+		efuse field.
+		This parameter is optional and if omitted defaults to 0.
+
+- flash_id	- 4 byte hexadecimal number to be used as the flash ID.
+		This value will be part of the secure extension in trusted boot
+		image and should match the value burned in the appropriate efuse
+		field.
+		This parameter is optional and if omitted defaults to 0.
+
+- control	- Array of hexadecimal addresses to be set on each CP connected
+		to an AP in trusted mode.
+		It is required to add two addresses for each connected CP.
+		The first address points to the CP SecureBootControl register
+		and the second address points to the CP EfuseBurnControl
+		register.
+		Refer to your SoC documentation for details. For instance,
+		Armada-7040 SoC has a single CP connected to AP, so this array
+		has to list 2 register addresses. The Armada-8040 has two CPS
+		connected to AP, so this array has to include 4 register
+		addresses.
+		This parameter is optional.
+
+
+A3700 platforms
+~~~~~~~~~~~~~~~
+Please refer to MARVELL WIRELESS Trusted Platform Tools Packages functional
+specification for details about trusted boot image components.
+The secure image configuration is defined by a single file atf_timN.txt located
+in the build folder. This file will be generated after compilation.
+There are some files in the A3700_utils/tim folder which are used for
+trusted image boot.
+
+- aes-256.txt - This file includes AES-256 encryption key values. This key
+		is used to do Encryption/Decryption on wtmi and obmi images
+		which should be programmed into efuse. it can be updated by the
+		image provider.
+
+- kak.txt - The file including (DSA Algorithm ID/Hash Algorithm ID/Key Size
+		in bits/RSA Public Exponent/RSA System Modulus/RSA Private Key)
+		is used to signature the TIM file, and will generate the OEM key
+		in "otphash.txt" The file is generated by Key Generation command
+		by KeyGeneration.txt file stored in tools/wtp/key folder.
+		This file is mandatory and can be updated according to
+		requirements for updating the Secure Trusted image.
+
+- CSK[0-F].txt	- These files contain different CSK Key information (Hash
+		Algorithm ID/Key Size in bits/Public Key Size in bits/Encrypt
+		Algorithm ID/RSA System Modulus). These files are also generated
+		by the Key Generation command with KeyGeneration.txt by setting
+		different parameters(i.e. Seed...).
+
+- timnsign.txt- This file defines which key is used to signature the TIMH file.
+		Indicate the CSK_INDEX of this file in fuse. All of parameters
+		(DSA Algorithm ID/Hash Algorithm ID/Key Size in bits/RSA Public
+		Exponent/RSA System Modulus/RSA Private Key) in the file should
+		be aligned with one of 16 KEY files in the tools/wtp/key folder.
+		This file is mandatory and and can be updated according to
+		requirements for updating Secure Trusted image.
+
+Work flow - Target Preparation
+------------------------------
+After the trusted boot mode is selected by the SoC eFuse, the BootROM enforces
+security checks upon boot image load. Therefore a right work flow is essential
+for target preparation and preventing the system from self-locking.
+
+A8K platforms
+~~~~~~~~~~~~~
+
+1. Build an image for trusted boot mode using the configuration file described
+   above and any additional settings required by ATF.
+   The image encryption option should not be used in this build, since the
+   resulting image should be compatible with non-trusted systems.
+2. Burn the image on the target board and boot it. The secure header will be
+   bypassed in non-trusted boot mode and the system will start as usual.
+3. Enable eFuse burning in the HW by connecting 1.8V source to AP_VHV, CP0_VHV
+   and CP1_VHV pins.
+   For example on A8K-DB Rev1.4 platform it is done by shortening on-board
+   jumpers JP36 and JP42.
+   Please refer to your Marvell Development Board manual or consult Marvell
+   representative
+   for the details about VHV connection setup on other supported HW platforms.
+4. Burn all required efuses to each efuse rows using "fuse prog" commands.
+   The trusted boot enable efuse should be burned last since any further
+   modifications to the SoC efuses will not be possible afterwards.
+   See the efuse programming example(HD and LD efuse rows) for A8K device below.
+   uboot fuse command::
+
+	/* HD efuse rows(64bits width) programming */
+	/* prog KAK_DIGEST key to efuse */
+	fuse prog -y 25 0 <KAK_DIGEST bit 31-0>    <KAK_DIGEST bit 55-32>   0x1
+	fuse prog -y 26 0 <KAK_DIGEST bit 95-56>   <KAK_DIGEST bit 111-96>  0x1
+	fuse prog -y 27 0 <KAK_DIGEST bit 143-112> <KAK_DIGEST bit 167-144> 0x1
+	fuse prog -y 28 0 <KAK_DIGEST bit 199-168> <KAK_DIGEST bit 223-200> 0x1
+	fuse prog -y 29 0 <KAK_DIGEST bit 255-224> 0x0 0x1
+
+	For example:
+	KAK key hash
+	8B3732C8F03D0C407F34200C206CA36B0701E47C9074034EDE97FBFF5BA6D778
+	fuse prog -y 25 0 0xC832378B 0x000C3DF0 0x1
+	fuse prog -y 26 0 0x20347F40 0x006C200C 0x1
+	fuse prog -y 27 0 0x01076BA3 0x00907CE4 0x1
+	fuse prog -y 28 0 0xDE4E0374 0x00FFFB97 0x1
+	fuse prog -y 29 0 0x78D7A65B 0x0 0x1
+
+	/* prog AES key to efuse */
+	fuse prog -y 32 0 <AES_KEY bit 31-0>    <AES_KEY bit 55-32>   0x1
+	fuse prog -y 33 0 <AES_KEY bit 95-56>   <AES_KEY bit 111-96>  0x1
+	fuse prog -y 34 0 <AES_KEY bit 143-112> <AES_KEY bit 167-144> 0x1
+	fuse prog -y 35 0 <AES_KEY bit 199-168> <AES_KEY bit 223-200> 0x1
+	fuse prog -y 36 0 <AES_KEY bit 255-224> 0x0 0x1
+
+	For example:
+	AES key
+	ABCDEF1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF1234567890
+	fuse prog -y 32 0 0x12EFCDAB 0x00785634 0x1
+	fuse prog -y 33 0 0xEFCDAB90 0x00563412 0x1
+	fuse prog -y 34 0 0xCDAB9078 0x003412EF 0x1
+	fuse prog -y 35 0 0xAB907856 0x0012EFCD 0x1
+	fuse prog -y 36 0 0x90785634 0x0 0x1
+
+	/* prog efuse row to select CSK valid - the first empty row specifies
+	 * the CSK index
+	 */
+	fuse prog -y 37~50 0 0x00000001 0x00000000 0x1
+
+	For example:
+	/* prog efuse row to select CSK 3 valid,need to set bit[0] in the efuse
+	 * rows 37, 38 and 39 to non zero values and leave the efuse row 40
+	 * intact
+	 */
+	fuse prog -y 37 0 0x00000001 0x00000000 0x1
+	fuse prog -y 38 0 0x00000001 0x00000000 0x1
+	fuse prog -y 39 0 0x00000001 0x00000000 0x1
+
+	/* prog flash ID to efuse row 30 */
+	fuse prog -y 30 0 0xbaddf00d 0x00000000 0x1
+
+	/* prog Box ID to efuse row 31 */
+	fuse prog -y 31 0 0xdeadbeef 0x00000000 0x1
+
+	/* LD efuse rows(256bits width) programming */
+	/* For A8k SoCs, both AP and SB0/1 have LD0 and LD1 efuse rows.
+	 * Only LD1 rows could be programmed.
+	 * Efuse row 65 is AP LD1 while row 67 is SB0 LD1. Row 69 is SB1 LD1.
+	 * /
+	fuse prog -y <RowIndex> 0 <bit 31-0> <bit 63-32> <bit 95-64>
+	<bit 127-96> <bit 159-128> <bit 191-160> <bit 223-192> <bit 255-224>
+
+	Below example shows secure boot fusing to select CP0_SPI as boot device.
+
+	/* enable trusted boot and disable JTAG permanent, select boot device
+	 * (from AP perspective, here the value is 0x0 which means IHB to select
+	 * device. Please see Table(Boot Source Options) for boot device
+	 * selection in functional specifications document), enable CPU
+	 * Wakeup/Enable in AP LD1.
+	 */
+	fuse prog -y 65 0 0x00000001 0x0000C000 0x00000000 0x00000000
+			  0x00000000 0x00000000 0x00000000 0x00000000
+
+	.. ATTENTION!::
+	Devices based on AP807 have different AP LD1 CPU-wakeup related fields.
+	For instance, the Armada-3900 DB board with boot device on AP SPI should
+	be programmed in the following way (boot device 0x2):
+
+	fuse prog -y 65 0 0x00000011 0x00003000 0x00000000 0x00000000
+			  0x00000000 0x00000000 0x00000000 0x00000000
+
+
+	/* enable trusted boot and disable JTAG permanent, select boot device
+	 * (from SB perspective, the value is 0x32 which means boot from CP0_SPI
+	 * Please see the HW sepcificaiton document for a list of supported
+	 * values), disable ICU message LD1 in SB0
+	 */
+	fuse prog -y 67 0 0x000000c9 0x00000001 0x00000000 0x00000000
+			  0x00000000 0x00000000 0x00000000 0x00000000
+
+	/* enable trusted boot and disable JTAG permanent, select boot device
+	 * (from SB perspective, the value is 0x32 which means boot from CP0_SPI
+	 * Please see the HW sepcificaiton document for a list of supported
+	 * values), disable ICU message LD1 in SB1
+	 */
+	fuse prog -y 69 0 0x000000c9 0x00000001 0x00000000 0x00000000
+			  0x00000000 0x00000000 0x00000000 0x00000000
+
+   .. Note::
+	HD_efuse (bank ID 0~63's bit56-63 must be 0x0 according to Functional
+	Specification document). Efuse row 64,66,68 are LD0 and read-only.
+
+5. Verify the efuse values for correct efuse rows using "fuse read" commands.
+6. Restart the system and ensure the secure boot authentication stage has been
+   passed.
+7. If the image encryption option is required, build a new image with image
+   encryption enabled and burn it to the system boot device using the regular
+   "bubt" command.
+
+A3700 platforms
+~~~~~~~~~~~~~~~
+1. Create an UNTRUSTED boot image with eFuse command module support (as stated
+   in the "eFuses" chapter above) and burn it on the target flash device using
+   the regular "bubt" command.
+2. Create a TRUSTED boot image with Encryption option (as stated in "Boot image
+   format" chapter above)and save it for later use. Actually, encryption option
+   is enabled by default to "AES-256-CBC"(only AES-256 CBC is supported).
+3. Boot the target board with the UNTRUSTED boot image.
+4. Run the below commands in uboot before burning TRUSTED boot image
+	a. efuse write ENCRYPTION <binary value> (it always is 10 -- enable
+	   encryption for primary type image)
+	b. efuse write AES256_KEY <AES-256 key value>
+	c. efuse write BOOT_DEVICE <device_type>
+	d. efuse write KAK_DIGEST <otphash_value>
+	e. efuse write CSK_INDEX <key_index>
+	f. efuse write OPER_MODE <mode_type> (mode_type should be always 2).
+	g. efuse DEV_DEPLOY <deploy_value> (1 - enable/0 - disable), this
+	   command will set the chip into trusted mode.
+	   It will also hide the AES-256 key.
+5. Burn the TRUSTED boot image using regular "bubt" command.
+6. Reset the board and verify that the trusted boot mode works.
+
+.. Note::
+	a. binary value: supports 00/01/10/11 disable/.../enable encryption for
+	   primary type image/...
+	b. AES-256 value: AES-256 symmetric encryption key in HEX format.
+	   The values are in the aes-256.txt file.
+	c. device_type: SPINOR, SPINAND, EMMCNORM..., select device flash
+	   according to requirement.
+	   After selecting device_type by efuse, the device could not be changed
+	   anymore. The device flash is locked.
+	d. otphash_value: OEM key generated by tbb tool when signature the TIM
+	   header with kak.txt
+	e. key_index: Range 0 to 15 in DEC format to select which CSK KEY is
+	   used.
+	f. mode_type: Operation mode in range of 0 to 3, where mode 2 is Trusted
+	   boot, security check is performed on the boot device content
+	g. deploy_value: Enable(1) this feature will mask AES-256 KEY value. The
+	   command is optional. When secure trusted images need to hide AES-256
+	   KEY value to stop reading.
+
+<otphash_value>
+   When the trusted boot image is created, the the TBB tool saves the OEM key
+   in OtpHash.txt. This digest value is otphash_value which is used for efuse
+   KAK_DIGEST command.
+   The OtpHash.txt file lists the otphash_value in groups of 4-bytes values,
+   organized in the following
+   order::
+
+       LSB
+       ...
+       ...
+       MSB
+
+   These otphash_value should be converted to a single 32-bytes value for
+   eFuse burning::
+
+       MSB ... ... ... LSB.
+
+   For instance, the following otphash_value::
+
+       0x1887C298
+       0x59C9AFD9
+       0x6E814E34
+       0x25CD518B
+       0x3CDB7EED
+       0x33CC58B1
+       0x2C69997A
+       0xC27B7242
+
+   Will be used in the following form in eFuse KAK digest write command::
+
+       efuse write KAK_DIGEST C27B72422C69997A33CC58B13CDB7EED25CD518B6E814E3459C9AFD91887C298
+
+<key_index>
+   key_index is the index of the "timnsign.txt", refer to "timnsign.txt" in the
+   previous chapter for detailed description.
+   For instance, the following sample content is from timnsign.txt::
+
+      DSA Algorithm ID:                7		; Signed with CSK6
+      Hash Algorithm ID:               32
+      Key Size in bits:                2048
+      RSA Public Exponent
+	  ... ... ... ...(aligned with CSK6 file)
+	  ... ... ... ...
+	  RSA System Modulus:
+	  ... ... ... ...(aligned with CSK6 file)
+	  ... ... ... ...
+	  RSA Private Key:
+	  ... ... ... ...(aligned with CSK6 file)
+	  ... ... ... ...
+
+   The key_index will be used in the following form in eFuse CSK_INDEX
+   write command::
+
+      efuse write CSK_INDEX 6
+
+i.e.
+
+Default commands before bubt Secure Trusted boot image::
+
+	efuse write ENCRYPTION 10
+	efuse write AES256_KEY 0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF
+	efuse write BOOT_DEVICE SPINOR
+	efuse write KAK_DIGEST C27B72422C69997A33CC58B13CDB7EED25CD518B6E814E3459C9AFD91887C298
+	efuse write CSK_INDEX 6
+	efuse write OPER_MODE 2
+
+
+Authentication/Encryption Keys Generation and Selection
+-------------------------------------------------------
+
+A3700 platforms
+~~~~~~~~~~~~~~~
+
+A3700 platform supports selecting 16 authentication key files(CSK[0-F].txt
+in the A3700_utils/tim/trusted/keys/ folder) for trusted boot.
+All of the authentication keys files must be generated by TBB tool before
+building Secure Trusted image.
+
+KAK.txt (Keysignauture file) is also generated by using the same Key Generation
+command.
+
+From the above chapters decriptions, in order to update the authentication keys
+of the Secure Trusted Image, we could update two files (kak.txt/timnsign.txt)
+stored in the A3700_utils/tim folder.
+Please follow the below steps to update these files.
+
+1. Key Generation command::
+
+       tbb_linux.exe -G <<path\>KeyGeneration.txt>
+
+   Normally KeyGenernation.txt is stored in the A3700_utils/tim/trusted/keys/
+   folder. If the file is a directory other than the directory from which TBB
+   is executed, then a file path must also be provided.
+
+2. KeyGeneration.txt
+
+   Content::
+
+	Seed: Trusted platform
+	Key ID: DSIG
+	Encrypt Algorithm ID: 7
+	Hash Algorithm ID: 32
+	Key Size: 2048
+	Output Binary Filename:
+	Output Text Filename: ./KAK.txt
+
+   - Seed - The ASCII seed value can be any continuous ASCII alphanumeric
+	sequence delimited by white-space. TBB hashes the ASCII seed value to
+	a 32-bit value and uses that value to seed the random number generator.
+
+   - Key ID - The ASCII tag can be any 4-character string. i.e. DSIG -- means
+	that it will be created for digital signature.
+
+   - Encrypt Algorithm ID - i.e.7 = PKCS_2_2(ippcp). Currenlty, only 7 is
+	supported.
+
+   - Hash Algorithm ID - Hash Algorithm uses the Hash Algorithm ID to hash the
+	data associated with the key.
+	i.e. 20 = SHA160, 32 = SHA256, 64 = SHA512. Our A3700 use 32 as default.
+
+   - Key Size - For PKCS, the supported key sixe in bits is 2048.
+
+   - Output Binary Filename - if blank, no binary file is generated.
+	Normally, we keep this empty.
+
+   - Output Text Filename - if a path\filename is provided, TBB outputs an
+	ASCII txt file containing the generated key components.
+
+3. Update kak.txt files according the KAK.txt file. Copy the KAK.txt to
+   the A3700_utils/tim/trusted folder and update some parameters
+   Rename KAK.txt to kak.txt in the A3700_utils/tim folder.
+   Change the kak.txt file headers in the content:
+
+       Key ID: DSIG
+       Encrypt Algorithm ID: 7
+       ... ... ... ...
+
+   to below format::
+
+       DSA Algorithm ID:                7		; Signed with KAK
+       ... ... ... ...
+
+   The kak.txt is used to be generated to OtpHash.txt mentioned in the above
+   chapter.
+
+4. Update timnsign.txt file content to select CSK_Index
+
+   Update all parameters(DSA Algorithm ID/Hash Algorithm ID/Key Size in bits
+   /RSA Public Exponent/RSA System Modulus/RSA Private Key) value in
+   timnsign.txt according to CSK[0-F].txt files located in tools/wtp/key folder.
+   For instance, if you decide to use CSKA file (eFsue write CSK_INDEX 10),
+   you should update timnsign.txt's parameters aligned with CSKA.txt file.
diff --git a/doc/mvebu/uart_boot.txt b/doc/mvebu/uart_boot.txt
new file mode 100644
index 0000000..9d9dc3b
--- /dev/null
+++ b/doc/mvebu/uart_boot.txt
@@ -0,0 +1,117 @@
+UART boot
+=========
+
+UART boot for Armada-70x0/80x0/3900 and OcteonTX2 CN913x
+----------------------------------------------------------
+
+UART recovery is a method of loading boot flash image using Xmodem protocol
+when the target board is used for the first time or when the board fails to
+start due to invalid flash image located on its boot device.
+
+1. The entire process is greatly simplified with a dedicated script usage.
+   The script is located under /tools folder and named mrvl_uart.sh.
+   This script supports 2 parameters - the serial interface and the
+   path to flash image::
+
+	mrvl_uart.sh <port> <file>
+
+2. Power on the board, connect it to the Linux workstation using serail cable,
+   run the script and follow the on-screen instructions.
+   Below is the example for A-8040 board connected to /dev/ttyUSB0 serial line::
+
+	./tools/mrvl_uart.sh /dev/ttyUSB0 /srv/tftp/flash-image-a8040-db.bin
+
+   The script generates UART escape sequence pattern and requests
+   the target board reset::
+
+	Using device connected on serial port "/dev/ttyUSB0"
+	Loading flash image file "/srv/tftp/flash-image-a8040-db.bin"
+	Recovery will run at 115200 baud
+	========================================
+	Press the "Reset" button on the target board and the "Enter" key on the host keyboard simultaneously
+
+3. Once "Enter" key is pressed, the script sends escape pattern to the target
+   board (interrupting normal boot flow) followed by X-modem transfer of the flash image.
+   When the download process ends, the "minicom" application is started on the
+   same serial port, presenting u-boot startup messages.
+
+4. Note that after downloading flash image using UART recovery it is still required
+   to burn the image on the target board boot device, since serial image boot uses
+   binary loaded to the target DRAM.
+
+UART boot for Armada-3700 platform
+----------------------------------
+
+Note that WtpDownload application (v3.3.11.15) is Linux host tool used
+to do the UART boot. The source code and binaries is provided as part
+of A3700 utility package, which is out of the bootloader source tree.
+The package is located in same folder of the bootloader source. Please
+refer to the readme.txt in wtptp/src/Wtpdownloader_Linux folder for the
+prerequisitions of the tool.
+
+The following shows the detail steps of UART boot. The target board is
+connected to /dev/ttyUSB0 in this example, replace the port number
+according to your set-up.
+
+1. The normal ATF build procedure for A3700 target creates a folder
+   with all the images required for UART boot under ATF build output
+   folder (A.K.A., build/a3700/release or build/a3700/debug). Make
+   sure u-boot was built before ATF, see detail in build.txt.
+
+2. Make sure the target board is in UART mode and ">" prompt is
+   presented on the connected terminal. Pressing "Enter" in this mode
+   will show "E" and then ">" again.
+   There is a way to stop the target board booting from other sources,
+   SPI flash for example, and switch to UART boot mode, by using the
+   WtpDownload application::
+
+	(power down the board or hold the RESET button)
+	sudo stty -F /dev/ttyUSB0 clocal
+	(power up the board or release the RESET button)
+	./WtpDownload_linux -P UART -C 0 -R 115200 -Y
+
+3. Stop the terminal emulator program on the UART port attached to the
+   target board (minicom) for releasing the serial port and allowing
+   an application to use it for image download.
+
+4. Disable the TTY modem control signals::
+
+	sudo stty -F /dev/ttyUSB0 clocal
+
+5. Start the image download application in the ATF build folder using
+   the following parameters.
+
+   WTP downloader usage example - non-secure boot::
+
+	./WtpDownload_linux -P UART -C 0 -R 115200 \
+		-B ./uart-images/TIM_ATF.bin \
+		-I ./uart-images/boot-image_h.bin \
+		-I ./uart-images/wtmi_h.bin -E
+
+   WTP downloader usage example - secure boot::
+
+	./WtpDownload_linux -P UART -C 0 -R 115200 \
+		-B ./uart-images/TIM_ATF_TRUSTED.bin \
+		-B ./uart-images/TIMN_ATF_TRUSTED.bin \
+		-I ./uart-images/boot-image_h.bin \
+		-I ./uart-images/wtmi_h.bin -E
+
+   Note that "-E" parameter can be dropped from the above commands.
+   If you do this, check that the BootROM UART download mode is
+   selected in paragraph 2, type in terminal "wtp" without quotes and
+   press Enter. Then follow the procedure described in paragraph 3.
+   This command will switch the BootROM to WTP download mode. The same is
+   archieved by "-E" parameter in latest downloader SW.
+
+6. After the process is finished, start the terminal emulator
+   program (minicom) on that the UART port attached to the target
+   board and ensure the U-Boot prompt is reached.
+
+Note that steps 2-5 can be simplified with a single command as below::
+
+	sudo stty -F /dev/ttyUSB0 clocal
+	./WtpDownload_linux -P UART -C 0 -R 115200 \
+		-B ./uart-images/TIM_ATF.bin \
+		-I ./uart-images/boot-image_h.bin \
+		-I ./uart-images/wtmi_h.bin -E -O
+
diff --git a/doc/mvebu/uboot_cmd.txt b/doc/mvebu/uboot_cmd.txt
new file mode 100644
index 0000000..7c182d2
--- /dev/null
+++ b/doc/mvebu/uboot_cmd.txt
@@ -0,0 +1,366 @@
+.. _uboot_cmd:
+
+U-Boot Commands
+===============
+
+For standard U-Boot commands (mmc, usb, sata, fdt), please refer to denx
+mainline documentation.
+
+
+Base command
+------------
+Base command provides the ability to change the base address of a memory command
+(ir, md, mm, etc..).
+
+   Examples:
+
+	(1) Show the current base address::
+
+		> base
+
+		Base Address: 0x00000000
+
+	(2) change the base address::
+
+		> base 0xf2000000
+
+		Base Address: 0xf2000000
+
+
+BUBT (Burn ATF) command
+-----------------------
+Bubt command is used to burn a new ATF image to flash device.
+
+The bubt command gets the following parameters: ATF file name, destination
+device and source device::
+
+	bubt [file-name] [destination [source]]
+
+	- file-name:	Image file name to burn. default = flash-image.bin
+	- destination:	Flash to burn to [spi, nand, mmc]. default = active flash
+	- source:	Source to load image from [tftp, usb]. default = tftp
+
+Examples:
+
+	``bubt``			- Burn flash-image.bin from tftp to active flash
+	``bubt latest-spi.bin nand``	- Burn latest-spi.bin from tftp to NAND flash
+
+.. Note::
+	- For the TFTP interface set serverip and ipaddr.
+	- To burn image to SD/eMMC device, the target is defined
+	  by parameters CONFIG_SYS_MMC_ENV_DEV and CONFIG_SYS_MMC_ENV_PART.
+
+Bubt command details (burn image step by-step)
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+This section describes bubt command flow:
+
+1. Fetch the requested ATF image from an available interface (USB/SD/SATA/XDB, etc.)
+   into the DRAM, and place it at <load_address>
+   Example: when using the FAT file system on USB flash device::
+
+	# usb reset
+	# fatls usb 0 (see files in device)
+	# fatload usb 0 <load_address> <file_name>
+
+2. Erase the target device::
+
+	- NAND:		# nand erase 0 100000
+	- SPI:		# sf probe 0
+			# sf erase 0 100000
+	- SD/eMMC:	# mmc dev <dev_id> <boot_partition>
+
+   .. Note::
+	- The eMMC has 2 boot partitions (BOOT0 and BOOT1) and a user data
+	  partition (DATA). The boot partitions are numbered as partition 1 and
+	  2 in MMC driver. Number 0 is used for user data partition and should
+	  not be utilized for storing boot images and U-Boot environment in RAW
+	  mode since it will break file system structures usually located here.
+
+	  The default boot partition is BOOT0. It is selected by the following
+	  parameter::
+
+		CONFIG_SYS_MMC_ENV_PART=1
+
+	  Valid values for this parameter are 1 for BOOT0 and 2 for BOOT1.
+	  Please never use partition number 0 here!
+
+	- The partition number is ignored if the target device is SD card.
+
+	- The boot image offset starts at block 0 for eMMC and block 1 for SD
+	  devices. The block 0 on SD devices is left for MBR storage.
+
+3. Write the ATF image::
+
+	- NAND:		# nand write <load_address> 0 <ATF Size>
+	- SPI:		# sf write <load_address> 0 <ATF Size>
+	- SD/eMMC:	# mmc write <load_address> [0|1] <ATF Size>/<block_size>
+
+
+hw_info command
+---------------
+hw_info commands are used for the following:
+
+  - Store HW manufacturing information to EEPROM during the board production in
+    order to keep these parameters, regardless of the boot-loader upgrading.
+  - Load HW manufacturing information from the EEPROM to the relevant U-Boot
+    env variable in order to take effect.
+
+.. Note::
+	hw_info commands are only relevant for Marvell boards that use the
+	EEPROM device to save the HW manufacturing information.
+
+
+hw_info usage
+~~~~~~~~~~~~~
+- ``hw_info dump [name]``  - Dump all or specific HW parameters from the EEPROM.
+
+- ``hw_info load [name]``  - Load all or specific HW parameters from the EEPROM
+			     to env variables. The hw_info load will be
+			     performed automatically with the ``env default -a``
+			     operation, however it requires that the user
+			     executes ``env save`` manually, later on.
+
+- ``hw_info store [name]`` - Store all or specific HW parameters from env
+			     variables to the EEPROM. Before the operation, the
+			     expected env varibles should already be saved to
+			     env by using the command setenv or editenv.
+
+Supported HW information parameters:
+
+	- board_id      board ID
+	- pcb_slm       PCB system level manufacturing part ID (SLM)
+	- pcb_rev       PCB revision number
+	- eco_rev       ECO revision number
+	- pcb_sn        PCB SN
+	- ethaddr       first MAC address
+	- eth1addr      second MAC address
+	- eth2addr      third MAC address
+	- eth3addr      fourth MAC address
+
+Examples
+~~~~~~~~
+1. Initialize or change HW manufacturing information for the Armada-3700::
+
+	# setenv board_id 0020
+	# setenv pcb_slm 1443
+	# setenv pcb_rev 10
+	# setenv eco_rev 12
+	# setenv pcb_sn 0028
+	# setenv ethaddr 00:50:43:00:00:01
+	# setenv eth1addr 00:50:43:00:00:02
+	# setenv eth2addr 00:50:43:00:00:03
+	# setenv eth3addr 00:50:43:00:00:04
+	# saveenv
+	# hw_info store
+
+2. Restore HW manufacturing information env variables after the resetenv command::
+
+	# hw_info load
+	# saveenv (optional since hw_info load will ask user whether to saveenv)
+
+3. Dump HW parameters from EEPROM
+
+	# hw_info dump
+
+
+ir command
+----------
+Reading and changing internal register values.
+
+Displays the contents of the internal register in 2 forms, hex and binary.
+It is possible to change the value by writing a hex value beginning with 0x
+or by writing 0 or 1 in the required place.
+Pressing enter without any value keeps the value unchanged.
+
+NOTE: before using the ir command, the base address (using base command,
+described above) must be set:
+
+	- Armada3700	-	0xd0000000
+	- AP806		-	0xf0000000
+	- CP110-0	-	0xf2000000
+	- CP110-1	-	0xf4000000
+
+Example::
+
+	# base 0xf4000000
+	Base Address: 0xf4000000
+	# ir 440000
+	Internal register 0x440000 value : 0x33333333
+
+	31      24        16         8         0
+	 |       |         |         |         |
+	OLD: 0011-0011-0011-0011-0011-0011-0011-0011
+	NEW:             00           1			/* Set specific bits */
+
+	New value = 0x33033b33
+
+	# ir 440000
+	Internal register 0x440000 value : 0x33033b33
+
+	31      24        16         8         0
+	 |       |         |         |         |
+	OLD: 0011-0011-0000-0011-0011-1011-0011-0011
+	NEW:	/* Press enter to keep the value unchanged */
+
+
+
+mg_boot command
+---------------
+mg_boot command allows to load MG CM3 firmware and emulate MG's CM3 UART
+
+Introduced commands allows to load MG CM3 firmware into MG's CM3 SRAM and
+release it from reset. The MG's CM3 doesn't have hardware UART but after
+enabling CMD_MVEBU_MG_BOOT option, UART emulation can be used and console
+input/output can be redirected to MG's CM3
+
+The MG's CM3 UART emulation is done in the shared memory where both MG's CM3
+and ARMv8 has access to. The CM3 instead of putting some characters into UART
+registers, puts char into memory which can be read by ARMv8 U-Boot.
+
+Receiving character from CM3 perspective: The CM3 polls some other part of
+shared memory, if it finds some new chars it process it (instead of reading UART
+register). Thanks to that, ARMv8 U-Boot can send some characters to this
+shared memory and the CM3 will be able to receive and process them.
+
+A complementary patch can be found in FreeRTOS github repo:
+"a8k_mg: add uart emulation support"
+
+parameters:
+
+	- remote_file_name - TFTP image path to be loaded to MG CM3 SRAM
+	- cp_nr - CPx number [0 | 1]
+	- io_redirect - redirect console IO to CM3 [0=no (deflt) | 1=yes]
+
+Load the FreeRTOS firmware and switch to emulated MG's CM3 console::
+
+	# mg_boot path/to/tftpfile/RTOSDemo-cm3-mg.bin 0 1
+	# Using egiga1 device
+	# TFTP from server 10.2.0.102; our IP address is 10.2.2.182
+	# Filename 'path/to/tftpfile/RTOSDemo-cm3-mg.bin'.
+	# Load address: 0xf2100000
+	# Loading: #############
+	# 	 1.3 MiB/s
+	# done
+	# Bytes transferred = 61801 (f169 hex)
+	# Opening MG CM3 console..
+	# 	Use "poweroff" for powerdown CM3 and falling back to u-boot prompt
+	# 	Use "exit" falling back to u-boot prompt (CM3 still running)
+	#
+	#
+	# 	<some FreeRTOS log>
+
+.. Note::
+
+   Be aware that A8K MG's CM3 doesn't have hardware UART, therefore are emulated
+   console was prepared. After loading the CM3 firmware and using console
+   redirect (io_redirect set to 1), the emulated console of CM3 takes control
+   over A8K U-Boot's console.
+
+The logs from CM3 are not printed in real time, they are buffered in shared
+memory. To dump buffered log just:
+
+	- Press the 'Enter' key (this is needed to see logs that are buffered by
+	  FreeRTOS and they are not a direct result of entered command)
+	- Enter a command followed by 'Enter' key (this will dump log which is
+	  direct results of entered command)
+
+Falling back to u-boot console:
+
+  - To exit from it (and leave the CM3 running) do::
+
+	# MG-CM3>exit
+
+  - To exit and shutdown CM3 do::
+
+	# MG-CM3>poweroff
+
+
+mg_console command
+------------------
+
+mg_console command allows to switch console IO to CPn MG CM3. It is useful
+in cases where:
+
+- we run mg_boot without console IO redirection
+- we fall back to u-boot console but after some time we want to switch
+  back console redirection to CPn MG CM3
+
+parameters:
+- cp_nr - CPx number [0 | 1]
+
+Returning to MG CM3's console:
+
+If there is need to check status in CM3, we can return by running the command::
+
+	# Marvell>> mg_console 0
+
+Afterwards, we can dump what was buffered by FreeRTOS as described earlier by:
+
+- Pressing the 'Enter' key (this is needed to see logs that are buffered by FreeRTOS)
+- Enter new command followed by 'Enter' key (this will dump log which is direct
+  results of entered command)
+
+
+rx_training command
+-------------------
+
+RX training allows to improve link quality (for SFI/XFI mode) by running training
+sequence, this allows to reach better link quality then using static configuration.
+
+When running rx_training sequence, the user must state CP index (0/1/2) and comphy ID (0/5).
+
+If after rx training procedure the kernel will be booted (without
+resetting/rebooting the board), Linux will skip comphy power off and power on
+sequence, so the user can test the link quality in Linux.
+
+After board reset/reboot the comphy parameters for SFI/XFI are the default one
+(the training results are not valid anymore after reset).
+
+.. seealso::
+        Please refer to :ref:`porting` section: Comphy Porting.
+
+SAR (Sample at Reset) commands
+-------------------------------
+SAR commands are used to toggle the available Sample at Reset modes.
+
+.. Note::
+	- SAR commands are only relevant for Marvell boards that use EEPROM
+	  device.
+	- At first use, a reset should be done to SAR fields values with
+	  ``sar default`` command.
+	- In order to use SAR fields values a jumper should be in:
+
+		- jumper 52 in a8040-db
+		- jumper 38 in a7040-db
+
+	- After a SAR write command, a reset is required for the changes to
+	  take effect.
+
+Examples
+~~~~~~~~
+- ``sar list`` - Get the list of possible fields.
+- ``sar list <field>`` - Get the list of possible values for a specific field.
+- ``sar read`` - Get the current values of all available SAR fields.
+- ``sar read <field>`` - Get the current value of a specific SAR field.
+- ``sar write <field> <value>`` - Set the required value for a specific field.
+   A reset is required after a SAR write command for the changes to take effect.
+- ``sar default`` - Reset all writable SAR fields back to their default values.
+- ``sar default <field>`` - Reset SAR field back to his default value.
+
+The list of the Sample At Reset possible fields and values is defined in the
+device tree. For more information, please refer to
+doc/device-tree-bindings/misc/mvebu-sar.txt.
+
+
+tsen command
+-------------
+tsen command is used to display the SoC thermal sensor readout.
+When tsen command is executed, AP's and CP's temperature is sampled:
+
+Example::
+
+	Running 'tsen' on Armada-7040:
+
+	Marvell>> tsen
+	Thermal.f06f8084 = 49
+	Thermal.f2400070 = 53
diff --git a/drivers/Kconfig b/drivers/Kconfig
index c2e813f..5bb8aa5 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -32,6 +32,8 @@ source "drivers/firmware/Kconfig"
 
 source "drivers/fpga/Kconfig"
 
+source "drivers/fuse/Kconfig"
+
 source "drivers/gpio/Kconfig"
 
 source "drivers/i2c/Kconfig"
@@ -42,6 +44,8 @@ source "drivers/led/Kconfig"
 
 source "drivers/mailbox/Kconfig"
 
+source "drivers/mdio/Kconfig"
+
 source "drivers/memory/Kconfig"
 
 source "drivers/misc/Kconfig"
diff --git a/drivers/Makefile b/drivers/Makefile
index 2673428..a773e91 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -9,6 +9,7 @@ obj-$(CONFIG_$(SPL_TPL_)I2C_SUPPORT) += i2c/
 obj-$(CONFIG_$(SPL_TPL_)LED) += led/
 obj-$(CONFIG_$(SPL_TPL_)MMC_SUPPORT) += mmc/
 obj-$(CONFIG_$(SPL_TPL_)NAND_SUPPORT) += mtd/nand/
+obj-$(CONFIG_$(SPL_TPL_)PCI) += pci/
 obj-$(CONFIG_$(SPL_TPL_)PHY) += phy/
 obj-$(CONFIG_$(SPL_TPL_)PINCTRL) += pinctrl/
 obj-$(CONFIG_$(SPL_TPL_)RAM) += ram/
@@ -20,11 +21,17 @@ obj-$(CONFIG_$(SPL_TPL_)TIMER) += timer/
 ifndef CONFIG_TPL_BUILD
 ifdef CONFIG_SPL_BUILD
 
+ifneq ($(EXT_DDR_PATH),)
+DDR_PATH := $(EXT_DDR_PATH)
+else
+DDR_PATH := ddr/marvell/a38x/
+endif
+
 obj-$(CONFIG_SPL_CPU_SUPPORT) += cpu/
 obj-$(CONFIG_SPL_CRYPTO_SUPPORT) += crypto/
 obj-$(CONFIG_SPL_GPIO_SUPPORT) += gpio/
 obj-$(CONFIG_SPL_MPC8XXX_INIT_DDR_SUPPORT) += ddr/fsl/
-obj-$(CONFIG_ARMADA_38X) += ddr/marvell/a38x/
+obj-$(CONFIG_ARMADA_38X) += $(DDR_PATH)
 obj-$(CONFIG_ARMADA_XP) += ddr/marvell/axp/
 obj-$(CONFIG_ALTERA_SDRAM) += ddr/altera/
 obj-$(CONFIG_SPL_POWER_SUPPORT) += power/ power/pmic/
@@ -76,10 +83,12 @@ obj-$(CONFIG_FPGA) += fpga/
 obj-y += misc/
 obj-$(CONFIG_MMC) += mmc/
 obj-$(CONFIG_NVME) += nvme/
+obj-$(CONFIG_DM_MMC) += mmc/
 obj-y += pcmcia/
 obj-y += dfu/
 obj-$(CONFIG_X86) += pch/
 obj-y += phy/marvell/
+obj-y += mdio/
 obj-y += rtc/
 obj-y += scsi/
 obj-y += sound/
@@ -95,6 +104,7 @@ obj-y += memory/
 obj-y += pwm/
 obj-y += reset/
 obj-y += input/
+obj-y += fuse/
 # SOC specific infrastructure drivers.
 obj-y += soc/
 obj-$(CONFIG_REMOTEPROC) += remoteproc/
diff --git a/drivers/ata/Kconfig b/drivers/ata/Kconfig
index 86ec628..9ef4589 100644
--- a/drivers/ata/Kconfig
+++ b/drivers/ata/Kconfig
@@ -99,4 +99,13 @@ config SATA_SIL3114
 	help
 	  Enable this driver to support the SIL3114 SATA controllers.
 
+config AHCI_MVEBU
+	bool "Marvell EBU AHCI SATA support"
+	depends on ARCH_MVEBU
+	select DM_SCSI
+	help
+	  This option enables support for the Marvell EBU SoC's
+	  onboard AHCI SATA.
+
+	  If unsure, say N.
 endmenu
diff --git a/drivers/ata/Makefile b/drivers/ata/Makefile
index a94c804..0254640 100644
--- a/drivers/ata/Makefile
+++ b/drivers/ata/Makefile
@@ -19,3 +19,4 @@ obj-$(CONFIG_SATA_MV) += sata_mv.o
 obj-$(CONFIG_SATA_SIL3114) += sata_sil3114.o
 obj-$(CONFIG_SATA_SIL) += sata_sil.o
 obj-$(CONFIG_SANDBOX) += sata_sandbox.o
+obj-$(CONFIG_AHCI_MVEBU) += ahci_mvebu.o
diff --git a/drivers/ata/ahci-pci.c b/drivers/ata/ahci-pci.c
index 5a45edc..833e318 100644
--- a/drivers/ata/ahci-pci.c
+++ b/drivers/ata/ahci-pci.c
@@ -12,8 +12,19 @@
 static int ahci_pci_bind(struct udevice *dev)
 {
 	struct udevice *scsi_dev;
+	int ret;
 
-	return ahci_bind_scsi(dev, &scsi_dev);
+	ret = ahci_bind_scsi(dev, &scsi_dev);
+
+	if (ret)
+		goto out;
+
+	scsi_dev->uclass_priv = calloc(1, sizeof(struct ahci_uc_priv));
+	if (!scsi_dev->uclass_priv)
+		ret = -ENOMEM;
+
+out:
+	return ret;
 }
 
 static int ahci_pci_probe(struct udevice *dev)
diff --git a/drivers/ata/ahci.c b/drivers/ata/ahci.c
index 690d35c..36e19cd 100644
--- a/drivers/ata/ahci.c
+++ b/drivers/ata/ahci.c
@@ -1,4 +1,6 @@
 /*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
  * Copyright (C) Freescale Semiconductor, Inc. 2006.
  * Author: Jason Jin<Jason.jin@freescale.com>
  *         Zhang Wei<wei.zhang@freescale.com>
@@ -26,6 +28,9 @@
 #include <ahci.h>
 #include <dm/device-internal.h>
 #include <dm/lists.h>
+#if CONFIG_ARCH_OCTEONTX
+#include <asm/arch/octeontx.h>
+#endif
 
 static int ata_io_flush(struct ahci_uc_priv *uc_priv, u8 port);
 
@@ -270,7 +275,7 @@ static int ahci_host_init(struct ahci_uc_priv *uc_priv)
 		/* Bring up SATA link. */
 		ret = ahci_link_up(uc_priv, i);
 		if (ret) {
-			printf("SATA link %d timeout.\n", i);
+			debug("SATA link %d timeout.\n", i);
 			continue;
 		} else {
 			debug("SATA link ok.\n");
@@ -303,7 +308,7 @@ static int ahci_host_init(struct ahci_uc_priv *uc_priv)
 			continue;
 		}
 
-		printf("Target spinup took %d ms.\n", j);
+		debug("Target spinup took %d ms.\n", j);
 		if (j == WAIT_MS_SPINUP)
 			debug("timeout.\n");
 		else
@@ -397,38 +402,38 @@ static void ahci_print_info(struct ahci_uc_priv *uc_priv)
 	else
 		scc_s = "unknown";
 #endif
-	printf("AHCI %02x%02x.%02x%02x "
-	       "%u slots %u ports %s Gbps 0x%x impl %s mode\n",
-	       (vers >> 24) & 0xff,
-	       (vers >> 16) & 0xff,
-	       (vers >> 8) & 0xff,
-	       vers & 0xff,
-	       ((cap >> 8) & 0x1f) + 1, (cap & 0x1f) + 1, speed_s, impl, scc_s);
-
-	printf("flags: "
-	       "%s%s%s%s%s%s%s"
-	       "%s%s%s%s%s%s%s"
-	       "%s%s%s%s%s%s\n",
-	       cap & (1 << 31) ? "64bit " : "",
-	       cap & (1 << 30) ? "ncq " : "",
-	       cap & (1 << 28) ? "ilck " : "",
-	       cap & (1 << 27) ? "stag " : "",
-	       cap & (1 << 26) ? "pm " : "",
-	       cap & (1 << 25) ? "led " : "",
-	       cap & (1 << 24) ? "clo " : "",
-	       cap & (1 << 19) ? "nz " : "",
-	       cap & (1 << 18) ? "only " : "",
-	       cap & (1 << 17) ? "pmp " : "",
-	       cap & (1 << 16) ? "fbss " : "",
-	       cap & (1 << 15) ? "pio " : "",
-	       cap & (1 << 14) ? "slum " : "",
-	       cap & (1 << 13) ? "part " : "",
-	       cap & (1 << 7) ? "ccc " : "",
-	       cap & (1 << 6) ? "ems " : "",
-	       cap & (1 << 5) ? "sxs " : "",
-	       cap2 & (1 << 2) ? "apst " : "",
-	       cap2 & (1 << 1) ? "nvmp " : "",
-	       cap2 & (1 << 0) ? "boh " : "");
+	debug("AHCI %02x%02x.%02x%02x "
+	      "%u slots %u ports %s Gbps 0x%x impl %s mode\n",
+	      (vers >> 24) & 0xff,
+	      (vers >> 16) & 0xff,
+	      (vers >> 8) & 0xff,
+	      vers & 0xff,
+	      ((cap >> 8) & 0x1f) + 1, (cap & 0x1f) + 1, speed_s, impl, scc_s);
+
+	debug("flags: "
+	      "%s%s%s%s%s%s%s"
+	      "%s%s%s%s%s%s%s"
+	      "%s%s%s%s%s%s\n",
+	      cap & (1 << 31) ? "64bit " : "",
+	      cap & (1 << 30) ? "ncq " : "",
+	      cap & (1 << 28) ? "ilck " : "",
+	      cap & (1 << 27) ? "stag " : "",
+	      cap & (1 << 26) ? "pm " : "",
+	      cap & (1 << 25) ? "led " : "",
+	      cap & (1 << 24) ? "clo " : "",
+	      cap & (1 << 19) ? "nz " : "",
+	      cap & (1 << 18) ? "only " : "",
+	      cap & (1 << 17) ? "pmp " : "",
+	      cap & (1 << 16) ? "fbss " : "",
+	      cap & (1 << 15) ? "pio " : "",
+	      cap & (1 << 14) ? "slum " : "",
+	      cap & (1 << 13) ? "part " : "",
+	      cap & (1 << 7) ? "ccc " : "",
+	      cap & (1 << 6) ? "ems " : "",
+	      cap & (1 << 5) ? "sxs " : "",
+	      cap2 & (1 << 2) ? "apst " : "",
+	      cap2 & (1 << 1) ? "nvmp " : "",
+	      cap2 & (1 << 0) ? "boh " : "");
 }
 
 #if defined(CONFIG_DM_SCSI) || !defined(CONFIG_SCSI_AHCI_PLAT)
@@ -517,6 +522,11 @@ static int ahci_fill_sg(struct ahci_uc_priv *uc_priv, u8 port,
 		ahci_sg->addr =
 		    cpu_to_le32((unsigned long) buf + i * MAX_DATA_BYTE_COUNT);
 		ahci_sg->addr_hi = 0;
+#ifdef CONFIG_PHYS_64BIT
+		ahci_sg->addr_hi =
+		    cpu_to_le32((u32)(((u64)(buf + i * MAX_DATA_BYTE_COUNT)
+					>> 16) >> 16));
+#endif
 		ahci_sg->flags_size = cpu_to_le32(0x3fffff &
 					  (buf_len < MAX_DATA_BYTE_COUNT
 					   ? (buf_len - 1)
@@ -601,7 +611,7 @@ static int ahci_port_start(struct ahci_uc_priv *uc_priv, u8 port)
 	 * and its scatter-gather table
 	 */
 	pp->cmd_tbl = virt_to_phys((void *)mem);
-	debug("cmd_tbl_dma = %lx\n", pp->cmd_tbl);
+	debug("cmd_tbl_dma = %llx\n", pp->cmd_tbl);
 
 	mem += AHCI_CMD_TBL_HDR;
 	pp->cmd_tbl_sg =
@@ -609,8 +619,20 @@ static int ahci_port_start(struct ahci_uc_priv *uc_priv, u8 port)
 
 	writel_with_flush((unsigned long)pp->cmd_slot,
 			  port_mmio + PORT_LST_ADDR);
+#ifdef CONFIG_PHYS_64BIT
+	if (uc_priv->cap & HOST_64BIT)
+		writel_with_flush(
+			cpu_to_le32((u32)(((u64)(pp->cmd_slot) >> 16) >> 16)),
+			port_mmio + PORT_LST_ADDR_HI);
+#endif
 
 	writel_with_flush(pp->rx_fis, port_mmio + PORT_FIS_ADDR);
+#ifdef CONFIG_PHYS_64BIT
+	if (uc_priv->cap & HOST_64BIT)
+		writel_with_flush(
+			cpu_to_le32((u32)(((pp->rx_fis) >> 16) >> 16)),
+			port_mmio + PORT_FIS_ADDR_HI);
+#endif
 
 #ifdef CONFIG_SUNXI_AHCI
 	sunxi_dma_init(port_mmio);
@@ -622,6 +644,18 @@ static int ahci_port_start(struct ahci_uc_priv *uc_priv, u8 port)
 
 	debug("Exit start port %d\n", port);
 
+#if CONFIG_ARCH_OCTEONTX
+	/*
+	 * Skip interface busy check based on error and status
+	 * information from task file data register as these boards
+	 * have port multiplier and device is always present
+	 * U-boot lacks port multiplier support hence this ugly hack.
+	 */
+
+	if (octeontx_board_has_pmp())
+		return 0;
+#endif
+
 	/*
 	 * Make sure interface is not busy based on error and status
 	 * information from task file data register before proceeding
@@ -653,6 +687,17 @@ static int ahci_device_data_io(struct ahci_uc_priv *uc_priv, u8 port, u8 *fis,
 		return -1;
 	}
 
+	/*
+	 * If the device was plugged after boot, the port is not initialized
+	 * Try to restart the port for supporting device hot plug-in
+	 */
+	if (pp->cmd_tbl == 0) {
+		if (ahci_port_start(uc_priv, port)) {
+			printf("Cannot restart port %d\n", port);
+			return -1;
+		}
+	}
+
 	memcpy((unsigned char *)pp->cmd_tbl, fis, fis_len);
 
 	sg_count = ahci_fill_sg(uc_priv, port, buf, buf_len);
@@ -941,6 +986,8 @@ static int ahci_scsi_exec(struct udevice *dev, struct scsi_cmd *pccb)
 #endif
 	int ret;
 
+	debug("ahci_scsi_exec: CMD %d\n", pccb->cmd[0]);
+
 	switch (pccb->cmd[0]) {
 	case SCSI_READ16:
 	case SCSI_READ10:
@@ -984,7 +1031,7 @@ static int ahci_start_ports(struct ahci_uc_priv *uc_priv)
 	for (i = 0; i < CONFIG_SYS_SCSI_MAX_SCSI_ID; i++) {
 		if (((linkmap >> i) & 0x01)) {
 			if (ahci_port_start(uc_priv, (u8) i)) {
-				printf("Can not start port %d\n", i);
+				debug("AHCI Can not start port %d\n", i);
 				continue;
 			}
 		}
@@ -1177,6 +1224,9 @@ int ahci_probe_scsi(struct udevice *ahci_dev, ulong base)
 	ret = ahci_init_one(uc_priv, dev);
 	if (ret)
 		return ret;
+
+	uc_plat->max_id = uc_priv->n_ports;
+
 	ret = ahci_start_ports(uc_priv);
 	if (ret)
 		return ret;
@@ -1188,9 +1238,17 @@ int ahci_probe_scsi(struct udevice *ahci_dev, ulong base)
 int ahci_probe_scsi_pci(struct udevice *ahci_dev)
 {
 	ulong base;
+	int bar = 5;
+	size_t size;
+	u16 vendor, device;
+
+	dm_pci_read_config16(ahci_dev, PCI_VENDOR_ID, &vendor);
+	dm_pci_read_config16(ahci_dev, PCI_DEVICE_ID, &device);
 
-	base = (ulong)dm_pci_map_bar(ahci_dev, PCI_BASE_ADDRESS_5,
-				     PCI_REGION_MEM);
+	debug("AHCI device %04x:%04x\n", vendor, device);
+	if ((vendor == 0x177d) && (device == 0xa01c))
+		bar = 0;
+	base = (uintptr_t)dm_pci_map_bar(ahci_dev, bar, &size, PCI_REGION_MEM);
 
 	return ahci_probe_scsi(ahci_dev, base);
 }
diff --git a/drivers/ata/ahci_mvebu.c b/drivers/ata/ahci_mvebu.c
new file mode 100644
index 0000000..7b97d9d
--- /dev/null
+++ b/drivers/ata/ahci_mvebu.c
@@ -0,0 +1,59 @@
+// SPDX-License-Identifier:	GPL-2.0+
+/*
+ * Copyright (C) 2016 Stefan Roese <sr@denx.de>
+ *
+ */
+
+#include <common.h>
+#include <ahci.h>
+#include <dm.h>
+
+/*
+ * Dummy implementation that can be overwritten by a board
+ * specific function
+ */
+__weak int board_ahci_enable(void)
+{
+	return 0;
+}
+
+static int mvebu_ahci_bind(struct udevice *dev)
+{
+	struct udevice *scsi_dev;
+	int ret;
+
+	ret = ahci_bind_scsi(dev, &scsi_dev);
+	if (ret) {
+		debug("%s: Failed to bind (err=%d\n)", __func__, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int mvebu_ahci_probe(struct udevice *dev)
+{
+	/*
+	 * Board specific SATA / AHCI enable code, e.g. enable the
+	 * AHCI power or deassert reset
+	 */
+	board_ahci_enable();
+
+	ahci_probe_scsi(dev, (ulong)devfdt_get_addr_ptr(dev));
+
+	return 0;
+}
+
+static const struct udevice_id mvebu_ahci_ids[] = {
+	{ .compatible = "marvell,armada-3700-ahci" },
+	{ .compatible = "marvell,armada-8k-ahci" },
+	{ }
+};
+
+U_BOOT_DRIVER(ahci_mvebu_drv) = {
+	.name		= "ahci_mvebu",
+	.id		= UCLASS_AHCI,
+	.of_match	= mvebu_ahci_ids,
+	.bind		= mvebu_ahci_bind,
+	.probe		= mvebu_ahci_probe,
+};
diff --git a/drivers/ata/dwc_ahsata.c b/drivers/ata/dwc_ahsata.c
index 480ae11..b0a6a11 100644
--- a/drivers/ata/dwc_ahsata.c
+++ b/drivers/ata/dwc_ahsata.c
@@ -100,7 +100,12 @@ static int waiting_for_cmd_completed(u8 *offset,
 	return (i < timeout_msec) ? 0 : -1;
 }
 
+<<<<<<< HEAD
 static int ahci_setup_oobr(struct ahci_uc_priv *uc_priv, int clk)
+=======
+static int ahci_setup_oobr(struct ahci_uc_priv *probe_ent,
+						int clk)
+>>>>>>> dm: ahci: Rename struct ahci_probe_ent
 {
 	struct sata_host_regs *host_mmio = uc_priv->mmio_base;
 
@@ -110,7 +115,11 @@ static int ahci_setup_oobr(struct ahci_uc_priv *uc_priv, int clk)
 	return 0;
 }
 
+<<<<<<< HEAD
 static int ahci_host_init(struct ahci_uc_priv *uc_priv)
+=======
+static int ahci_host_init(struct ahci_uc_priv *probe_ent)
+>>>>>>> dm: ahci: Rename struct ahci_probe_ent
 {
 	u32 tmp, cap_save, num_ports;
 	int i, j, timeout = 1000;
@@ -267,7 +276,11 @@ static int ahci_host_init(struct ahci_uc_priv *uc_priv)
 	return 0;
 }
 
+<<<<<<< HEAD
 static void ahci_print_info(struct ahci_uc_priv *uc_priv)
+=======
+static void ahci_print_info(struct ahci_uc_priv *probe_ent)
+>>>>>>> dm: ahci: Rename struct ahci_probe_ent
 {
 	struct sata_host_regs *host_mmio = uc_priv->mmio_base;
 	u32 vers, cap, impl, speed;
@@ -319,8 +332,46 @@ static void ahci_print_info(struct ahci_uc_priv *uc_priv)
 		cap & (1 << 13) ? "part " : "");
 }
 
+<<<<<<< HEAD
 static int ahci_fill_sg(struct ahci_uc_priv *uc_priv, u8 port,
 			unsigned char *buf, int buf_len)
+=======
+static int ahci_init_one(int pdev)
+{
+	int rc;
+	struct ahci_uc_priv *probe_ent = NULL;
+
+	probe_ent = malloc(sizeof(struct ahci_uc_priv));
+	memset(probe_ent, 0, sizeof(struct ahci_uc_priv));
+	probe_ent->dev = pdev;
+
+	probe_ent->host_flags = ATA_FLAG_SATA
+				| ATA_FLAG_NO_LEGACY
+				| ATA_FLAG_MMIO
+				| ATA_FLAG_PIO_DMA
+				| ATA_FLAG_NO_ATAPI;
+
+	probe_ent->mmio_base = (void __iomem *)CONFIG_DWC_AHSATA_BASE_ADDR;
+
+	/* initialize adapter */
+	rc = ahci_host_init(probe_ent);
+	if (rc)
+		goto err_out;
+
+	ahci_print_info(probe_ent);
+
+	/* Save the private struct to block device struct */
+	sata_dev_desc[pdev].priv = (void *)probe_ent;
+
+	return 0;
+
+err_out:
+	return rc;
+}
+
+static int ahci_fill_sg(struct ahci_uc_priv *probe_ent,
+			u8 port, unsigned char *buf, int buf_len)
+>>>>>>> dm: ahci: Rename struct ahci_probe_ent
 {
 	struct ahci_ioports *pp = &uc_priv->port[port];
 	struct ahci_sg *ahci_sg = pp->cmd_tbl_sg;
@@ -366,9 +417,15 @@ static void ahci_fill_cmd_slot(struct ahci_ioports *pp, u32 cmd_slot, u32 opts)
 
 #define AHCI_GET_CMD_SLOT(c) ((c) ? ffs(c) : 0)
 
+<<<<<<< HEAD
 static int ahci_exec_ata_cmd(struct ahci_uc_priv *uc_priv, u8 port,
 			     struct sata_fis_h2d *cfis, u8 *buf, u32 buf_len,
 			     s32 is_write)
+=======
+static int ahci_exec_ata_cmd(struct ahci_uc_priv *probe_ent,
+		u8 port, struct sata_fis_h2d *cfis,
+		u8 *buf, u32 buf_len, s32 is_write)
+>>>>>>> dm: ahci: Rename struct ahci_probe_ent
 {
 	struct ahci_ioports *pp = &uc_priv->port[port];
 	struct sata_port_regs *port_mmio = pp->port_mmio;
@@ -418,6 +475,11 @@ static int ahci_exec_ata_cmd(struct ahci_uc_priv *uc_priv, u8 port,
 
 static void ahci_set_feature(struct ahci_uc_priv *uc_priv, u8 port)
 {
+<<<<<<< HEAD
+=======
+	struct ahci_uc_priv *probe_ent =
+		(struct ahci_uc_priv *)sata_dev_desc[dev].priv;
+>>>>>>> dm: ahci: Rename struct ahci_probe_ent
 	struct sata_fis_h2d h2d __aligned(ARCH_DMA_MINALIGN);
 	struct sata_fis_h2d *cfis = &h2d;
 
@@ -431,7 +493,12 @@ static void ahci_set_feature(struct ahci_uc_priv *uc_priv, u8 port)
 	ahci_exec_ata_cmd(uc_priv, port, cfis, NULL, 0, READ_CMD);
 }
 
+<<<<<<< HEAD
 static int ahci_port_start(struct ahci_uc_priv *uc_priv, u8 port)
+=======
+static int ahci_port_start(struct ahci_uc_priv *probe_ent,
+					u8 port)
+>>>>>>> dm: ahci: Rename struct ahci_probe_ent
 {
 	struct ahci_ioports *pp = &uc_priv->port[port];
 	struct sata_port_regs *port_mmio = pp->port_mmio;
@@ -509,7 +576,73 @@ static int ahci_port_start(struct ahci_uc_priv *uc_priv, u8 port)
 	return 0;
 }
 
+<<<<<<< HEAD
 static void dwc_ahsata_print_info(struct blk_desc *pdev)
+=======
+int init_sata(int dev)
+{
+	int i;
+	u32 linkmap;
+	struct ahci_uc_priv *probe_ent = NULL;
+
+#if defined(CONFIG_MX6)
+	if (!is_mx6dq() && !is_mx6dqp())
+		return 1;
+#endif
+	if (dev < 0 || dev > (CONFIG_SYS_SATA_MAX_DEVICE - 1)) {
+		printf("The sata index %d is out of ranges\n\r", dev);
+		return -1;
+	}
+
+	ahci_init_one(dev);
+
+	probe_ent = (struct ahci_uc_priv *)sata_dev_desc[dev].priv;
+	linkmap = probe_ent->link_port_map;
+
+	if (0 == linkmap) {
+		printf("No port device detected!\n");
+		return 1;
+	}
+
+	for (i = 0; i < probe_ent->n_ports; i++) {
+		if ((linkmap >> i) && ((linkmap >> i) & 0x01)) {
+			if (ahci_port_start(probe_ent, (u8)i)) {
+				printf("Can not start port %d\n", i);
+				return 1;
+			}
+			probe_ent->hard_port_no = i;
+			break;
+		}
+	}
+
+	return 0;
+}
+
+int reset_sata(int dev)
+{
+	struct ahci_uc_priv *probe_ent;
+	struct sata_host_regs *host_mmio;
+
+	if (dev < 0 || dev > (CONFIG_SYS_SATA_MAX_DEVICE - 1)) {
+		printf("The sata index %d is out of ranges\n\r", dev);
+		return -1;
+	}
+
+	probe_ent = (struct ahci_uc_priv *)sata_dev_desc[dev].priv;
+	if (NULL == probe_ent)
+		/* not initialized, so nothing to reset */
+		return 0;
+
+	host_mmio = (struct sata_host_regs *)probe_ent->mmio_base;
+	setbits_le32(&host_mmio->ghc, SATA_HOST_GHC_HR);
+	while (readl(&host_mmio->ghc) & SATA_HOST_GHC_HR)
+		udelay(100);
+
+	return 0;
+}
+
+static void dwc_ahsata_print_info(int dev)
+>>>>>>> dm: ahci: Rename struct ahci_probe_ent
 {
 	printf("SATA Device Info:\n\r");
 #ifdef CONFIG_SYS_64BIT_LBA
@@ -525,6 +658,11 @@ static void dwc_ahsata_print_info(struct blk_desc *pdev)
 
 static void dwc_ahsata_identify(struct ahci_uc_priv *uc_priv, u16 *id)
 {
+<<<<<<< HEAD
+=======
+	struct ahci_uc_priv *probe_ent =
+		(struct ahci_uc_priv *)sata_dev_desc[dev].priv;
+>>>>>>> dm: ahci: Rename struct ahci_probe_ent
 	struct sata_fis_h2d h2d __aligned(ARCH_DMA_MINALIGN);
 	struct sata_fis_h2d *cfis = &h2d;
 	u8 port = uc_priv->hard_port_no;
@@ -542,14 +680,29 @@ static void dwc_ahsata_identify(struct ahci_uc_priv *uc_priv, u16 *id)
 
 static void dwc_ahsata_xfer_mode(struct ahci_uc_priv *uc_priv, u16 *id)
 {
+<<<<<<< HEAD
 	uc_priv->pio_mask = id[ATA_ID_PIO_MODES];
 	uc_priv->udma_mask = id[ATA_ID_UDMA_MODES];
 	debug("pio %04x, udma %04x\n\r", uc_priv->pio_mask, uc_priv->udma_mask);
+=======
+	struct ahci_uc_priv *probe_ent =
+		(struct ahci_uc_priv *)sata_dev_desc[dev].priv;
+
+	probe_ent->pio_mask = id[ATA_ID_PIO_MODES];
+	probe_ent->udma_mask = id[ATA_ID_UDMA_MODES];
+	debug("pio %04x, udma %04x\n\r",
+		probe_ent->pio_mask, probe_ent->udma_mask);
+>>>>>>> dm: ahci: Rename struct ahci_probe_ent
 }
 
 static u32 dwc_ahsata_rw_cmd(struct ahci_uc_priv *uc_priv, u32 start,
 			     u32 blkcnt, u8 *buffer, int is_write)
 {
+<<<<<<< HEAD
+=======
+	struct ahci_uc_priv *probe_ent =
+		(struct ahci_uc_priv *)sata_dev_desc[dev].priv;
+>>>>>>> dm: ahci: Rename struct ahci_probe_ent
 	struct sata_fis_h2d h2d __aligned(ARCH_DMA_MINALIGN);
 	struct sata_fis_h2d *cfis = &h2d;
 	u8 port = uc_priv->hard_port_no;
@@ -579,6 +732,11 @@ static u32 dwc_ahsata_rw_cmd(struct ahci_uc_priv *uc_priv, u32 start,
 
 static void dwc_ahsata_flush_cache(struct ahci_uc_priv *uc_priv)
 {
+<<<<<<< HEAD
+=======
+	struct ahci_uc_priv *probe_ent =
+		(struct ahci_uc_priv *)sata_dev_desc[dev].priv;
+>>>>>>> dm: ahci: Rename struct ahci_probe_ent
 	struct sata_fis_h2d h2d __aligned(ARCH_DMA_MINALIGN);
 	struct sata_fis_h2d *cfis = &h2d;
 	u8 port = uc_priv->hard_port_no;
@@ -595,6 +753,11 @@ static void dwc_ahsata_flush_cache(struct ahci_uc_priv *uc_priv)
 static u32 dwc_ahsata_rw_cmd_ext(struct ahci_uc_priv *uc_priv, u32 start,
 				 lbaint_t blkcnt, u8 *buffer, int is_write)
 {
+<<<<<<< HEAD
+=======
+	struct ahci_uc_priv *probe_ent =
+		(struct ahci_uc_priv *)sata_dev_desc[dev].priv;
+>>>>>>> dm: ahci: Rename struct ahci_probe_ent
 	struct sata_fis_h2d h2d __aligned(ARCH_DMA_MINALIGN);
 	struct sata_fis_h2d *cfis = &h2d;
 	u8 port = uc_priv->hard_port_no;
@@ -627,8 +790,58 @@ static u32 dwc_ahsata_rw_cmd_ext(struct ahci_uc_priv *uc_priv, u32 start,
 		return 0;
 }
 
+<<<<<<< HEAD
 static void dwc_ahsata_flush_cache_ext(struct ahci_uc_priv *uc_priv)
 {
+=======
+u32 dwc_ahsata_rw_ncq_cmd(int dev, u32 start, lbaint_t blkcnt,
+				u8 *buffer, int is_write)
+{
+	struct ahci_uc_priv *probe_ent =
+		(struct ahci_uc_priv *)sata_dev_desc[dev].priv;
+	struct sata_fis_h2d h2d __aligned(ARCH_DMA_MINALIGN);
+	struct sata_fis_h2d *cfis = &h2d;
+	u8 port = probe_ent->hard_port_no;
+	u64 block;
+
+	if (sata_dev_desc[dev].lba48 != 1) {
+		printf("execute FPDMA command on non-LBA48 hard disk\n\r");
+		return -1;
+	}
+
+	block = (u64)start;
+
+	memset(cfis, 0, sizeof(struct sata_fis_h2d));
+
+	cfis->fis_type = SATA_FIS_TYPE_REGISTER_H2D;
+	cfis->pm_port_c = 0x80; /* is command */
+
+	cfis->command = (is_write) ? ATA_CMD_FPDMA_WRITE
+				 : ATA_CMD_FPDMA_READ;
+
+	cfis->lba_high_exp = (block >> 40) & 0xff;
+	cfis->lba_mid_exp = (block >> 32) & 0xff;
+	cfis->lba_low_exp = (block >> 24) & 0xff;
+	cfis->lba_high = (block >> 16) & 0xff;
+	cfis->lba_mid = (block >> 8) & 0xff;
+	cfis->lba_low = block & 0xff;
+
+	cfis->device = ATA_LBA;
+	cfis->features_exp = (blkcnt >> 8) & 0xff;
+	cfis->features = blkcnt & 0xff;
+
+	/* Use the latest queue */
+	ahci_exec_ata_cmd(probe_ent, port, cfis,
+			buffer, ATA_SECT_SIZE * blkcnt, is_write);
+
+	return blkcnt;
+}
+
+void dwc_ahsata_flush_cache_ext(int dev)
+{
+	struct ahci_uc_priv *probe_ent =
+		(struct ahci_uc_priv *)sata_dev_desc[dev].priv;
+>>>>>>> dm: ahci: Rename struct ahci_probe_ent
 	struct sata_fis_h2d h2d __aligned(ARCH_DMA_MINALIGN);
 	struct sata_fis_h2d *cfis = &h2d;
 	u8 port = uc_priv->hard_port_no;
@@ -644,6 +857,12 @@ static void dwc_ahsata_flush_cache_ext(struct ahci_uc_priv *uc_priv)
 
 static void dwc_ahsata_init_wcache(struct ahci_uc_priv *uc_priv, u16 *id)
 {
+<<<<<<< HEAD
+=======
+	struct ahci_uc_priv *probe_ent =
+		(struct ahci_uc_priv *)sata_dev_desc[dev].priv;
+
+>>>>>>> dm: ahci: Rename struct ahci_probe_ent
 	if (ata_id_has_wcache(id) && ata_id_wcache_enabled(id))
 		uc_priv->flags |= SATA_FLAG_WCACHE;
 	if (ata_id_has_flush(id))
@@ -725,10 +944,24 @@ static u32 ata_low_level_rw_lba28(struct ahci_uc_priv *uc_priv, u32 blknr,
 
 static int dwc_ahci_start_ports(struct ahci_uc_priv *uc_priv)
 {
+<<<<<<< HEAD
 	u32 linkmap;
 	int i;
 
 	linkmap = uc_priv->link_port_map;
+=======
+	struct sata_port_regs *port_mmio;
+	struct ahci_uc_priv *probe_ent = NULL;
+
+	if (dev < 0 || dev > (CONFIG_SYS_SATA_MAX_DEVICE - 1))
+		return -EINVAL;
+
+	if (sata_dev_desc[dev].priv == NULL)
+		return -ENODEV;
+
+	probe_ent = (struct ahci_uc_priv *)sata_dev_desc[dev].priv;
+	port_mmio = (struct sata_port_regs *)probe_ent->port[port].port_mmio;
+>>>>>>> dm: ahci: Rename struct ahci_probe_ent
 
 	if (0 == linkmap) {
 		printf("No port device detected!\n");
@@ -749,15 +982,57 @@ static int dwc_ahci_start_ports(struct ahci_uc_priv *uc_priv)
 	return 0;
 }
 
+<<<<<<< HEAD
 static int dwc_ahsata_scan_common(struct ahci_uc_priv *uc_priv,
 				  struct blk_desc *pdev)
+=======
+ulong sata_write(int dev, ulong blknr, lbaint_t blkcnt, const void *buffer)
+{
+	u32 rc;
+	struct ahci_uc_priv *probe_ent =
+		(struct ahci_uc_priv *)sata_dev_desc[dev].priv;
+	u32 flags = probe_ent->flags;
+
+	if (sata_dev_desc[dev].lba48) {
+		rc = ata_low_level_rw_lba48(dev, blknr, blkcnt,
+						buffer, WRITE_CMD);
+		if ((flags & SATA_FLAG_WCACHE) &&
+			(flags & SATA_FLAG_FLUSH_EXT))
+			dwc_ahsata_flush_cache_ext(dev);
+	} else {
+		rc = ata_low_level_rw_lba28(dev, blknr, blkcnt,
+						buffer, WRITE_CMD);
+		if ((flags & SATA_FLAG_WCACHE) &&
+			(flags & SATA_FLAG_FLUSH))
+			dwc_ahsata_flush_cache(dev);
+	}
+	return rc;
+}
+
+int scan_sata(int dev)
+>>>>>>> dm: ahci: Rename struct ahci_probe_ent
 {
 	u8 serial[ATA_ID_SERNO_LEN + 1] = { 0 };
 	u8 firmware[ATA_ID_FW_REV_LEN + 1] = { 0 };
 	u8 product[ATA_ID_PROD_LEN + 1] = { 0 };
 	u64 n_sectors;
+<<<<<<< HEAD
 	u8 port = uc_priv->hard_port_no;
 	ALLOC_CACHE_ALIGN_BUFFER(u16, id, ATA_ID_WORDS);
+=======
+	struct ahci_uc_priv *probe_ent =
+		(struct ahci_uc_priv *)sata_dev_desc[dev].priv;
+	u8 port = probe_ent->hard_port_no;
+	struct blk_desc *pdev = &(sata_dev_desc[dev]);
+
+	id = (u16 *)memalign(ARCH_DMA_MINALIGN,
+				roundup(ARCH_DMA_MINALIGN,
+					(ATA_ID_WORDS * 2)));
+	if (!id) {
+		printf("id malloc failed\n\r");
+		return -1;
+	}
+>>>>>>> dm: ahci: Rename struct ahci_probe_ent
 
 	/* Identify device to get information */
 	dwc_ahsata_identify(uc_priv, id);
diff --git a/drivers/block/Kconfig b/drivers/block/Kconfig
index 15fd1bc..8e1abc6 100644
--- a/drivers/block/Kconfig
+++ b/drivers/block/Kconfig
@@ -36,6 +36,13 @@ config BLOCK_CACHE
 	  it will prevent repeated reads from directory structures and other
 	  filesystem data structures.
 
+config NVME
+	bool "Support NVMe devices"
+	depends on PCI
+	help
+	  This option enables supporting for NVMe devices.
+	  It supports basic functions of NVMe(read/write).
+
 config IDE
 	bool "Support IDE controllers"
 	select HAVE_BLOCK_DEVICE
diff --git a/drivers/block/blk-uclass.c b/drivers/block/blk-uclass.c
index c32aee6..e7ea8e9 100644
--- a/drivers/block/blk-uclass.c
+++ b/drivers/block/blk-uclass.c
@@ -4,7 +4,6 @@
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
-
 #include <common.h>
 #include <blk.h>
 #include <dm.h>
diff --git a/drivers/core/device.c b/drivers/core/device.c
index 940a153..16d8769 100644
--- a/drivers/core/device.c
+++ b/drivers/core/device.c
@@ -231,6 +231,14 @@ int device_bind(struct udevice *parent, const struct driver *drv,
 				  offset_to_ofnode(of_offset), 0, devp);
 }
 
+int device_bind_ofnode(struct udevice *parent, const struct driver *drv,
+		       const char *name, void *platdata, ofnode node,
+		       struct udevice **devp)
+{
+	return device_bind_common(parent, drv, name, platdata, 0, node, 0,
+				  devp);
+}
+
 int device_bind_by_name(struct udevice *parent, bool pre_reloc_only,
 			const struct driver_info *info, struct udevice **devp)
 {
diff --git a/drivers/core/ofnode.c b/drivers/core/ofnode.c
index 4e45326..78c97e7 100644
--- a/drivers/core/ofnode.c
+++ b/drivers/core/ofnode.c
@@ -589,6 +589,42 @@ fail:
 	return ret;
 }
 
+int ofnode_read_pci_vendev(ofnode node, u16 *vendor, u16 *device)
+{
+	const char *list, *end;
+	int len;
+
+	list = ofnode_get_property(node, "compatible", &len);
+	if (!list)
+		return -ENOENT;
+
+	end = list + len;
+	while (list < end) {
+		len = strlen(list);
+		if (len >= strlen("pciVVVV,DDDD")) {
+			char *s = strstr(list, "pci");
+
+			/*
+			 * check if the string is something like pciVVVV,DDDD.RR
+			 * or just pciVVVV,DDDD
+			 */
+			if (s && s[7] == ',' &&
+			    (s[12] == '.' || s[12] == 0)) {
+				s += 3;
+				*vendor = simple_strtol(s, NULL, 16);
+
+				s += 5;
+				*device = simple_strtol(s, NULL, 16);
+
+				return 0;
+			}
+		}
+		list += (len + 1);
+	}
+
+	return -ENOENT;
+}
+
 int ofnode_read_addr_cells(ofnode node)
 {
 	if (ofnode_is_np(node))
diff --git a/drivers/ddr/marvell/a38x/ddr3_init.c b/drivers/ddr/marvell/a38x/ddr3_init.c
index 55baad4..032c4d5 100644
--- a/drivers/ddr/marvell/a38x/ddr3_init.c
+++ b/drivers/ddr/marvell/a38x/ddr3_init.c
@@ -109,30 +109,6 @@ static int ddr3_hws_tune_training_params(u8 dev_num);
 #define MV_88F69XX_Z1_ID		0x2
 
 /*
- * sys_env_device_rev_get - Get Marvell controller device revision number
- *
- * DESCRIPTION:
- *       This function returns 8bit describing the device revision as defined
- *       Revision ID Register.
- *
- * INPUT:
- *       None.
- *
- * OUTPUT:
- *       None.
- *
- * RETURN:
- *       8bit desscribing Marvell controller revision number
- */
-u8 sys_env_device_rev_get(void)
-{
-	u32 value;
-
-	value = reg_read(DEV_VERSION_ID_REG);
-	return (value & (REVISON_ID_MASK)) >> REVISON_ID_OFFS;
-}
-
-/*
  * sys_env_dlb_config_ptr_get
  *
  * DESCRIPTION: defines pointer to to DLB COnfiguration table
diff --git a/drivers/fuse/Kconfig b/drivers/fuse/Kconfig
new file mode 100644
index 0000000..005673e
--- /dev/null
+++ b/drivers/fuse/Kconfig
@@ -0,0 +1,24 @@
+#
+# EFUSE infrastructure and drivers
+#
+
+menu "EFUSE Support"
+
+config MVEBU_EFUSE
+	bool "Enable eFuse support"
+	default n
+	depends on HAVE_MVEBU_EFUSE
+	help
+	  This enable mvebu efuse driver.
+	  It supports for reading and writing eFuses.
+	  This efuse driver supports marvell
+	  a38x and a7k/8k SoC chips.
+
+config MVEBU_EFUSE_READ_ONLY
+	bool "eFuse read only access"
+	default n
+	depends on MVEBU_EFUSE
+	help
+	  This enables a "read only" mode. Write attempt
+          will result in an error message.
+endmenu
diff --git a/drivers/fuse/Makefile b/drivers/fuse/Makefile
new file mode 100644
index 0000000..02971f3
--- /dev/null
+++ b/drivers/fuse/Makefile
@@ -0,0 +1,4 @@
+obj-$(CONFIG_MVEBU_EFUSE) += fuse-mvebu.o
+obj-$(CONFIG_MVEBU_EFUSE) += fuse-mvebu-hd.o
+obj-$(CONFIG_MVEBU_EFUSE) += fuse-mvebu-ld.o
+obj-$(CONFIG_ARMADA_38X) += fuse-mvebu-init.o
diff --git a/drivers/fuse/fuse-mvebu-hd.c b/drivers/fuse/fuse-mvebu-hd.c
new file mode 100644
index 0000000..1a338fb
--- /dev/null
+++ b/drivers/fuse/fuse-mvebu-hd.c
@@ -0,0 +1,111 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <asm/io.h>
+#include <errno.h>
+#include <mvebu/fuse-mvebu.h>
+
+#define GET_LEN(width)  DIV_ROUND_UP(width, 32)
+#define ROW_WORDS_LEN	3
+#define ECC_BITS_MASK	0xfe000000
+
+static int valid_prog_words;
+static u32 prog_val[ROW_WORDS_LEN];
+
+int mvebu_efuse_hd_read(struct udevice *dev, int row_id, u32 *val)
+{
+	void __iomem *otp_mem;
+	int row_base, i, row_widths;
+	struct mvebu_fuse_block_data *priv = dev_get_priv(dev);
+
+	row_base = priv->row_base;
+	otp_mem = priv->target_otp_mem + (row_id - row_base) *
+		   priv->pdata->row_step;
+	row_widths = priv->pdata->row_bit_width;
+
+	for (i = 0; i < GET_LEN(row_widths); i++)
+		*(val + i) = readl(otp_mem + 4 * i);
+
+	return 0;
+}
+
+static int do_mvebu_efuse_hd_prog(struct udevice *dev, int row_id, u32 *new_val)
+{
+	void __iomem *otp_mem, *ctrl_reg;
+	int row_base, i, row_widths;
+	struct mvebu_fuse_block_data *priv = dev_get_priv(dev);
+	u32 fuse_read_value[ROW_WORDS_LEN];
+
+	row_base = priv->row_base;
+	otp_mem = priv->target_otp_mem + (row_id - row_base) *
+		   priv->pdata->row_step;
+	ctrl_reg = priv->control_reg;
+	row_widths = priv->pdata->row_bit_width;
+
+	/* only write a fuse line with lock bit */
+	if (!(*(new_val + 2) & 0x1))
+		return -EINVAL;
+	/* according to specs ECC protection bits must be 0 on write */
+	if (*(new_val + 1) & ECC_BITS_MASK)
+		return -EINVAL;
+
+	/* enable fuse prog */
+	setbits_le32(ctrl_reg, MVEBU_EFUSE_CTRL_PROGRAM_ENABLE);
+	/* read fuse row value before burn fuse */
+	for (i = 0; i < GET_LEN(row_widths); i++)
+		fuse_read_value[i] = readl(otp_mem + 4 * i);
+	/* fuse row value burn */
+	for (i = 0; i < GET_LEN(row_widths); i++) {
+		fuse_read_value[i] |= *(new_val + i);
+		writel(fuse_read_value[i], otp_mem + 4 * i);
+	}
+
+	/* wait 1 ms for burn efuse */
+	mdelay(1);
+
+	/* Disable efuse write */
+	clrbits_le32(ctrl_reg, MVEBU_EFUSE_CTRL_PROGRAM_ENABLE);
+
+	return 0;
+}
+
+int mvebu_efuse_hd_prog(struct udevice *dev, int word, int row_id, u32 new_val)
+{
+	int res = 0;
+
+#ifdef EFUSE_READ_ONLY
+	dev_err(&dev->dev, "ERROR: fuse programming disabled!\n");
+	return -EPERM;
+#endif
+
+	if (word < ROW_WORDS_LEN - 1) {
+		prog_val[word] = new_val;
+		valid_prog_words |= (1 << word);
+	}
+
+	if (word == ROW_WORDS_LEN - 1) {
+		if ((valid_prog_words & 3) == 0 && new_val) {
+			prog_val[0] = 0;
+			prog_val[1] = 0;
+			/* lock bit is set to 1*/
+			prog_val[2] = 1;
+			res = do_mvebu_efuse_hd_prog(dev, row_id, prog_val);
+			valid_prog_words = 0;
+		} else if ((valid_prog_words & 3) == 3 && new_val) {
+			prog_val[ROW_WORDS_LEN - 1] = new_val;
+			res = do_mvebu_efuse_hd_prog(dev, row_id, prog_val);
+			valid_prog_words = 0;
+		} else {
+			res = -EINVAL;
+			valid_prog_words = 0;
+		}
+	}
+
+	return res;
+}
diff --git a/drivers/fuse/fuse-mvebu-init.c b/drivers/fuse/fuse-mvebu-init.c
new file mode 100644
index 0000000..b487ac6
--- /dev/null
+++ b/drivers/fuse/fuse-mvebu-init.c
@@ -0,0 +1,33 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ * Copyright (C) 2015-2016 Reinhard Pfau <reinhard.pfau@gdsys.cc>
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <config.h>
+#include <common.h>
+#include <asm/arch/cpu.h>
+#include <linux/mbus.h>
+#include <dm.h>
+#include <asm/io.h>
+#include <errno.h>
+#include <mvebu/fuse-mvebu.h>
+
+#define MBUS_EFUSE_SIZE BIT(20)
+#define EFUSE_ADDR_MASK	0xff000000
+
+int mvebu_efuse_init_hw(struct udevice *dev)
+{
+	struct mvebu_fuse_block_data *priv = dev_get_priv(dev);
+	int ret = 0;
+	phys_addr_t efuse_base;
+
+	efuse_base = (phys_addr_t)priv->target_otp_mem & EFUSE_ADDR_MASK;
+
+	ret = mvebu_mbus_add_window_by_id(CPU_TARGET_SATA23_DFX,
+					  0xA, efuse_base, MBUS_EFUSE_SIZE);
+
+	return ret;
+}
diff --git a/drivers/fuse/fuse-mvebu-ld.c b/drivers/fuse/fuse-mvebu-ld.c
new file mode 100644
index 0000000..7f42678
--- /dev/null
+++ b/drivers/fuse/fuse-mvebu-ld.c
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:       GPL-2.0+
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <asm/io.h>
+#include <errno.h>
+#include <mvebu/fuse-mvebu.h>
+
+#define GET_LEN(width)  DIV_ROUND_UP(width, 32)
+#define ROW_WORDS_LEN	8
+
+static int valid_prog_words;
+static u32 prog_val[ROW_WORDS_LEN];
+
+int mvebu_efuse_ld_read(struct udevice *dev, int row_id, u32 *val)
+{
+	void __iomem *otp_mem, *ctrl_reg;
+	int row_base, i, row_widths;
+	struct mvebu_fuse_block_data *priv = dev_get_priv(dev);
+
+	row_base = priv->row_base;
+	otp_mem = priv->target_otp_mem + (row_id - row_base) *
+		   priv->pdata->row_step;
+	ctrl_reg = priv->control_reg;
+	row_widths = priv->pdata->row_bit_width;
+
+	/* when read_only flag is set, which means read LD0 */
+	if (device_is_compatible(dev, "marvell,mvebu-fuse-ld-user"))
+		clrbits_le32(ctrl_reg, MVEBU_EFUSE_SRV_CTRL_LD_SEL_USER);
+	else
+		setbits_le32(ctrl_reg, MVEBU_EFUSE_SRV_CTRL_LD_SEL_USER);
+
+	for (i = 0; i < GET_LEN(row_widths); i++)
+		*(val + i) = readl(otp_mem + 4 * i);
+
+	return 0;
+}
+
+int do_mvebu_efuse_ld_prog(struct udevice *dev, int row_id, u32 *new_val)
+{
+	void __iomem *otp_mem, *ctrl_reg;
+	int row_base, i, row_widths;
+	struct mvebu_fuse_block_data *priv = dev_get_priv(dev);
+	u32 fuse_read_value[ROW_WORDS_LEN];
+
+	row_base = priv->row_base;
+	otp_mem = priv->target_otp_mem + (row_id - row_base) *
+		   priv->pdata->row_step;
+	ctrl_reg = priv->control_reg;
+	row_widths = priv->pdata->row_bit_width;
+
+	if (device_is_compatible(dev, "marvell,mvebu-fuse-ld-user")) {
+		printf("This efuse row is LD0 and read-only\n");
+		return -EINVAL;
+	}
+	/* select LD1 for fuse burn */
+	setbits_le32(ctrl_reg, MVEBU_EFUSE_SRV_CTRL_LD_SEL_USER);
+
+	/* enable fuse prog */
+	setbits_le32(ctrl_reg, MVEBU_EFUSE_CTRL_PROGRAM_ENABLE);
+
+	/* enable security bit to lock LD efuse row for further programming */
+	setbits_le32(ctrl_reg, MVEBU_EFUSE_CTRL_LD_SEC_EN_MASK);
+	/* read fuse row value before burn fuse */
+	for (i = 0; i < GET_LEN(row_widths); i++)
+		fuse_read_value[i] = readl(otp_mem + 4 * i);
+	/* fuse row value burn */
+	for (i = 0; i < GET_LEN(row_widths); i++) {
+		fuse_read_value[i] |= *(new_val + i);
+		writel(fuse_read_value[i], otp_mem + 4 * i);
+	}
+
+	/* write all 0 for LD eFuse to burn efuse */
+	writel(0x0, otp_mem + 0x20);
+
+	/* wait 1 ms for burn efuse */
+	mdelay(1);
+
+	/* Disable efuse write */
+	clrbits_le32(ctrl_reg, MVEBU_EFUSE_CTRL_PROGRAM_ENABLE);
+
+	return 0;
+}
+
+int mvebu_efuse_ld_prog(struct udevice *dev, int word, int row_id, u32 new_val)
+{
+	int res = 0;
+
+#ifdef EFUSE_READ_ONLY
+	dev_err(&dev->dev, "ERROR: fuse programming disabled!\n");
+	return -EPERM;
+#endif
+
+	if (word < ROW_WORDS_LEN - 1) {
+		prog_val[word] = new_val;
+		valid_prog_words |= (1 << word);
+	} else if ((valid_prog_words & 0x7F) != 0x7F) {
+		res = -EINVAL;
+	} else {
+		prog_val[ROW_WORDS_LEN - 1] = new_val;
+		res = do_mvebu_efuse_ld_prog(dev, row_id, prog_val);
+		valid_prog_words = 0;
+	}
+
+	return res;
+}
diff --git a/drivers/fuse/fuse-mvebu.c b/drivers/fuse/fuse-mvebu.c
new file mode 100644
index 0000000..8be854c
--- /dev/null
+++ b/drivers/fuse/fuse-mvebu.c
@@ -0,0 +1,268 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#include <config.h>
+#include <common.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/soc.h>
+#include <dm.h>
+#include <fdt_support.h>
+#include <mvebu/fuse-mvebu.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define GET_LEN(width)  DIV_ROUND_UP(width, 32)
+
+static int row_index;
+
+static struct fuse_ops fuse_ops = {
+	.fuse_init = NULL,
+	.fuse_hd_read = mvebu_efuse_hd_read,
+	.fuse_hd_prog = mvebu_efuse_hd_prog,
+	.fuse_ld_read = mvebu_efuse_ld_read,
+	.fuse_ld_prog = mvebu_efuse_ld_prog,
+};
+
+int reg_fuse_ops(struct fuse_ops *ops)
+{
+	if (!ops) {
+		printf("ERROR: No fuse operation registration\n");
+		return -EINVAL;
+	}
+	if (ops->fuse_init)
+		fuse_ops.fuse_init = ops->fuse_init;
+	if (ops->fuse_hd_read)
+		fuse_ops.fuse_hd_read = ops->fuse_hd_read;
+	if (ops->fuse_hd_prog)
+		fuse_ops.fuse_hd_prog = ops->fuse_hd_prog;
+	if (ops->fuse_ld_read)
+		fuse_ops.fuse_ld_read = ops->fuse_ld_read;
+	if (ops->fuse_ld_prog)
+		fuse_ops.fuse_ld_prog = ops->fuse_ld_prog;
+
+	return 0;
+}
+
+static int get_fuse_device(u32 bank, struct udevice **devp)
+{
+	struct mvebu_fuse_block_data *priv;
+	struct udevice *dev;
+
+	for (uclass_first_device(UCLASS_MISC, &dev); dev;
+	     uclass_next_device(&dev)) {
+		if ((device_is_compatible(dev, "marvell,mvebu-fuse-hd")) ||
+		    (device_is_compatible(dev,
+		     "marvell,mvebu-fuse-ld-user")) ||
+		    (device_is_compatible(dev,
+		     "marvell,mvebu-fuse-ld-prop"))) {
+			priv = dev_get_priv(dev);
+			if (bank >= priv->row_base &&
+			    bank < priv->row_base + priv->row_num) {
+				*devp = dev;
+				break;
+			}
+		}
+	}
+
+	return 0;
+}
+
+int fuse_read(u32 bank, u32 word, u32 *val)
+{
+	int res = 0;
+	u32 *fuse_data;
+	struct udevice *dev = NULL;
+	struct mvebu_fuse_block_data *priv;
+	const struct fuse_ops *ops;
+	int row_widths;
+
+	if (bank < 0 || bank >= row_index)
+		return -EINVAL;
+
+	res = get_fuse_device(bank, &dev);
+	if (res)
+		return res;
+
+	priv = dev_get_priv(dev);
+	ops = device_get_ops(dev);
+	row_widths = priv->pdata->row_bit_width;
+
+	if (word >= GET_LEN(row_widths))
+		return -EINVAL;
+
+	fuse_data = kmalloc_array(GET_LEN(row_widths), sizeof(u32),
+				  GFP_KERNEL);
+
+	if (priv->hd_ld_flag)
+		res = ops->fuse_hd_read(dev, bank, fuse_data);
+	else
+		res = ops->fuse_ld_read(dev, bank, fuse_data);
+
+	if (res)
+		goto read_end;
+
+	*val = fuse_data[word];
+
+read_end:
+	kfree(fuse_data);
+	return res;
+}
+
+int fuse_sense(u32 bank, u32 word, u32 *val)
+{
+	/* not supported */
+	return -EPERM;
+}
+
+int fuse_prog(u32 bank, u32 word, u32 val)
+{
+	int res = 0;
+	struct udevice *dev = NULL;
+	struct mvebu_fuse_block_data *priv;
+	const struct fuse_ops *ops;
+	int row_widths;
+
+	if (bank < 0 || bank >= row_index)
+		return -EINVAL;
+
+	res = get_fuse_device(bank, &dev);
+	if (res)
+		return res;
+
+	priv = dev_get_priv(dev);
+	ops = device_get_ops(dev);
+	row_widths = priv->pdata->row_bit_width;
+
+	if (word >= GET_LEN(row_widths))
+		return -EINVAL;
+
+	if (priv->hd_ld_flag)
+		res = ops->fuse_hd_prog(dev, word, bank, val);
+	else
+		res = ops->fuse_ld_prog(dev, word, bank, val);
+
+	return res;
+}
+
+int fuse_override(u32 bank, u32 word, u32 val)
+{
+	/* not supported */
+	return -EPERM;
+}
+
+static int fuse_probe(struct udevice *dev)
+{
+	const void *blob = gd->fdt_blob;
+	int node = dev_of_offset(dev);
+	struct mvebu_fuse_block_data *priv = dev_get_priv(dev);
+	const struct fuse_ops *ops;
+	int res = 0;
+
+	priv->control_reg = dev_read_addr_ptr(dev);
+	if (IS_ERR(priv->control_reg))
+		return -EINVAL;
+
+	priv->pdata =
+		(struct mvebu_fuse_platform_data *)dev_get_driver_data(dev);
+	priv->target_otp_mem =
+		(void *)(((phys_addr_t)dev_read_addr(dev) & ~0x00ffffff) +
+		(((phys_addr_t)fdtdec_get_int(blob, node,
+			"otp-mem", 0)) & 0x00ffffff));
+
+	if (device_is_compatible(dev, "marvell,mvebu-fuse-hd"))
+		priv->hd_ld_flag = true;
+	else
+		priv->hd_ld_flag = false;
+
+	priv->row_num = fdtdec_get_int(blob, node, "rows-count", 1);
+	priv->row_base = row_index;
+	row_index = priv->row_num + row_index;
+
+	debug("%s efuse OTP mem %p, row base = %d\n",
+	      priv->hd_ld_flag != 0 ? "HD " :
+	      (device_is_compatible(dev, "marvell,mvebu-fuse-ld-user") != 0 ?
+			"LD0" : "LD1"),
+	      priv->target_otp_mem, priv->row_base);
+
+	ops = device_get_ops(dev);
+	if (ops->fuse_init)
+		res = ops->fuse_init(dev);
+
+	return res;
+}
+
+static struct mvebu_fuse_platform_data fuse_hd_pdata = {
+	.row_bit_width = 65,
+	.row_step = 16,
+};
+
+static struct mvebu_fuse_platform_data fuse_ld_pdata = {
+	.row_bit_width = 256,
+};
+
+static const struct udevice_id mvebu_fuse_ids[] = {
+	{ .compatible = "marvell,mvebu-fuse-hd",
+		.data = (ulong)&fuse_hd_pdata },
+	{ .compatible = "marvell,mvebu-fuse-ld-user",
+		.data = (ulong)&fuse_ld_pdata },
+	{ .compatible = "marvell,mvebu-fuse-ld-prop",
+		.data = (ulong)&fuse_ld_pdata },
+
+	{}
+};
+
+int fuse_bind(struct udevice *dev)
+{
+	struct udevice *bank;
+	struct uclass *uc;
+	const void *blob = gd->fdt_blob;
+	int node = dev_of_offset(dev);
+	int ret = 0;
+
+	fdtdec_get_alias_seq(blob, "fuse", node, &dev->req_seq);
+
+	/* Get MISC uclass */
+	ret = uclass_get(UCLASS_MISC, &uc);
+	if (ret)
+		return ret;
+
+	/*
+	 * Reorder the efuse bank device in devices
+	 * list by its request sequence number.
+	 */
+	uclass_foreach_dev(bank, uc) {
+		node = dev_of_offset(bank);
+		fdtdec_get_alias_seq(blob, "fuse", node, &bank->req_seq);
+
+		if ((device_is_compatible(bank, "marvell,mvebu-fuse-hd")) ||
+		    (device_is_compatible(bank,
+		     "marvell,mvebu-fuse-ld-user")) ||
+		    (device_is_compatible(bank,
+		     "marvell,mvebu-fuse-ld-prop"))) {
+			if (bank->req_seq > dev->req_seq) {
+				list_move(&dev->uclass_node,
+					  bank->uclass_node.prev);
+				break;
+			}
+		}
+	}
+
+	return 0;
+}
+
+U_BOOT_DRIVER(mvebu_efuse) = {
+	.name	= "mvebu_efuse",
+	.id	= UCLASS_MISC,
+	.of_match = mvebu_fuse_ids,
+	.probe	= fuse_probe,
+	.priv_auto_alloc_size = sizeof(struct mvebu_fuse_block_data),
+	.ops	= &fuse_ops,
+	.bind	= fuse_bind,
+};
+
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index cc75aec..0d96452 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -232,6 +232,13 @@ config PIC32_GPIO
 	help
 	  Say yes here to support Microchip PIC32 GPIOs.
 
+config OCTEONTX_GPIO
+	bool "OcteonTX GPIO driver"
+	depends on DM_GPIO && (ARCH_OCTEONTX || ARCH_OCTEONTX2)
+	default y
+	help
+	  Say yes here to support OcteonTX GPIOs.
+
 config STM32F7_GPIO
 	bool "ST STM32 GPIO driver"
 	depends on DM_GPIO && STM32
@@ -308,4 +315,16 @@ config MPC8XXX_GPIO
 	  Aside from the standard functions of input/output mode, and output
 	  value setting, the open-drain feature, which can configure individual
 	  GPIOs to work as open-drain outputs, is supported.
+
+config I2C_GPIO
+	bool  "Generic I2C->GPIO no-irq expander"
+	depends on DM_GPIO
+	help
+	  Select this option to enable GPIO for simple I2C devices,
+	  parameterized by device-tree, and having no interrupts.
+	  Developed to model a custom board's CPLD, but may be useful
+	  for various hardware where i2c-poking flips external pins.
+
+	  If unsure, say N.
+
 endmenu
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index 266c958..a978292 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -56,7 +56,9 @@ obj-$(CONFIG_HIKEY_GPIO)	+= hi6220_gpio.o
 obj-$(CONFIG_HSDK_CREG_GPIO)	+= hsdk-creg-gpio.o
 obj-$(CONFIG_IMX_RGPIO2P)	+= imx_rgpio2p.o
 obj-$(CONFIG_PIC32_GPIO)	+= pic32_gpio.o
+obj-$(CONFIG_OCTEONTX_GPIO)	+= octeontx_gpio.o
 obj-$(CONFIG_MVEBU_GPIO)	+= mvebu_gpio.o
 obj-$(CONFIG_MSM_GPIO)		+= msm_gpio.o
 obj-$(CONFIG_$(SPL_)PCF8575_GPIO)	+= pcf8575_gpio.o
 obj-$(CONFIG_PM8916_GPIO)	+= pm8916_gpio.o
+obj-$(CONFIG_I2C_GPIO)		+= i2c_gpio.o
diff --git a/drivers/gpio/i2c_gpio.c b/drivers/gpio/i2c_gpio.c
new file mode 100644
index 0000000..df3dc78
--- /dev/null
+++ b/drivers/gpio/i2c_gpio.c
@@ -0,0 +1,236 @@
+/*
+ * Take linux kernel driver drivers/i2c/busses/i2c-gpio.c for reference.
+ *
+ * Copyright (C) 2019 Marvell, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/* This driver handles generic i2c GPIO devices where a GPIO pin is indexed
+ * by the register address and bit number.  This driver is based off of the
+ * linux kernel gpio-i2c.c driver.
+ *
+ * Note that this driver should not be confused with i2c-gpio as this is
+ * an i2c to gpio driver whereas the other driver is a gpio to i2c driver.
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <dm.h>
+#include <asm-generic/gpio.h>
+#include <fdtdec.h>
+#include <i2c.h>
+#include <malloc.h>
+#include <asm/gpio.h>
+#include <asm/io.h>
+#include <dt-bindings/gpio/gpio.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+struct i2c_gpio_chip {
+	int addr;	/** I2C address */
+	int gpio_count;	/** No. of GPIOs supported by the chip */
+	u8 *func;	/** Array to specify if pin is input or output */
+};
+
+static int i2c_gpio_write8(struct udevice *dev, uint offset, u8 byte)
+{
+	struct dm_i2c_chip *chip = dev_get_parent_platdata(dev);
+	int ret;
+
+	ret = dm_i2c_write(dev, offset, &byte, 1);
+	if (ret)
+		pr_err("%s(%s): i2c write failed to addr 0x%x\n",
+		       __func__, dev->name, chip->chip_addr);
+
+	return ret;
+}
+
+static int i2c_gpio_read8(struct udevice *dev, uint offset)
+{
+	struct dm_i2c_chip *chip = dev_get_parent_platdata(dev);
+	u8 data;
+	int ret;
+
+	ret = dm_i2c_read(dev, offset, &data, 1);
+	if (ret)
+		pr_err("%s(%s): i2c read failed from addr 0x%x\n", __func__,
+		       dev->name, chip->chip_addr);
+
+	return ret < 0 ? ret : data;
+}
+
+static int i2c_gpio_get_value(struct udevice *dev, unsigned int offset)
+{
+	struct i2c_gpio_chip *chip = dev_get_platdata(dev);
+	int value;
+	int byte = (offset >> 3);
+	int bit = (offset & 7);
+
+	if (offset >= chip->gpio_count) {
+		pr_err("%s(%s): Error: offset %u out of range 0..%u\n",
+		       __func__, dev->name, offset, chip->gpio_count);
+		return -EINVAL;
+	}
+	value = i2c_gpio_read8(dev, byte);
+	value = (value < 0) ? value : ((value >> bit) & 1);
+	return value;
+}
+
+static int i2c_gpio_set_value(struct udevice *dev, unsigned int offset,
+			      int value)
+{
+	struct i2c_gpio_chip *chip = dev_get_platdata(dev);
+	unsigned int byte = offset >> 3;
+	unsigned int bit = offset & 7;
+	unsigned int mask = (1 << bit);
+	int status;
+	int was;
+
+	if (offset >= chip->gpio_count) {
+		pr_err("%s(%s): Error: offset %u out of range 0..%u\n",
+		       __func__, dev->name, offset, chip->gpio_count);
+		return -EINVAL;
+	}
+
+	was = i2c_gpio_get_value(dev, byte);
+	if (was < 0)
+		return was;
+
+	if (value)
+		was |= mask;
+	else
+		was &= ~mask;
+	status = i2c_gpio_write8(dev, byte, was);
+	return status;
+}
+
+static int i2c_gpio_direction_input(struct udevice *dev, unsigned int offset)
+{
+	struct i2c_gpio_chip *chip = dev_get_platdata(dev);
+	int byte = offset >> 3;
+	u8 bit = offset & 7;
+	u8 mask = ~(1 << bit);
+
+	chip->func[byte] &= mask;
+
+	/* For open drain: set as input by letting output go high */
+
+	return i2c_gpio_set_value(dev, offset, 1);
+}
+
+static int i2c_gpio_direction_output(struct udevice *dev, unsigned int offset,
+				     int value)
+{
+	struct i2c_gpio_chip *chip = dev_get_platdata(dev);
+	int byte = offset >> 3;
+	u8 bit = offset & 7;
+	u8 mask = (1 << bit);
+
+	chip->func[byte] |= mask;
+
+	return i2c_gpio_set_value(dev, offset, value);
+}
+
+static int i2c_gpio_get_function(struct udevice *dev, unsigned int offset)
+{
+	struct i2c_gpio_chip *chip = dev_get_platdata(dev);
+	int byte = offset >> 3;
+	u8 bit = offset & 7;
+	u8 mask = (1 << bit);
+
+	return (chip->func[byte] & mask) ? GPIOF_OUTPUT : GPIOF_INPUT;
+}
+
+static int i2c_gpio_xlate(struct udevice *dev, struct gpio_desc *desc,
+			  struct ofnode_phandle_args *args)
+{
+	if (args->args_count < 1)
+		return -EINVAL;
+
+	desc->offset = args->args[0];
+	desc->flags = 0;
+	if (args->args_count > 1) {
+		if (args->args[1] & GPIO_ACTIVE_LOW)
+			desc->flags |= GPIOD_ACTIVE_LOW;
+	}
+	return 0;
+}
+
+static int i2c_gpio_probe(struct udevice *dev)
+{
+	struct gpio_dev_priv *uc_priv = dev_get_uclass_priv(dev);
+	struct i2c_gpio_chip *chip = dev_get_platdata(dev);
+	char name[32], label[16], *str;
+	const char *tmp;
+	int size;
+	const char *status;
+
+	debug("%s(%s)\n", __func__, dev->name);
+
+	status = ofnode_read_string(dev->node, "status");
+	if (status && !strncmp(status, "ok", 2)) {
+		debug("%s(%s): GPIO device disabled in device tree\n",
+		      __func__, dev->name);
+		return -ENODEV;
+	}
+
+	chip->addr = ofnode_read_u32_default(dev->node, "reg", 0);
+	if (!chip->addr) {
+		pr_err("%s(%s): Missing reg property\n",
+		       __func__, dev->name);
+		return -ENODEV;
+	}
+	chip->gpio_count = ofnode_read_u32_default(dev->node, "ngpios", 0);
+	if (!chip->gpio_count) {
+		pr_err("%s(%s): Missing ngpios property\n",
+		       __func__, dev->name);
+		return -ENODEV;
+	}
+
+	tmp = dev_read_prop(dev, "label", &size);
+	if (tmp) {
+		strlcpy(label, tmp, sizeof(label));
+		snprintf(name, sizeof(name), "%s@%x_", label, chip->addr);
+	} else {
+		snprintf(name, sizeof(name), "gpio@%x_", chip->addr);
+	}
+
+	str = strdup(name);
+	if (!str)
+		return -ENOMEM;
+
+	uc_priv->bank_name = str;
+	uc_priv->gpio_count = chip->gpio_count;
+	chip->func = calloc((chip->gpio_count + 7) / 8, 1);
+	if (!chip->func)
+		return -ENOMEM;
+
+	debug("%s(%s): probed at address %d with %u gpios and name %s\n",
+	      __func__, dev->name, chip->addr, chip->gpio_count, name);
+
+	return 0;
+}
+
+static const struct dm_gpio_ops i2c_gpio_ops = {
+	.direction_input	= i2c_gpio_direction_input,
+	.direction_output	= i2c_gpio_direction_output,
+	.get_value		= i2c_gpio_get_value,
+	.set_value		= i2c_gpio_set_value,
+	.get_function		= i2c_gpio_get_function,
+	.xlate			= i2c_gpio_xlate,
+};
+
+static const struct udevice_id i2c_gpio_ids[] = {
+	{ .compatible = "gpio-i2c" },
+	{ }
+};
+
+U_BOOT_DRIVER(i2c_gpio) = {
+	.name		= "gpio-i2c",
+	.id		= UCLASS_GPIO,
+	.ops		= &i2c_gpio_ops,
+	.probe		= i2c_gpio_probe,
+	.platdata_auto_alloc_size = sizeof(struct i2c_gpio_chip),
+	.of_match	= i2c_gpio_ids,
+};
diff --git a/drivers/gpio/octeontx_gpio.c b/drivers/gpio/octeontx_gpio.c
new file mode 100644
index 0000000..98098d0
--- /dev/null
+++ b/drivers/gpio/octeontx_gpio.c
@@ -0,0 +1,220 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ *
+ * (C) Copyright 2011
+ * eInfochips Ltd. <www.einfochips.com>
+ * Written-by: Ajay Bhargav <ajay.bhargav@einfochips.com>
+ *
+ * (C) Copyright 2010
+ * Marvell Semiconductor <www.marvell.com>
+ *
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <malloc.h>
+#include <errno.h>
+#include <fdtdec.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <asm/bitops.h>
+#include <dt-bindings/gpio/gpio.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/** Returns the bit value to write or read based on the offset */
+#define GPIO_BIT(x)		(1ULL << ((x) & 0x3f))
+
+#define GPIO_RX_DAT		(0x0)
+#define GPIO_TX_SET		(0x8)
+#define GPIO_TX_CLR		(0x10)
+#define GPIO_CONST		(0x90)
+#define GPIO_RX1_DAT		(0x1400)
+#define GPIO_TX1_SET		(0x1408)
+#define GPIO_TX1_CLR		(0x1410)
+
+/** Returns the offset to the output register based on the offset and value */
+#define GPIO_TX_REG(offset, value)					\
+	((offset) >= 64 ? ((value) ? GPIO_TX1_SET : GPIO_TX1_CLR) :	\
+			  ((value) ? GPIO_TX_SET : GPIO_TX_CLR))
+
+/** Returns the offset to the input data register based on the offset */
+#define GPIO_RX_DAT_REG(offset) ((offset >= 64) ? GPIO_RX1_DAT : GPIO_RX_DAT)
+
+/** Returns the bit configuration register based on the offset */
+#define GPIO_BIT_CFG(x)		(0x400 + 8 * (x))
+#define GPIO_BIT_CFG_FN(x)	(((x) >> 16) & 0x3ff)
+#define GPIO_BIT_CFG_TX_OE(x)	((x) & 0x1)
+#define GPIO_BIT_CFG_RX_DAT(x)	((x) & 0x1)
+
+/** PCI ID on NCB bus */
+#define PCI_DEVICE_ID_CAVIUM_GPIO	0xa00a
+
+union gpio_const {
+	u64 u;
+	struct {
+		u64 gpios:8;	/** Number of GPIOs implemented */
+		u64 pp:8;	/** Number of PP vectors */
+		u64:48;	/* Reserved */
+	} s;
+};
+
+struct octeontx_gpio {
+	void __iomem *baseaddr;
+};
+
+static int octeontx_gpio_dir_input(struct udevice *dev, unsigned offset)
+{
+	struct octeontx_gpio *gpio = dev_get_priv(dev);
+	debug("%s(%s, %u)\n", __func__, dev->name, offset);
+	clrbits_le64(gpio->baseaddr + GPIO_BIT_CFG(offset),
+		     (0x3ffUL << 16) | 4UL | 2UL | 1UL);
+	return 0;
+}
+
+static int octeontx_gpio_dir_output(struct udevice *dev, unsigned offset,
+				    int value)
+{
+	struct octeontx_gpio *gpio = dev_get_priv(dev);
+
+	debug("%s(%s, %u, %d)\n", __func__, dev->name, offset, value);
+	writeq(GPIO_BIT(offset), gpio->baseaddr + GPIO_TX_REG(offset, value));
+
+	clrsetbits_le64(gpio->baseaddr + GPIO_BIT_CFG(offset),
+			((0x3ffUL << 16) | 4UL), 1UL);
+	return 0;
+}
+
+static int octeontx_gpio_get_value(struct udevice *dev,
+				   unsigned offset)
+{
+	struct octeontx_gpio *gpio = dev_get_priv(dev);
+	u64 reg = readq(gpio->baseaddr + GPIO_RX_DAT_REG(offset));
+
+	debug("%s(%s, %u): value: %d\n", __func__, dev->name, offset,
+	      !!(reg & GPIO_BIT(offset)));
+
+	return !!(reg & GPIO_BIT(offset));
+}
+
+static int octeontx_gpio_set_value(struct udevice *dev,
+				   unsigned offset, int value)
+{
+	struct octeontx_gpio *gpio = dev_get_priv(dev);
+
+	debug("%s(%s, %u, %d)\n", __func__, dev->name, offset, value);
+	writeq(GPIO_BIT(offset), gpio->baseaddr + GPIO_TX_REG(offset, value));
+
+	return 0;
+
+}
+
+static int octeontx_gpio_get_function(struct udevice *dev,
+				      unsigned offset)
+{
+	struct octeontx_gpio *gpio = dev_get_priv(dev);
+	u64 pinsel = readl(gpio->baseaddr + GPIO_BIT_CFG(offset));
+	debug("%s(%s, %u): pinsel: 0x%llx\n", __func__, dev->name, offset,
+	      pinsel);
+	if (GPIO_BIT_CFG_FN(pinsel))
+		return GPIOF_FUNC;
+	else if (GPIO_BIT_CFG_TX_OE(pinsel))
+		return GPIOF_OUTPUT;
+	else
+		return GPIOF_INPUT;
+}
+
+static int octeontx_gpio_xlate(struct udevice *dev, struct gpio_desc *desc,
+			    struct ofnode_phandle_args *args)
+{
+	if (args->args_count < 1)
+		return -EINVAL;
+
+	desc->offset = args->args[0];
+	desc->flags = 0;
+	if (args->args_count > 1) {
+		if (args->args[1] & GPIO_ACTIVE_LOW)
+			desc->flags |= GPIOD_ACTIVE_LOW;
+		/* In the future add tri-state flag support */
+	}
+	return 0;
+}
+
+static const struct dm_gpio_ops octeontx_gpio_ops = {
+	.direction_input	= octeontx_gpio_dir_input,
+	.direction_output	= octeontx_gpio_dir_output,
+	.get_value		= octeontx_gpio_get_value,
+	.set_value		= octeontx_gpio_set_value,
+	.get_function		= octeontx_gpio_get_function,
+	.xlate			= octeontx_gpio_xlate,
+};
+
+static int octeontx_gpio_probe(struct udevice *dev)
+{
+	pci_dev_t bdf = dm_pci_get_bdf(dev);
+	struct gpio_dev_priv *uc_priv = dev_get_uclass_priv(dev);
+	struct octeontx_gpio *priv = dev_get_priv(dev);
+	union gpio_const gpio_const;
+	size_t size;
+	char *end;
+	const char *status;
+
+	status = ofnode_read_string(dev->node, "status");
+
+	if (status && !strncmp(status, "ok", 2)) {
+		debug("%s(%s): GPIO device disabled in device tree\n",
+		      __func__, dev->name);
+		return -1;
+	}
+
+	dev->req_seq = PCI_FUNC(bdf);
+	priv->baseaddr = dm_pci_map_bar(dev, 0, &size, PCI_REGION_MEM);
+
+	if (!priv->baseaddr) {
+		debug("%s(%s): Could not get base address\n",
+		      __func__, dev->name);
+		return -1;
+	}
+
+	gpio_const.u = readq(priv->baseaddr + GPIO_CONST);
+
+	debug("%s(%s): base address: %p, of_offset: %ld, pin count: %d\n",
+	      __func__, dev->name, priv->baseaddr, dev->node.of_offset,
+	      gpio_const.s.gpios);
+
+	uc_priv->gpio_count = gpio_const.s.gpios;
+	uc_priv->bank_name  = strdup(dev->name);
+	end = strchr(uc_priv->bank_name, '@');
+	end[0] = 'A' + dev->seq;
+	end[1] = '\0';
+
+	return 0;
+}
+
+
+static const struct udevice_id octeontx_gpio_ids[] = {
+	{ .compatible = "cavium,thunder-8890-gpio" },
+	{ .compatible = "cavium,gpio" },
+	{ .compatible = "cavium,thunderx-gpio" },
+	{ }
+};
+
+U_BOOT_DRIVER(cavium_pci_gpio) = {
+	.name	= "gpio_cavium",
+	.id	= UCLASS_GPIO,
+	.of_match = of_match_ptr(octeontx_gpio_ids),
+	.probe = octeontx_gpio_probe,
+	.priv_auto_alloc_size = sizeof(struct octeontx_gpio),
+	.ops	= &octeontx_gpio_ops,
+	.flags	= DM_FLAG_PRE_RELOC,
+};
+
+static struct pci_device_id cavium_pci_gpio_supported[] = {
+	{ PCI_VDEVICE(CAVIUM, PCI_DEVICE_ID_CAVIUM_GPIO) },
+	{ },
+};
+
+U_BOOT_PCI_DEVICE(cavium_pci_gpio, cavium_pci_gpio_supported);
diff --git a/drivers/gpio/pca953x_gpio.c b/drivers/gpio/pca953x_gpio.c
index 08742f9..6d15f36 100644
--- a/drivers/gpio/pca953x_gpio.c
+++ b/drivers/gpio/pca953x_gpio.c
@@ -50,6 +50,8 @@ enum {
 #define MAX_BANK 5
 #define BANK_SZ 8
 
+DECLARE_GLOBAL_DATA_PTR;
+
 /*
  * struct pca953x_info - Data for pca953x
  *
@@ -253,7 +255,7 @@ static int pca953x_probe(struct udevice *dev)
 	int size;
 	const u8 *tmp;
 
-	addr = dev_read_addr(dev);
+	addr = fdtdec_get_int(gd->fdt_blob, dev_of_offset(dev), "reg", 0);
 	if (addr == 0)
 		return -ENODEV;
 
diff --git a/drivers/i2c/Kconfig b/drivers/i2c/Kconfig
index 932abd3..f24a20f 100644
--- a/drivers/i2c/Kconfig
+++ b/drivers/i2c/Kconfig
@@ -199,6 +199,13 @@ config SYS_I2C_SANDBOX
 	  bus. Devices can be attached to the bus using the device tree
 	  which specifies the driver to use.  See sandbox.dts as an example.
 
+config SYS_I2C_OCTEONTX
+	bool "OcteonTX i2c driver"
+	depends on (ARCH_OCTEONTX || ARCH_OCTEONTX2) && DM_I2C
+	default y
+	help
+	 Enable I2C support for OcteonTX line of processors.
+
 config SYS_I2C_S3C24X0
 	bool "Samsung I2C driver"
 	depends on ARCH_EXYNOS4 && DM_I2C
diff --git a/drivers/i2c/Makefile b/drivers/i2c/Makefile
index 169a2f1..7459078 100644
--- a/drivers/i2c/Makefile
+++ b/drivers/i2c/Makefile
@@ -4,6 +4,7 @@
 #
 # SPDX-License-Identifier:	GPL-2.0+
 #
+
 obj-$(CONFIG_DM_I2C) += i2c-uclass.o
 obj-$(CONFIG_DM_I2C_COMPAT) += i2c-uclass-compat.o
 obj-$(CONFIG_DM_I2C_GPIO) += i2c-gpio.o
@@ -39,6 +40,7 @@ obj-$(CONFIG_SYS_I2C_SH) += sh_i2c.o
 obj-$(CONFIG_SYS_I2C_SOFT) += soft_i2c.o
 obj-$(CONFIG_SYS_I2C_STM32F7) += stm32f7_i2c.o
 obj-$(CONFIG_SYS_I2C_TEGRA) += tegra_i2c.o
+obj-$(CONFIG_SYS_I2C_OCTEONTX) += octeontx_i2c.o
 obj-$(CONFIG_SYS_I2C_UNIPHIER) += i2c-uniphier.o
 obj-$(CONFIG_SYS_I2C_UNIPHIER_F) += i2c-uniphier-f.o
 obj-$(CONFIG_SYS_I2C_ZYNQ) += zynq_i2c.o
diff --git a/drivers/i2c/i2c-uclass.c b/drivers/i2c/i2c-uclass.c
index 920811a..58a14db 100644
--- a/drivers/i2c/i2c-uclass.c
+++ b/drivers/i2c/i2c-uclass.c
@@ -256,6 +256,9 @@ static int i2c_probe_chip(struct udevice *bus, uint chip_addr,
 	/* Probe with a zero-length message */
 	msg->addr = chip_addr;
 	msg->flags = chip_flags & DM_I2C_CHIP_10BIT ? I2C_M_TEN : 0;
+#ifdef CONFIG_ARCH_OCTEONTX
+	msg->flags |= I2C_M_RD;
+#endif
 	msg->len = 0;
 	msg->buf = NULL;
 
diff --git a/drivers/i2c/mv_i2c.c b/drivers/i2c/mv_i2c.c
index 913721b..e0efe58 100644
--- a/drivers/i2c/mv_i2c.c
+++ b/drivers/i2c/mv_i2c.c
@@ -239,6 +239,7 @@ static int __i2c_read(struct mv_i2c *base, uchar chip, u8 *addr, int alen,
 		      uchar *buffer, int len)
 {
 	struct mv_i2c_msg msg;
+	int i = 0;
 
 	debug("i2c_read(chip=0x%02x, addr=0x%02x, alen=0x%02x, "
 	      "len=0x%02x)\n", chip, *addr, alen, len);
@@ -270,7 +271,7 @@ static int __i2c_read(struct mv_i2c *base, uchar chip, u8 *addr, int alen,
 		msg.condition = I2C_COND_NORMAL;
 		msg.acknack   = I2C_ACKNAK_WAITACK;
 		msg.direction = I2C_WRITE;
-		msg.data      = addr[alen];
+		msg.data      = addr[i++];
 		if (i2c_transfer(base, &msg))
 			return -1;
 	}
@@ -315,6 +316,7 @@ static int __i2c_write(struct mv_i2c *base, uchar chip, u8 *addr, int alen,
 		       uchar *buffer, int len)
 {
 	struct mv_i2c_msg msg;
+	int i = 0;
 
 	debug("i2c_write(chip=0x%02x, addr=0x%02x, alen=0x%02x, "
 	      "len=0x%02x)\n", chip, *addr, alen, len);
@@ -341,7 +343,7 @@ static int __i2c_write(struct mv_i2c *base, uchar chip, u8 *addr, int alen,
 		msg.condition = I2C_COND_NORMAL;
 		msg.acknack   = I2C_ACKNAK_WAITACK;
 		msg.direction = I2C_WRITE;
-		msg.data      = addr[alen];
+		msg.data      = addr[i++];
 		if (i2c_transfer(base, &msg))
 			return -1;
 	}
@@ -566,10 +568,18 @@ static int mv_i2c_set_bus_speed(struct udevice *bus, unsigned int speed)
 	struct mv_i2c_priv *priv = dev_get_priv(bus);
 	u32 val;
 
-	if (speed > 100000)
-		val = ICR_FM;
-	else
+	switch (speed) {
+	case 100000:
 		val = ICR_SM;
+		break;
+	case 400000:
+		val = ICR_FM;
+		break;
+	default:
+		printf("Only 100k and 400k modes supported\n");
+		return -EOPNOTSUPP;
+	}
+
 	clrsetbits_le32(&priv->base->icr, ICR_MODE_MASK, val);
 
 	return 0;
@@ -584,9 +594,18 @@ static int mv_i2c_probe(struct udevice *bus)
 	return 0;
 }
 
+static int mv_i2c_reset(struct udevice *bus)
+{
+	struct mv_i2c_priv *priv = dev_get_priv(bus);
+
+	i2c_reset(priv->base);
+	return 0;
+}
+
 static const struct dm_i2c_ops mv_i2c_ops = {
 	.xfer		= mv_i2c_xfer,
 	.set_bus_speed	= mv_i2c_set_bus_speed,
+	.deblock	= mv_i2c_reset,
 };
 
 static const struct udevice_id mv_i2c_ids[] = {
diff --git a/drivers/i2c/mvtwsi.c b/drivers/i2c/mvtwsi.c
index 38bca89..f9c012f 100644
--- a/drivers/i2c/mvtwsi.c
+++ b/drivers/i2c/mvtwsi.c
@@ -601,13 +601,14 @@ static int __twsi_i2c_read(struct mvtwsi_registers *twsi, uchar chip,
 	int status = 0;
 	int stop_status;
 	int expected_start = MVTWSI_STATUS_START;
+	int i = 0;
 
 	if (alen > 0) {
 		/* Begin i2c write to send the address bytes */
 		status = i2c_begin(twsi, expected_start, (chip << 1), tick);
 		/* Send address bytes */
 		while ((status == 0) && alen--)
-			status = twsi_send(twsi, addr[alen],
+			status = twsi_send(twsi, addr[i++],
 					   MVTWSI_STATUS_DATA_W_ACK, tick);
 		/* Send repeated STARTs after the initial START */
 		expected_start = MVTWSI_STATUS_REPEATED_START;
@@ -648,13 +649,14 @@ static int __twsi_i2c_write(struct mvtwsi_registers *twsi, uchar chip,
 			    uint tick)
 {
 	int status, stop_status;
+	int i = 0;
 
 	/* Begin i2c write to send first the address bytes, then the
 	 * data bytes */
 	status = i2c_begin(twsi, MVTWSI_STATUS_START, (chip << 1), tick);
 	/* Send address bytes */
 	while ((status == 0) && (alen-- > 0))
-		status = twsi_send(twsi, addr[alen], MVTWSI_STATUS_DATA_W_ACK,
+		status = twsi_send(twsi, addr[i++], MVTWSI_STATUS_DATA_W_ACK,
 				   tick);
 	/* Send data bytes */
 	while ((status == 0) && (length-- > 0))
diff --git a/drivers/i2c/octeontx_i2c.c b/drivers/i2c/octeontx_i2c.c
new file mode 100644
index 0000000..958c1da
--- /dev/null
+++ b/drivers/i2c/octeontx_i2c.c
@@ -0,0 +1,962 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <i2c.h>
+#include <dm.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+
+#if defined(CONFIG_ARCH_OCTEONTX)
+# define TWSI_THP		24
+#else
+# define TWSI_THP		3
+#endif
+
+/**
+ * Slave address to use for Thunder when accessed by another master
+ */
+#ifndef CONFIG_SYS_I2C_OCTEONTX_SLAVE_ADDR
+# define CONFIG_SYS_I2C_OCTEONTX_SLAVE_ADDR	0x77
+#endif
+
+#ifndef CONFIG_SYS_I2C_OCTEONTX_SPEED_0
+# ifdef CONFIG_SYS_I2C_SPEED
+#  define CONFIG_SYS_I2C_OCTEONTX_SPEED_0	CONFIG_SYS_I2C_SPEED
+# else
+#  define CONFIG_SYS_I2C_SPEED			100000
+#  define CONFIG_SYS_I2C_OCTEONTX_SPEED_0	CONFIG_SYS_I2C_SPEED
+# endif
+#endif
+
+#ifndef CONFIG_SYS_I2C_OCTEONTX_SPEED_1
+# define CONFIG_SYS_I2C_OCTEONTX_SPEED_1	CONFIG_SYS_I2C_OCTEONTX_SPEED_0
+#endif
+
+#ifndef CONFIG_SYS_I2C_OCTEONTX_SPEED_2
+# define CONFIG_SYS_I2C_OCTEONTX_SPEED_2	CONFIG_SYS_I2C_OCTEONTX_SPEED_1
+#endif
+
+#ifndef CONFIG_SYS_I2C_OCTEONTX_SPEED_3
+# define CONFIG_SYS_I2C_OCTEONTX_SPEED_3	CONFIG_SYS_I2C_OCTEONTX_SPEED_2
+#endif
+
+#ifndef CONFIG_SYS_I2C_OCTEONTX_SPEED_4
+# define CONFIG_SYS_I2C_OCTEONTX_SPEED_4	CONFIG_SYS_I2C_OCTEONTX_SPEED_3
+#endif
+
+#ifndef CONFIG_SYS_I2C_OCTEONTX_SPEED_5
+# define CONFIG_SYS_I2C_OCTEONTX_SPEED_5	CONFIG_SYS_I2C_OCTEONTX_SPEED_4
+#endif
+
+#ifndef CONFIG_SYS_I2C_OCTEONTX_SPEED_6
+# define CONFIG_SYS_I2C_OCTEONTX_SPEED_6	CONFIG_SYS_I2C_OCTEONTX_SPEED_5
+#endif
+
+#ifndef CONFIG_SYS_I2C_OCTEONTX_SPEED_7
+# define CONFIG_SYS_I2C_OCTEONTX_SPEED_7	CONFIG_SYS_I2C_OCTEONTX_SPEED_6
+#endif
+
+#ifndef CONFIG_SYS_I2C_OCTEONTX_SPEED_8
+# define CONFIG_SYS_I2C_OCTEONTX_SPEED_8	CONFIG_SYS_I2C_OCTEONTX_SPEED_7
+#endif
+
+#ifndef CONFIG_SYS_I2C_OCTEONTX_SPEED_9
+# define CONFIG_SYS_I2C_OCTEONTX_SPEED_9	CONFIG_SYS_I2C_OCTEONTX_SPEED_8
+#endif
+
+#ifndef CONFIG_SYS_I2C_OCTEONTX_SPEED_10
+# define CONFIG_SYS_I2C_OCTEONTX_SPEED_10	CONFIG_SYS_I2C_OCTEONTX_SPEED_9
+#endif
+
+#ifndef CONFIG_SYS_I2C_OCTEONTX_SPEED_11
+# define CONFIG_SYS_I2C_OCTEONTX_SPEED_11	CONFIG_SYS_I2C_OCTEONTX_SPEED_10
+#endif
+
+#define TWSI_SW_TWSI		0x1000
+#define TWSI_TWSI_SW		0x1008
+#define TWSI_INT		0x1010
+#define TWSI_SW_TWSI_EXT	0x1018
+
+union twsx_sw_twsi {
+	u64 u;
+	struct {
+		u64 data:32;
+		u64 eop_ia:3;
+		u64 ia:5;
+		u64 addr:10;
+		u64 scr:2;
+		u64 size:3;
+		u64 sovr:1;
+		u64 r:1;
+		u64 op:4;
+		u64 eia:1;
+		u64 slonly:1;
+		u64 v:1;
+	} s;
+};
+
+union twsx_sw_twsi_ext {
+	u64 u;
+	struct {
+		u64	data:32;
+		u64	ia:8;
+		u64	:24;
+	} s;
+};
+
+union twsx_int {
+	u64 u;
+	struct {
+		u64	st_int:1;	/** TWSX_SW_TWSI register update int */
+		u64	ts_int:1;	/** TWSX_TWSI_SW register update int */
+		u64	core_int:1;	/** TWSI core interrupt, ignored for HLC */
+		u64	:5;		/** Reserved */
+		u64	sda_ovr:1;	/** SDA testing override */
+		u64	scl_ovr:1;	/** SCL testing override */
+		u64	sda:1;		/** SDA signal */
+		u64	scl:1;		/** SCL signal */
+		u64	:52;		/** Reserved */
+	} s;
+};
+
+enum {
+	TWSI_OP_WRITE	= 0,
+	TWSI_OP_READ	= 1,
+};
+
+enum {
+	TWSI_EOP_SLAVE_ADDR = 0,
+	TWSI_EOP_CLK_CTL = 3,
+	TWSI_SW_EOP_IA   = 6,
+};
+
+enum {
+	TWSI_SLAVEADD     = 0,
+	TWSI_DATA         = 1,
+	TWSI_CTL          = 2,
+	TWSI_CLKCTL       = 3,
+	TWSI_STAT         = 3,
+	TWSI_SLAVEADD_EXT = 4,
+	TWSI_RST          = 7,
+};
+
+enum {
+	TWSI_CTL_AAK	= BIT(2),
+	TWSI_CTL_IFLG	= BIT(3),
+	TWSI_CTL_STP	= BIT(4),
+	TWSI_CTL_STA	= BIT(5),
+	TWSI_CTL_ENAB	= BIT(6),
+	TWSI_CTL_CE	= BIT(7),
+};
+
+enum {
+	/** Bus error */
+	TWSI_STAT_BUS_ERROR		= 0x00,
+	/** Start condition transmitted */
+	TWSI_STAT_START			= 0x08,
+	/** Repeat start condition transmitted */
+	TWSI_STAT_RSTART		= 0x10,
+	/** Address + write bit transmitted, ACK received */
+	TWSI_STAT_TXADDR_ACK		= 0x18,
+	/** Address + write bit transmitted, /ACK received */
+	TWSI_STAT_TXADDR_NAK		= 0x20,
+	/** Data byte transmitted in master mode, ACK received */
+	TWSI_STAT_TXDATA_ACK		= 0x28,
+	/** Data byte transmitted in master mode, ACK received */
+	TWSI_STAT_TXDATA_NAK		= 0x30,
+	/** Arbitration lost in address or data byte */
+	TWSI_STAT_TX_ARB_LOST		= 0x38,
+	/** Address + read bit transmitted, ACK received */
+	TWSI_STAT_RXADDR_ACK		= 0x40,
+	/** Address + read bit transmitted, /ACK received */
+	TWSI_STAT_RXADDR_NAK		= 0x48,
+	/** Data byte received in master mode, ACK transmitted */
+	TWSI_STAT_RXDATA_ACK_SENT	= 0x50,
+	/** Data byte received, NACK transmitted */
+	TWSI_STAT_RXDATA_NAK_SENT	= 0x58,
+	/** Slave address received, sent ACK */
+	TWSI_STAT_SLAVE_RXADDR_ACK	= 0x60,
+	/**
+	 * Arbitration lost in address as master, slave address + write bit
+	 * received, ACK transmitted
+	 */
+	TWSI_STAT_TX_ACK_ARB_LOST	= 0x68,
+	/** General call address received, ACK transmitted */
+	TWSI_STAT_RX_GEN_ADDR_ACK	= 0x70,
+	/**
+	 * Arbitration lost in address as master, general call address
+	 * received, ACK transmitted
+	 */
+	TWSI_STAT_RX_GEN_ADDR_ARB_LOST	= 0x78,
+	/** Data byte received after slave address received, ACK transmitted */
+	TWSI_STAT_SLAVE_RXDATA_ACK	= 0x80,
+	/** Data byte received after slave address received, /ACK transmitted */
+	TWSI_STAT_SLAVE_RXDATA_NAK	= 0x88,
+	/**
+	 * Data byte received after general call address received, ACK
+	 * transmitted
+	 */
+	TWSI_STAT_GEN_RXADDR_ACK	= 0x90,
+	/**
+	 * Data byte received after general call address received, /ACK
+	 * transmitted
+	 */
+	TWSI_STAT_GEN_RXADDR_NAK	= 0x98,
+	/** STOP or repeated START condition received in slave mode */
+	TWSI_STAT_STOP_MULTI_START	= 0xA0,
+	/** Slave address + read bit received, ACK transmitted */
+	TWSI_STAT_SLAVE_RXADDR2_ACK	= 0xA8,
+	/**
+	 * Arbitration lost in address as master, slave address + read bit
+	 * received, ACK transmitted
+	 */
+	TWSI_STAT_RXDATA_ACK_ARB_LOST	= 0xB0,
+	/** Data byte transmitted in slave mode, ACK received */
+	TWSI_STAT_SLAVE_TXDATA_ACK	= 0xB8,
+	/** Data byte transmitted in slave mode, /ACK received */
+	TWSI_STAT_SLAVE_TXDATA_NAK	= 0xC0,
+	/** Last byte transmitted in slave mode, ACK received */
+	TWSI_STAT_SLAVE_TXDATA_END_ACK	= 0xC8,
+	/** Second address byte + write bit transmitted, ACK received */
+	TWSI_STAT_TXADDR2DATA_ACK	= 0xD0,
+	/** Second address byte + write bit transmitted, /ACK received */
+	TWSI_STAT_TXADDR2DATA_NAK	= 0xD8,
+	/** No relevant status information */
+	TWSI_STAT_IDLE		= 0xF8
+};
+
+struct octeontx_twsi {
+	int			id;
+	int			speed;
+	void			*baseaddr;
+};
+
+/** Array of bus speeds */
+static unsigned speeds[] = {
+	CONFIG_SYS_I2C_OCTEONTX_SPEED_0,
+	CONFIG_SYS_I2C_OCTEONTX_SPEED_1,
+	CONFIG_SYS_I2C_OCTEONTX_SPEED_2,
+	CONFIG_SYS_I2C_OCTEONTX_SPEED_3,
+	CONFIG_SYS_I2C_OCTEONTX_SPEED_4,
+	CONFIG_SYS_I2C_OCTEONTX_SPEED_5,
+	CONFIG_SYS_I2C_OCTEONTX_SPEED_6,
+	CONFIG_SYS_I2C_OCTEONTX_SPEED_7,
+	CONFIG_SYS_I2C_OCTEONTX_SPEED_8,
+	CONFIG_SYS_I2C_OCTEONTX_SPEED_9,
+	CONFIG_SYS_I2C_OCTEONTX_SPEED_10,
+	CONFIG_SYS_I2C_OCTEONTX_SPEED_11,
+};
+
+/** Last i2c id assigned */
+static int last_id = 0;
+
+static void twsi_unblock(void *baseaddr);
+static int twsi_stop(void *baseaddr);
+
+
+/**
+ * Converts the i2c status to a meaningful string
+ *
+ * @param	status	status to convert
+ *
+ * @return	string representation of the status
+ */
+static const char *twsi_i2c_status_str(uint8_t status)
+{
+	switch (status) {
+	case TWSI_STAT_BUS_ERROR:
+		return "Bus error";
+	case TWSI_STAT_START:
+		return "START condition transmitted";
+	case TWSI_STAT_RSTART:
+		return "Repeated START condition transmitted";
+	case TWSI_STAT_TXADDR_ACK:
+		return "Address + write bit transmitted, ACK received";
+	case TWSI_STAT_TXADDR_NAK:
+		return "Address + write bit transmitted, NAK received";
+	case TWSI_STAT_TXDATA_ACK:
+		return "Data byte transmitted in master mode, ACK received";
+	case TWSI_STAT_TXDATA_NAK:
+		return "Data byte transmitted in master mode, NAK received";
+	case TWSI_STAT_TX_ARB_LOST:
+		return "Arbitration lost in address or data byte";
+	case TWSI_STAT_RXADDR_ACK:
+		return "Address + read bit transmitted, ACK received";
+	case TWSI_STAT_RXADDR_NAK:
+		return "Address + read bit transmitted, NAK received";
+	case TWSI_STAT_RXDATA_ACK_SENT:
+		return "Data byte received in master mode, ACK transmitted";
+	case TWSI_STAT_RXDATA_NAK_SENT:
+		return "Data byte received in master mode, NAK transmitted";
+	case TWSI_STAT_SLAVE_RXADDR_ACK:
+		return "Slave address + write bit received, ACK transmitted";
+	case TWSI_STAT_TX_ACK_ARB_LOST:
+		return "Arbitration lost in address as master, slave address + write bit received, ACK transmitted";
+	case TWSI_STAT_RX_GEN_ADDR_ACK:
+		return "General call address received, ACK transmitted";
+	case TWSI_STAT_RX_GEN_ADDR_ARB_LOST:
+		return "Arbitration lost in address as master, general call address received, ACK transmitted";
+	case TWSI_STAT_SLAVE_RXDATA_ACK:
+		return "Data byte received after slave address received, ACK transmitted";
+	case TWSI_STAT_SLAVE_RXDATA_NAK:
+		return "Data byte received after slave address received, NAK transmitted";
+	case TWSI_STAT_GEN_RXADDR_ACK:
+		return "Data byte received after general call address received, ACK transmitted";
+	case TWSI_STAT_GEN_RXADDR_NAK:
+		return "Data byte received after general call address received, NAK transmitted";
+	case TWSI_STAT_STOP_MULTI_START:
+		return "STOP or repeated START condition received in slave mode";
+	case TWSI_STAT_SLAVE_RXADDR2_ACK:
+		return "Slave address + read bit received, ACK transmitted";
+	case TWSI_STAT_RXDATA_ACK_ARB_LOST:
+		return "Arbitration lost in address as master, slave address + read bit received, ACK transmitted";
+	case TWSI_STAT_SLAVE_TXDATA_ACK:
+		return "Data byte transmitted in slave mode, ACK received";
+	case TWSI_STAT_SLAVE_TXDATA_NAK:
+		return "Data byte transmitted in slave mode, NAK received";
+	case TWSI_STAT_SLAVE_TXDATA_END_ACK:
+		return "Last byte transmitted in slave mode, ACK received";
+	case TWSI_STAT_TXADDR2DATA_ACK:
+		return "Second address byte + write bit transmitted, ACK received";
+	case TWSI_STAT_TXADDR2DATA_NAK:
+		return "Second address byte + write bit transmitted, NAK received";
+	case TWSI_STAT_IDLE:
+		return "Idle";
+	default:
+		return "Unknown status code";
+	}
+}
+
+/**
+ * Returns true if we lost arbitration
+ *
+ * @param	code		status code
+ * @param	final_read	true if this is the final read operation
+ *
+ * @return	true if arbitration has been lost, false if it hasn't been lost.
+ */
+static int twsi_i2c_lost_arb(u8 code, int final_read)
+{
+	switch (code) {
+	/* Arbitration lost */
+	case TWSI_STAT_TX_ARB_LOST:
+	case TWSI_STAT_TX_ACK_ARB_LOST:
+	case TWSI_STAT_RX_GEN_ADDR_ARB_LOST:
+	case TWSI_STAT_RXDATA_ACK_ARB_LOST:
+		return -EAGAIN;
+
+	/* Being addressed as slave, should back off and listen */
+	case TWSI_STAT_SLAVE_RXADDR_ACK:
+	case TWSI_STAT_RX_GEN_ADDR_ACK:
+	case TWSI_STAT_GEN_RXADDR_ACK:
+	case TWSI_STAT_GEN_RXADDR_NAK:
+		return -EIO;
+
+	/* Core busy as slave */
+	case TWSI_STAT_SLAVE_RXDATA_ACK:
+	case TWSI_STAT_SLAVE_RXDATA_NAK:
+	case TWSI_STAT_STOP_MULTI_START:
+	case TWSI_STAT_SLAVE_RXADDR2_ACK:
+	case TWSI_STAT_SLAVE_TXDATA_ACK:
+	case TWSI_STAT_SLAVE_TXDATA_NAK:
+	case TWSI_STAT_SLAVE_TXDATA_END_ACK:
+		return  -EIO;
+
+	/* Ack allowed on pre-terminal bytes only */
+	case TWSI_STAT_RXDATA_ACK_SENT:
+		if (!final_read)
+			return 0;
+		return -EAGAIN;
+
+	/* NAK allowed on terminal byte only */
+	case TWSI_STAT_RXDATA_NAK_SENT:
+		if (!final_read)
+			return 0;
+		return -EAGAIN;
+
+	case TWSI_STAT_TXDATA_NAK:
+	case TWSI_STAT_TXADDR_NAK:
+	case TWSI_STAT_RXADDR_NAK:
+	case TWSI_STAT_TXADDR2DATA_NAK:
+		return -EAGAIN;
+	}
+	return 0;
+}
+
+#define RST_BOOT_PNR_MUL(Val)  ((Val >> 33) & 0x1F)
+
+/**
+ * Writes to the MIO_TWS(0..5)_SW_TWSI register
+ *
+ * @param	baseaddr	Base address of i2c registers
+ * @param	sw_twsi		value to write
+ *
+ * @return	0 for success, otherwise error
+ */
+static u64 twsi_write_sw(void *baseaddr, union twsx_sw_twsi sw_twsi)
+{
+	unsigned long start = get_timer(0);
+
+	sw_twsi.s.r = 0;
+	sw_twsi.s.v = 1;
+
+	debug("%s(%p, 0x%llx)\n", __func__, baseaddr, sw_twsi.u);
+	writeq(sw_twsi.u, baseaddr + TWSI_SW_TWSI);
+	do {
+		sw_twsi.u = readq(baseaddr + TWSI_SW_TWSI);
+	} while (sw_twsi.s.v != 0 && get_timer(start) < 50);
+
+	if (sw_twsi.s.v)
+		debug("%s: timed out\n", __func__);
+	return sw_twsi.u;
+}
+
+/**
+ * Reads the MIO_TWS(0..5)_SW_TWSI register
+ *
+ * @param	baseaddr	Base address of i2c registers
+ * @param	sw_twsi		value for eia and op, etc. to read
+ *
+ * @return	value of the register
+ */
+static u64 twsi_read_sw(void *baseaddr, union twsx_sw_twsi sw_twsi)
+{
+	unsigned long start = get_timer(0);
+	sw_twsi.s.r = 1;
+	sw_twsi.s.v = 1;
+
+	debug("%s(%p, 0x%llx)\n", __func__, baseaddr, sw_twsi.u);
+	writeq(sw_twsi.u, baseaddr + TWSI_SW_TWSI);
+
+	do {
+		sw_twsi.u = readq(baseaddr + TWSI_SW_TWSI);
+	} while (sw_twsi.s.v != 0 && get_timer(start) < 50);
+
+	if (sw_twsi.s.v)
+		debug("%s: Error writing 0x%llx\n", __func__, sw_twsi.u);
+
+	debug("%s: Returning 0x%llx\n", __func__, sw_twsi.u);
+	return sw_twsi.u;
+}
+
+/**
+ * Write control register
+ *
+ * @param	baseaddr	Base address for i2c registers
+ * @param	data		data to write
+ */
+static void twsi_write_ctl(void *baseaddr, u8 data)
+{
+	union twsx_sw_twsi twsi_sw;
+
+	debug("%s(%p, 0x%x)\n", __func__, baseaddr, data);
+	twsi_sw.u = 0;
+
+	twsi_sw.s.op	 = TWSI_SW_EOP_IA;
+	twsi_sw.s.eop_ia = TWSI_CTL;
+	twsi_sw.s.data	 = data;
+
+	twsi_write_sw(baseaddr, twsi_sw);
+}
+
+/**
+ * Reads the TWSI Control Register
+ *
+ * @param[in]	baseaddr	Base address for i2c
+ *
+ * @return	8-bit TWSI control register
+ */
+static u32 twsi_read_ctl(void *baseaddr)
+{
+	union twsx_sw_twsi sw_twsi;
+
+	sw_twsi.u	 = 0;
+	sw_twsi.s.op	 = TWSI_SW_EOP_IA;
+	sw_twsi.s.eop_ia = TWSI_CTL;
+
+	sw_twsi.u = twsi_read_sw(baseaddr, sw_twsi);
+	debug("%s(%p): 0x%x\n", __func__, baseaddr, sw_twsi.s.data);
+	return sw_twsi.s.data;
+}
+
+/**
+ * Read i2c status register
+ *
+ * @param	baseaddr	Base address of i2c registers
+ *
+ * @return	value of status register
+ */
+static u8 twsi_read_status(void *baseaddr)
+{
+	union twsx_sw_twsi twsi_sw;
+
+	twsi_sw.u	= 0;
+	twsi_sw.s.op	= TWSI_SW_EOP_IA;
+	twsi_sw.s.eop_ia = TWSI_STAT;
+
+	return twsi_read_sw(baseaddr, twsi_sw);
+}
+
+/**
+ * Waits for an i2c operation to complete
+ *
+ * @param	baseaddr	Base address of registers
+ *
+ * @return	0 for success, 1 if timeout
+ */
+static int twsi_wait(void *baseaddr)
+{
+	unsigned long start = get_timer(0);
+	u8 twsi_ctl;
+
+	debug("%s(%p)\n", __func__, baseaddr);
+	do {
+		twsi_ctl = twsi_read_ctl(baseaddr);
+		twsi_ctl &= TWSI_CTL_IFLG;
+	} while (!twsi_ctl && get_timer(start) < 50);
+
+	debug("  return: %u\n", !twsi_ctl);
+	return !twsi_ctl;
+}
+
+/**
+ * Unsticks the i2c bus
+ *
+ * @param	baseaddr	base address of registers
+ */
+static int twsi_start_unstick(void *baseaddr)
+{
+	twsi_stop(baseaddr);
+
+	twsi_unblock(baseaddr);
+
+	return 0;
+}
+
+/**
+ * Sends an i2c start condition
+ *
+ * @param	baseaddr	base address of registers
+ *
+ * @return	0 for success, otherwise error
+ */
+static int twsi_start(void *baseaddr)
+{
+	int result;
+	u8 stat;
+
+	debug("%s(%p)\n", __func__, baseaddr);
+	twsi_write_ctl(baseaddr, TWSI_CTL_STA | TWSI_CTL_ENAB);
+	result = twsi_wait(baseaddr);
+	if (result) {
+		stat = twsi_read_status(baseaddr);
+		debug("%s: result: 0x%x, status: 0x%x\n", __func__,
+		      result, stat);
+		switch (stat) {
+		case TWSI_STAT_START:
+		case TWSI_STAT_RSTART:
+			return 0;
+		case TWSI_STAT_RXADDR_ACK:
+		default:
+			return twsi_start_unstick(baseaddr);
+		}
+	}
+	debug("%s: success\n", __func__);
+	return 0;
+}
+
+/**
+ * Sends an i2c stop condition
+ *
+ * @param	baseaddr	register base address
+ *
+ * @return	0 for success, -1 if error
+ */
+static int twsi_stop(void *baseaddr)
+{
+	u8 stat;
+	twsi_write_ctl(baseaddr, TWSI_CTL_STP | TWSI_CTL_ENAB);
+
+	stat = twsi_read_status(baseaddr);
+	if (stat != TWSI_STAT_IDLE) {
+		debug("%s: Bad status on bus@%p\n", __func__, baseaddr);
+		return -1;
+	}
+	return 0;
+}
+
+/**
+ * Writes data to the i2c bus
+ *
+ * @param	baseraddr	register base address
+ * @param	slave_addr	address of slave to write to
+ * @param	buffer		Pointer to buffer to write
+ * @param	length		Number of bytes in buffer to write
+ *
+ * @return	0 for success, otherwise error
+ */
+static int twsi_write_data(void *baseaddr, u8  slave_addr,
+			   u8 *buffer, unsigned int length)
+{
+	union twsx_sw_twsi twsi_sw;
+	unsigned int curr = 0;
+	int result;
+
+	debug("%s(%p, 0x%x, %p, 0x%x)\n", __func__, baseaddr, slave_addr,
+	      buffer, length);
+	result = twsi_start(baseaddr);
+	if (result) {
+		debug("%s: Could not start BUS transaction\n", __func__);
+		return -1;
+	}
+
+	result = twsi_wait(baseaddr);
+	if (result) {
+		debug("%s: wait failed\n", __func__);
+		return result;
+	}
+
+	twsi_sw.u	 = 0;
+	twsi_sw.s.op	 = TWSI_SW_EOP_IA;
+	twsi_sw.s.eop_ia = TWSI_DATA;
+	twsi_sw.s.data	 = (u32) (slave_addr << 1) | TWSI_OP_WRITE;
+
+	twsi_write_sw(baseaddr, twsi_sw);
+	twsi_write_ctl(baseaddr, TWSI_CTL_ENAB);
+
+	debug("%s: Waiting\n", __func__);
+	result = twsi_wait(baseaddr);
+	if (result) {
+		debug("%s: Timed out writing slave address 0x%x to target\n",
+		      __func__, slave_addr);
+		return result;
+	}
+	result = twsi_read_status(baseaddr);
+	debug("%s: status: (%d) %s\n", __func__, result,
+	      twsi_i2c_status_str(result));
+	if ((result = twsi_read_status(baseaddr)) != TWSI_STAT_TXADDR_ACK) {
+		debug("%s: status: (%d) %s\n", __func__, result,
+		      twsi_i2c_status_str(result));
+		twsi_stop(baseaddr);
+		return twsi_i2c_lost_arb(result, 0);
+	}
+
+	while (curr < length) {
+		twsi_sw.u	 = 0;
+		twsi_sw.s.op	 = TWSI_SW_EOP_IA;
+		twsi_sw.s.eop_ia = TWSI_DATA;
+		twsi_sw.s.data	 = buffer[curr++];
+
+		twsi_write_sw(baseaddr, twsi_sw);
+		twsi_write_ctl(baseaddr, TWSI_CTL_ENAB);
+
+		debug("%s: Writing 0x%x\n", __func__, twsi_sw.s.data);
+
+		result = twsi_wait(baseaddr);
+		if (result) {
+			debug("%s: Timed out writing data to 0x%x\n",
+			      __func__, slave_addr);
+			return result;
+		}
+		result = twsi_read_status(baseaddr);
+		debug("%s: status: (%d) %s\n", __func__, result,
+		      twsi_i2c_status_str(result));
+	}
+
+	debug("%s: Stopping\n", __func__);
+	return twsi_stop(baseaddr);
+}
+
+/**
+ * Manually clear the I2C bus and send a stop
+ */
+static void twsi_unblock(void *baseaddr)
+{
+	int i;
+	union twsx_int	int_reg;
+
+	int_reg.u = 0;
+	for (i = 0; i < 9; i++) {
+		int_reg.s.scl_ovr = 0;
+		writeq(int_reg.u, baseaddr + TWSI_INT);
+		udelay(5);
+		int_reg.s.scl_ovr = 1;
+		writeq(int_reg.u, baseaddr + TWSI_INT);
+		udelay(5);
+	}
+	int_reg.s.sda_ovr = 1;
+	writeq(int_reg.u, baseaddr + TWSI_INT);
+	udelay(5);
+	int_reg.s.scl_ovr = 0;
+	writeq(int_reg.u, baseaddr + TWSI_INT);
+	udelay(5);
+	int_reg.u = 0;
+	writeq(int_reg.u, baseaddr + TWSI_INT);
+	udelay(5);
+}
+
+/**
+ * Performs a read transaction on the i2c bus
+ *
+ * @param	baseaddr	Base address of twsi registers
+ * @param	slave_addr	i2c bus address to read from
+ * @param	buffer		buffer to read into
+ * @param	length		number of bytes to read
+ *
+ * @return	0 for success, otherwise error
+ */
+static int twsi_read_data(void *baseaddr, u8 slave_addr,
+			  u8 *buffer, unsigned int length)
+{
+	union twsx_sw_twsi twsi_sw;
+	unsigned int curr = 0;
+	int result;
+
+	debug("%s(%p, 0x%x, %p, %u)\n", __func__, baseaddr, slave_addr,
+	      buffer, length);
+	result = twsi_start(baseaddr);
+	if (result) {
+		debug("%s: start failed\n", __func__);
+		return result;
+	}
+
+	result = twsi_wait(baseaddr);
+	if (result) {
+		debug("%s: wait failed\n", __func__);
+		return result;
+	}
+
+	twsi_sw.u	 = 0;
+	twsi_sw.s.op	 = TWSI_SW_EOP_IA;
+	twsi_sw.s.eop_ia = TWSI_DATA;
+
+	twsi_sw.s.data  = (u32) (slave_addr << 1) | TWSI_OP_READ;
+
+	twsi_write_sw(baseaddr, twsi_sw);
+	twsi_write_ctl(baseaddr, TWSI_CTL_ENAB);
+
+	result = twsi_wait(baseaddr);
+	if (result) {
+		debug("%s: waiting for sending addr failed\n", __func__);
+		return result;
+	}
+
+	result = twsi_read_status(baseaddr);
+	debug("%s: status: (%d) %s\n", __func__, result,
+	      twsi_i2c_status_str(result));
+	if (result != TWSI_STAT_RXADDR_ACK) {
+		debug("%s: status: (%d) %s\n", __func__, result,
+		      twsi_i2c_status_str(result));
+		twsi_stop(baseaddr);
+		return twsi_i2c_lost_arb(result, 0);
+	}
+
+	while (curr < length) {
+		twsi_write_ctl(baseaddr, TWSI_CTL_ENAB |
+				((curr < length - 1) ? TWSI_CTL_AAK : 0));
+
+		result = twsi_wait(baseaddr);
+		if (result) {
+			debug("%s: waiting for data failed\n", __func__);
+			return result;
+		}
+
+		twsi_sw.u = twsi_read_sw(baseaddr, twsi_sw);
+		buffer[curr++] = twsi_sw.s.data;
+	}
+
+	twsi_stop(baseaddr);
+
+	return 0;
+}
+
+static void twsi_calc_div(unsigned int speed, int *m_div, int *n_div)
+{
+	int io_clock_hz;
+	int tclk, fsamp;
+	int ndiv, mdiv;
+
+#if defined(CONFIG_ARCH_OCTEONTX)
+	io_clock_hz = octeontx_get_io_clock();
+	tclk = io_clock_hz / 2 * (TWSI_THP + 1);
+#elif defined(CONFIG_ARCH_OCTEONTX2)
+	/* Refclk src in mode register defaults to 100MHz clock */
+	io_clock_hz = 100000000; /* 100 Mhz */
+	tclk = io_clock_hz / (TWSI_THP + 2);
+#endif
+	debug("%s( io_clock %u)\n", __func__, io_clock_hz);
+
+	/* Set the TWSI clock to a conservative TWSI_BUS_FREQ.
+	 * Compute the clocks M divider based on the SCLK.
+	 *
+	 * TWSI freq = (core freq) / (10 x (M+1) x 2 * (thp+1) x 2^N)
+	 * M = ((core freq) / (10 x (TWSI freq) x 2 * (thp+1) x 2^N)) - 1
+	 *
+	 * For OcteonTX2 -
+	 * TWSI freq = (core freq) / (10 x (M+1) x (thp+2) x 2^N)
+	 * M = ((core freq) / (10 x (TWSI freq) x (thp+2) x 2^N)) - 1
+	 */
+	for (ndiv = 0; ndiv < 8; ndiv++) {
+		fsamp = tclk / (1 << ndiv);
+		mdiv = fsamp / speed / 10;
+		mdiv -= 1;
+		if (mdiv < 16)
+			break;
+	}
+	*m_div = mdiv;
+	*n_div = ndiv;
+}
+
+static int twsi_init(void *baseaddr, unsigned int speed, int slaveaddr)
+{
+	int n_div, m_div;
+	union twsx_sw_twsi sw_twsi;
+
+	debug("%s(%p, %u, 0x%x)\n", __func__, baseaddr, speed, slaveaddr);
+
+	twsi_calc_div(speed, &m_div, &n_div);
+	if (m_div >= 16)
+		return -1;
+
+	sw_twsi.u = 0;
+	sw_twsi.s.v = 1;	/* Clear valid bit */
+	sw_twsi.s.op = 0x6;	/* See EOP field */
+	sw_twsi.s.r = 0;	/* Select CLKCTL when R = 0 */
+	sw_twsi.s.eop_ia = 3;	/* R=0 selects CLKCTL, R=1 selects STAT */
+	sw_twsi.s.data = ((m_div & 0xf) << 3) | ((n_div & 0x7) << 0);
+
+	twsi_write_sw(baseaddr, sw_twsi);
+	/* Only init non-slave ports */
+	debug("%s: Writing 0x%llx to sw_twsi, m_div: 0x%x, n_div: 0x%x\n",
+	      __func__, sw_twsi.u, m_div, n_div);
+
+
+	sw_twsi.u = 0;
+	sw_twsi.s.v = 1;
+	sw_twsi.s.op = TWSI_SW_EOP_IA;
+	sw_twsi.s.r = 0;
+	sw_twsi.s.eop_ia = 0;
+	sw_twsi.s.data = slaveaddr << 1;
+
+	twsi_write_sw(baseaddr, sw_twsi);
+
+	/* Set slave address */
+	sw_twsi.u = 0;
+	sw_twsi.s.v = 1;
+	sw_twsi.s.op = TWSI_SW_EOP_IA;
+	sw_twsi.s.r = 0;
+	sw_twsi.s.eop_ia = TWSI_EOP_SLAVE_ADDR;
+	sw_twsi.s.data = slaveaddr;
+	twsi_write_sw(baseaddr, sw_twsi);
+
+	return 0;
+}
+
+/**
+ * Transfers data over the i2c bus
+ *
+ * @param	bus	i2c bus to transfer data over
+ * @param	msg	Array of i2c messages
+ * @param	nmsgs	Number of messages to send/receive
+ *
+ * @return	0 for success, otherwise error
+ */
+static int octeontx_i2c_xfer(struct udevice *bus, struct i2c_msg *msg,
+			     int nmsgs)
+{
+	struct octeontx_twsi *twsi = dev_get_priv(bus);
+	int result;
+
+	debug("octeontx_i2c_xfer: %d messages\n", nmsgs);
+	for (; nmsgs > 0; nmsgs--, msg++) {
+		debug("octeontx_i2c_xfer: chip=0x%x, len=0x%x\n",
+		      msg->addr, msg->len);
+		if (msg->flags & I2C_M_RD) {
+			debug("%s: Reading data\n", __func__);
+			result = twsi_read_data(twsi->baseaddr, msg->addr,
+					     msg->buf, msg->len);
+		} else {
+			debug("%s: Writing data\n", __func__);
+			result = twsi_write_data(twsi->baseaddr, msg->addr,
+					      msg->buf, msg->len);
+		}
+		if (result) {
+			debug("octeontx_i2c_xfer: error sending\n");
+			return -EREMOTEIO;
+		}
+	}
+
+	return 0;
+}
+
+static int octeontx_i2c_set_bus_speed(struct udevice *bus, unsigned int speed)
+{
+	struct octeontx_twsi *twsi = dev_get_priv(bus);
+	int m_div, n_div;
+	union twsx_sw_twsi sw_twsi;
+	void *baseaddr = twsi->baseaddr;
+
+	debug("%s(%p, %u)\n", __func__, bus, speed);
+
+	twsi_calc_div(speed, &m_div, &n_div);
+	if (m_div >= 16)
+		return -1;
+
+	sw_twsi.u = 0;
+	sw_twsi.s.v = 1;		/* Clear valid bit */
+	sw_twsi.s.op = TWSI_SW_EOP_IA;	/* See EOP field */
+	sw_twsi.s.r = 0;		/* Select CLKCTL when R = 0 */
+	sw_twsi.s.eop_ia = TWSI_CLKCTL;	/* R=0 selects CLKCTL, R=1 selects STAT */
+	sw_twsi.s.data = ((m_div & 0xf) << 3) | ((n_div & 0x7) << 0);
+
+	/* Only init non-slave ports */
+	writeq(sw_twsi.u, baseaddr + TWSI_SW_TWSI);
+
+	debug("%s: Wrote 0x%llx to sw_twsi\n", __func__, sw_twsi.u);
+	return 0;
+}
+
+static int octeontx_pci_i2c_probe(struct udevice *dev)
+{
+	struct octeontx_twsi *twsi = dev_get_priv(dev);
+	pci_dev_t bdf = dm_pci_get_bdf(dev);
+	size_t size;
+
+	debug("TWSI PCI device: %x\n", bdf);
+	dev->req_seq = PCI_FUNC(bdf);
+
+	twsi->baseaddr = dm_pci_map_bar(dev, 0, &size, PCI_REGION_MEM);
+	twsi->id = last_id++;
+
+	debug("TWSI bus %d at %p\n",dev->seq, twsi->baseaddr);
+
+	return twsi_init(twsi->baseaddr,
+			 twsi->id < ARRAY_SIZE(speeds) ?
+			 speeds[twsi->id] : CONFIG_SYS_I2C_SPEED,
+			 CONFIG_SYS_I2C_OCTEONTX_SLAVE_ADDR);
+}
+
+static const struct dm_i2c_ops octeontx_i2c_ops = {
+	.xfer		= octeontx_i2c_xfer,
+	.set_bus_speed	= octeontx_i2c_set_bus_speed,
+};
+
+static const struct udevice_id octeontx_i2c_ids[] = {
+	{ .compatible = "cavium,thunder-8890-twsi" },
+	{ }
+};
+
+U_BOOT_DRIVER(octeontx_pci_twsi) = {
+	.name	= "i2c_octeontx",
+	.id	= UCLASS_I2C,
+	.of_match = octeontx_i2c_ids,
+	.probe	= octeontx_pci_i2c_probe,
+	.priv_auto_alloc_size = sizeof(struct octeontx_twsi),
+	.ops	= &octeontx_i2c_ops,
+};
+
diff --git a/drivers/mdio/Kconfig b/drivers/mdio/Kconfig
new file mode 100644
index 0000000..1aebc36
--- /dev/null
+++ b/drivers/mdio/Kconfig
@@ -0,0 +1,23 @@
+#
+# MDIO infrastructure and drivers
+#
+
+menu "MDIO Support"
+
+config DM_MDIO
+	bool "Enable Driver Model for MDIO drivers"
+	depends on DM
+	help
+	  Enable driver model for MDIO access.
+
+config MVMDIO
+	bool "Marvell MDIO interface support"
+	depends on DM_MDIO
+	select PHYLIB
+	---help---
+	  This driver supports the MDIO interface found in the network
+	  interface units of the Marvell EBU SoCs (Kirkwood, Orion5x,
+	  Dove, Armada 370, Armada XP, Armada 37xx and Armada7K/8K/8KP).
+
+	  This driver is used by the MVPP2 and MVNETA drivers.
+endmenu
diff --git a/drivers/mdio/Makefile b/drivers/mdio/Makefile
new file mode 100644
index 0000000..9f571aa
--- /dev/null
+++ b/drivers/mdio/Makefile
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0+
+#
+# Copyright (C) 2018 Marvell International Ltd.
+# Author: Ken Ma<make@marvell.com>
+
+obj-$(CONFIG_DM_MDIO) += mdio-uclass.o
+obj-$(CONFIG_MVMDIO) += mvmdio.o
diff --git a/drivers/mdio/mdio-uclass.c b/drivers/mdio/mdio-uclass.c
new file mode 100644
index 0000000..251776b
--- /dev/null
+++ b/drivers/mdio/mdio-uclass.c
@@ -0,0 +1,119 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ * Author: Ken Ma<make@marvell.com>
+ */
+
+#include <common.h>
+#include <fdtdec.h>
+#include <errno.h>
+#include <dm.h>
+#include <dm/uclass.h>
+#include <dm/uclass-internal.h>
+#include <miiphy.h>
+#include <mdio.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int mdio_mii_bus_get(struct udevice *mdio_dev, struct mii_dev **bus)
+{
+	*bus = *(struct mii_dev **)dev_get_uclass_platdata(mdio_dev);
+
+	return 0;
+}
+
+int mdio_device_get_from_phy(int phy_node, struct udevice **devp)
+{
+	int mdio_off;
+
+	mdio_off = fdt_parent_offset(gd->fdt_blob, phy_node);
+	return uclass_get_device_by_of_offset(UCLASS_MDIO, mdio_off,
+					      devp);
+}
+
+int mdio_mii_bus_get_from_phy(int phy_node, struct mii_dev **bus)
+{
+	struct udevice *mdio_dev;
+	int ret;
+
+	ret = mdio_device_get_from_phy(phy_node, &mdio_dev);
+	if (ret)
+		return ret;
+
+	*bus = *(struct mii_dev **)dev_get_uclass_platdata(mdio_dev);
+
+	return 0;
+}
+
+int mdio_device_get_from_eth(struct udevice *eth, struct udevice **devp)
+{
+	int dev_node = dev_of_offset(eth);
+	int phy_node;
+
+	phy_node = fdtdec_lookup_phandle(gd->fdt_blob, dev_node, "phy");
+	if (phy_node > 0)
+		return mdio_device_get_from_phy(phy_node, devp);
+
+	/*
+	 * If there is no phy reference under the ethernet fdt node,
+	 * it is not an error since the ethernet device may do not use
+	 * mode; so in this case, the output mdio device pointer is set
+	 * as NULL.
+	 */
+	*devp = NULL;
+	return 0;
+}
+
+int mdio_mii_bus_get_from_eth(struct udevice *eth, struct mii_dev **bus)
+{
+	struct udevice *mdio_dev;
+	int ret;
+
+	ret = mdio_device_get_from_eth(eth, &mdio_dev);
+	if (ret)
+		return ret;
+
+	if (mdio_dev)
+		*bus = *(struct mii_dev **)dev_get_uclass_platdata(mdio_dev);
+	else
+		*bus = NULL;
+
+	return 0;
+}
+
+static int mdio_uclass_pre_probe(struct udevice *dev)
+{
+	struct mii_dev **pbus = dev_get_uclass_platdata(dev);
+	struct mii_dev *bus;
+	const char *name;
+
+	bus = mdio_alloc();
+	if (!bus) {
+		printf("Failed to allocate MDIO bus @%p\n",
+		       devfdt_get_addr_ptr(dev));
+		return -1;
+	}
+
+	name = fdt_getprop(gd->fdt_blob, dev_of_offset(dev),
+			   "mdio-name", NULL);
+	if (name)
+		strncpy(bus->name, name, MDIO_NAME_LEN);
+	*pbus = bus;
+
+	return 0;
+}
+
+static int mdio_uclass_post_probe(struct udevice *dev)
+{
+	struct mii_dev **pbus = dev_get_uclass_platdata(dev);
+
+	return mdio_register(*pbus);
+}
+
+UCLASS_DRIVER(mdio) = {
+	.id		= UCLASS_MDIO,
+	.name		= "mdio",
+	.pre_probe	= mdio_uclass_pre_probe,
+	.post_probe	= mdio_uclass_post_probe,
+	.per_device_platdata_auto_alloc_size = sizeof(struct mii_dev *),
+};
diff --git a/drivers/mdio/mvmdio.c b/drivers/mdio/mvmdio.c
new file mode 100644
index 0000000..b2c6636
--- /dev/null
+++ b/drivers/mdio/mvmdio.c
@@ -0,0 +1,237 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ * Author: Ken Ma<make@marvell.com>
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <dm/device-internal.h>
+#include <dm/lists.h>
+#include <miiphy.h>
+#include <phy.h>
+#include <asm/io.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define MVMDIO_SMI_DATA_SHIFT		0
+#define MVMDIO_SMI_PHY_ADDR_SHIFT	16
+#define MVMDIO_SMI_PHY_REG_SHIFT	21
+#define MVMDIO_SMI_READ_OPERATION	BIT(26)
+#define MVMDIO_SMI_WRITE_OPERATION	0
+#define MVMDIO_SMI_READ_VALID		BIT(27)
+#define MVMDIO_SMI_BUSY			BIT(28)
+
+#define MVMDIO_XSMI_MGNT_REG		0x0
+#define MVMDIO_XSMI_PHYADDR_SHIFT	16
+#define MVMDIO_XSMI_DEVADDR_SHIFT	21
+#define MVMDIO_XSMI_WRITE_OPERATION	(0x5 << 26)
+#define MVMDIO_XSMI_READ_OPERATION	(0x7 << 26)
+#define MVMDIO_XSMI_READ_VALID		BIT(29)
+#define MVMDIO_XSMI_BUSY		BIT(30)
+#define MVMDIO_XSMI_ADDR_REG		0x8
+
+#define MVMDIO_TIMEOUT			10000
+
+struct mvmdio_priv {
+	void *mdio_base;
+};
+
+enum mvmdio_bus_type {
+	BUS_TYPE_SMI,
+	BUS_TYPE_XSMI
+};
+
+/* Wait for the SMI unit to be ready for another operation */
+static int mvmdio_smi_wait_ready(struct mii_dev *bus)
+{
+	u32 timeout = MVMDIO_TIMEOUT;
+	struct mvmdio_priv *priv = bus->priv;
+	u32 smi_reg;
+
+	/* Wait till the SMI is not busy */
+	do {
+		/* Read smi register */
+		smi_reg = readl(priv->mdio_base);
+		if (timeout-- == 0) {
+			debug("Error: SMI busy timeout\n");
+			return -ETIME;
+		}
+	} while (smi_reg & MVMDIO_SMI_BUSY);
+
+	return 0;
+}
+
+static int mvmdio_smi_read(struct mii_dev *bus, int addr,
+			   int devad, int reg)
+{
+	struct mvmdio_priv *priv = bus->priv;
+	u32 val;
+	int ret;
+
+	if (devad != MDIO_DEVAD_NONE)
+		return -EOPNOTSUPP;
+
+	ret = mvmdio_smi_wait_ready(bus);
+	if (ret < 0)
+		return ret;
+
+	writel(((addr << MVMDIO_SMI_PHY_ADDR_SHIFT) |
+		(reg << MVMDIO_SMI_PHY_REG_SHIFT)  |
+		MVMDIO_SMI_READ_OPERATION),
+	       priv->mdio_base);
+
+	ret = mvmdio_smi_wait_ready(bus);
+	if (ret < 0)
+		return ret;
+
+	val = readl(priv->mdio_base);
+	if (!(val & MVMDIO_SMI_READ_VALID)) {
+		dev_err(bus->parent, "SMI bus read not valid\n");
+		return -ENODEV;
+	}
+
+	return val & GENMASK(15, 0);
+}
+
+static int mvmdio_smi_write(struct mii_dev *bus, int addr, int devad,
+			    int reg, u16 value)
+{
+	struct mvmdio_priv *priv = bus->priv;
+	int ret;
+
+	if (devad != MDIO_DEVAD_NONE)
+		return -EOPNOTSUPP;
+
+	ret = mvmdio_smi_wait_ready(bus);
+	if (ret < 0)
+		return ret;
+
+	writel(((addr << MVMDIO_SMI_PHY_ADDR_SHIFT) |
+		(reg << MVMDIO_SMI_PHY_REG_SHIFT)  |
+		MVMDIO_SMI_WRITE_OPERATION            |
+		(value << MVMDIO_SMI_DATA_SHIFT)),
+	       priv->mdio_base);
+
+	return 0;
+}
+
+static int mvmdio_xsmi_wait_ready(struct mii_dev *bus)
+{
+	u32 timeout = MVMDIO_TIMEOUT;
+	struct mvmdio_priv *priv = bus->priv;
+	u32 xsmi_reg;
+
+	/* Wait till the xSMI is not busy */
+	do {
+		/* Read xSMI register */
+		xsmi_reg = readl(priv->mdio_base);
+		if (timeout-- == 0) {
+			debug("xSMI busy time-out\n");
+			return -ETIME;
+		}
+	} while (xsmi_reg & MVMDIO_XSMI_BUSY);
+
+	return 0;
+}
+
+static int mvmdio_xsmi_read(struct mii_dev *bus, int addr,
+			    int devad, int reg)
+{
+	struct mvmdio_priv *priv = bus->priv;
+	int ret;
+
+	if (devad == MDIO_DEVAD_NONE)
+		return -EOPNOTSUPP;
+
+	ret = mvmdio_xsmi_wait_ready(bus);
+	if (ret < 0)
+		return ret;
+
+	writel(reg & GENMASK(15, 0), priv->mdio_base + MVMDIO_XSMI_ADDR_REG);
+	writel(((addr << MVMDIO_XSMI_PHYADDR_SHIFT) |
+		(devad << MVMDIO_XSMI_DEVADDR_SHIFT) |
+		MVMDIO_XSMI_READ_OPERATION),
+	       priv->mdio_base + MVMDIO_XSMI_MGNT_REG);
+
+	ret = mvmdio_xsmi_wait_ready(bus);
+	if (ret < 0)
+		return ret;
+
+	if (!(readl(priv->mdio_base + MVMDIO_XSMI_MGNT_REG) &
+	      MVMDIO_XSMI_READ_VALID)) {
+		dev_err(bus->parent, "XSMI bus read not valid\n");
+		return -ENODEV;
+	}
+
+	return readl(priv->mdio_base + MVMDIO_XSMI_MGNT_REG) & GENMASK(15, 0);
+}
+
+static int mvmdio_xsmi_write(struct mii_dev *bus, int addr, int devad,
+			     int reg, u16 value)
+{
+	struct mvmdio_priv *priv = bus->priv;
+	int ret;
+
+	if (devad == MDIO_DEVAD_NONE)
+		return -EOPNOTSUPP;
+
+	ret = mvmdio_xsmi_wait_ready(bus);
+	if (ret < 0)
+		return ret;
+
+	writel(reg & GENMASK(15, 0), priv->mdio_base + MVMDIO_XSMI_ADDR_REG);
+	writel(((addr << MVMDIO_XSMI_PHYADDR_SHIFT) |
+		(devad << MVMDIO_XSMI_DEVADDR_SHIFT) |
+		MVMDIO_XSMI_WRITE_OPERATION | value),
+	       priv->mdio_base + MVMDIO_XSMI_MGNT_REG);
+
+	return 0;
+}
+
+static int mvmdio_probe(struct udevice *dev)
+{
+	struct mii_dev **pbus = dev_get_uclass_platdata(dev);
+	struct mii_dev *bus = *pbus;
+	struct mvmdio_priv *priv;
+	enum mvmdio_bus_type type;
+
+	priv = dev_get_priv(dev);
+	priv->mdio_base = (void *)devfdt_get_addr(dev);
+	bus->priv = priv;
+
+	type = (enum mvmdio_bus_type)dev_get_driver_data(dev);
+	switch (type) {
+	case BUS_TYPE_SMI:
+		bus->read = mvmdio_smi_read;
+		bus->write = mvmdio_smi_write;
+		if (!bus->name)
+			snprintf(bus->name, MDIO_NAME_LEN,
+				 "orion-mdio.%p", priv->mdio_base);
+		break;
+	case BUS_TYPE_XSMI:
+		bus->read = mvmdio_xsmi_read;
+		bus->write = mvmdio_xsmi_write;
+		if (!bus->name)
+			snprintf(bus->name, MDIO_NAME_LEN,
+				 "xmdio.%p", priv->mdio_base);
+		break;
+	}
+
+	return 0;
+}
+
+static const struct udevice_id mvmdio_ids[] = {
+	{ .compatible = "marvell,orion-mdio", .data = BUS_TYPE_SMI },
+	{ .compatible = "marvell,xmdio", .data = BUS_TYPE_XSMI },
+	{ }
+};
+
+U_BOOT_DRIVER(mvmdio) = {
+	.name			= "mvmdio",
+	.id			= UCLASS_MDIO,
+	.of_match		= mvmdio_ids,
+	.probe			= mvmdio_probe,
+	.priv_auto_alloc_size	= sizeof(struct mvmdio_priv),
+};
+
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index e8d598c..d39ec5a 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -50,6 +50,7 @@ obj-$(CONFIG_FSL_SEC_MON) += fsl_sec_mon.o
 obj-$(CONFIG_PCA9551_LED) += pca9551_led.o
 obj-$(CONFIG_FSL_DEVICE_DISABLE) += fsl_devdis.o
 obj-$(CONFIG_WINBOND_W83627) += winbond_w83627.o
+obj-$(CONFIG_MVEBU_SAR) += mvebu_sar/
 obj-$(CONFIG_QFW) += qfw.o
 obj-$(CONFIG_ROCKCHIP_EFUSE) += rockchip-efuse.o
 obj-$(CONFIG_STM32_RCC) += stm32_rcc.o
diff --git a/drivers/misc/mvebu_sar/Makefile b/drivers/misc/mvebu_sar/Makefile
new file mode 100644
index 0000000..412c139
--- /dev/null
+++ b/drivers/misc/mvebu_sar/Makefile
@@ -0,0 +1,13 @@
+
+obj-$(CONFIG_MVEBU_SAR) += sar-uclass.o
+ifdef CONFIG_TARGET_MVEBU_ARMADA_8K
+	obj-$(CONFIG_TARGET_MVEBU_ARMADA_8K) += ap806_sar.o
+	obj-$(CONFIG_TARGET_MVEBU_ARMADA_8K) += ap807_sar.o
+	obj-$(CONFIG_TARGET_MVEBU_ARMADA_8K) += cp110_sar.o
+endif
+
+ifdef CONFIG_TARGET_OCTEONTX2_CN913x
+	obj-$(CONFIG_TARGET_OCTEONTX2_CN913x) += ap807_sar.o
+	obj-$(CONFIG_TARGET_OCTEONTX2_CN913x) += cp110_sar.o
+endif
+
diff --git a/drivers/misc/mvebu_sar/ap806_sar.c b/drivers/misc/mvebu_sar/ap806_sar.c
new file mode 100644
index 0000000..a19de16
--- /dev/null
+++ b/drivers/misc/mvebu_sar/ap806_sar.c
@@ -0,0 +1,249 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+/* #define DEBUG */
+#include <common.h>
+#include <asm/io.h>
+#include <errno.h>
+#include <fdtdec.h>
+#include <mach/clock.h>
+#include <mvebu/mvebu_chip_sar.h>
+
+#include <sar-uclass.h>
+
+#define CPU_CLOCK_ID	0
+#define DDR_CLOCK_ID	1
+#define RING_CLOCK_ID	2
+
+/* SAR AP806 registers */
+#define SAR_CLOCK_FREQ_MODE_OFFSET	0
+#define SAR_CLOCK_FREQ_MODE_MASK	(0x1f << SAR_CLOCK_FREQ_MODE_OFFSET)
+#define SAR_TEST_MODE_ENABLE_OFFSET	5
+#define SAR_TEST_MODE_ENABLE_MASK	(0x1 << SAR_TEST_MODE_ENABLE_OFFSET)
+#define SAR_SKIP_LINK_I2C_INIT_OFFSET	6
+#define SAR_SKIP_LINK_I2C_INIT_MASK	(0x1 << SAR_SKIP_LINK_I2C_INIT_OFFSET)
+#define SAR_POR_BYPASS_OFFSET		7
+#define SAR_POR_BYPASS_MASK		(0x1 << SAR_POR_BYPASS_OFFSET)
+#define SAR_BOOT_SOURCE_OFFSET		8
+#define SAR_BOOT_SOURCE_MASK		(0x7 << SAR_BOOT_SOURCE_OFFSET)
+#define SAR_PIDI_C2C_IHB_SELECT_OFFSET	11
+#define SAR_PIDI_C2C_IHB_SELECT_MASK	(0x1 << SAR_PIDI_C2C_IHB_SELECT_OFFSET)
+#define SAR_I2C_INIT_ENABLE_OFFSET	12
+#define SAR_I2C_INIT_ENABLE_MASK	(0x1 << SAR_I2C_INIT_ENABLE_OFFSET)
+#define SAR_SSCG_DISABLE_OFFSET		13
+#define SAR_SSCG_DISABLE_MASK		(0x1 << SAR_SSCG_DISABLE_OFFSET)
+#define SAR_PIDI_HW_TRAINING_DIS_OFFSET	14
+#define SAR_PIDI_HW_TRAINING_DIS_MASK	(0x1 << SAR_PIDI_HW_TRAINING_DIS_OFFSET)
+#define SAR_CPU_FMAX_REFCLK_OFFSET	15
+#define SAR_CPU_FMAX_REFCLK_MASK	(0x1 << SAR_CPU_FMAX_REFCLK_OFFSET)
+#define SAR_IHB_DIFF_REFCLK_DIS_OFFSET	16
+#define SAR_IHB_DIFF_REFCLK_DIS_MASK	(0x1 << SAR_IHB_DIFF_REFCLK_DIS_OFFSET)
+#define SAR_REF_CLK_MSTR_OFFSET		17
+#define SAR_REF_CLK_MSTR_MASK		(0x1 << SAR_REF_CLK_MSTR_OFFSET)
+#define SAR_CPU_WAKE_UP_OFFSET		18
+#define SAR_CPU_WAKE_UP_MASK		(0x1 << SAR_CPU_WAKE_UP_OFFSET)
+#define SAR_XTAL_BYPASS_OFFSET		19
+#define SAR_XTAL_BYPASS_MASK		(0x1 << SAR_XTAL_BYPASS_OFFSET)
+#define SAR_PIDI_LOW_SPEED_OFFSET	20
+#define SAR_PIDI_LOW_SPEED_MASK		(0x1 << SAR_PIDI_LOW_SPEED_OFFSET)
+
+#define AP806_SAR_1_REG			4
+#define SAR1_PLL2_OFFSET		(9)
+#define SAR1_PLL2_MASK			(0x1f << SAR1_PLL2_OFFSET)
+#define SAR1_PLL1_OFFSET		(14)
+#define SAR1_PLL1_MASK			(0x1f << SAR1_PLL1_OFFSET)
+#define SAR1_PLL0_OFFSET		(19)
+#define SAR1_PLL0_MASK			(0x1f << SAR1_PLL0_OFFSET)
+#define SAR1_PIDI_CONNECT_OFFSET	(24)
+#define SAR1_PIDI_CONNECT_MASK		(0x1 << SAR1_PIDI_CONNECT_OFFSET)
+
+struct sar_info {
+	char *name;
+	u32 offset;
+	u32 mask;
+};
+
+struct sar_info ap806_sar_0[] = {
+	{"Clock Freq mode		  ",
+		SAR_CLOCK_FREQ_MODE_OFFSET, SAR_CLOCK_FREQ_MODE_MASK },
+	{"Test mode enable		  ",
+		SAR_TEST_MODE_ENABLE_OFFSET, SAR_TEST_MODE_ENABLE_MASK },
+	{"Skip link i2c init		  ",
+		SAR_SKIP_LINK_I2C_INIT_OFFSET, SAR_SKIP_LINK_I2C_INIT_MASK },
+	{"Por ByPass			  ",
+		SAR_POR_BYPASS_OFFSET, SAR_POR_BYPASS_MASK },
+	{"Boot Source			  ",
+		SAR_BOOT_SOURCE_OFFSET, SAR_BOOT_SOURCE_MASK },
+	{"PIDI C2C IHB select		  ",
+		SAR_PIDI_C2C_IHB_SELECT_OFFSET, SAR_PIDI_C2C_IHB_SELECT_MASK },
+	{"I2C init enable		  ",
+		SAR_I2C_INIT_ENABLE_OFFSET, SAR_I2C_INIT_ENABLE_MASK },
+	{"SSCG disable			  ",
+		SAR_SSCG_DISABLE_OFFSET, SAR_SSCG_DISABLE_MASK },
+	{"PIDI hw training disable	  ",
+		SAR_PIDI_HW_TRAINING_DIS_OFFSET,
+		SAR_PIDI_HW_TRAINING_DIS_MASK },
+	{"CPU Fmax refclk select	  ",
+		SAR_CPU_FMAX_REFCLK_OFFSET, SAR_CPU_FMAX_REFCLK_MASK },
+	{"IHB differential refclk disable ",
+		SAR_IHB_DIFF_REFCLK_DIS_OFFSET, SAR_IHB_DIFF_REFCLK_DIS_MASK },
+	{"Ref clk mstr			  ",
+		SAR_REF_CLK_MSTR_OFFSET, SAR_REF_CLK_MSTR_MASK },
+	{"CPU wake up			  ",
+		SAR_CPU_WAKE_UP_OFFSET, SAR_CPU_WAKE_UP_MASK },
+	{"Xtal ByPass			  ",
+		SAR_XTAL_BYPASS_OFFSET, SAR_XTAL_BYPASS_MASK },
+	{"PIDI low speed		  ",
+		SAR_PIDI_LOW_SPEED_OFFSET, SAR_PIDI_LOW_SPEED_MASK },
+	{"",			-1,			-1},
+};
+
+struct sar_info ap806_sar_1[] = {
+	{"PIDI connect       ", SAR1_PIDI_CONNECT_OFFSET,
+				SAR1_PIDI_CONNECT_MASK },
+	{"PLL0 Config        ", SAR1_PLL0_OFFSET, SAR1_PLL0_MASK },
+	{"PLL1 Config        ", SAR1_PLL1_OFFSET, SAR1_PLL1_MASK },
+	{"PLL2 Config        ", SAR1_PLL2_OFFSET, SAR1_PLL2_MASK },
+	{"",			-1,			-1},
+};
+
+enum clocking_options {
+	CPU_2000_DDR_1200_RCLK_1200 = 0x0,
+	CPU_2000_DDR_1050_RCLK_1050 = 0x1,
+	CPU_1600_DDR_800_RCLK_800 = 0x4,
+	CPU_1800_DDR_1200_RCLK_1200 = 0x6,
+	CPU_1800_DDR_1050_RCLK_1050 = 0x7,
+	CPU_1600_DDR_1050_RCLK_1050 = 0x0d,
+	CPU_1000_DDR_650_RCLK_650 = 0x13,
+	CPU_1300_DDR_800_RCLK_800 = 0x14,
+	CPU_1300_DDR_650_RCLK_650 = 0x17,
+	CPU_1200_DDR_800_RCLK_800 = 0x19,
+	CPU_1400_DDR_800_RCLK_800 = 0x1a,
+	CPU_600_DDR_800_RCLK_800 = 0x1b,
+	CPU_800_DDR_800_RCLK_800 = 0x1c,
+	CPU_1000_DDR_800_RCLK_800 = 0x1d,
+};
+
+static const u32 pll_freq_tbl[16][4] = {
+	/* CPU */   /* DDR */   /* Ring */
+	{2.0 * GHz, 1.2  * GHz, 1.2  * GHz, CPU_2000_DDR_1200_RCLK_1200},
+	{2.0 * GHz, 1.05 * GHz, 1.05 * GHz, CPU_2000_DDR_1050_RCLK_1050},
+	{1.8 * GHz, 1.2  * GHz, 1.2  * GHz, CPU_1800_DDR_1200_RCLK_1200},
+	{1.8 * GHz, 1.05 * GHz, 1.05 * GHz, CPU_1800_DDR_1050_RCLK_1050},
+	{1.6 * GHz, 1.05 * GHz, 1.05 * GHz, CPU_1600_DDR_1050_RCLK_1050},
+	{1.3 * GHz, 800  * MHz, 800  * MHz, CPU_1300_DDR_800_RCLK_800},
+	{1.3 * GHz, 650  * MHz, 650  * MHz, CPU_1300_DDR_650_RCLK_650},
+	{1.6 * GHz, 800  * MHz, 800  * MHz, CPU_1600_DDR_800_RCLK_800},
+	{1.0 * GHz, 650  * MHz, 650  * MHz, CPU_1000_DDR_650_RCLK_650},
+	{1.2 * GHz, 800  * MHz, 800  * MHz, CPU_1200_DDR_800_RCLK_800},
+	{1.4 * GHz, 800  * MHz, 800  * MHz, CPU_1400_DDR_800_RCLK_800},
+	{600 * MHz, 800  * MHz, 800  * MHz, CPU_600_DDR_800_RCLK_800},
+	{800 * MHz, 800  * MHz, 800  * MHz, CPU_800_DDR_800_RCLK_800},
+	{1.0 * GHz, 800  * MHz, 800  * MHz, CPU_1000_DDR_800_RCLK_800}
+};
+
+static u32 sar_get_clock_freq_mode(struct udevice *dev)
+{
+	u32 i;
+	struct dm_sar_pdata *priv = dev_get_priv(dev);
+
+	u32 clock_freq = (readl(priv->sar_base) & SAR_CLOCK_FREQ_MODE_MASK) >>
+			  SAR_CLOCK_FREQ_MODE_OFFSET;
+	for (i = 0; i < 16; i++) {
+		if (pll_freq_tbl[i][3] == clock_freq)
+			return i;
+	}
+	pr_err("sar regs: Unsupported clock freq mode %d", clock_freq);
+	return -1;
+}
+
+int ap806_sar_value_get(struct udevice *dev, enum mvebu_sar_opts sar_opt,
+			struct sar_val *val)
+{
+	u32 clock_type, clock_freq_mode;
+
+	switch (sar_opt) {
+	case(SAR_CPU_FREQ):
+		clock_type = CPU_CLOCK_ID;
+		break;
+	case(SAR_DDR_FREQ):
+		clock_type = DDR_CLOCK_ID;
+		break;
+	case(SAR_AP_FABRIC_FREQ):
+		clock_type = RING_CLOCK_ID;
+		break;
+	default:
+		pr_err("AP806-SAR: Unsupported SAR option %d.\n", sar_opt);
+		return -EINVAL;
+	}
+	clock_freq_mode = sar_get_clock_freq_mode(dev);
+	val->raw_sar_val = clock_freq_mode;
+	val->freq = pll_freq_tbl[clock_freq_mode][clock_type];
+	return 0;
+}
+
+static int ap806_sar_dump(struct udevice *dev)
+{
+	u32 reg, val;
+	struct sar_info *sar;
+	struct dm_sar_pdata *priv = dev_get_priv(dev);
+
+	reg = readl(priv->sar_base);
+	printf("AP806 SAR register 0 [0x%08x]:\n", reg);
+	printf("----------------------------------\n");
+	sar = ap806_sar_0;
+	while (sar->offset != -1) {
+		val = (reg & sar->mask) >> sar->offset;
+		printf("%s  0x%x\n", sar->name, val);
+		sar++;
+	}
+
+	reg = readl(priv->sar_base + AP806_SAR_1_REG);
+	printf("\nAP806 SAR register 1 [0x%08x]:\n", reg);
+	printf("----------------------------------\n");
+	sar = ap806_sar_1;
+	while (sar->offset != -1) {
+		val = (reg & sar->mask) >> sar->offset;
+		printf("%s  0x%x\n", sar->name, val);
+		sar++;
+	}
+	return 0;
+}
+
+int ap806_sar_init(struct udevice *dev)
+{
+	int ret, i;
+
+	u32 sar_list[] = {
+		SAR_CPU_FREQ,
+		SAR_DDR_FREQ,
+		SAR_AP_FABRIC_FREQ
+	};
+
+	for (i = 0; i < ARRAY_SIZE(sar_list); i++) {
+		ret = mvebu_sar_id_register(dev, sar_list[i]);
+		if (ret) {
+			pr_err("Failed to register SAR %d, for AP806.\n",
+			       sar_list[i]);
+			return ret;
+		}
+	}
+	return 0;
+}
+
+static const struct sar_ops ap806_sar_ops = {
+	.sar_init_func = ap806_sar_init,
+	.sar_value_get_func = ap806_sar_value_get,
+	.sar_dump_func = ap806_sar_dump,
+};
+
+U_BOOT_DRIVER(ap806_sar) = {
+	.name = "ap806_sar",
+	.id = UCLASS_SAR,
+	.priv_auto_alloc_size = sizeof(struct dm_sar_pdata),
+	.ops = &ap806_sar_ops,
+};
diff --git a/drivers/misc/mvebu_sar/ap807_sar.c b/drivers/misc/mvebu_sar/ap807_sar.c
new file mode 100644
index 0000000..4387bef
--- /dev/null
+++ b/drivers/misc/mvebu_sar/ap807_sar.c
@@ -0,0 +1,230 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+/* #define DEBUG */
+#include <common.h>
+#include <asm/io.h>
+#include <errno.h>
+#include <mvebu/mvebu_chip_sar.h>
+#include <mach/clock.h>
+
+#include <sar-uclass.h>
+
+#define CPU_CLOCK_ID	0
+#define DDR_CLOCK_ID	1
+#define RING_CLOCK_ID	2
+
+/* SAR AP807 registers */
+#define SAR_CLOCK_FREQ_MODE_OFFSET	0
+#define SAR_CLOCK_FREQ_MODE_MASK	(0x1f << SAR_CLOCK_FREQ_MODE_OFFSET)
+#define SAR_TEST_MODE_ENABLE_OFFSET	5
+#define SAR_TEST_MODE_ENABLE_MASK	(0x1 << SAR_TEST_MODE_ENABLE_OFFSET)
+#define SAR_SKIP_LINK_I2C_INIT_OFFSET	6
+#define SAR_SKIP_LINK_I2C_INIT_MASK	(0x1 << SAR_SKIP_LINK_I2C_INIT_OFFSET)
+#define SAR_POR_BYPASS_OFFSET		7
+#define SAR_POR_BYPASS_MASK		(0x1 << SAR_POR_BYPASS_OFFSET)
+#define SAR_BOOT_SOURCE_OFFSET		8
+#define SAR_BOOT_SOURCE_MASK		(0x7 << SAR_BOOT_SOURCE_OFFSET)
+#define SAR_PIDI_C2C_IHB_SELECT_OFFSET	11
+#define SAR_PIDI_C2C_IHB_SELECT_MASK	(0x1 << SAR_PIDI_C2C_IHB_SELECT_OFFSET)
+#define SAR_I2C_INIT_ENABLE_OFFSET	12
+#define SAR_I2C_INIT_ENABLE_MASK	(0x1 << SAR_I2C_INIT_ENABLE_OFFSET)
+#define SAR_PIDI_HW_TRAINING_DIS_OFFSET	13
+#define SAR_PIDI_HW_TRAINING_DIS_MASK	(0x1 << SAR_PIDI_HW_TRAINING_DIS_OFFSET)
+#define SAR_CPU_FMAX_REFCLK_OFFSET	14
+#define SAR_CPU_FMAX_REFCLK_MASK	(0x1 << SAR_CPU_FMAX_REFCLK_OFFSET)
+#define SAR_IHB_DIFF_REFCLK_DIS_OFFSET	15
+#define SAR_IHB_DIFF_REFCLK_DIS_MASK	(0x1 << SAR_IHB_DIFF_REFCLK_DIS_OFFSET)
+#define SAR_REF_CLK_MSTR_OFFSET		16
+#define SAR_REF_CLK_MSTR_MASK		(0x1 << SAR_REF_CLK_MSTR_OFFSET)
+#define SAR_CPU_WAKE_UP_OFFSET		17
+#define SAR_CPU_WAKE_UP_MASK		(0x1 << SAR_CPU_WAKE_UP_OFFSET)
+#define SAR_XTAL_BYPASS_OFFSET		18
+#define SAR_XTAL_BYPASS_MASK		(0x1 << SAR_XTAL_BYPASS_OFFSET)
+#define SAR_PIDI_LOW_SPEED_OFFSET	19
+#define SAR_PIDI_LOW_SPEED_MASK		(0x1 << SAR_PIDI_LOW_SPEED_OFFSET)
+
+#define AP807_SAR_1_REG			4
+#define SAR1_PLL2_OFFSET		(9)
+#define SAR1_PLL2_MASK			(0x1f << SAR1_PLL2_OFFSET)
+#define SAR1_PLL1_OFFSET		(14)
+#define SAR1_PLL1_MASK			(0x1f << SAR1_PLL1_OFFSET)
+#define SAR1_PLL0_OFFSET		(19)
+#define SAR1_PLL0_MASK			(0x1f << SAR1_PLL0_OFFSET)
+#define SAR1_PIDI_CONNECT_OFFSET	(24)
+#define SAR1_PIDI_CONNECT_MASK		(0x1 << SAR1_PIDI_CONNECT_OFFSET)
+
+struct sar_info {
+	char *name;
+	u32 offset;
+	u32 mask;
+};
+
+struct sar_info ap807_sar_0[] = {
+	{"Clock Freq mode		  ",
+		SAR_CLOCK_FREQ_MODE_OFFSET, SAR_CLOCK_FREQ_MODE_MASK },
+	{"Test mode enable		  ",
+		SAR_TEST_MODE_ENABLE_OFFSET, SAR_TEST_MODE_ENABLE_MASK },
+	{"Skip link i2c init		  ",
+		SAR_SKIP_LINK_I2C_INIT_OFFSET, SAR_SKIP_LINK_I2C_INIT_MASK },
+	{"Por ByPass			  ",
+		SAR_POR_BYPASS_OFFSET, SAR_POR_BYPASS_MASK },
+	{"Boot Source			  ",
+		SAR_BOOT_SOURCE_OFFSET, SAR_BOOT_SOURCE_MASK },
+	{"PIDI C2C IHB select		  ",
+		SAR_PIDI_C2C_IHB_SELECT_OFFSET, SAR_PIDI_C2C_IHB_SELECT_MASK },
+	{"I2C init enable		  ",
+		SAR_I2C_INIT_ENABLE_OFFSET, SAR_I2C_INIT_ENABLE_MASK },
+	{"PIDI hw training disable	  ",
+		SAR_PIDI_HW_TRAINING_DIS_OFFSET,
+		SAR_PIDI_HW_TRAINING_DIS_MASK },
+	{"CPU Fmax refclk select	  ",
+		SAR_CPU_FMAX_REFCLK_OFFSET, SAR_CPU_FMAX_REFCLK_MASK },
+	{"IHB differential refclk disable ",
+		SAR_IHB_DIFF_REFCLK_DIS_OFFSET, SAR_IHB_DIFF_REFCLK_DIS_MASK },
+	{"Ref clk mstr			  ",
+		SAR_REF_CLK_MSTR_OFFSET, SAR_REF_CLK_MSTR_MASK },
+	{"CPU wake up			  ",
+		SAR_CPU_WAKE_UP_OFFSET, SAR_CPU_WAKE_UP_MASK },
+	{"Xtal ByPass			  ",
+		SAR_XTAL_BYPASS_OFFSET, SAR_XTAL_BYPASS_MASK },
+	{"PIDI low speed		  ",
+		SAR_PIDI_LOW_SPEED_OFFSET, SAR_PIDI_LOW_SPEED_MASK },
+	{"",			-1,			-1},
+};
+
+struct sar_info ap807_sar_1[] = {
+	{"PIDI connect       ", SAR1_PIDI_CONNECT_OFFSET,
+				SAR1_PIDI_CONNECT_MASK },
+	{"PLL0 Config        ", SAR1_PLL0_OFFSET, SAR1_PLL0_MASK },
+	{"PLL1 Config        ", SAR1_PLL1_OFFSET, SAR1_PLL1_MASK },
+	{"PLL2 Config        ", SAR1_PLL2_OFFSET, SAR1_PLL2_MASK },
+	{"",			-1,			-1},
+};
+
+enum clocking_options {
+	CPU_2000_DDR_1200_RCLK_1200 = 0x0,
+	CPU_2000_DDR_1050_RCLK_1050 = 0x1,
+	CPU_2200_DDR_1200_RCLK_1200 = 0x6,
+	CPU_1800_DDR_1050_RCLK_1200 = 0x7,
+	CPU_1600_DDR_1200_RCLK_1200 = 0x0d,
+	CPU_1600_DDR_900_RCLK_900 = 0x0e,
+	CPU_1300_DDR_800_RCLK_800 = 0x14,
+};
+
+static const u32 pll_freq_tbl[16][4] = {
+	/* CPU */   /* DDR */   /* Ring */
+	{2.0 * GHz, 1.2  * GHz, 1.2  * GHz, CPU_2000_DDR_1200_RCLK_1200},
+	{2.0 * GHz, 1.05 * GHz, 1.05 * GHz, CPU_2000_DDR_1050_RCLK_1050},
+	{2.2 * GHz, 1.2  * GHz, 1.2  * GHz, CPU_2200_DDR_1200_RCLK_1200},
+	{1.8 * GHz, 1.05 * GHz, 1.2 * GHz, CPU_1800_DDR_1050_RCLK_1200},
+	{1.6 * GHz, 1.2 * GHz, 1.2 * GHz, CPU_1600_DDR_1200_RCLK_1200},
+	{1.6 * GHz, 0.9  * GHz, 0.9  * GHz, CPU_1600_DDR_900_RCLK_900},
+	{1.3 * GHz, 0.8  * GHz, 0.8  * GHz, CPU_1300_DDR_800_RCLK_800},
+};
+
+static u32 sar_get_clock_freq_mode(struct udevice *dev)
+{
+	u32 i;
+	struct dm_sar_pdata *priv = dev_get_priv(dev);
+
+	u32 clock_freq = (readl(priv->sar_base) & SAR_CLOCK_FREQ_MODE_MASK) >>
+			  SAR_CLOCK_FREQ_MODE_OFFSET;
+	for (i = 0; i < 7; i++) {
+		if (pll_freq_tbl[i][3] == clock_freq)
+			return i;
+	}
+	pr_err("sar regs: unsupported clock freq mode %d", clock_freq);
+	return -1;
+}
+
+int ap807_sar_value_get(struct udevice *dev, enum mvebu_sar_opts sar_opt,
+			struct sar_val *val)
+{
+	u32 clock_type, clock_freq_mode;
+
+	switch (sar_opt) {
+	case(SAR_CPU_FREQ):
+		clock_type = CPU_CLOCK_ID;
+		break;
+	case(SAR_DDR_FREQ):
+		clock_type = DDR_CLOCK_ID;
+		break;
+	case(SAR_AP_FABRIC_FREQ):
+		clock_type = RING_CLOCK_ID;
+		break;
+	default:
+		pr_err("AP807-SAR: Unsupported SAR option %d.\n", sar_opt);
+		return -EINVAL;
+	}
+	clock_freq_mode = sar_get_clock_freq_mode(dev);
+	val->raw_sar_val = clock_freq_mode;
+	val->freq = pll_freq_tbl[clock_freq_mode][clock_type];
+	return 0;
+}
+
+static int ap807_sar_dump(struct udevice *dev)
+{
+	u32 reg, val;
+	struct sar_info *sar;
+	struct dm_sar_pdata *priv = dev_get_priv(dev);
+
+	reg = readl(priv->sar_base);
+	printf("AP807 SAR register 0 [0x%08x]:\n", reg);
+	printf("----------------------------------\n");
+	sar = ap807_sar_0;
+	while (sar->offset != -1) {
+		val = (reg & sar->mask) >> sar->offset;
+		printf("%s  0x%x\n", sar->name, val);
+		sar++;
+	}
+
+	reg = readl(priv->sar_base + AP807_SAR_1_REG);
+	printf("\nAP807 SAR register 1 [0x%08x]:\n", reg);
+	printf("----------------------------------\n");
+	sar = ap807_sar_1;
+	while (sar->offset != -1) {
+		val = (reg & sar->mask) >> sar->offset;
+		printf("%s  0x%x\n", sar->name, val);
+		sar++;
+	}
+	return 0;
+}
+
+int ap807_sar_init(struct udevice *dev)
+{
+	int ret, i;
+
+	u32 sar_list[] = {
+		SAR_CPU_FREQ,
+		SAR_DDR_FREQ,
+		SAR_AP_FABRIC_FREQ
+	};
+
+	for (i = 0; i < ARRAY_SIZE(sar_list); i++) {
+		ret = mvebu_sar_id_register(dev, sar_list[i]);
+		if (ret) {
+			pr_err("Failed to register SAR %d, for AP807.\n",
+			       sar_list[i]);
+			return ret;
+		}
+	}
+	return 0;
+}
+
+static const struct sar_ops ap807_sar_ops = {
+	.sar_init_func = ap807_sar_init,
+	.sar_value_get_func = ap807_sar_value_get,
+	.sar_dump_func = ap807_sar_dump,
+};
+
+U_BOOT_DRIVER(ap807_sar) = {
+	.name = "ap807_sar",
+	.id = UCLASS_SAR,
+	.priv_auto_alloc_size = sizeof(struct dm_sar_pdata),
+	.ops = &ap807_sar_ops,
+};
diff --git a/drivers/misc/mvebu_sar/cp110_sar.c b/drivers/misc/mvebu_sar/cp110_sar.c
new file mode 100644
index 0000000..d319c7d
--- /dev/null
+++ b/drivers/misc/mvebu_sar/cp110_sar.c
@@ -0,0 +1,236 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+/* #define DEBUG */
+#include <common.h>
+#include <asm/io.h>
+#include <errno.h>
+#include <fdtdec.h>
+#include <mvebu/mvebu_chip_sar.h>
+
+#include <sar-uclass.h>
+
+/* SAR CP1 registers */
+#define SAR1_RST_PCIE0_CLOCK_CONFIG_CP1_OFFSET	(0)
+#define SAR1_RST_PCIE0_CLOCK_CONFIG_CP1_MASK	\
+	(0x1 << SAR1_RST_PCIE0_CLOCK_CONFIG_CP1_OFFSET)
+#define SAR1_RST_PCIE1_CLOCK_CONFIG_CP1_OFFSET	(1)
+#define SAR1_RST_PCIE1_CLOCK_CONFIG_CP1_MASK	\
+	(0x1 << SAR1_RST_PCIE1_CLOCK_CONFIG_CP1_OFFSET)
+
+/* SAR CP0 registers */
+#define SAR1_RST_PCIE0_CLOCK_CONFIG_CP0_OFFSET	(2)
+#define SAR1_RST_PCIE0_CLOCK_CONFIG_CP0_MASK	\
+	(0x1 << SAR1_RST_PCIE0_CLOCK_CONFIG_CP0_OFFSET)
+#define SAR1_RST_PCIE1_CLOCK_CONFIG_CP0_OFFSET	(3)
+#define SAR1_RST_PCIE1_CLOCK_CONFIG_CP0_MASK	\
+	(0x1 << SAR1_RST_PCIE1_CLOCK_CONFIG_CP0_OFFSET)
+
+#define SAR1_RST_BOOT_MODE_AP_CP0_OFFSET	(4)
+#define SAR1_RST_BOOT_MODE_AP_CP0_MASK		\
+	(0x3f << SAR1_RST_BOOT_MODE_AP_CP0_OFFSET)
+
+struct sar_info {
+	char *name;
+	u32 offset;
+	u32 mask;
+};
+
+struct sar_info cp110_sar_1[] = {
+	{"PCIE0 clock config   ", SAR1_RST_PCIE0_CLOCK_CONFIG_CP1_OFFSET,
+				  SAR1_RST_PCIE0_CLOCK_CONFIG_CP1_MASK},
+	{"PCIE1 clock config   ", SAR1_RST_PCIE1_CLOCK_CONFIG_CP1_OFFSET,
+				  SAR1_RST_PCIE1_CLOCK_CONFIG_CP1_MASK},
+	{"",			-1,			-1},
+};
+
+struct sar_info cp110_sar_0[] = {
+	{"PCIE0 clock config   ", SAR1_RST_PCIE0_CLOCK_CONFIG_CP0_OFFSET,
+				  SAR1_RST_PCIE0_CLOCK_CONFIG_CP0_MASK},
+	{"PCIE1 clock config   ", SAR1_RST_PCIE1_CLOCK_CONFIG_CP0_OFFSET,
+				  SAR1_RST_PCIE1_CLOCK_CONFIG_CP0_MASK},
+	{"Reset Boot Mode     ", SAR1_RST_BOOT_MODE_AP_CP0_OFFSET,
+				 SAR1_RST_BOOT_MODE_AP_CP0_MASK },
+	{"",			-1,			-1},
+};
+
+struct bootsrc_idx_info {
+	int start;
+	int end;
+	enum mvebu_bootsrc_type src;
+	int index;
+};
+
+static struct bootsrc_idx_info bootsrc_list[] = {
+	{0x0,	0x5,	BOOTSRC_NOR,		0},
+	{0xA,	0x25,	BOOTSRC_NAND,		0},
+	{0x28,	0x28,	BOOTSRC_AP_SD_EMMC,	0},
+	{0x29,	0x29,	BOOTSRC_SD_EMMC,	0},
+	{0x2A,	0x2A,	BOOTSRC_AP_SD_EMMC,	0},
+	{0x2B,	0x2B,	BOOTSRC_SD_EMMC,	0},
+	{0x30,	0x30,	BOOTSRC_AP_SPI,		0},
+	{0x31,	0x31,	BOOTSRC_AP_SPI,		0}, /* BootRom disabled */
+	{0x32,	0x33,	BOOTSRC_SPI,		1},
+	{0x34,	0x35,	BOOTSRC_SPI,		0},
+	{0x36,	0x37,	BOOTSRC_SPI,		1}, /* BootRom disabled */
+	{-1,	-1,	-1}
+};
+
+int cp110_sar_bootsrc_get(struct udevice *dev, enum mvebu_sar_opts sar_opt,
+			  struct sar_val *val)
+{
+	u32 reg, mode;
+	int i;
+
+	struct dm_sar_pdata *priv = dev_get_priv(dev);
+
+	reg = readl(priv->sar_base);
+	mode = (reg & SAR1_RST_BOOT_MODE_AP_CP0_MASK) >>
+		SAR1_RST_BOOT_MODE_AP_CP0_OFFSET;
+
+	val->raw_sar_val = mode;
+
+	i = 0;
+	while (bootsrc_list[i].start != -1) {
+		if ((mode >= bootsrc_list[i].start) &&
+		    (mode <= bootsrc_list[i].end)) {
+			val->bootsrc.type = bootsrc_list[i].src;
+			val->bootsrc.index = bootsrc_list[i].index;
+			break;
+		}
+		i++;
+	}
+
+	if (bootsrc_list[i].start == -1) {
+		pr_err("Bad CP110 sample at reset mode (%d).\n", mode);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+int cp110_sar_value_get(struct udevice *dev, enum mvebu_sar_opts sar_opt,
+			struct sar_val *val)
+{
+	u32 reg, mode;
+	struct dm_sar_pdata *priv = dev_get_priv(dev);
+
+	reg = readl(priv->sar_base);
+
+	switch (sar_opt) {
+	case SAR_BOOT_SRC:
+		return cp110_sar_bootsrc_get(dev, sar_opt, val);
+	case SAR_CP0_PCIE0_CLK:
+		mode = (reg & SAR1_RST_PCIE0_CLOCK_CONFIG_CP0_MASK) >>
+			SAR1_RST_PCIE0_CLOCK_CONFIG_CP0_OFFSET;
+		val->raw_sar_val = mode;
+		val->clk_direction = mode;
+		break;
+	case SAR_CP0_PCIE1_CLK:
+		mode = (reg & SAR1_RST_PCIE1_CLOCK_CONFIG_CP0_MASK) >>
+			SAR1_RST_PCIE1_CLOCK_CONFIG_CP0_OFFSET;
+		val->raw_sar_val = mode;
+		val->clk_direction = mode;
+		break;
+	case SAR_CP1_PCIE0_CLK:
+		mode = (reg & SAR1_RST_PCIE0_CLOCK_CONFIG_CP1_MASK) >>
+			SAR1_RST_PCIE0_CLOCK_CONFIG_CP1_OFFSET;
+		val->raw_sar_val = mode;
+		val->clk_direction = mode;
+		break;
+	case SAR_CP1_PCIE1_CLK:
+		mode = (reg & SAR1_RST_PCIE1_CLOCK_CONFIG_CP1_MASK) >>
+			SAR1_RST_PCIE1_CLOCK_CONFIG_CP1_OFFSET;
+		val->raw_sar_val = mode;
+		val->clk_direction = mode;
+		break;
+	default:
+		pr_err("AP806-SAR: Unsupported SAR option %d.\n", sar_opt);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int cp110_sar_dump(struct udevice *dev)
+{
+	u32 reg, val;
+	struct sar_info *sar;
+	struct dm_sar_pdata *priv = dev_get_priv(dev);
+
+	reg = readl(priv->sar_base);
+	printf("\nCP110 SAR register 0 [0x%08x]:\n", reg);
+	printf("----------------------------------\n");
+
+	if (!strcmp(priv->sar_name, "cp0-sar"))
+		sar = cp110_sar_0;
+	else
+		sar = cp110_sar_1;
+
+	while (sar->offset != -1) {
+		val = (reg & sar->mask) >> sar->offset;
+		printf("%s  0x%x\n", sar->name, val);
+		sar++;
+	}
+	return 0;
+}
+
+static int cp110_sar_register(struct udevice *dev, u32 sar_list[], int size)
+{
+	int ret, i;
+
+	for (i = 0; i < size; i++) {
+		ret = mvebu_sar_id_register(dev, sar_list[i]);
+		if (ret) {
+			pr_err("Failed to register SAR %d, for %s.\n",
+			       sar_list[i], dev->name);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+int cp110_sar_init(struct udevice *dev)
+{
+	int ret = 0;
+	struct dm_sar_pdata *priv = dev_get_priv(dev);
+
+	u32 cp0_sar_list[] = {
+		SAR_CP0_PCIE0_CLK,
+		SAR_CP0_PCIE1_CLK,
+		SAR_BOOT_SRC
+	};
+
+	u32 cp1_sar_list[] = {
+		SAR_CP1_PCIE0_CLK,
+		SAR_CP1_PCIE1_CLK,
+	};
+
+	if (!strcmp(priv->sar_name, "cp0-sar"))
+		ret = cp110_sar_register(dev, cp0_sar_list,
+					 ARRAY_SIZE(cp0_sar_list));
+	else if (!strcmp(priv->sar_name, "cp1-sar"))
+		ret = cp110_sar_register(dev, cp1_sar_list,
+					 ARRAY_SIZE(cp1_sar_list));
+
+	if (ret)
+		return -EINVAL;
+
+	return 0;
+}
+
+static const struct sar_ops cp110_sar_ops = {
+	.sar_init_func = cp110_sar_init,
+	.sar_value_get_func = cp110_sar_value_get,
+	.sar_dump_func = cp110_sar_dump,
+};
+
+U_BOOT_DRIVER(cp110_sar) = {
+	.name = "cp110_sar",
+	.id = UCLASS_SAR,
+	.priv_auto_alloc_size = sizeof(struct dm_sar_pdata),
+	.ops = &cp110_sar_ops,
+};
diff --git a/drivers/misc/mvebu_sar/sar-uclass.c b/drivers/misc/mvebu_sar/sar-uclass.c
new file mode 100644
index 0000000..74cfe9f
--- /dev/null
+++ b/drivers/misc/mvebu_sar/sar-uclass.c
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+/* #define DEBUG */
+#include <common.h>
+#include <asm/io.h>
+#include <errno.h>
+#include <sar-uclass.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define SAR_MAX_CHIP	4
+
+UCLASS_DRIVER(sar) = {
+	.name = "sar",
+	.id = UCLASS_SAR,
+};
+
+struct udevice *__attribute__((section(".data")))soc_sar_info[SAR_MAX_IDX];
+
+int mvebu_sar_id_register(struct udevice *dev, u32 sar_id)
+{
+	if (soc_sar_info[sar_id]) {
+		pr_err("sar %d was already registered.\n", sar_id);
+		return -EBUSY;
+	}
+	soc_sar_info[sar_id] = dev;
+
+	return 0;
+}
+
+/* find all drivers for sar device and initialize each driver */
+int mvebu_sar_init(void)
+{
+	int ret, i;
+	int node, chip_count, sar_list[SAR_MAX_CHIP];
+	const void *blob = gd->fdt_blob;
+	struct udevice *sar_chip[SAR_MAX_CHIP];
+	struct dm_sar_pdata *priv;
+	const struct sar_ops *ops;
+	struct udevice *parent;
+	struct driver_info sar_drivers[SAR_MAX_CHIP];
+	void *sar_base = NULL;
+	const char *sar_driver, *sar_name;
+
+	chip_count = fdtdec_find_aliases_for_id(blob, "sar-reg",
+						COMPAT_MVEBU_SAR_REG_COMMON,
+						sar_list, SAR_MAX_CHIP);
+
+	if (chip_count <= 0) {
+		pr_err("Cannot find sample-at-reset dt entry (%d).\n",
+		       chip_count);
+		return -ENODEV;
+	}
+	uclass_get_device_by_name(UCLASS_ROOT, "root_driver", &parent);
+	memset(soc_sar_info, 0, sizeof(soc_sar_info));
+
+	for (i = 0; i < chip_count ; i++) {
+		node = sar_list[i];
+		if (node <= 0)
+			continue;
+
+		/* Skip if Node is disabled */
+		if (!fdtdec_get_is_enabled(blob, node))
+			continue;
+		/* Binding stage */
+		sar_driver = fdt_getprop(blob, node, "sar-driver", NULL);
+		sar_drivers[i].name = sar_driver;
+		ret = device_bind_by_name(parent, false,
+					  &sar_drivers[i], &sar_chip[i]);
+
+		if (!sar_chip[i]) {
+			pr_err("SAR driver binding failed\n");
+			return 0;
+		}
+
+		/* fetch driver info from device-tree */
+		sar_base = (void *)fdtdec_get_addr_size_auto_noparent(blob,
+				node, "reg", 0, NULL, true);
+		if (!sar_base) {
+			pr_err("SAR address isn't found in the device-tree\n");
+			return 0;
+		}
+		sar_name = fdt_getprop(blob, node, "sar-name", NULL);
+		/* Initialize driver priv struct */
+		device_probe(sar_chip[i]);
+		priv = dev_get_priv(sar_chip[i]);
+		priv->sar_base = sar_base;
+		priv->sar_name = sar_name;
+		ops = device_get_ops(sar_chip[i]);
+		if (!ops->sar_init_func)
+			return -EINVAL;
+
+		ret = ops->sar_init_func(sar_chip[i]);
+		if (ret) {
+			pr_err("sar_init failed (%d).\n", ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+int mvebu_sar_value_get(enum mvebu_sar_opts opt, struct sar_val *val)
+{
+	const struct sar_ops *ops;
+
+	if (soc_sar_info[opt]) {
+		ops = device_get_ops(soc_sar_info[opt]);
+		return ops->sar_value_get_func(soc_sar_info[opt], opt, val);
+	}
+
+	pr_err("SAR - No chip registered on sar %d.\n", opt);
+	return -ENODEV;
+}
+
+char *mvebu_sar_bootsrc_to_name(enum mvebu_bootsrc_type src)
+{
+	switch (src) {
+	case(BOOTSRC_NAND):
+		return "nand";
+	case(BOOTSRC_SPI):
+	case(BOOTSRC_AP_SPI):
+		return "spi";
+	case(BOOTSRC_SD_EMMC):
+	case(BOOTSRC_AP_SD_EMMC):
+		return "mmc";
+	case(BOOTSRC_NOR):
+		return "nor";
+	default:
+		return "unknown";
+	}
+}
+
+void mvebu_sar_dump(struct udevice *dev)
+{
+	const struct sar_ops *ops;
+
+	ops = device_get_ops(dev);
+
+	ops->sar_dump_func(dev);
+}
diff --git a/drivers/mmc/Kconfig b/drivers/mmc/Kconfig
index 5f67e33..41fc4ad 100644
--- a/drivers/mmc/Kconfig
+++ b/drivers/mmc/Kconfig
@@ -13,16 +13,10 @@ config MMC
 
 config MMC_WRITE
 	bool "support for MMC/SD write operations"
-	depends on MMC
 	default y
 	help
 	  Enable write access to MMC and SD Cards
 
-config MMC_BROKEN_CD
-	bool "Poll for broken card detection case"
-	help
-	  If card  detection feature is broken, just poll to detect.
-
 config DM_MMC
 	bool "Enable MMC controllers using Driver Model"
 	depends on DM
@@ -44,6 +38,30 @@ config SPL_DM_MMC
 	  appear as block devices in U-Boot and can support filesystems such
 	  as EXT4 and FAT.
 
+config MMC_OCTEONTX
+	bool "Marvell OcteonTX Multimedia Card Interface support"
+	depends on (ARCH_OCTEONTX || ARCH_OCTEONTX2)
+	depends on DM_MMC
+	help
+	  This selects the OcteonTX Multimedia card Interface.
+	  If you have an OcteonTX board with a Multimedia Card slot,
+	  say Y here.  If unsure, say N.
+
+config MMC_SUPPORTS_TUNING
+	depends on MMC_OCTEONTX
+	bool "Support for HW partitioning command(eMMC)"
+	default	y
+	help
+	  This adds support for tuning in OcteonTX MMC driver.
+
+
+config MMC_HW_PARTITIONING
+	bool "Support for HW partitioning command(eMMC)"
+	default y
+	help
+	  This adds a command and an API to do hardware partitioning on eMMC
+	  devices.
+
 if MMC
 
 config ARM_PL180_MMCI
@@ -104,6 +122,19 @@ config SPL_MMC_UHS_SUPPORT
 	  cards. The IO voltage must be switchable from 3.3v to 1.8v. The bus
 	  frequency can go up to 208MHz (SDR104)
 
+config MMC_HS400_SUPPORT
+	bool "enable HS400 support"
+	select MMC_HS200_SUPPORT
+	help
+	  The HS400 mode is support by some eMMC. The bus frequency is up to
+	  200MHz. This mode requires tuning the IO.
+
+config SPL_MMC_HS400_SUPPORT
+	bool "enable HS400 support in SPL"
+	help
+	  The HS400 mode is support by some eMMC. The bus frequency is up to
+	  200MHz. This mode requires tuning the IO.
+
 config MMC_HS200_SUPPORT
 	bool "enable HS200 support"
 	help
diff --git a/drivers/mmc/Makefile b/drivers/mmc/Makefile
index 42113e2..eb1792c 100644
--- a/drivers/mmc/Makefile
+++ b/drivers/mmc/Makefile
@@ -5,9 +5,9 @@
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
-obj-y += mmc.o
 obj-$(CONFIG_$(SPL_)DM_MMC) += mmc-uclass.o
 obj-$(CONFIG_$(SPL_)MMC_WRITE) += mmc_write.o
+obj-$(CONFIG_MMC) += mmc.o
 
 ifndef CONFIG_$(SPL_)BLK
 obj-y += mmc_legacy.o
@@ -35,6 +35,7 @@ obj-$(CONFIG_MVEBU_MMC) += mvebu_mmc.o
 obj-$(CONFIG_MMC_OMAP_HS)		+= omap_hsmmc.o
 obj-$(CONFIG_MMC_MXC)			+= mxcmmc.o
 obj-$(CONFIG_MMC_MXS)			+= mxsmmc.o
+obj-$(CONFIG_MMC_OCTEONTX)		+= octeontx_hsmmc.o
 obj-$(CONFIG_MMC_PCI)			+= pci_mmc.o
 obj-$(CONFIG_PXA_MMC_GENERIC) += pxa_mmc_gen.o
 obj-$(CONFIG_SUPPORT_EMMC_RPMB) += rpmb.o
diff --git a/drivers/mmc/fsl_esdhc.c b/drivers/mmc/fsl_esdhc.c
index 6018f84..f5424c7 100644
--- a/drivers/mmc/fsl_esdhc.c
+++ b/drivers/mmc/fsl_esdhc.c
@@ -983,7 +983,7 @@ static int esdhc_init_common(struct fsl_esdhc_priv *priv, struct mmc *mmc)
 #endif
 
 	/* Set the initial clock speed */
-	mmc_set_clock(mmc, 400000, false);
+	mmc_set_clock(mmc, 400000, MMC_CLK_ENABLE);
 
 	/* Disable the BRR and BWR bits in IRQSTAT */
 	esdhc_clrbits32(&regs->irqstaten, IRQSTATEN_BRR | IRQSTATEN_BWR);
diff --git a/drivers/mmc/meson_gx_mmc.c b/drivers/mmc/meson_gx_mmc.c
index a2cd5d3..3cd9346 100644
--- a/drivers/mmc/meson_gx_mmc.c
+++ b/drivers/mmc/meson_gx_mmc.c
@@ -250,7 +250,7 @@ static int meson_mmc_probe(struct udevice *dev)
 	mmc->priv = pdata;
 	upriv->mmc = mmc;
 
-	mmc_set_clock(mmc, cfg->f_min, false);
+	mmc_set_clock(mmc, cfg->f_min, MMC_CLK_ENABLE);
 
 	/* reset all status bits */
 	meson_write(mmc, STATUS_MASK, MESON_SD_EMMC_STATUS);
diff --git a/drivers/mmc/mmc-uclass.c b/drivers/mmc/mmc-uclass.c
index a3536b1..e9c2a51 100644
--- a/drivers/mmc/mmc-uclass.c
+++ b/drivers/mmc/mmc-uclass.c
@@ -169,16 +169,19 @@ int mmc_of_parse(struct udevice *dev, struct mmc_config *cfg)
 		cfg->host_caps |= MMC_CAP(MMC_HS_200);
 	if (dev_read_bool(dev, "mmc-hs200-1_2v"))
 		cfg->host_caps |= MMC_CAP(MMC_HS_200);
+	if (dev_read_bool(dev, "mmc-hs400-1_8v"))
+		cfg->host_caps |= MMC_CAP(MMC_HS_400);
+	if (dev_read_bool(dev, "mmc-hs400-1_2v"))
+		cfg->host_caps |= MMC_CAP(MMC_HS_400);
 
 	return 0;
 }
 
 struct mmc *mmc_get_mmc_dev(struct udevice *dev)
 {
-	struct mmc_uclass_priv *upriv;
-
 	if (!device_active(dev))
 		return NULL;
+	struct mmc_uclass_priv *upriv;
 	upriv = dev_get_uclass_priv(dev);
 	return upriv->mmc;
 }
@@ -196,7 +199,7 @@ struct mmc *find_mmc_device(int dev_num)
 		printf("MMC Device %d not found\n", dev_num);
 #endif
 		return NULL;
-	}
+        }
 
 	mmc_dev = dev_get_parent(dev);
 
@@ -272,7 +275,8 @@ void print_mmc_devices(char separator)
 		else
 			mmc_type = NULL;
 
-		printf("%s: %d", m->cfg->name, mmc_get_blk_desc(m)->devnum);
+		printf("%s: %d", m->cfg->name,
+			mmc_get_blk_desc(m)->devnum);
 		if (mmc_type)
 			printf(" (%s)", mmc_type);
 	}
@@ -339,9 +343,8 @@ int mmc_unbind(struct udevice *dev)
 static int mmc_select_hwpart(struct udevice *bdev, int hwpart)
 {
 	struct udevice *mmc_dev = dev_get_parent(bdev);
-	struct mmc *mmc = mmc_get_mmc_dev(mmc_dev);
 	struct blk_desc *desc = dev_get_uclass_platdata(bdev);
-
+	struct mmc *mmc = mmc_get_mmc_dev(mmc_dev);
 	if (desc->hwpart == hwpart)
 		return 0;
 
diff --git a/drivers/mmc/mmc.c b/drivers/mmc/mmc.c
index c930893..cf3f57a 100644
--- a/drivers/mmc/mmc.c
+++ b/drivers/mmc/mmc.c
@@ -1,10 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Copyright 2008, Freescale Semiconductor, Inc
  * Andy Fleming
  *
  * Based vaguely on the Linux code
- *
- * SPDX-License-Identifier:	GPL-2.0+
  */
 
 #include <config.h>
@@ -24,29 +23,8 @@
 
 static int mmc_set_signal_voltage(struct mmc *mmc, uint signal_voltage);
 static int mmc_power_cycle(struct mmc *mmc);
+#if !CONFIG_IS_ENABLED(MMC_TINY)
 static int mmc_select_mode_and_width(struct mmc *mmc, uint card_caps);
-
-#if CONFIG_IS_ENABLED(MMC_TINY)
-static struct mmc mmc_static;
-struct mmc *find_mmc_device(int dev_num)
-{
-	return &mmc_static;
-}
-
-void mmc_do_preinit(void)
-{
-	struct mmc *m = &mmc_static;
-#ifdef CONFIG_FSL_ESDHC_ADAPTER_IDENT
-	mmc_set_preinit(m, 1);
-#endif
-	if (m->preinit)
-		mmc_start_init(m);
-}
-
-struct blk_desc *mmc_get_blk_desc(struct mmc *mmc)
-{
-	return &mmc->block_dev;
-}
 #endif
 
 #if !CONFIG_IS_ENABLED(DM_MMC)
@@ -169,6 +147,7 @@ const char *mmc_mode_name(enum bus_mode mode)
 	      [MMC_HS_52]	= "MMC High Speed (52MHz)",
 	      [MMC_DDR_52]	= "MMC DDR52 (52MHz)",
 	      [MMC_HS_200]	= "HS200 (200MHz)",
+	      [MMC_HS_400]	= "HS400 (200MHz)",
 	};
 
 	if (mode >= MMC_MODES_END)
@@ -193,6 +172,7 @@ static uint mmc_mode2freq(struct mmc *mmc, enum bus_mode mode)
 	      [UHS_DDR50]	= 50000000,
 	      [UHS_SDR104]	= 208000000,
 	      [MMC_HS_200]	= 200000000,
+	      [MMC_HS_400]	= 200000000,
 	};
 
 	if (mode == MMC_LEGACY)
@@ -530,7 +510,7 @@ static int mmc_switch_voltage(struct mmc *mmc, int signal_voltage)
 	 * During a signal voltage level switch, the clock must be gated
 	 * for 5 ms according to the SD spec
 	 */
-	mmc_set_clock(mmc, mmc->clock, true);
+	mmc_set_clock(mmc, mmc->clock, MMC_CLK_DISABLE);
 
 	err = mmc_set_signal_voltage(mmc, signal_voltage);
 	if (err)
@@ -538,7 +518,7 @@ static int mmc_switch_voltage(struct mmc *mmc, int signal_voltage)
 
 	/* Keep clock gated for at least 10 ms, though spec only says 5 ms */
 	mdelay(10);
-	mmc_set_clock(mmc, mmc->clock, false);
+	mmc_set_clock(mmc, mmc->clock, MMC_CLK_ENABLE);
 
 	/*
 	 * Failure to switch is indicated by the card holding
@@ -680,7 +660,7 @@ static int mmc_complete_op_cond(struct mmc *mmc)
 {
 	struct mmc_cmd cmd;
 	int timeout = 1000;
-	uint start;
+	ulong start;
 	int err;
 
 	mmc->op_cond_pending = 0;
@@ -744,7 +724,8 @@ static int mmc_send_ext_csd(struct mmc *mmc, u8 *ext_csd)
 	return err;
 }
 
-int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value)
+static int __mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value,
+			bool send_status)
 {
 	struct mmc_cmd cmd;
 	int timeout = 1000;
@@ -760,20 +741,32 @@ int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value)
 	while (retries > 0) {
 		ret = mmc_send_cmd(mmc, &cmd, NULL);
 
-		/* Waiting for the ready status */
-		if (!ret) {
-			ret = mmc_send_status(mmc, timeout);
-			return ret;
+		if (ret) {
+			retries--;
+			continue;
 		}
 
-		retries--;
+		if (!send_status) {
+			mdelay(50);
+			return 0;
+		}
+
+		/* Waiting for the ready status */
+		return mmc_send_status(mmc, timeout);
 	}
 
 	return ret;
 
 }
 
-static int mmc_set_card_speed(struct mmc *mmc, enum bus_mode mode)
+int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value)
+{
+	return __mmc_switch(mmc, set, index, value, true);
+}
+
+#if !CONFIG_IS_ENABLED(MMC_TINY)
+static int mmc_set_card_speed(struct mmc *mmc, enum bus_mode mode,
+			      bool hsdowngrade)
 {
 	int err;
 	int speed_bits;
@@ -791,17 +784,37 @@ static int mmc_set_card_speed(struct mmc *mmc, enum bus_mode mode)
 		speed_bits = EXT_CSD_TIMING_HS200;
 		break;
 #endif
+#if CONFIG_IS_ENABLED(MMC_HS400_SUPPORT)
+	case MMC_HS_400:
+		speed_bits = EXT_CSD_TIMING_HS400;
+		break;
+#endif
 	case MMC_LEGACY:
 		speed_bits = EXT_CSD_TIMING_LEGACY;
 		break;
 	default:
 		return -EINVAL;
 	}
-	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING,
-			 speed_bits);
+
+	err = __mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING,
+			   speed_bits, !hsdowngrade);
 	if (err)
 		return err;
 
+#if CONFIG_IS_ENABLED(MMC_HS200_SUPPORT) || \
+	CONFIG_IS_ENABLED(MMC_HS400_SUPPORT)
+	/*
+	 * In case the eMMC is in HS200/HS400 mode and we are downgrading
+	 * to HS mode, the card clock are still running much faster than
+	 * the supported HS mode clock, so we can not reliably read out
+	 * Extended CSD. Reconfigure the controller to run at HS mode.
+	 */
+	if (hsdowngrade) {
+		mmc_select_mode(mmc, MMC_HS);
+		mmc_set_clock(mmc, mmc_mode2freq(mmc, MMC_HS), false);
+	}
+#endif
+
 	if ((mode == MMC_HS) || (mode == MMC_HS_52)) {
 		/* Now check to see that it worked */
 		err = mmc_send_ext_csd(mmc, test_csd);
@@ -837,7 +850,7 @@ static int mmc_get_capabilities(struct mmc *mmc)
 
 	mmc->card_caps |= MMC_MODE_4BIT | MMC_MODE_8BIT;
 
-	cardtype = ext_csd[EXT_CSD_CARD_TYPE] & 0x3f;
+	cardtype = ext_csd[EXT_CSD_CARD_TYPE];
 	mmc->cardtype = cardtype;
 
 #if CONFIG_IS_ENABLED(MMC_HS200_SUPPORT)
@@ -846,6 +859,12 @@ static int mmc_get_capabilities(struct mmc *mmc)
 		mmc->card_caps |= MMC_MODE_HS200;
 	}
 #endif
+#if CONFIG_IS_ENABLED(MMC_HS400_SUPPORT)
+	if (cardtype & (EXT_CSD_CARD_TYPE_HS400_1_2V |
+			EXT_CSD_CARD_TYPE_HS400_1_8V)) {
+		mmc->card_caps |= MMC_MODE_HS400;
+	}
+#endif
 	if (cardtype & EXT_CSD_CARD_TYPE_52) {
 		if (cardtype & EXT_CSD_CARD_TYPE_DDR_52)
 			mmc->card_caps |= MMC_MODE_DDR_52MHz;
@@ -856,6 +875,7 @@ static int mmc_get_capabilities(struct mmc *mmc)
 
 	return 0;
 }
+#endif
 
 static int mmc_set_capacity(struct mmc *mmc, int part_num)
 {
@@ -1155,6 +1175,7 @@ int mmc_getcd(struct mmc *mmc)
 }
 #endif
 
+#if !CONFIG_IS_ENABLED(MMC_TINY)
 static int sd_switch(struct mmc *mmc, int mode, int group, u8 value, u8 *resp)
 {
 	struct mmc_cmd cmd;
@@ -1175,7 +1196,6 @@ static int sd_switch(struct mmc *mmc, int mode, int group, u8 value, u8 *resp)
 	return mmc_send_cmd(mmc, &cmd, &data);
 }
 
-
 static int sd_get_capabilities(struct mmc *mmc)
 {
 	int err;
@@ -1296,6 +1316,10 @@ static int sd_set_card_speed(struct mmc *mmc, enum bus_mode mode)
 	ALLOC_CACHE_ALIGN_BUFFER(uint, switch_status, 16);
 	int speed;
 
+	/* SD version 1.00 and 1.01 does not support CMD 6 */
+	if (mmc->version == SD_VERSION_1_0)
+		return 0;
+
 	switch (mode) {
 	case SD_LEGACY:
 		speed = UHS_SDR12_BUS_SPEED;
@@ -1334,7 +1358,7 @@ static int sd_set_card_speed(struct mmc *mmc, enum bus_mode mode)
 	return 0;
 }
 
-int sd_select_bus_width(struct mmc *mmc, int w)
+static int sd_select_bus_width(struct mmc *mmc, int w)
 {
 	int err;
 	struct mmc_cmd cmd;
@@ -1362,6 +1386,7 @@ int sd_select_bus_width(struct mmc *mmc, int w)
 
 	return 0;
 }
+#endif
 
 #if CONFIG_IS_ENABLED(MMC_WRITE)
 static int sd_read_ssr(struct mmc *mmc)
@@ -1507,6 +1532,8 @@ int mmc_set_clock(struct mmc *mmc, uint clock, bool disable)
 	mmc->clock = clock;
 	mmc->clk_disable = disable;
 
+	debug("clock is %s (%dHz)\n", disable ? "disabled" : "enabled", clock);
+
 	return mmc_set_ios(mmc);
 }
 
@@ -1583,6 +1610,7 @@ static inline int mmc_set_signal_voltage(struct mmc *mmc, uint signal_voltage)
 }
 #endif
 
+#if !CONFIG_IS_ENABLED(MMC_TINY)
 static const struct mode_width_tuning sd_modes_by_pref[] = {
 #if CONFIG_IS_ENABLED(MMC_UHS_SUPPORT)
 #ifdef MMC_SUPPORTS_TUNING
@@ -1673,7 +1701,8 @@ static int sd_select_mode_and_width(struct mmc *mmc, uint card_caps)
 
 				/* configure the bus mode (host) */
 				mmc_select_mode(mmc, mwt->mode);
-				mmc_set_clock(mmc, mmc->tran_speed, false);
+				mmc_set_clock(mmc, mmc->tran_speed,
+					      MMC_CLK_ENABLE);
 
 #ifdef MMC_SUPPORTS_TUNING
 				/* execute tuning if needed */
@@ -1689,7 +1718,7 @@ static int sd_select_mode_and_width(struct mmc *mmc, uint card_caps)
 
 #if CONFIG_IS_ENABLED(MMC_WRITE)
 				err = sd_read_ssr(mmc);
-				if (!err)
+				if (err)
 					pr_warn("unable to read ssr\n");
 #endif
 				if (!err)
@@ -1698,7 +1727,8 @@ static int sd_select_mode_and_width(struct mmc *mmc, uint card_caps)
 error:
 				/* revert to a safer bus speed */
 				mmc_select_mode(mmc, SD_LEGACY);
-				mmc_set_clock(mmc, mmc->tran_speed, false);
+				mmc_set_clock(mmc, mmc->tran_speed,
+					      MMC_CLK_ENABLE);
 			}
 		}
 	}
@@ -1748,10 +1778,13 @@ static int mmc_set_lowest_voltage(struct mmc *mmc, enum bus_mode mode,
 	u32 card_mask = 0;
 
 	switch (mode) {
+	case MMC_HS_400:
 	case MMC_HS_200:
-		if (mmc->cardtype & EXT_CSD_CARD_TYPE_HS200_1_8V)
+		if (mmc->cardtype & (EXT_CSD_CARD_TYPE_HS200_1_8V |
+		    EXT_CSD_CARD_TYPE_HS400_1_8V))
 			card_mask |= MMC_SIGNAL_VOLTAGE_180;
-		if (mmc->cardtype & EXT_CSD_CARD_TYPE_HS200_1_2V)
+		if (mmc->cardtype & (EXT_CSD_CARD_TYPE_HS200_1_2V |
+		    EXT_CSD_CARD_TYPE_HS400_1_2V))
 			card_mask |= MMC_SIGNAL_VOLTAGE_120;
 		break;
 	case MMC_DDR_52:
@@ -1787,6 +1820,13 @@ static inline int mmc_set_lowest_voltage(struct mmc *mmc, enum bus_mode mode,
 #endif
 
 static const struct mode_width_tuning mmc_modes_by_pref[] = {
+#if CONFIG_IS_ENABLED(MMC_HS400_SUPPORT)
+	{
+		.mode = MMC_HS_400,
+		.widths = MMC_MODE_8BIT,
+		.tuning = MMC_CMD_SEND_TUNING_BLOCK_HS200
+	},
+#endif
 #if CONFIG_IS_ENABLED(MMC_HS200_SUPPORT)
 	{
 		.mode = MMC_HS_200,
@@ -1830,6 +1870,54 @@ static const struct ext_csd_bus_width {
 	{MMC_MODE_1BIT, false, EXT_CSD_BUS_WIDTH_1},
 };
 
+#if CONFIG_IS_ENABLED(MMC_HS400_SUPPORT)
+static int mmc_select_hs400(struct mmc *mmc)
+{
+	int err;
+
+	/* Set timing to HS200 for tuning */
+	err = mmc_set_card_speed(mmc, MMC_HS_200, false);
+	if (err)
+		return err;
+
+	/* configure the bus mode (host) */
+	mmc_select_mode(mmc, MMC_HS_200);
+	mmc_set_clock(mmc, mmc->tran_speed, false);
+
+	/* execute tuning if needed */
+	err = mmc_execute_tuning(mmc, MMC_CMD_SEND_TUNING_BLOCK_HS200);
+	if (err) {
+		debug("tuning failed\n");
+		return err;
+	}
+
+	/* Set back to HS */
+	mmc_set_card_speed(mmc, MMC_HS, false);
+	mmc_set_clock(mmc, mmc_mode2freq(mmc, MMC_HS), false);
+
+	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_BUS_WIDTH,
+			 EXT_CSD_BUS_WIDTH_8 | EXT_CSD_DDR_FLAG);
+	if (err)
+		return err;
+
+	err = mmc_set_card_speed(mmc, MMC_HS_400, false);
+	if (err)
+		return err;
+
+	mmc_select_mode(mmc, MMC_HS_400);
+	err = mmc_set_clock(mmc, mmc->tran_speed, false);
+	if (err)
+		return err;
+
+	return 0;
+}
+#else
+static int mmc_select_hs400(struct mmc *mmc)
+{
+	return -ENOTSUPP;
+}
+#endif
+
 #define for_each_supported_width(caps, ddr, ecbv) \
 	for (ecbv = ext_csd_bus_width;\
 	    ecbv < ext_csd_bus_width + ARRAY_SIZE(ext_csd_bus_width);\
@@ -1859,7 +1947,19 @@ static int mmc_select_mode_and_width(struct mmc *mmc, uint card_caps)
 		return -ENOTSUPP;
 	}
 
-	mmc_set_clock(mmc, mmc->legacy_speed, false);
+#if CONFIG_IS_ENABLED(MMC_HS200_SUPPORT) || \
+	CONFIG_IS_ENABLED(MMC_HS400_SUPPORT)
+	/*
+	 * In case the eMMC is in HS200/HS400 mode, downgrade to HS mode
+	 * before doing anything else, since a transition from either of
+	 * the HS200/HS400 mode directly to legacy mode is not supported.
+	 */
+	if (mmc->selected_mode == MMC_HS_200 ||
+	    mmc->selected_mode == MMC_HS_400)
+		mmc_set_card_speed(mmc, MMC_HS, true);
+	else
+#endif
+		mmc_set_clock(mmc, mmc->legacy_speed, MMC_CLK_ENABLE);
 
 	for_each_mmc_mode_by_pref(card_caps, mwt) {
 		for_each_supported_width(card_caps & mwt->widths,
@@ -1883,37 +1983,49 @@ static int mmc_select_mode_and_width(struct mmc *mmc, uint card_caps)
 				goto error;
 			mmc_set_bus_width(mmc, bus_width(ecbw->cap));
 
-			/* configure the bus speed (card) */
-			err = mmc_set_card_speed(mmc, mwt->mode);
-			if (err)
-				goto error;
-
-			/*
-			 * configure the bus width AND the ddr mode (card)
-			 * The host side will be taken care of in the next step
-			 */
-			if (ecbw->ext_csd_bits & EXT_CSD_DDR_FLAG) {
-				err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
-						 EXT_CSD_BUS_WIDTH,
-						 ecbw->ext_csd_bits);
+			if (mwt->mode == MMC_HS_400) {
+				err = mmc_select_hs400(mmc);
+				if (err) {
+					printf("Select HS400 failed %d\n", err);
+					goto error;
+				}
+			} else {
+				/* configure the bus speed (card) */
+				err = mmc_set_card_speed(mmc, mwt->mode, false);
 				if (err)
 					goto error;
-			}
 
-			/* configure the bus mode (host) */
-			mmc_select_mode(mmc, mwt->mode);
-			mmc_set_clock(mmc, mmc->tran_speed, false);
+				/*
+				 * configure the bus width AND the ddr mode
+				 * (card). The host side will be taken care
+				 * of in the next step
+				 */
+				if (ecbw->ext_csd_bits & EXT_CSD_DDR_FLAG) {
+					err = mmc_switch(mmc,
+							 EXT_CSD_CMD_SET_NORMAL,
+							 EXT_CSD_BUS_WIDTH,
+							 ecbw->ext_csd_bits);
+					if (err)
+						goto error;
+				}
+
+				/* configure the bus mode (host) */
+				mmc_select_mode(mmc, mwt->mode);
+				mmc_set_clock(mmc, mmc->tran_speed,
+					      MMC_CLK_ENABLE);
 #ifdef MMC_SUPPORTS_TUNING
 
-			/* execute tuning if needed */
-			if (mwt->tuning) {
-				err = mmc_execute_tuning(mmc, mwt->tuning);
-				if (err) {
-					pr_debug("tuning failed\n");
-					goto error;
+				/* execute tuning if needed */
+				if (mwt->tuning) {
+					err = mmc_execute_tuning(mmc,
+								 mwt->tuning);
+					if (err) {
+						pr_debug("tuning failed\n");
+						goto error;
+					}
 				}
-			}
 #endif
+			}
 
 			/* do a transfer to check the configuration */
 			err = mmc_read_and_compare_ext_csd(mmc);
@@ -1933,6 +2045,11 @@ error:
 
 	return -ENOTSUPP;
 }
+#endif
+
+#if CONFIG_IS_ENABLED(MMC_TINY)
+DEFINE_CACHE_ALIGN_BUFFER(u8, ext_csd_bkup, MMC_MAX_BLOCK_LEN);
+#endif
 
 static int mmc_startup_v4(struct mmc *mmc)
 {
@@ -1952,6 +2069,23 @@ static int mmc_startup_v4(struct mmc *mmc)
 		MMC_VERSION_5_1
 	};
 
+#if CONFIG_IS_ENABLED(MMC_TINY)
+	u8 *ext_csd = ext_csd_bkup;
+
+	if (IS_SD(mmc) || mmc->version < MMC_VERSION_4)
+		return 0;
+
+	if (!mmc->ext_csd)
+		memset(ext_csd_bkup, 0, sizeof(ext_csd_bkup));
+
+	err = mmc_send_ext_csd(mmc, ext_csd);
+	if (err)
+		goto error;
+
+	/* store the ext csd for future reference */
+	if (!mmc->ext_csd)
+		mmc->ext_csd = ext_csd;
+#else
 	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, MMC_MAX_BLOCK_LEN);
 
 	if (IS_SD(mmc) || (mmc->version < MMC_VERSION_4))
@@ -1968,7 +2102,7 @@ static int mmc_startup_v4(struct mmc *mmc)
 	if (!mmc->ext_csd)
 		return -ENOMEM;
 	memcpy(mmc->ext_csd, ext_csd, MMC_MAX_BLOCK_LEN);
-
+#endif
 	if (ext_csd[EXT_CSD_REV] >= ARRAY_SIZE(mmc_versions))
 		return -EINVAL;
 
@@ -2107,7 +2241,9 @@ static int mmc_startup_v4(struct mmc *mmc)
 	return 0;
 error:
 	if (mmc->ext_csd) {
+#if !CONFIG_IS_ENABLED(MMC_TINY)
 		free(mmc->ext_csd);
+#endif
 		mmc->ext_csd = NULL;
 	}
 	return err;
@@ -2296,6 +2432,11 @@ static int mmc_startup(struct mmc *mmc)
 	if (err)
 		return err;
 
+#if CONFIG_IS_ENABLED(MMC_TINY)
+	mmc_set_clock(mmc, mmc->legacy_speed, false);
+	mmc_select_mode(mmc, IS_SD(mmc) ? SD_LEGACY : MMC_LEGACY);
+	mmc_set_bus_width(mmc, 1);
+#else
 	if (IS_SD(mmc)) {
 		err = sd_get_capabilities(mmc);
 		if (err)
@@ -2307,7 +2448,7 @@ static int mmc_startup(struct mmc *mmc)
 			return err;
 		mmc_select_mode_and_width(mmc, mmc->card_caps);
 	}
-
+#endif
 	if (err)
 		return err;
 
@@ -2346,9 +2487,8 @@ static int mmc_startup(struct mmc *mmc)
 	bdesc->product[0] = 0;
 	bdesc->revision[0] = 0;
 #endif
-#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBDISK_SUPPORT)
+
 	part_init(bdesc);
-#endif
 
 	return 0;
 }
@@ -2383,7 +2523,7 @@ __weak void board_mmc_power_init(void)
 }
 #endif
 
-static int mmc_power_init(struct mmc *mmc)
+int mmc_power_init(struct mmc *mmc)
 {
 #if CONFIG_IS_ENABLED(DM_MMC)
 #if CONFIG_IS_ENABLED(DM_REGULATOR)
@@ -2427,7 +2567,7 @@ static void mmc_set_initial_state(struct mmc *mmc)
 
 	mmc_select_mode(mmc, MMC_LEGACY);
 	mmc_set_bus_width(mmc, 1);
-	mmc_set_clock(mmc, 0, false);
+	mmc_set_clock(mmc, 0, MMC_CLK_ENABLE);
 }
 
 static int mmc_power_on(struct mmc *mmc)
@@ -2447,7 +2587,7 @@ static int mmc_power_on(struct mmc *mmc)
 
 static int mmc_power_off(struct mmc *mmc)
 {
-	mmc_set_clock(mmc, 0, true);
+	mmc_set_clock(mmc, 0, MMC_CLK_DISABLE);
 #if CONFIG_IS_ENABLED(DM_MMC) && CONFIG_IS_ENABLED(DM_REGULATOR)
 	if (mmc->vmmc_supply) {
 		int ret = regulator_set_enable(mmc->vmmc_supply, false);
@@ -2476,36 +2616,11 @@ static int mmc_power_cycle(struct mmc *mmc)
 	return mmc_power_on(mmc);
 }
 
-int mmc_start_init(struct mmc *mmc)
+int mmc_get_op_cond(struct mmc *mmc)
 {
-	bool no_card;
 	bool uhs_en = supports_uhs(mmc->cfg->host_caps);
 	int err;
 
-	/*
-	 * all hosts are capable of 1 bit bus-width and able to use the legacy
-	 * timings.
-	 */
-	mmc->host_caps = mmc->cfg->host_caps | MMC_CAP(SD_LEGACY) |
-			 MMC_CAP(MMC_LEGACY) | MMC_MODE_1BIT;
-
-#if !defined(CONFIG_MMC_BROKEN_CD)
-	/* we pretend there's no card when init is NULL */
-	no_card = mmc_getcd(mmc) == 0;
-#else
-	no_card = 0;
-#endif
-#if !CONFIG_IS_ENABLED(DM_MMC)
-	no_card = no_card || (mmc->cfg->ops->init == NULL);
-#endif
-	if (no_card) {
-		mmc->has_init = 0;
-#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBCOMMON_SUPPORT)
-		pr_err("MMC: no card present\n");
-#endif
-		return -ENOMEDIUM;
-	}
-
 	if (mmc->has_init)
 		return 0;
 
@@ -2582,6 +2697,40 @@ retry:
 		}
 	}
 
+	return err;
+}
+
+int mmc_start_init(struct mmc *mmc)
+{
+	bool no_card;
+	int err = 0;
+
+	/*
+	 * all hosts are capable of 1 bit bus-width and able to use the legacy
+	 * timings.
+	 */
+	mmc->host_caps = mmc->cfg->host_caps | MMC_CAP(SD_LEGACY) |
+			 MMC_CAP(MMC_LEGACY) | MMC_MODE_1BIT;
+
+#if !defined(CONFIG_MMC_BROKEN_CD)
+	/* we pretend there's no card when init is NULL */
+	no_card = mmc_getcd(mmc) == 0;
+#else
+	no_card = 0;
+#endif
+#if !CONFIG_IS_ENABLED(DM_MMC)
+	no_card = no_card || (mmc->cfg->ops->init == NULL);
+#endif
+	if (no_card) {
+		mmc->has_init = 0;
+#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBCOMMON_SUPPORT)
+		pr_err("MMC: no card present\n");
+#endif
+		return -ENOMEDIUM;
+	}
+
+	err = mmc_get_op_cond(mmc);
+
 	if (!err)
 		mmc->init_in_progress = 1;
 
@@ -2608,7 +2757,7 @@ static int mmc_complete_init(struct mmc *mmc)
 int mmc_init(struct mmc *mmc)
 {
 	int err = 0;
-	__maybe_unused unsigned start;
+	__maybe_unused ulong start;
 #if CONFIG_IS_ENABLED(DM_MMC)
 	struct mmc_uclass_priv *upriv = dev_get_uclass_priv(mmc->dev);
 
@@ -2676,8 +2825,14 @@ static int mmc_probe(bd_t *bis)
 	}
 	uclass_foreach_dev(dev, uc) {
 		ret = device_probe(dev);
-		if (ret)
-			pr_err("%s - probe failed: %d\n", dev->name, ret);
+		if (ret) {
+			if (ret == -ENODEV || ret == -ENXIO)
+				pr_debug("%s: probe of %s rejects match %d\n",
+					 __func__, dev->name, ret);
+			else
+				pr_err("%s - probe failed: %d\n",
+				       dev->name, ret);
+		}
 	}
 
 	return 0;
diff --git a/drivers/mmc/mmc_legacy.c b/drivers/mmc/mmc_legacy.c
index 100b931..8d62440 100644
--- a/drivers/mmc/mmc_legacy.c
+++ b/drivers/mmc/mmc_legacy.c
@@ -13,7 +13,28 @@
 static struct list_head mmc_devices;
 static int cur_dev_num = -1;
 
-#if !CONFIG_IS_ENABLED(MMC_TINY)
+#if CONFIG_IS_ENABLED(MMC_TINY)
+static struct mmc mmc_static;
+struct mmc *find_mmc_device(int dev_num)
+{
+	return &mmc_static;
+}
+
+void mmc_do_preinit(void)
+{
+	struct mmc *m = &mmc_static;
+#ifdef CONFIG_FSL_ESDHC_ADAPTER_IDENT
+	mmc_set_preinit(m, 1);
+#endif
+	if (m->preinit)
+		mmc_start_init(m);
+}
+
+struct blk_desc *mmc_get_blk_desc(struct mmc *mmc)
+{
+	return &mmc->block_dev;
+}
+#else
 struct mmc *find_mmc_device(int dev_num)
 {
 	struct mmc *m;
diff --git a/drivers/mmc/octeontx_hsmmc.c b/drivers/mmc/octeontx_hsmmc.c
new file mode 100644
index 0000000..42c86b3
--- /dev/null
+++ b/drivers/mmc/octeontx_hsmmc.c
@@ -0,0 +1,3281 @@
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <memalign.h>
+#include <mmc.h>
+#include <part.h>
+#include <asm/io.h>
+#include <dm.h>
+#include <dm/lists.h>
+#include <errno.h>
+#include <pci.h>
+#include <linux/libfdt.h>
+#include <fdtdec.h>
+#include <asm/arch/fdt-helper.h>
+#include <asm/arch/cavm-csrs-mio_emm.h>
+#include <asm/arch/clock.h>
+#include <linux/list.h>
+#include <div64.h>
+#include <watchdog.h>
+#include <power/regulator.h>
+#include <console.h>	/* for ctrlc */
+#include "octeontx_hsmmc.h"
+#if defined(CONFIG_ARCH_OCTEONTX)
+# include <asm/arch/octeontx.h>
+#elif defined(CONFIG_ARCH_OCTEONTX2)
+# include <asm/arch/octeontx2.h>
+#else
+# error Unsupported architecture!
+#endif
+
+#define PCI_DEVICE_ID_OCTEONTX_EMMC	0xA010
+
+#define MMC_TIMEOUT_SHORT	20	/* in ms */
+#define MMC_TIMEOUT_LONG	1000
+#define MMC_TIMEOUT_ERASE	10000
+
+#define MMC_DEFAULT_DATA_IN_TAP			10
+#define MMC_DEFAULT_CMD_IN_TAP			10
+#define MMC_DEFAULT_CMD_OUT_TAP			39
+#define MMC_DEFAULT_DATA_OUT_TAP		39
+#define MMC_DEFAULT_HS200_CMD_IN_TAP		24
+#define MMC_DEFAULT_HS200_DATA_IN_TAP		24
+#define MMC_DEFAULT_HS200_CMD_OUT_TAP	(is_board_model(CN95XX) ? 10 : 5)
+#define MMC_DEFAULT_HS200_DATA_OUT_TAP	(is_board_model(CN95XX) ? 10 : 5)
+#define MMC_DEFAULT_SD_UHS_SDR104_CMD_OUT_TAP	MMC_DEFAULT_HS200_CMD_OUT_TAP
+#define MMC_DEFAULT_SD_UHS_SDR104_DATA_OUT_TAP	MMC_DEFAULT_HS200_DATA_OUT_TAP
+#define MMC_LEGACY_DEFAULT_CMD_OUT_TAP		39
+#define MMC_LEGACY_DEFAULT_DATA_OUT_TAP		39
+#define MMC_SD_LEGACY_DEFAULT_CMD_OUT_TAP	63
+#define MMC_SD_LEGACY_DEFAULT_DATA_OUT_TAP	63
+#define MMC_HS_CMD_OUT_TAP			32
+#define MMC_HS_DATA_OUT_TAP			32
+#define MMC_SD_HS_CMD_OUT_TAP			26
+#define MMC_SD_HS_DATA_OUT_TAP			26
+#define MMC_SD_UHS_SDR25_CMD_OUT_TAP		26
+#define MMC_SD_UHS_SDR25_DATA_OUT_TAP		26
+#define MMC_SD_UHS_SDR50_CMD_OUT_TAP		26
+#define MMC_SD_UHS_SDR50_DATA_OUT_TAP		26
+#define MMC_DEFAULT_TAP_DELAY			4
+
+static void octeontx_mmc_switch_to(struct mmc *mmc);
+static int octeontx_mmc_configure_delay(struct mmc *mmc);
+#if defined(CONFIG_MMC_SUPPORTS_TUNING) || defined(MMC_SUPPORTS_TUNING)
+static void octeontx_mmc_set_timing(struct mmc *mmc);
+#endif
+static void set_wdog(struct mmc *mmc, u64 us);
+static void do_switch(struct mmc *mmc, union cavm_mio_emm_switch emm_switch);
+static int octeontx_mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
+				 struct mmc_data *data);
+#ifndef CONFIG_ARCH_OCTEONTX
+static int octeontx2_mmc_calc_delay(struct mmc *mmc, int delay);
+static int octeontx_mmc_calibrate_delay(struct mmc *mmc);
+#endif
+static int octeontx_mmc_set_input_bus_timing(struct mmc *mmc);
+static int octeontx_mmc_set_output_bus_timing(struct mmc *mmc);
+
+static bool host_probed;
+
+/**
+ * Get the slot data structure from a MMC data structure
+ */
+static inline struct octeontx_mmc_slot *mmc_to_slot(struct mmc *mmc)
+{
+	return container_of(mmc, struct octeontx_mmc_slot, mmc);
+}
+
+static inline struct octeontx_mmc_host *mmc_to_host(struct mmc *mmc)
+{
+	return mmc_to_slot(mmc)->host;
+}
+
+static inline struct octeontx_mmc_slot *dev_to_mmc_slot(struct udevice *dev)
+{
+	return dev_get_priv(dev);
+}
+
+static inline struct mmc *dev_to_mmc(struct udevice *dev)
+{
+	return &((struct octeontx_mmc_slot *)dev_get_priv(dev))->mmc;
+}
+
+#ifdef DEBUG
+const char *mmc_reg_str(u64 reg)
+{
+	if (reg == CAVM_MIO_EMM_DMA_CFG())
+		return "MIO_EMM_DMA_CFG";
+	if (reg == CAVM_MIO_EMM_DMA_ADR())
+		return "MIO_EMM_DMA_ADR";
+	if (reg == CAVM_MIO_EMM_DMA_INT())
+		return "MIO_EMM_DMA_INT";
+	if (reg == CAVM_MIO_EMM_CFG())
+		return "MIO_EMM_CFG";
+	if (reg == CAVM_MIO_EMM_MODEX(0))
+		return "MIO_EMM_MODE0";
+	if (reg == CAVM_MIO_EMM_MODEX(1))
+		return "MIO_EMM_MODE1";
+	if (reg == CAVM_MIO_EMM_MODEX(2))
+		return "MIO_EMM_MODE2";
+	if (reg == CAVM_MIO_EMM_MODEX(3))
+		return "MIO_EMM_MODE3";
+	if (reg == CAVM_MIO_EMM_IO_CTL())
+		return "MIO_EMM_IO_CTL";
+	if (reg == CAVM_MIO_EMM_SWITCH())
+		return "MIO_EMM_SWITCH";
+	if (reg == CAVM_MIO_EMM_DMA())
+		return "MIO_EMM_DMA";
+	if (reg == CAVM_MIO_EMM_CMD())
+		return "MIO_EMM_CMD";
+	if (reg == CAVM_MIO_EMM_RSP_STS())
+		return "MIO_EMM_RSP_STS";
+	if (reg == CAVM_MIO_EMM_RSP_LO())
+		return "MIO_EMM_RSP_LO";
+	if (reg == CAVM_MIO_EMM_RSP_HI())
+		return "MIO_EMM_RSP_HI";
+	if (reg == CAVM_MIO_EMM_INT())
+		return "MIO_EMM_INT";
+	if (reg == CAVM_MIO_EMM_WDOG())
+		return "MIO_EMM_WDOG";
+	if (reg == CAVM_MIO_EMM_DMA_ARG())
+		return "MIO_EMM_DMA_ARG";
+#if defined(CONFIG_ARCH_OCTEONTX)
+	if (reg == CAVM_MIO_EMM_SAMPLE())
+		return "MIO_EMM_SAMPLE";
+#endif
+	if (reg == CAVM_MIO_EMM_STS_MASK())
+		return "MIO_EMM_STS_MASK";
+	if (reg == CAVM_MIO_EMM_RCA())
+		return "MIO_EMM_RCA";
+	if (reg == CAVM_MIO_EMM_BUF_IDX())
+		return "MIO_EMM_BUF_IDX";
+	if (reg == CAVM_MIO_EMM_BUF_DAT())
+		return "MIO_EMM_BUF_DAT";
+#if !defined(CONFIG_ARCH_OCTEONTX)
+	if (reg == CAVM_MIO_EMM_CALB())
+		return "MIO_EMM_CALB";
+	if (reg == CAVM_MIO_EMM_TAP())
+		return "MIO_EMM_TAP";
+	if (reg == CAVM_MIO_EMM_TIMING())
+		return "MIO_EMM_TIMING";
+	if (reg == CAVM_MIO_EMM_DEBUG())
+		return "MIO_EMM_DEBUG";
+#endif
+	return "UNKNOWN";
+}
+#endif
+
+static void octeontx_print_rsp_sts(struct mmc *mmc)
+{
+#ifdef DEBUG
+	union cavm_mio_emm_rsp_sts emm_rsp_sts;
+	const struct octeontx_mmc_host *host = mmc_to_host(mmc);
+	static const char * const ctype_xor_str[] = {
+		"No data",
+		"Read data into Dbuf",
+		"Write data from Dbuf",
+		"Reserved"
+	};
+
+	static const char * const rtype_xor_str[] = {
+		"No response",
+		"R1, 48 bits",
+		"R2, 136 bits",
+		"R3, 48 bits",
+		"R4, 48 bits",
+		"R5, 48 bits",
+		"Reserved 6",
+		"Reserved 7"
+	};
+
+	emm_rsp_sts.u = readq(host->base_addr + CAVM_MIO_EMM_RSP_STS());
+	printf("\nMIO_EMM_RSP_STS:              0x%016llx\n", emm_rsp_sts.u);
+	printf("    60-61: bus_id:              %u\n", emm_rsp_sts.s.bus_id);
+	printf("    59:    cmd_val:             %s\n",
+	       emm_rsp_sts.s.cmd_val ? "yes" : "no");
+	printf("    58:    switch_val:          %s\n",
+	       emm_rsp_sts.s.switch_val ? "yes" : "no");
+	printf("    57:    dma_val:             %s\n",
+	       emm_rsp_sts.s.dma_val ? "yes" : "no");
+	printf("    56:    dma_pend:            %s\n",
+	       emm_rsp_sts.s.dma_pend ? "yes" : "no");
+	printf("    28:    dbuf_err:            %s\n",
+	       emm_rsp_sts.s.dbuf_err ? "yes" : "no");
+	printf("    23:    dbuf:                %u\n", emm_rsp_sts.s.dbuf);
+	printf("    22:    blk_timeout:         %s\n",
+	       emm_rsp_sts.s.blk_timeout ? "yes" : "no");
+	printf("    21:    blk_crc_err:         %s\n",
+	       emm_rsp_sts.s.blk_crc_err ? "yes" : "no");
+	printf("    20:    rsp_busybit:         %s\n",
+	       emm_rsp_sts.s.rsp_busybit ? "yes" : "no");
+	printf("    19:    stp_timeout:         %s\n",
+	       emm_rsp_sts.s.stp_timeout ? "yes" : "no");
+	printf("    18:    stp_crc_err:         %s\n",
+	       emm_rsp_sts.s.stp_crc_err ? "yes" : "no");
+	printf("    17:    stp_bad_sts:         %s\n",
+	       emm_rsp_sts.s.stp_bad_sts ? "yes" : "no");
+	printf("    16:    stp_val:             %s\n",
+	       emm_rsp_sts.s.stp_val ? "yes" : "no");
+	printf("    15:    rsp_timeout:         %s\n",
+	       emm_rsp_sts.s.rsp_timeout ? "yes" : "no");
+	printf("    14:    rsp_crc_err:         %s\n",
+	       emm_rsp_sts.s.rsp_crc_err ? "yes" : "no");
+	printf("    13:    rsp_bad_sts:         %s\n",
+	       emm_rsp_sts.s.rsp_bad_sts ? "yes" : "no");
+	printf("    12:    rsp_val:             %s\n",
+	       emm_rsp_sts.s.rsp_val ? "yes" : "no");
+	printf("    9-11:  rsp_type:            %s\n",
+	       rtype_xor_str[emm_rsp_sts.s.rsp_type]);
+	printf("    7-8:   cmd_type:            %s\n",
+	       ctype_xor_str[emm_rsp_sts.s.cmd_type]);
+	printf("    1-6:   cmd_idx:             %u\n",
+	       emm_rsp_sts.s.cmd_idx);
+	printf("    0:     cmd_done:            %s\n",
+	       emm_rsp_sts.s.cmd_done ? "yes" : "no");
+#endif
+}
+
+static inline u64 read_csr(struct mmc *mmc, u64 reg)
+{
+	const struct octeontx_mmc_host *host = mmc_to_host(mmc);
+	u64 value = readq(host->base_addr + reg);
+#ifdef DEBUG_CSR
+	printf("        %s: %s(0x%p) => 0x%llx\n", __func__,
+	       mmc_reg_str(reg), host->base_addr + reg,
+	       value);
+#endif
+	return value;
+}
+
+/**
+ * Writes to a CSR register
+ *
+ * @param[in]	mmc	pointer to mmc data structure
+ * @param	reg	register offset
+ * @param	value	value to write to register
+ */
+static inline void write_csr(struct mmc *mmc, u64 reg, u64 value)
+{
+	const struct octeontx_mmc_host *host = mmc_to_host(mmc);
+	void *addr = host->base_addr + reg;
+
+#ifdef DEBUG_CSR
+	printf("        %s: %s(0x%p) <= 0x%llx\n", __func__, mmc_reg_str(reg),
+	       addr, value);
+#endif
+	writeq(value, addr);
+}
+
+#ifdef DEBUG
+static void mmc_print_status(u32 status)
+{
+#ifdef DEBUG_STATUS
+	static const char * const state[] = {
+		"Idle",		/* 0 */
+		"Ready",	/* 1 */
+		"Ident",	/* 2 */
+		"Standby",	/* 3 */
+		"Tran",		/* 4 */
+		"Data",		/* 5 */
+		"Receive",	/* 6 */
+		"Program",	/* 7 */
+		"Dis",		/* 8 */
+		"Btst",		/* 9 */
+		"Sleep",	/* 10 */
+		"reserved",	/* 11 */
+		"reserved",	/* 12 */
+		"reserved",	/* 13 */
+		"reserved",	/* 14 */
+		"reserved"	/* 15 */ };
+	if (status & R1_APP_CMD)
+		puts("MMC ACMD\n");
+	if (status & R1_SWITCH_ERROR)
+		puts("MMC switch error\n");
+	if (status & R1_READY_FOR_DATA)
+		puts("MMC ready for data\n");
+	printf("MMC %s state\n", state[R1_CURRENT_STATE(status)]);
+	if (status & R1_ERASE_RESET)
+		puts("MMC erase reset\n");
+	if (status & R1_WP_ERASE_SKIP)
+		puts("MMC partial erase due to write protected blocks\n");
+	if (status & R1_CID_CSD_OVERWRITE)
+		puts("MMC CID/CSD overwrite error\n");
+	if (status & R1_ERROR)
+		puts("MMC undefined device error\n");
+	if (status & R1_CC_ERROR)
+		puts("MMC device error\n");
+	if (status & R1_CARD_ECC_FAILED)
+		puts("MMC internal ECC failed to correct data\n");
+	if (status & R1_ILLEGAL_COMMAND)
+		puts("MMC illegal command\n");
+	if (status & R1_COM_CRC_ERROR)
+		puts("MMC CRC of previous command failed\n");
+	if (status & R1_LOCK_UNLOCK_FAILED)
+		puts("MMC sequence or password error in lock/unlock device command\n");
+	if (status & R1_CARD_IS_LOCKED)
+		puts("MMC device locked by host\n");
+	if (status & R1_WP_VIOLATION)
+		puts("MMC attempt to program write protected block\n");
+	if (status & R1_ERASE_PARAM)
+		puts("MMC invalid selection of erase groups for erase\n");
+	if (status & R1_ERASE_SEQ_ERROR)
+		puts("MMC error in sequence of erase commands\n");
+	if (status & R1_BLOCK_LEN_ERROR)
+		puts("MMC block length error\n");
+	if (status & R1_ADDRESS_ERROR)
+		puts("MMC address misalign error\n");
+	if (status & R1_OUT_OF_RANGE)
+		puts("MMC address out of range\n");
+#endif
+}
+#endif
+
+/**
+ * Print out all of the register values where mmc is optional
+ *
+ * @param mmc	MMC device (can be NULL)
+ * @param host	Pointer to host data structure (can be NULL if mmc is !NULL)
+ */
+static void octeontx_mmc_print_registers2(struct mmc *mmc,
+					  struct octeontx_mmc_host *host)
+{
+	struct octeontx_mmc_slot *slot = mmc ? mmc->priv : NULL;
+	union cavm_mio_emm_dma_cfg emm_dma_cfg;
+	union cavm_mio_emm_dma_adr emm_dma_adr;
+	union cavm_mio_emm_dma_int emm_dma_int;
+	union cavm_mio_emm_cfg emm_cfg;
+	union cavm_mio_emm_modex emm_mode;
+	union cavm_mio_emm_switch emm_switch;
+	union cavm_mio_emm_dma emm_dma;
+	union cavm_mio_emm_cmd emm_cmd;
+	union cavm_mio_emm_rsp_sts emm_rsp_sts;
+	union cavm_mio_emm_rsp_lo emm_rsp_lo;
+	union cavm_mio_emm_rsp_hi emm_rsp_hi;
+	union cavm_mio_emm_int emm_int;
+	union cavm_mio_emm_wdog emm_wdog;
+#if defined(CONFIG_ARCH_OCTEONTX)
+	union cavm_mio_emm_sample emm_sample;
+#else
+	union cavm_mio_emm_calb emm_calb;
+	union cavm_mio_emm_tap emm_tap;
+	union cavm_mio_emm_timing emm_timing;
+	union cavm_mio_emm_io_ctl io_ctl;
+	union cavm_mio_emm_debug emm_debug;
+#endif
+	union cavm_mio_emm_sts_mask emm_sts_mask;
+	union cavm_mio_emm_rca emm_rca;
+	int bus;
+
+	static const char * const bus_width_str[] = {
+		"1-bit data bus (power on)",
+		"4-bit data bus",
+		"8-bit data bus",
+		"reserved (3)",
+		"reserved (4)",
+		"4-bit data bus (dual data rate)",
+		"8-bit data bus (dual data rate)",
+		"reserved (7)",
+		"reserved (8)",
+		"invalid (9)",
+		"invalid (10)",
+		"invalid (11)",
+		"invalid (12)",
+		"invalid (13)",
+		"invalid (14)",
+		"invalid (15)",
+	};
+	static const char * const ctype_xor_str[] = {
+		"No data",
+		"Read data into Dbuf",
+		"Write data from Dbuf",
+		"Reserved"
+	};
+
+	static const char * const rtype_xor_str[] = {
+		"No response",
+		"R1, 48 bits",
+		"R2, 136 bits",
+		"R3, 48 bits",
+		"R4, 48 bits",
+		"R5, 48 bits",
+		"Reserved 6",
+		"Reserved 7"
+	};
+
+	if (!host && mmc)
+		host = mmc_to_host(mmc);
+
+	if (mmc)
+		printf("%s: bus id: %u\n", __func__, slot->bus_id);
+	emm_dma_cfg.u = readq(host->base_addr + CAVM_MIO_EMM_DMA_CFG());
+	printf("MIO_EMM_DMA_CFG:                0x%016llx\n",
+	       emm_dma_cfg.u);
+	printf("    63:    en:                  %s\n",
+	       emm_dma_cfg.s.en ? "enabled" : "disabled");
+	printf("    62:    rw:                  %s\n",
+	       emm_dma_cfg.s.rw ? "write" : "read");
+	printf("    61:    clr:                 %s\n",
+	       emm_dma_cfg.s.clr ? "clear" : "not clear");
+	printf("    59:    swap32:              %s\n",
+	       emm_dma_cfg.s.swap32 ? "yes" : "no");
+	printf("    58:    swap16:              %s\n",
+	       emm_dma_cfg.s.swap16 ? "yes" : "no");
+	printf("    57:    swap8:               %s\n",
+	       emm_dma_cfg.s.swap8 ? "yes" : "no");
+	printf("    56:    endian:              %s\n",
+	       emm_dma_cfg.s.endian ? "little" : "big");
+	printf("    36-55: size:                %u\n",
+	       emm_dma_cfg.s.size);
+
+	emm_dma_adr.u = readq(host->base_addr + CAVM_MIO_EMM_DMA_ADR());
+	printf("MIO_EMM_DMA_ADR:              0x%016llx\n", emm_dma_adr.u);
+	printf("    0-49:  adr:                 0x%llx\n",
+	       (u64)emm_dma_adr.s.adr);
+
+	emm_dma_int.u = readq(host->base_addr + CAVM_MIO_EMM_DMA_INT());
+	printf("\nMIO_EMM_DMA_INT:              0x%016llx\n",
+	       emm_dma_int.u);
+	printf("    1:     FIFO:                %s\n",
+	       emm_dma_int.s.fifo ? "yes" : "no");
+	printf("    0:     Done:                %s\n",
+	       emm_dma_int.s.done ? "yes" : "no");
+		emm_cfg.u = readq(host->base_addr + CAVM_MIO_EMM_CFG());
+
+	printf("\nMIO_EMM_CFG:                  0x%016llx\n",
+	       emm_cfg.u);
+	printf("    3:     bus_ena3:            %s\n",
+	       emm_cfg.s.bus_ena & 0x08 ? "yes" : "no");
+	printf("    2:     bus_ena2:            %s\n",
+	       emm_cfg.s.bus_ena & 0x04 ? "yes" : "no");
+	printf("    1:     bus_ena1:            %s\n",
+	       emm_cfg.s.bus_ena & 0x02 ? "yes" : "no");
+	printf("    0:     bus_ena0:            %s\n",
+	       emm_cfg.s.bus_ena & 0x01 ? "yes" : "no");
+	for (bus = 0; bus < 4; bus++) {
+		emm_mode.u = readq(host->base_addr + CAVM_MIO_EMM_MODEX(bus));
+		printf("\nMIO_EMM_MODE%u:               0x%016llx\n",
+		       bus, emm_mode.u);
+#ifndef CONFIG_ARCH_OCTEONTX
+		printf("    50:    hs400_timing:        %s\n",
+		       emm_mode.s.hs400_timing ? "yes" : "no");
+		printf("    49:    hs200_timing:        %s\n",
+		       emm_mode.s.hs200_timing ? "yes" : "no");
+#endif
+		printf("    48:    hs_timing:           %s\n",
+		       emm_mode.s.hs_timing ? "yes" : "no");
+		printf("    40-42: bus_width:           %s\n",
+		       bus_width_str[emm_mode.s.bus_width]);
+		printf("    32-35: power_class          %u\n",
+		       emm_mode.s.power_class);
+		printf("    16-31: clk_hi:              %u\n",
+		       emm_mode.s.clk_hi);
+		printf("    0-15:  clk_lo:              %u\n",
+		       emm_mode.s.clk_lo);
+	}
+
+	emm_switch.u = readq(host->base_addr + CAVM_MIO_EMM_SWITCH());
+	printf("\nMIO_EMM_SWITCH:               0x%016llx\n", emm_switch.u);
+	printf("    60-61: bus_id:              %u\n", emm_switch.s.bus_id);
+	printf("    59:    switch_exe:          %s\n",
+	       emm_switch.s.switch_exe ? "yes" : "no");
+	printf("    58:    switch_err0:         %s\n",
+	       emm_switch.s.switch_err0 ? "yes" : "no");
+	printf("    57:    switch_err1:         %s\n",
+	       emm_switch.s.switch_err1 ? "yes" : "no");
+	printf("    56:    switch_err2:         %s\n",
+	       emm_switch.s.switch_err2 ? "yes" : "no");
+	printf("    48:    hs_timing:           %s\n",
+	       emm_switch.s.hs_timing ? "yes" : "no");
+	printf("    42-40: bus_width:           %s\n",
+	       bus_width_str[emm_switch.s.bus_width]);
+	printf("    32-35: power_class:         %u\n",
+	       emm_switch.s.power_class);
+	printf("    16-31: clk_hi:              %u\n",
+	       emm_switch.s.clk_hi);
+	printf("    0-15:  clk_lo:              %u\n", emm_switch.s.clk_lo);
+
+	emm_dma.u = readq(host->base_addr + CAVM_MIO_EMM_DMA());
+	printf("\nMIO_EMM_DMA:                  0x%016llx\n", emm_dma.u);
+	printf("    60-61: bus_id:              %u\n", emm_dma.s.bus_id);
+	printf("    59:    dma_val:             %s\n",
+	       emm_dma.s.dma_val ? "yes" : "no");
+	printf("    58:    sector:              %s mode\n",
+	       emm_dma.s.sector ? "sector" : "byte");
+	printf("    57:    dat_null:            %s\n",
+	       emm_dma.s.dat_null ? "yes" : "no");
+	printf("    51-56: thres:               %u\n", emm_dma.s.thres);
+	printf("    50:    rel_wr:              %s\n",
+	       emm_dma.s.rel_wr ? "yes" : "no");
+	printf("    49:    rw:                  %s\n",
+	       emm_dma.s.rw ? "write" : "read");
+	printf("    48:    multi:               %s\n",
+	       emm_dma.s.multi ? "yes" : "no");
+	printf("    32-47: block_cnt:           %u\n",
+	       emm_dma.s.block_cnt);
+	printf("    0-31:  card_addr:           0x%x\n",
+	       emm_dma.s.card_addr);
+
+	emm_cmd.u = readq(host->base_addr + CAVM_MIO_EMM_CMD());
+	printf("\nMIO_EMM_CMD:                  0x%016llx\n", emm_cmd.u);
+	printf("\n  62:    skip_busy:           %s\n",
+	       emm_cmd.s.skip_busy ? "yes" : "no");
+	printf("    60-61: bus_id:              %u\n", emm_cmd.s.bus_id);
+	printf("    59:    cmd_val:             %s\n",
+	       emm_cmd.s.cmd_val ? "yes" : "no");
+	printf("    55:    dbuf:                %u\n", emm_cmd.s.dbuf);
+	printf("    49-54: offset:              %u\n", emm_cmd.s.offset);
+	printf("    41-42: ctype_xor:           %s\n",
+	       ctype_xor_str[emm_cmd.s.ctype_xor]);
+	printf("    38-40: rtype_xor:           %s\n",
+	       rtype_xor_str[emm_cmd.s.rtype_xor]);
+	printf("    32-37: cmd_idx:             %u\n", emm_cmd.s.cmd_idx);
+	printf("    0-31:  arg:                 0x%x\n", emm_cmd.s.arg);
+
+	emm_rsp_sts.u = readq(host->base_addr + CAVM_MIO_EMM_RSP_STS());
+	printf("\nMIO_EMM_RSP_STS:              0x%016llx\n", emm_rsp_sts.u);
+	printf("    60-61: bus_id:              %u\n", emm_rsp_sts.s.bus_id);
+	printf("    59:    cmd_val:             %s\n",
+	       emm_rsp_sts.s.cmd_val ? "yes" : "no");
+	printf("    58:    switch_val:          %s\n",
+	       emm_rsp_sts.s.switch_val ? "yes" : "no");
+	printf("    57:    dma_val:             %s\n",
+	       emm_rsp_sts.s.dma_val ? "yes" : "no");
+	printf("    56:    dma_pend:            %s\n",
+	       emm_rsp_sts.s.dma_pend ? "yes" : "no");
+	printf("    28:    dbuf_err:            %s\n",
+	       emm_rsp_sts.s.dbuf_err ? "yes" : "no");
+	printf("    23:    dbuf:                %u\n", emm_rsp_sts.s.dbuf);
+	printf("    22:    blk_timeout:         %s\n",
+	       emm_rsp_sts.s.blk_timeout ? "yes" : "no");
+	printf("    21:    blk_crc_err:         %s\n",
+	       emm_rsp_sts.s.blk_crc_err ? "yes" : "no");
+	printf("    20:    rsp_busybit:         %s\n",
+	       emm_rsp_sts.s.rsp_busybit ? "yes" : "no");
+	printf("    19:    stp_timeout:         %s\n",
+	       emm_rsp_sts.s.stp_timeout ? "yes" : "no");
+	printf("    18:    stp_crc_err:         %s\n",
+	       emm_rsp_sts.s.stp_crc_err ? "yes" : "no");
+	printf("    17:    stp_bad_sts:         %s\n",
+	       emm_rsp_sts.s.stp_bad_sts ? "yes" : "no");
+	printf("    16:    stp_val:             %s\n",
+	       emm_rsp_sts.s.stp_val ? "yes" : "no");
+	printf("    15:    rsp_timeout:         %s\n",
+	       emm_rsp_sts.s.rsp_timeout ? "yes" : "no");
+	printf("    14:    rsp_crc_err:         %s\n",
+	       emm_rsp_sts.s.rsp_crc_err ? "yes" : "no");
+	printf("    13:    rsp_bad_sts:         %s\n",
+	       emm_rsp_sts.s.rsp_bad_sts ? "yes" : "no");
+	printf("    12:    rsp_val:             %s\n",
+	       emm_rsp_sts.s.rsp_val ? "yes" : "no");
+	printf("    9-11:  rsp_type:            %s\n",
+	       rtype_xor_str[emm_rsp_sts.s.rsp_type]);
+	printf("    7-8:   cmd_type:            %s\n",
+	       ctype_xor_str[emm_rsp_sts.s.cmd_type]);
+	printf("    1-6:   cmd_idx:             %u\n",
+	       emm_rsp_sts.s.cmd_idx);
+	printf("    0:     cmd_done:            %s\n",
+	       emm_rsp_sts.s.cmd_done ? "yes" : "no");
+
+	emm_rsp_lo.u = readq(host->base_addr + CAVM_MIO_EMM_RSP_LO());
+	printf("\nMIO_EMM_RSP_STS_LO:           0x%016llx\n", emm_rsp_lo.u);
+
+	emm_rsp_hi.u = readq(host->base_addr + CAVM_MIO_EMM_RSP_HI());
+	printf("\nMIO_EMM_RSP_STS_HI:           0x%016llx\n", emm_rsp_hi.u);
+
+	emm_int.u = readq(host->base_addr + CAVM_MIO_EMM_INT());
+	printf("\nMIO_EMM_INT:                  0x%016llx\n", emm_int.u);
+	printf("    6:    switch_err:           %s\n",
+	       emm_int.s.switch_err ? "yes" : "no");
+	printf("    5:    switch_done:          %s\n",
+	       emm_int.s.switch_done ? "yes" : "no");
+	printf("    4:    dma_err:              %s\n",
+	       emm_int.s.dma_err ? "yes" : "no");
+	printf("    3:    cmd_err:              %s\n",
+	       emm_int.s.cmd_err ? "yes" : "no");
+	printf("    2:    dma_done:             %s\n",
+	       emm_int.s.dma_done ? "yes" : "no");
+	printf("    1:    cmd_done:             %s\n",
+	       emm_int.s.cmd_done ? "yes" : "no");
+	printf("    0:    buf_done:             %s\n",
+	       emm_int.s.buf_done ? "yes" : "no");
+
+	emm_wdog.u = readq(host->base_addr + CAVM_MIO_EMM_WDOG());
+	printf("\nMIO_EMM_WDOG:                 0x%016llx (%u)\n",
+	       emm_wdog.u, emm_wdog.s.clk_cnt);
+
+#if defined(CONFIG_ARCH_OCTEONTX)
+	emm_sample.u = readq(host->base_addr + CAVM_MIO_EMM_SAMPLE());
+	printf("\nMIO_EMM_SAMPLE:               0x%016llx\n", emm_sample.u);
+	printf("    16-25: cmd_cnt:             %u\n", emm_sample.s.cmd_cnt);
+	printf("    0-9:   dat_cnt:             %u\n", emm_sample.s.dat_cnt);
+#endif
+
+	emm_sts_mask.u = readq(host->base_addr + CAVM_MIO_EMM_STS_MASK());
+	printf("\nMIO_EMM_STS_MASK:             0x%016llx\n", emm_sts_mask.u);
+
+	emm_rca.u = readq(host->base_addr + CAVM_MIO_EMM_RCA());
+	printf("\nMIO_EMM_RCA:                  0x%016llx\n", emm_rca.u);
+	printf("    0-15:  card_rca:            0x%04x\n",
+	       emm_rca.s.card_rca);
+#if !defined(CONFIG_ARCH_OCTEONTX)
+	emm_calb.u = readq(host->base_addr + CAVM_MIO_EMM_CALB());
+	printf("\nMIO_EMM_CALB:                 0x%016llx\n", emm_calb.u);
+	printf("       0:  start:               %u\n", emm_calb.s.start);
+	emm_tap.u = readq(host->base_addr + CAVM_MIO_EMM_TAP());
+	printf("\nMIO_EMM_TAP:                  0x%016llx\n", emm_tap.u);
+	printf("     7-0:  delay:               %u\n", emm_tap.s.delay);
+	emm_timing.u = readq(host->base_addr + CAVM_MIO_EMM_TIMING());
+	printf("\nMIO_EMM_TIMING:               0x%016llx\n", emm_timing.u);
+	printf("   53-48:  cmd_in_tap:          %u\n",
+	       emm_timing.s.cmd_in_tap);
+	printf("   37-32:  cmd_out_tap:         %u\n",
+	       emm_timing.s.cmd_out_tap);
+	printf("   21-16:  data_in_tap:         %u\n",
+	       emm_timing.s.data_in_tap);
+	printf("     5-0:  data_out_tap:        %u\n",
+	       emm_timing.s.data_out_tap);
+	io_ctl.u = readq(host->base_addr + CAVM_MIO_EMM_IO_CTL());
+	printf("\nMIO_IO_CTL:                   0x%016llx\n", io_ctl.u);
+	printf("     3-2:  drive:               %u (%u mA)\n",
+	       io_ctl.s.drive, 2 << io_ctl.s.drive);
+	printf("       0:  slew:                %u %s\n", io_ctl.s.slew,
+	       io_ctl.s.slew ? "high" : "low");
+	emm_debug.u = readq(host->base_addr + CAVM_MIO_EMM_DEBUG());
+	printf("\nMIO_EMM_DEBUG:                0x%016llx\n", emm_debug.u);
+	printf("   19-16: dma_sm:               0x%x\n", emm_debug.s.dma_sm);
+	printf("   15-12: data_sm:              0x%x\n", emm_debug.s.data_sm);
+	printf("    11-8: cmd_sm:               0x%x\n", emm_debug.s.cmd_sm);
+	printf("       0: clk_on:               0x%x\n", emm_debug.s.clk_on);
+#endif
+	puts("\n");
+}
+
+/**
+ * Print out all of the register values
+ *
+ * @param mmc	MMC device
+ */
+static void octeontx_mmc_print_registers(struct mmc *mmc)
+{
+#ifdef DEBUG_REGISTERS
+	const int print = 1;
+#else
+	const int print = 0;
+#endif
+	if (print)
+		octeontx_mmc_print_registers2(mmc, mmc_to_host(mmc));
+}
+
+static const struct octeontx_sd_mods octeontx_cr_types[] = {
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD0 */
+{ {0, 3}, {0, 3}, {0, 0} },	/* CMD1 */
+{ {0, 2}, {0, 2}, {0, 0} },	/* CMD2 */
+{ {0, 1}, {0, 3}, {0, 0} },	/* CMD3 SD_CMD_SEND_RELATIVE_ADDR 0, 2 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD4 */
+{ {0, 1}, {0, 1}, {0, 0} },	/* CMD5 */
+{ {0, 1}, {1, 1}, {0, 1} },	/* CMD6 SD_CMD_SWITCH_FUNC 1,0
+				 * (ACMD) SD_APP_SET_BUS_WIDTH
+				 */
+{ {0, 1}, {0, 1}, {0, 0} },	/* CMD7 */
+{ {1, 1}, {0, 3}, {0, 0} },	/* CMD8 SD_CMD_SEND_IF_COND 1,2 */
+{ {0, 2}, {0, 2}, {0, 0} },	/* CMD9 */
+{ {0, 2}, {0, 2}, {0, 0} },	/* CMD10 */
+{ {1, 1}, {0, 1}, {1, 1} },	/* CMD11 SD_CMD_SWITCH_UHS18V 1,0 */
+{ {0, 1}, {0, 1}, {0, 0} },	/* CMD12 */
+{ {0, 1}, {0, 1}, {1, 3} },	/* CMD13 (ACMD)) SD_CMD_APP_SD_STATUS 1,2 */
+{ {1, 1}, {1, 1}, {0, 0} },	/* CMD14 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD15 */
+{ {0, 1}, {0, 1}, {0, 0} },	/* CMD16 */
+{ {1, 1}, {1, 1}, {0, 0} },	/* CMD17 */
+{ {1, 1}, {1, 1}, {0, 0} },	/* CMD18 */
+{ {3, 1}, {3, 1}, {0, 0} },	/* CMD19 */
+{ {2, 1}, {0, 0}, {0, 0} },	/* CMD20 */	/* SD 2,0 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD21 */
+{ {0, 0}, {0, 0}, {1, 1} },	/* CMD22 (ACMD) SD_APP_SEND_NUM_WR_BLKS 1,0 */
+{ {0, 1}, {0, 1}, {0, 1} },	/* CMD23 */	/* SD ACMD 1,0 */
+{ {2, 1}, {2, 1}, {2, 1} },	/* CMD24 */
+{ {2, 1}, {2, 1}, {2, 1} },	/* CMD25 */
+{ {2, 1}, {2, 1}, {2, 1} },	/* CMD26 */
+{ {2, 1}, {2, 1}, {2, 1} },	/* CMD27 */
+{ {0, 1}, {0, 1}, {0, 1} },	/* CMD28 */
+{ {0, 1}, {0, 1}, {0, 1} },	/* CMD29 */
+{ {1, 1}, {1, 1}, {1, 1} },	/* CMD30 */
+{ {1, 1}, {1, 1}, {1, 1} },	/* CMD31 */
+{ {0, 0}, {0, 1}, {0, 0} },	/* CMD32 SD_CMD_ERASE_WR_BLK_START 0,1 */
+{ {0, 0}, {0, 1}, {0, 0} },	/* CMD33 SD_CMD_ERASE_WR_BLK_END 0,1 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD34 */
+{ {0, 1}, {0, 1}, {0, 1} },	/* CMD35 */
+{ {0, 1}, {0, 1}, {0, 1} },	/* CMD36 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD37 */
+{ {0, 1}, {0, 1}, {0, 1} },	/* CMD38 */
+{ {0, 4}, {0, 4}, {0, 4} },	/* CMD39 */
+{ {0, 5}, {0, 5}, {0, 5} },	/* CMD40 */
+{ {0, 0}, {0, 0}, {0, 3} },	/* CMD41 (ACMD) SD_CMD_APP_SEND_OP_COND 0,3 */
+{ {2, 1}, {2, 1}, {2, 1} },	/* CMD42 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD43 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD44 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD45 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD46 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD47 */
+{ {0, 0}, {1, 0}, {0, 0} },	/* CMD48 SD_CMD_READ_EXTR_SINGLE */
+{ {0, 0}, {2, 0}, {0, 0} },	/* CMD49 SD_CMD_WRITE_EXTR_SINGLE */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD50 */
+{ {0, 0}, {0, 0}, {1, 1} },	/* CMD51 (ACMD) SD_CMD_APP_SEND_SCR 1,1 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD52 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD53 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD54 */
+{ {0, 1}, {0, 1}, {0, 1} },	/* CMD55 */
+{ {0xff, 0xff}, {0xff, 0xff}, {0xff, 0xff} },	/* CMD56 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD57 */
+{ {0, 0}, {0, 3}, {0, 3} },	/* CMD58 SD_CMD_SPI_READ_OCR 0,3 */
+{ {0, 0}, {0, 1}, {0, 0} },	/* CMD59 SD_CMD_SPI_CRC_ON_OFF 0,1 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD60 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD61 */
+{ {0, 0}, {0, 0}, {0, 0} },	/* CMD62 */
+{ {0, 0}, {0, 0}, {0, 0} }	/* CMD63 */
+};
+
+/**
+ * Returns XOR values needed for SD commands and other quirks
+ *
+ * @param	mmc	mmc device
+ * @param	cmd	command information
+ *
+ * @return octeontx_mmc_cr_mods data structure with various quirks and flags
+ */
+static struct octeontx_mmc_cr_mods
+octeontx_mmc_get_cr_mods(struct mmc *mmc, const struct mmc_cmd *cmd,
+			 const struct mmc_data *data)
+{
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	struct octeontx_mmc_cr_mods cr = {0, 0};
+	const struct octeontx_sd_mods *sdm =
+					&octeontx_cr_types[cmd->cmdidx & 0x3f];
+	u8 c = sdm->mmc.c, r = sdm->mmc.r;
+	u8 desired_ctype = 0;
+
+	if (IS_MMC(mmc)) {
+#if defined(CONFIG_MMC_SUPPORTS_TUNING) || defined(MMC_SUPPORTS_TUNING)
+		if (cmd->cmdidx == MMC_CMD_SEND_TUNING_BLOCK_HS200) {
+			if (cmd->resp_type == MMC_RSP_R1)
+				cr.rtype_xor = 1;
+			if (data && data->flags & MMC_DATA_READ)
+				cr.ctype_xor = 1;
+		}
+#endif
+		return cr;
+	}
+
+	if (cmd->cmdidx == 56)
+		c = (cmd->cmdarg & 1) ? 1 : 2;
+
+	if (data) {
+		if (data->flags & MMC_DATA_READ)
+			desired_ctype = 1;
+		else if (data->flags & MMC_DATA_WRITE)
+			desired_ctype = 2;
+	}
+
+	cr.ctype_xor = c ^ desired_ctype;
+	if (slot->is_acmd)
+		cr.rtype_xor = r ^ sdm->sdacmd.r;
+	else
+		cr.rtype_xor = r ^ sdm->sd.r;
+
+	debug("%s(%s): mmc c: %d, mmc r: %d, desired c: %d, xor c: %d, xor r: %d\n",
+	      __func__, mmc->dev->name, c, r, desired_ctype,
+	      cr.ctype_xor, cr.rtype_xor);
+	return cr;
+}
+
+/**
+ * Keep track of switch commands internally
+ */
+static void octeontx_mmc_track_switch(struct mmc *mmc, u32 cmd_arg)
+{
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	u8 how = (cmd_arg >> 24) & 3;
+	u8 where = (u8)(cmd_arg >> 16);
+	u8 val = (u8)(cmd_arg >> 8);
+
+	slot->want_switch = slot->cached_switch;
+
+	if (slot->is_acmd)
+		return;
+
+	if (how != 3)
+		return;
+
+	switch (where) {
+	case EXT_CSD_BUS_WIDTH:
+		slot->want_switch.s.bus_width = val;
+		break;
+	case EXT_CSD_POWER_CLASS:
+		slot->want_switch.s.power_class = val;
+		break;
+	case EXT_CSD_HS_TIMING:
+		slot->want_switch.s.hs_timing = 0;
+		slot->want_switch.s.hs200_timing = 0;
+		slot->want_switch.s.hs400_timing = 0;
+		switch (val & 0xf) {
+		case 0:
+			break;
+		case 1:
+			slot->want_switch.s.hs_timing = 1;
+			break;
+		case 2:
+			if (!slot->is_asim && !slot->is_emul)
+				slot->want_switch.s.hs200_timing = 1;
+			break;
+		case 3:
+			if (!slot->is_asim && !slot->is_emul)
+				slot->want_switch.s.hs400_timing = 1;
+			break;
+		default:
+			pr_err("%s(%s): Unsupported timing mode 0x%x\n",
+			       __func__, mmc->dev->name, val & 0xf);
+			break;
+		}
+		break;
+	default:
+		break;
+	}
+}
+
+static int octeontx_mmc_print_rsp_errors(struct mmc *mmc,
+					 union cavm_mio_emm_rsp_sts rsp_sts)
+{
+	bool err = false;
+	const char *name = mmc->dev->name;
+
+	if (rsp_sts.s.acc_timeout) {
+		pr_warn("%s(%s): acc_timeout\n", __func__, name);
+		err = true;
+	}
+	if (rsp_sts.s.dbuf_err) {
+		pr_warn("%s(%s): dbuf_err\n", __func__, name);
+		err = true;
+	}
+	if (rsp_sts.s.blk_timeout) {
+		pr_warn("%s(%s): blk_timeout\n", __func__, name);
+		err = true;
+	}
+	if (rsp_sts.s.blk_crc_err) {
+		pr_warn("%s(%s): blk_crc_err\n", __func__, name);
+		err = true;
+	}
+	if (rsp_sts.s.stp_timeout) {
+		pr_warn("%s(%s): stp_timeout\n", __func__, name);
+		err = true;
+	}
+	if (rsp_sts.s.stp_crc_err) {
+		pr_warn("%s(%s): stp_crc_err\n", __func__, name);
+		err = true;
+	}
+	if (rsp_sts.s.stp_bad_sts) {
+		pr_warn("%s(%s): stp_bad_sts\n", __func__, name);
+		err = true;
+	}
+	if (err)
+		pr_warn("  rsp_sts: 0x%llx\n", rsp_sts.u);
+
+	return err ? -1 : 0;
+}
+
+/**
+ * Starts a DMA operation for block read/write
+ *
+ * @param	mmc	mmc device
+ * @param	write	true if write operation
+ * @param	clear	true to clear DMA operation
+ * @param	adr	source or destination DMA address
+ * @param	size	size in blocks
+ * @param	timeout	timeout in ms
+ */
+static void octeontx_mmc_start_dma(struct mmc *mmc, bool write,
+				   bool clear, u32 block, dma_addr_t adr,
+				   u32 size, int timeout)
+{
+	const struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	union cavm_mio_emm_dma_cfg emm_dma_cfg;
+	union cavm_mio_emm_dma_adr emm_dma_adr;
+	union cavm_mio_emm_dma emm_dma;
+
+	/* Clear any interrupts */
+	write_csr(mmc, CAVM_MIO_EMM_DMA_INT(),
+		  read_csr(mmc, CAVM_MIO_EMM_DMA_INT()));
+
+	emm_dma_cfg.u = 0;
+	emm_dma_cfg.s.en = 1;
+	emm_dma_cfg.s.rw = !!write;
+	emm_dma_cfg.s.clr = !!clear;
+	emm_dma_cfg.s.size = ((u64)(size * mmc->read_bl_len) / 8) - 1;
+#if __BYTE_ORDER != __BIG_ENDIAN
+	emm_dma_cfg.s.endian = 1;
+#endif
+	emm_dma_adr.u = 0;
+	emm_dma_adr.s.adr = adr;
+	write_csr(mmc, CAVM_MIO_EMM_DMA_ADR(), emm_dma_adr.u);
+	write_csr(mmc, CAVM_MIO_EMM_DMA_CFG(), emm_dma_cfg.u);
+
+	emm_dma.u = 0;
+	emm_dma.s.bus_id = slot->bus_id;
+	emm_dma.s.dma_val = 1;
+	emm_dma.s.rw = !!write;
+	emm_dma.s.sector = mmc->high_capacity ? 1 : 0;
+
+	if ((size > 1) && ((IS_SD(mmc) && (mmc->scr[0] & 2)) || !IS_SD(mmc)))
+		emm_dma.s.multi = 1;
+	else
+		emm_dma.s.multi = 0;
+
+	emm_dma.s.block_cnt = size;
+	if (!mmc->high_capacity)
+		block *= mmc->read_bl_len;
+	emm_dma.s.card_addr = block;
+	debug("%s(%s): card address: 0x%x, size: %d, multi: %d\n",
+	      __func__, mmc->dev->name, block, size, emm_dma.s.multi);
+
+	if (timeout > 0)
+		timeout = (timeout * 1000) - 1000;
+	set_wdog(mmc, timeout);
+
+	debug("  Writing 0x%llx to mio_emm_dma\n", emm_dma.u);
+	write_csr(mmc, CAVM_MIO_EMM_DMA(), emm_dma.u);
+}
+
+/**
+ * Waits for a DMA operation to complete
+ *
+ * @param	mmc	mmc device
+ * @param	timeout	timeout in ms
+ *
+ * @return	0 for success (could be DMA errors), -ETIMEDOUT on timeout
+ */
+
+/**
+ * Cleanup DMA engine after a failure
+ *
+ * @param	mmc	mmc device
+ * @param	rsp_sts	rsp status
+ */
+static void octeontx_mmc_cleanup_dma(struct mmc *mmc,
+				     union cavm_mio_emm_rsp_sts rsp_sts)
+{
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	union cavm_mio_emm_dma emm_dma;
+	ulong start;
+
+	debug("%s(%s): rsp_sts: 0x%llx, rsp_lo: 0x%llx, dma_int: 0x%llx\n",
+	      __func__, mmc->dev->name, rsp_sts.u,
+	      read_csr(mmc, CAVM_MIO_EMM_RSP_LO()),
+	      read_csr(mmc, CAVM_MIO_EMM_DMA_INT()));
+	emm_dma.u = read_csr(mmc, CAVM_MIO_EMM_DMA());
+	emm_dma.s.dma_val = 1;
+	emm_dma.s.dat_null = 1;
+	emm_dma.s.bus_id = slot->bus_id;
+	write_csr(mmc, CAVM_MIO_EMM_DMA(), emm_dma.u);
+	start = get_timer(0);
+	do {
+		rsp_sts.u = read_csr(mmc, CAVM_MIO_EMM_RSP_STS());
+		WATCHDOG_RESET();
+	} while (get_timer(start) < 100 && rsp_sts.s.dma_val);
+	if (rsp_sts.s.dma_val) {
+		pr_err("%s(%s): Error: could not clean up DMA.  RSP_STS: 0x%llx, RSP_LO: 0x%llx\n",
+		       __func__, mmc->dev->name, rsp_sts.u,
+		       read_csr(mmc, CAVM_MIO_EMM_RSP_LO()));
+	}
+	debug("  rsp_sts after clearing up DMA: 0x%llx\n",
+	      read_csr(mmc, CAVM_MIO_EMM_RSP_STS()));
+}
+
+/**
+ * Waits for a DMA operation to complete
+ *
+ * @param	mmc	mmc device
+ * @param	timeout	timeout in ms
+ *
+ * @return	0 for success (could be DMA errors), -ETIMEDOUT on timeout
+ *		or -EIO if IO error.
+ */
+static int octeontx_mmc_wait_dma(struct mmc *mmc, bool write, ulong timeout)
+{
+	ulong start_time = get_timer(0);
+	union cavm_mio_emm_dma_int emm_dma_int;
+	union cavm_mio_emm_rsp_sts rsp_sts;
+	union cavm_mio_emm_dma emm_dma;
+	bool timed_out = false;
+	bool err = false;
+	debug("%s(%s, %lu)\n", __func__, mmc->dev->name, timeout);
+
+	do {
+		emm_dma_int.u = read_csr(mmc, CAVM_MIO_EMM_DMA_INT());
+		rsp_sts.u = read_csr(mmc, CAVM_MIO_EMM_RSP_STS());
+		if (write) {
+			if ((rsp_sts.s.dma_pend && !rsp_sts.s.dma_val) ||
+			    rsp_sts.s.blk_timeout ||
+			    rsp_sts.s.stp_timeout ||
+			    rsp_sts.s.rsp_timeout) {
+				err = true;
+#ifdef DEBUG
+				debug("%s: f1\n", __func__);
+				octeontx_mmc_print_rsp_errors(mmc, rsp_sts);
+#endif
+				break;
+			}
+		} else {
+			if (rsp_sts.s.blk_crc_err ||
+			    (rsp_sts.s.dma_pend && !rsp_sts.s.dma_val)) {
+#ifdef DEBUG
+				octeontx_mmc_print_rsp_errors(mmc, rsp_sts);
+#endif
+				break;
+			}
+		}
+		if (rsp_sts.s.dma_pend) {
+			/* If this is set then an error has occurred.
+			 * Try and restart the DMA operation.
+			 */
+			emm_dma.u = read_csr(mmc, CAVM_MIO_EMM_DMA());
+			pr_err("%s(%s): DMA pending error: rsp_sts: 0x%llx, dma_int: 0x%llx, emm_dma: 0x%llx\n",
+			       __func__, mmc->dev->name, rsp_sts.u,
+			       emm_dma_int.u, emm_dma.u);
+			octeontx_print_rsp_sts(mmc);
+			debug("  MIO_EMM_DEBUG: 0x%llx\n",
+			      read_csr(mmc, CAVM_MIO_EMM_DEBUG()));
+			pr_err("%s: Trying DMA resume...\n", __func__);
+			emm_dma.s.dma_val = 1;
+			write_csr(mmc, CAVM_MIO_EMM_DMA(), emm_dma.u);
+		} else if (!rsp_sts.s.dma_val && emm_dma_int.s.done) {
+			break;
+		}
+		WATCHDOG_RESET();
+		timed_out = (get_timer(start_time) > timeout);
+	} while (!timed_out);
+
+	if (timed_out || err) {
+		pr_err("%s(%s): MMC DMA %s after %lu ms, rsp_sts: 0x%llx, dma_int: 0x%llx, rsp_sts_lo: 0x%llx, emm_dma: 0x%llx\n",
+		       __func__, mmc->dev->name,
+			timed_out ? "timed out" : "error",
+			get_timer(start_time), rsp_sts.u,
+		       emm_dma_int.u,
+		       read_csr(mmc, CAVM_MIO_EMM_RSP_LO()),
+		       read_csr(mmc, CAVM_MIO_EMM_DMA()));
+		octeontx_print_rsp_sts(mmc);
+		if (rsp_sts.s.dma_pend)
+			octeontx_mmc_cleanup_dma(mmc, rsp_sts);
+	} else {
+		write_csr(mmc, CAVM_MIO_EMM_DMA_INT(),
+			  read_csr(mmc, CAVM_MIO_EMM_DMA_INT()));
+	}
+
+	return timed_out ? -ETIMEDOUT : (err ? -EIO : 0);
+}
+
+/**
+ * Read blocks from the MMC/SD device
+ *
+ * @param	mmc	mmc device
+ * @param	cmd	command
+ * @param	data	data for read
+ *
+ * @return	number of blocks read or 0 if error
+ */
+static int octeontx_mmc_read_blocks(struct mmc *mmc, struct mmc_cmd *cmd,
+				    struct mmc_data *data)
+{
+	struct octeontx_mmc_host *host = mmc_to_host(mmc);
+	union cavm_mio_emm_rsp_sts rsp_sts;
+	dma_addr_t dma_addr = (dma_addr_t)dm_pci_virt_to_mem(host->dev,
+							     data->dest);
+	ulong count;
+	ulong blkcnt = data->blocks;
+	ulong start = cmd->cmdarg;
+	int timeout = 1000 + blkcnt * 20;
+	bool timed_out = false;
+	bool multi_xfer = cmd->cmdidx == MMC_CMD_READ_MULTIPLE_BLOCK;
+
+	debug("%s(%s): dest: %p, dma address: 0x%llx, blkcnt: %lu, start: %lu\n",
+	      __func__, mmc->dev->name, data->dest, dma_addr, blkcnt, start);
+	debug("%s: rsp_sts: 0x%llx\n", __func__,
+	      read_csr(mmc, CAVM_MIO_EMM_RSP_STS()));
+	/* use max timeout for multi-block transfers */
+	/* timeout = 0; */
+
+	/* If we have a valid SD card in the slot, we set the response bit
+	 * mask to check for CRC errors and timeouts only.
+	 * Otherwise, use the default power on reset value.
+	 */
+	write_csr(mmc, CAVM_MIO_EMM_STS_MASK(),
+		  IS_SD(mmc) ? 0x00b00000ull : 0xe4390080ull);
+	invalidate_dcache_range((u64)data->dest,
+				(u64)data->dest + blkcnt * data->blocksize);
+
+	if (multi_xfer) {
+		octeontx_mmc_start_dma(mmc, false, false, start, dma_addr,
+				       blkcnt, timeout);
+		timed_out = !!octeontx_mmc_wait_dma(mmc, false, timeout);
+		rsp_sts.u = read_csr(mmc, CAVM_MIO_EMM_RSP_STS());
+		if (timed_out || rsp_sts.s.dma_val || rsp_sts.s.dma_pend) {
+			pr_err("%s(%s): Error: DMA timed out.  rsp_sts: 0x%llx, emm_int: 0x%llx, dma_int: 0x%llx, rsp_lo: 0x%llx\n",
+			       __func__, mmc->dev->name, rsp_sts.u,
+			       read_csr(mmc, CAVM_MIO_EMM_INT()),
+			       read_csr(mmc, CAVM_MIO_EMM_DMA_INT()),
+			       read_csr(mmc, CAVM_MIO_EMM_RSP_LO()));
+			pr_err("%s: block count: %lu, start: 0x%lx\n",
+			       __func__, blkcnt, start);
+			octeontx_mmc_print_registers(mmc);
+			return 0;
+		}
+	} else {
+		count = blkcnt;
+		timeout = 1000;
+		do {
+			octeontx_mmc_start_dma(mmc, false, false, start,
+					       dma_addr, 1, timeout);
+			dma_addr += mmc->read_bl_len;
+			start++;
+
+			timed_out = !!octeontx_mmc_wait_dma(mmc, false,
+							    timeout);
+			rsp_sts.u = read_csr(mmc, CAVM_MIO_EMM_RSP_STS());
+			if (timed_out || rsp_sts.s.dma_val ||
+			    rsp_sts.s.dma_pend) {
+				pr_err("%s: Error: DMA timed out.  rsp_sts: 0x%llx, emm_int: 0x%llx, dma_int: 0x%llx, rsp_lo: 0x%llx\n",
+				       __func__, rsp_sts.u,
+				       read_csr(mmc, CAVM_MIO_EMM_INT()),
+				       read_csr(mmc, CAVM_MIO_EMM_DMA_INT()),
+				       read_csr(mmc, CAVM_MIO_EMM_RSP_LO()));
+				pr_err("%s: block count: 1, start: 0x%lx\n",
+				       __func__, start);
+				octeontx_mmc_print_registers(mmc);
+				return blkcnt - count;
+			}
+			WATCHDOG_RESET();
+		} while (--count);
+	}
+#ifdef DEBUG
+	debug("%s(%s): Read %lu (0x%lx) blocks starting at block %u (0x%x) to address %p (dma address 0x%llx)\n",
+	      __func__, mmc->dev->name, blkcnt, blkcnt,
+	      cmd->cmdarg, cmd->cmdarg, data->dest,
+	      dm_pci_virt_to_mem(host->dev, data->dest));
+	print_buffer(0, data->dest, 1, 0x200, 0);
+#endif
+	return blkcnt;
+}
+
+static int octeontx_mmc_poll_ready(struct mmc *mmc, ulong timeout)
+{
+	ulong start;
+	struct mmc_cmd cmd;
+	int err;
+	bool not_ready = false;
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.cmdidx = MMC_CMD_SEND_STATUS;
+	cmd.cmdarg = mmc->rca << 16;
+	cmd.resp_type = MMC_RSP_R1;
+	start = get_timer(0);
+	do {
+		err = octeontx_mmc_send_cmd(mmc, &cmd, NULL);
+		if (err) {
+			pr_err("%s(%s): MMC command error: %d; Retry...\n",
+			       __func__, mmc->dev->name, err);
+			not_ready = true;
+		} else if (cmd.response[0] & R1_READY_FOR_DATA) {
+			return 0;
+		}
+		WATCHDOG_RESET();
+	} while (get_timer(start) < timeout);
+
+	if (not_ready)
+		pr_err("%s(%s): MMC command error; Retry timeout\n",
+		       __func__, mmc->dev->name);
+	return -ETIMEDOUT;
+}
+
+static ulong octeontx_mmc_write_blocks(struct mmc *mmc, struct mmc_cmd *cmd,
+				       struct mmc_data *data)
+{
+	struct octeontx_mmc_host *host = mmc_to_host(mmc);
+	ulong start = cmd->cmdarg;
+	ulong blkcnt = data->blocks;
+	dma_addr_t dma_addr;
+	union cavm_mio_emm_rsp_sts rsp_sts;
+	union cavm_mio_emm_sts_mask emm_sts_mask;
+	ulong timeout;
+	int count;
+	bool timed_out = false;
+	bool multi_xfer = (blkcnt > 1) &&
+			((IS_SD(mmc) && mmc->scr[0] & 2) || !IS_SD(mmc));
+
+	octeontx_mmc_switch_to(mmc);
+	emm_sts_mask.u = 0;
+	emm_sts_mask.s.sts_msk = R1_BLOCK_WRITE_MASK;
+	write_csr(mmc, CAVM_MIO_EMM_STS_MASK(), emm_sts_mask.u);
+
+	if (octeontx_mmc_poll_ready(mmc, 10000)) {
+		pr_err("%s(%s): Ready timed out\n", __func__, mmc->dev->name);
+		return 0;
+	}
+	flush_dcache_range((u64)data->src,
+			   (u64)data->src + blkcnt * mmc->write_bl_len);
+	dma_addr = (u64)dm_pci_virt_to_mem(host->dev, (void *)data->src);
+	if (multi_xfer) {
+		timeout = 5000 + 100 * blkcnt;
+		octeontx_mmc_start_dma(mmc, true, false, start, dma_addr,
+				       blkcnt, timeout);
+		timed_out = !!octeontx_mmc_wait_dma(mmc, true, timeout);
+		rsp_sts.u = read_csr(mmc, CAVM_MIO_EMM_RSP_STS());
+		if (timed_out || rsp_sts.s.dma_val || rsp_sts.s.dma_pend) {
+			pr_err("%s(%s): Error: multi-DMA timed out after %lums.  rsp_sts: 0x%llx, emm_int: 0x%llx, emm_dma_int: 0x%llx, rsp_sts_lo: 0x%llx, emm_dma: 0x%llx\n",
+			       __func__, mmc->dev->name, timeout,
+			       rsp_sts.u,
+			       read_csr(mmc, CAVM_MIO_EMM_INT()),
+			       read_csr(mmc, CAVM_MIO_EMM_DMA_INT()),
+			       read_csr(mmc, CAVM_MIO_EMM_RSP_LO()),
+			       read_csr(mmc, CAVM_MIO_EMM_DMA()));
+			return 0;
+		}
+	} else {
+		timeout = 5000;
+		count = blkcnt;
+		do {
+			octeontx_mmc_start_dma(mmc, true, false, start,
+					       dma_addr, 1, timeout);
+			dma_addr += mmc->read_bl_len;
+			start++;
+
+			timed_out = !!octeontx_mmc_wait_dma(mmc, true, timeout);
+			if (timed_out || rsp_sts.s.dma_val ||
+			    rsp_sts.s.dma_pend) {
+				pr_err("%s(%s): Error: single-DMA timed out after %lums.  rsp_sts: 0x%llx, emm_int: 0x%llx, emm_dma_int: 0x%llx, rsp_sts_lo: 0x%llx, emm_dma: 0x%llx\n",
+				       __func__, mmc->dev->name, timeout,
+				       rsp_sts.u,
+				       read_csr(mmc, CAVM_MIO_EMM_RSP_STS()),
+				       read_csr(mmc, CAVM_MIO_EMM_DMA_INT()),
+				       read_csr(mmc, CAVM_MIO_EMM_RSP_LO()),
+				       read_csr(mmc, CAVM_MIO_EMM_DMA()));
+				return blkcnt - count;
+			}
+			WATCHDOG_RESET();
+		} while (--count);
+	}
+
+	return blkcnt;
+}
+
+/**
+ * Send a command to the eMMC/SD device
+ *
+ * @param mmc	mmc device
+ * @param cmd	cmd to send and response
+ * @param data	additional data
+ * @param flags
+ * @return	0 for success, otherwise error
+ */
+static int octeontx_mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd,
+				 struct mmc_data *data)
+{
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	const char *name = slot->dev->name;
+	struct octeontx_mmc_cr_mods mods = {0, 0};
+	union cavm_mio_emm_rsp_sts rsp_sts;
+	union cavm_mio_emm_cmd emm_cmd;
+	union cavm_mio_emm_rsp_lo rsp_lo;
+	union cavm_mio_emm_buf_idx emm_buf_idx;
+	union cavm_mio_emm_buf_dat emm_buf_dat;
+	ulong start;
+	int i;
+	ulong blkcnt;
+
+	/**
+	 * This constant has a 1 bit for each command which should have a short
+	 * timeout and a 0 for each bit with a long timeout.  Currently the
+	 * following commands have a long timeout:
+	 *   CMD6, CMD17, CMD18, CMD24, CMD25, CMD32, CMD33, CMD35, CMD36 and
+	 *   CMD38.
+	 */
+	static const u64 timeout_short = 0xFFFFFFA4FCF9FFDFull;
+	uint timeout;
+
+	if (cmd->cmdidx == MMC_CMD_SEND_EXT_CSD) {
+		union cavm_mio_emm_rca emm_rca;
+
+		emm_rca.u = 0;
+		emm_rca.s.card_rca = mmc->rca;
+		write_csr(mmc, CAVM_MIO_EMM_RCA(), emm_rca.u);
+	}
+
+	if (timeout_short & (1ull << cmd->cmdidx))
+		timeout = MMC_TIMEOUT_SHORT;
+	else if (cmd->cmdidx == MMC_CMD_SWITCH && IS_SD(mmc))
+		timeout = 2560;
+	else if (cmd->cmdidx == MMC_CMD_ERASE)
+		timeout = MMC_TIMEOUT_ERASE;
+	else
+		timeout = MMC_TIMEOUT_LONG;
+
+	debug("%s(%s): cmd idx: %u, arg: 0x%x, resp type: 0x%x, timeout: %u\n",
+		 __func__, name, cmd->cmdidx, cmd->cmdarg, cmd->resp_type,
+		 timeout);
+	if (data)
+		debug("  data: addr: %p, flags: 0x%x, blocks: %u, blocksize: %u\n",
+		      data->dest, data->flags, data->blocks, data->blocksize);
+
+	octeontx_mmc_switch_to(mmc);
+
+	/* Clear any interrupts */
+	write_csr(mmc, CAVM_MIO_EMM_INT(), read_csr(mmc, CAVM_MIO_EMM_INT()));
+
+	/* We need to override the default command types and response types
+	 * when dealing with SD cards.
+	 */
+	mods = octeontx_mmc_get_cr_mods(mmc, cmd, data);
+
+	/* Handle block read/write/stop operations */
+	switch (cmd->cmdidx) {
+	case MMC_CMD_GO_IDLE_STATE:
+		slot->tuned = false;
+		slot->hs200_tuned = false;
+		break;
+	case MMC_CMD_STOP_TRANSMISSION:
+		return 0;
+	case MMC_CMD_READ_MULTIPLE_BLOCK:
+	case MMC_CMD_READ_SINGLE_BLOCK:
+		pr_debug("%s(%s): Reading blocks\n", __func__, name);
+		blkcnt = octeontx_mmc_read_blocks(mmc, cmd, data);
+		return (blkcnt > 0) ? 0 : -1;
+	case MMC_CMD_WRITE_MULTIPLE_BLOCK:
+	case MMC_CMD_WRITE_SINGLE_BLOCK:
+		blkcnt = octeontx_mmc_write_blocks(mmc, cmd, data);
+		return (blkcnt > 0) ? 0 : -1;
+	case MMC_CMD_SELECT_CARD:
+		/* Set the RCA register (is it set automatically?) */
+		if (IS_SD(mmc)) {
+			union cavm_mio_emm_rca emm_rca;
+
+			emm_rca.u = 0;
+			emm_rca.s.card_rca = (cmd->cmdarg >> 16);
+			write_csr(mmc, CAVM_MIO_EMM_RCA(), emm_rca.u);
+			debug("%s: Set SD relative address (RCA) to 0x%x\n",
+			      __func__, emm_rca.s.card_rca);
+		}
+		break;
+
+	case MMC_CMD_SWITCH:
+		if (!data && !slot->is_acmd)
+			octeontx_mmc_track_switch(mmc, cmd->cmdarg);
+		break;
+	}
+
+	emm_cmd.u = 0;
+	emm_cmd.s.cmd_val = 1;
+	emm_cmd.s.bus_id = slot->bus_id;
+	emm_cmd.s.cmd_idx = cmd->cmdidx;
+	emm_cmd.s.arg = cmd->cmdarg;
+	emm_cmd.s.ctype_xor = mods.ctype_xor;
+	emm_cmd.s.rtype_xor = mods.rtype_xor;
+	if (data && (data->blocks == 1) && (data->blocksize != 512)) {
+		emm_cmd.s.offset =
+			64 - ((data->blocks * data->blocksize) / 8);
+		debug("%s: offset set to %u\n", __func__, emm_cmd.s.offset);
+	}
+
+	if (data && data->flags & MMC_DATA_WRITE) {
+		u8 *src = (u8 *)data->src;
+
+		if (!src) {
+			pr_err("%s(%s): Error: data source for cmd 0x%x is NULL!\n",
+			       __func__, name, cmd->cmdidx);
+			return -1;
+		}
+		if (data->blocksize > 512) {
+			pr_err("%s(%s): Error: data for cmd 0x%x exceeds 512 bytes\n",
+			       __func__, name, cmd->cmdidx);
+			return -1;
+		}
+#ifdef DEBUG
+		debug("%s: Sending %d bytes data\n", __func__, data->blocksize);
+		print_buffer(0, src, 1, data->blocksize, 0);
+#endif
+		emm_buf_idx.u = 0;
+		emm_buf_idx.s.inc = 1;
+		write_csr(mmc, CAVM_MIO_EMM_BUF_IDX(), emm_buf_idx.u);
+		for (i = 0; i < (data->blocksize + 7) / 8; i++) {
+			memcpy(&emm_buf_dat.u, src, sizeof(emm_buf_dat.u));
+			write_csr(mmc, CAVM_MIO_EMM_BUF_DAT(),
+				  cpu_to_be64(emm_buf_dat.u));
+			src += sizeof(emm_buf_dat.u);
+		}
+		write_csr(mmc, CAVM_MIO_EMM_BUF_IDX(), 0);
+
+	}
+	debug("%s(%s): Sending command %u (emm_cmd: 0x%llx)\n", __func__,
+	      name, cmd->cmdidx, emm_cmd.u);
+	set_wdog(mmc, timeout * 1000);
+	write_csr(mmc, CAVM_MIO_EMM_CMD(), emm_cmd.u);
+
+	/* Wait for command to finish or time out */
+	start = get_timer(0);
+	do {
+		rsp_sts.u = read_csr(mmc, CAVM_MIO_EMM_RSP_STS());
+		WATCHDOG_RESET();
+	} while (!rsp_sts.s.cmd_done && !rsp_sts.s.rsp_timeout &&
+		 (get_timer(start) < timeout + 10));
+	octeontx_mmc_print_rsp_errors(mmc, rsp_sts);
+	if (rsp_sts.s.rsp_timeout || !rsp_sts.s.cmd_done) {
+		debug("%s(%s): Error: command %u(0x%x) timed out.  rsp_sts: 0x%llx\n",
+		      __func__, name, cmd->cmdidx, cmd->cmdarg, rsp_sts.u);
+		octeontx_mmc_print_registers(mmc);
+		return -ETIMEDOUT;
+	}
+	if (rsp_sts.s.rsp_crc_err) {
+		debug("%s(%s): RSP CRC error, rsp_sts: 0x%llx, cmdidx: %u, arg: 0x%08x\n",
+		      __func__, name, rsp_sts.u, cmd->cmdidx, cmd->cmdarg);
+		octeontx_mmc_print_registers(mmc);
+		return -1;
+	}
+	if (slot->bus_id != rsp_sts.s.bus_id) {
+		pr_warn("%s(%s): bus id mismatch, got %d, expected %d for command 0x%x(0x%x)\n",
+			__func__, name,
+			rsp_sts.s.bus_id, slot->bus_id,
+			cmd->cmdidx, cmd->cmdarg);
+		goto error;
+	}
+	if (rsp_sts.s.rsp_bad_sts) {
+		rsp_lo.u = read_csr(mmc, CAVM_MIO_EMM_RSP_LO());
+		debug("%s: Bad response for bus id %d, cmd id %d:\n"
+		      "    rsp_timeout: %d\n"
+		      "    rsp_bad_sts: %d\n"
+		      "    rsp_crc_err: %d\n",
+		      __func__, slot->bus_id, cmd->cmdidx,
+		      rsp_sts.s.rsp_timeout,
+		      rsp_sts.s.rsp_bad_sts,
+		      rsp_sts.s.rsp_crc_err);
+		if (rsp_sts.s.rsp_type == 1 && rsp_sts.s.rsp_bad_sts) {
+			debug("    Response status: 0x%llx\n",
+			      (rsp_lo.u >> 8) & 0xffffffff);
+#ifdef DEBUG
+			mmc_print_status((rsp_lo.u >> 8) & 0xffffffff);
+#endif
+		}
+		goto error;
+	}
+	if (rsp_sts.s.cmd_idx != cmd->cmdidx) {
+		debug("%s(%s): Command response index %d does not match command index %d\n",
+		      __func__, name, rsp_sts.s.cmd_idx, cmd->cmdidx);
+		octeontx_print_rsp_sts(mmc);
+		debug("%s: rsp_lo: 0x%llx\n", __func__,
+		      read_csr(mmc, CAVM_MIO_EMM_RSP_LO()));
+
+		goto error;
+	}
+
+	slot->is_acmd = (cmd->cmdidx == MMC_CMD_APP_CMD);
+
+	if (!cmd->resp_type & MMC_RSP_PRESENT)
+		debug("  Response type: 0x%x, no response expected\n",
+		      cmd->resp_type);
+	/* Get the response if present */
+	if (rsp_sts.s.rsp_val && (cmd->resp_type & MMC_RSP_PRESENT)) {
+		union cavm_mio_emm_rsp_hi rsp_hi;
+
+		rsp_lo.u = read_csr(mmc, CAVM_MIO_EMM_RSP_LO());
+
+		switch (rsp_sts.s.rsp_type) {
+		case 1:
+		case 3:
+		case 4:
+		case 5:
+			cmd->response[0] = (rsp_lo.u >> 8) & 0xffffffffull;
+			debug("  response: 0x%08x\n",
+			      cmd->response[0]);
+			cmd->response[1] = 0;
+			cmd->response[2] = 0;
+			cmd->response[3] = 0;
+			break;
+		case 2:
+			cmd->response[3] = rsp_lo.u & 0xffffffff;
+			cmd->response[2] = (rsp_lo.u >> 32) & 0xffffffff;
+			rsp_hi.u = read_csr(mmc, CAVM_MIO_EMM_RSP_HI());
+			cmd->response[1] = rsp_hi.u & 0xffffffff;
+			cmd->response[0] = (rsp_hi.u >> 32) & 0xffffffff;
+			debug("  response: 0x%08x 0x%08x 0x%08x 0x%08x\n",
+			      cmd->response[0], cmd->response[1],
+			      cmd->response[2], cmd->response[3]);
+			break;
+		default:
+			pr_err("%s(%s): Unknown response type 0x%x for command %d, arg: 0x%x, rsp_sts: 0x%llx\n",
+			       __func__, name, rsp_sts.s.rsp_type, cmd->cmdidx,
+			       cmd->cmdarg, rsp_sts.u);
+			return -1;
+		}
+	} else {
+		debug("  Response not expected\n");
+	}
+
+	if (data && data->flags & MMC_DATA_READ) {
+		u8 *dest = (u8 *)data->dest;
+
+		if (!dest) {
+			pr_err("%s(%s): Error, destination buffer NULL!\n",
+			       __func__, mmc->dev->name);
+			goto error;
+		}
+		if (data->blocksize > 512) {
+			printf("%s(%s): Error: data size %u exceeds 512\n",
+			       __func__, mmc->dev->name,
+			       data->blocksize);
+			goto error;
+		}
+		emm_buf_idx.u = 0;
+		emm_buf_idx.s.inc = 1;
+		write_csr(mmc, CAVM_MIO_EMM_BUF_IDX(), emm_buf_idx.u);
+		for (i = 0; i < (data->blocksize + 7) / 8; i++) {
+			emm_buf_dat.u = read_csr(mmc, CAVM_MIO_EMM_BUF_DAT());
+			emm_buf_dat.u = be64_to_cpu(emm_buf_dat.u);
+			memcpy(dest, &emm_buf_dat.u, sizeof(emm_buf_dat.u));
+			dest += sizeof(emm_buf_dat.u);
+		}
+		write_csr(mmc, CAVM_MIO_EMM_BUF_IDX(), 0);
+#ifdef DEBUG
+		debug("%s: Received %d bytes data\n", __func__,
+		      data->blocksize);
+		print_buffer(0, data->dest, 1, data->blocksize, 0);
+#endif
+	}
+
+	return 0;
+error:
+#ifdef DEBUG
+	octeontx_mmc_print_registers(mmc);
+#endif
+	return -1;
+}
+
+static int octeontx_mmc_dev_send_cmd(struct udevice *dev, struct mmc_cmd *cmd,
+				     struct mmc_data *data)
+{
+	return octeontx_mmc_send_cmd(dev_to_mmc(dev), cmd, data);
+}
+
+#if defined(CONFIG_MMC_SUPPORTS_TUNING) || defined(MMC_SUPPORTS_TUNING)
+static int octeontx_mmc_test_cmd(struct mmc *mmc, u32 opcode, int *statp)
+{
+	struct mmc_cmd cmd;
+	int err;
+
+	memset(&cmd, 0, sizeof(cmd));
+
+	debug("%s(%s, %u, %p)\n", __func__, mmc->dev->name, opcode, statp);
+	cmd.cmdidx = opcode;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = mmc->rca << 16;
+
+	err = octeontx_mmc_send_cmd(mmc, &cmd, NULL);
+	if (err)
+		debug("%s(%s, %u) returned %d\n", __func__,
+		      mmc->dev->name, opcode, err);
+	if (statp)
+		*statp = cmd.response[0];
+	return err;
+}
+
+static int octeontx_mmc_test_get_ext_csd(struct mmc *mmc, u32 opcode,
+					 int *statp)
+{
+	struct mmc_cmd cmd;
+	struct mmc_data data;
+	int err;
+	u8 ext_csd[MMC_MAX_BLOCK_LEN];
+
+	debug("%s(%s, %u, %p)\n",  __func__, mmc->dev->name, opcode, statp);
+	memset(&cmd, 0, sizeof(cmd));
+
+	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = 0;
+
+	data.dest = (char *)ext_csd;
+	data.blocks = 1;
+	data.blocksize = MMC_MAX_BLOCK_LEN;
+	data.flags = MMC_DATA_READ;
+
+	err = octeontx_mmc_send_cmd(mmc, &cmd, &data);
+	if (statp)
+		*statp = cmd.response[0];
+
+	return err;
+}
+
+/**
+ * Wrapper to set the MIO_EMM_TIMING register
+ *
+ * @param	mmc		pointer to mmc data structure
+ * @param	emm_timing	New emm_timing register value
+ *
+ * On some devices it is possible that changing the data out value can
+ * cause a glitch on an internal fifo.  This works around this problem
+ * by performing a soft-reset immediately before setting the timing register.
+ *
+ * Note: this function should not be called from any function that
+ * performs DMA or block operations since not all registers are
+ * preserved.
+ */
+static void octeontx_mmc_set_emm_timing(struct mmc *mmc,
+					union cavm_mio_emm_timing emm_timing)
+{
+	union cavm_mio_emm_cfg emm_cfg;
+
+	pr_debug("%s(%s, 0x%llx) din: %u\n", __func__, mmc->dev->name,
+		 emm_timing.u, emm_timing.s.data_in_tap);
+
+	emm_cfg.u = read_csr(mmc, CAVM_MIO_EMM_CFG());
+	emm_cfg.s.bus_ena = 1 << 3;
+	write_csr(mmc, CAVM_MIO_EMM_CFG(), emm_cfg.u);
+	udelay(1);
+	write_csr(mmc, CAVM_MIO_EMM_TIMING(), emm_timing.u);
+	udelay(1);
+	emm_cfg.s.bus_ena = 1 << mmc_to_slot(mmc)->bus_id;
+	write_csr(mmc, CAVM_MIO_EMM_CFG(), emm_cfg.u);
+}
+
+struct adj {
+	const char *name;
+	u8 mask_shift;
+	int (*test)(struct mmc *mmc, u32 opcode, int *error);
+	u32 opcode;
+	bool ddr_only;
+	bool hs200_only;
+	bool not_hs200_only;
+	u8 num_runs;
+};
+
+struct adj adj[] = {
+	{ "CMD_IN", 48, octeontx_mmc_test_cmd, MMC_CMD_SEND_STATUS,
+	  false, false, false, 2, },
+/*	{ "CMD_OUT", 32, octeontx_mmc_test_cmd, MMC_CMD_SEND_STATUS, },*/
+	{ "DATA_IN(HS200)", 16, mmc_send_tuning, 0, false, true, false, 2, },
+	{ "DATA_IN", 16, octeontx_mmc_test_get_ext_csd, 0, false, false,
+	  true, 2, },
+/*	{ "DATA_OUT", 0, octeontx_mmc_test_cmd, 0, true, false},*/
+	{ NULL, },
+};
+
+/**
+ * Perform tuning tests to find optimal timing
+ *
+ * @param	mmc	mmc device
+ * @param	adj	parameter to tune
+ * @param	opcode	command opcode to use
+ *
+ * @return	0 for success, -1 if tuning failed
+ */
+static int octeontx_mmc_adjust_tuning(struct mmc *mmc, struct adj *adj,
+				      u32 opcode)
+{
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	union cavm_mio_emm_timing timing;
+	int tap;
+	int err;
+	int run = 0;
+	int count;
+	int start_run = -1;
+	int best_run = 0;
+	int best_start = -1;
+	bool prev_ok = false;
+#ifdef DEBUG
+	char how[MAX_NO_OF_TAPS + 1] = "";
+#endif
+	bool is_hs200 = mmc->selected_mode == MMC_HS_200;
+
+	octeontx_mmc_set_emm_timing(mmc,
+				    is_hs200 ? slot->taps : slot->hs200_taps);
+
+#ifdef DEBUG
+	if (opcode == MMC_CMD_SEND_TUNING_BLOCK_HS200) {
+		printf("%s(%s): Before tuning %s, opcode: %d\n",
+		       __func__, mmc->dev->name, adj->name, opcode);
+		octeontx_mmc_print_registers2(mmc, NULL);
+	}
+#endif
+
+	/* The algorithm to find the optimal timing is to start
+	 * at the end and work backwards and select the second
+	 * value that passes.  Each test is repeated twice.
+	 */
+	for (tap = 0; tap <= MAX_NO_OF_TAPS; tap++, prev_ok = !err) {
+		if (tap < MAX_NO_OF_TAPS) {
+			timing.u = read_csr(mmc, CAVM_MIO_EMM_TIMING());
+			timing.u &= ~(0x3full << adj->mask_shift);
+			timing.u |= (u64)tap << adj->mask_shift;
+			write_csr(mmc, CAVM_MIO_EMM_TIMING(), timing.u);
+			debug("%s(%s): Testing ci: %d, co: %d, di: %d, do: %d\n",
+			      __func__, mmc->dev->name, timing.s.cmd_in_tap,
+			      timing.s.cmd_out_tap, timing.s.data_in_tap,
+			      timing.s.data_out_tap);
+
+			for (count = 0; count < 2; count++) {
+				err = adj->test(mmc, opcode, NULL);
+				if (err) {
+					debug("%s(%s, %s): tap %d failed, count: %d, rsp_sts: 0x%llx, rsp_lo: 0x%llx\n",
+					      __func__, mmc->dev->name,
+					      adj->name, tap, count,
+					      read_csr(mmc,
+						       CAVM_MIO_EMM_RSP_STS()),
+					      read_csr(mmc,
+						       CAVM_MIO_EMM_RSP_LO()));
+					debug("%s(%s, %s): tap: %d, do: %d, di: %d, co: %d, ci: %d\n",
+					      __func__, mmc->dev->name,
+					      adj->name, tap,
+					      timing.s.data_out_tap,
+					      timing.s.data_in_tap,
+					      timing.s.cmd_out_tap,
+					      timing.s.cmd_in_tap);
+					break;
+				}
+				debug("%s(%s, %s): tap %d passed, count: %d, rsp_sts: 0x%llx, rsp_lo: 0x%llx\n",
+				      __func__, mmc->dev->name, adj->name, tap,
+				      count,
+				      read_csr(mmc, CAVM_MIO_EMM_RSP_STS()),
+				      read_csr(mmc, CAVM_MIO_EMM_RSP_LO()));
+			}
+#ifdef DEBUG
+			how[tap] = "-+"[!err];
+#endif
+		} else {
+			/* Putting the end+1 case in the loop simplifies
+			 * logic, allowing 'prev_ok' to process a sweet
+			 * spot in tuning which extends to the wall.
+			 */
+			err = -EINVAL;
+		}
+		if (!err) {
+			/* If no CRC/etc errors in the response, but previous
+			 * failed, note the start of a new run.
+			 */
+			debug("  prev_ok: %d\n", prev_ok);
+			if (!prev_ok)
+				start_run = tap;
+		} else if (prev_ok) {
+			run = tap - 1 - start_run;
+			/* did we just exit a wider sweet spot? */
+			if (start_run >= 0 && run > best_run) {
+				best_start = start_run;
+				best_run = run;
+			}
+		}
+	}
+#ifdef DEBUG
+	how[tap - 1] = '\0';
+#endif
+	if (best_start < 0) {
+		printf("%s(%s, %s): %lldMHz tuning %s failed\n", __func__,
+		       mmc->dev->name, adj->name, slot->clock / 1000000,
+		       adj->name);
+		return -EINVAL;
+	}
+
+	tap = best_start + best_run / 2;
+#ifdef DEBUG
+	how[tap] = '@';
+	debug("%s/%s %d/%d/%d %s\n", mmc->dev->name,
+	      adj->name, best_start, tap, best_start + best_run, how);
+#endif
+	if (is_hs200) {
+		slot->hs200_taps.u &= ~(0x3full << adj->mask_shift);
+		slot->hs200_taps.u |= (u64)tap << adj->mask_shift;
+	} else {
+		slot->taps.u &= ~(0x3full << adj->mask_shift);
+		slot->taps.u |= (u64)tap << adj->mask_shift;
+	}
+#ifdef DEBUG
+	how[tap - 1] = '\0';
+#endif
+	if (best_start < 0) {
+		printf("%s(%s, %s): %lldMHz tuning %s failed\n", __func__,
+		       mmc->dev->name, adj->name, slot->clock / 1000000,
+		       adj->name);
+		return -EINVAL;
+	}
+
+	tap = best_start + best_run / 2;
+#ifdef DEBUG
+	how[tap] = '@';
+	debug("%s/%s %d/%d/%d %s\n", mmc->dev->name,
+	      adj->name, best_start, tap, best_start + best_run, how);
+#endif
+	slot->taps.u &= ~(0x3full << adj->mask_shift);
+	slot->taps.u |= (u64)tap << adj->mask_shift;
+
+
+#ifdef DEBUG
+	if (opcode == MMC_CMD_SEND_TUNING_BLOCK_HS200) {
+		debug("%s(%s, %s): After successful tuning\n",
+		      __func__, mmc->dev->name, adj->name);
+		debug("%s(%s, %s): tap: %d, new do: %d, di: %d, co: %d, ci: %d\n",
+		      __func__, mmc->dev->name, adj->name, tap,
+		      slot->taps.s.data_out_tap,
+		      slot->taps.s.data_in_tap,
+		      slot->taps.s.cmd_out_tap,
+		      slot->taps.s.cmd_in_tap);
+	}
+#endif
+	octeontx_mmc_set_timing(mmc);
+
+	return 0;
+}
+
+static int octeontx_mmc_execute_tuning(struct udevice *dev, u32 opcode)
+{
+	struct mmc *mmc = dev_to_mmc(dev);
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	union cavm_mio_emm_timing emm_timing;
+	int err;
+	struct adj *a;
+	bool is_hs200;
+
+	pr_info("%s re-tuning, opcode 0x%x\n", dev->name, opcode);
+
+	if (slot->is_asim || slot->is_emul)
+		return 0;
+
+	is_hs200 = ((mmc->selected_mode == MMC_HS_200) ||
+		    (mmc->selected_mode == MMC_HS_400));
+	if (is_hs200)
+		slot->hs200_tuned = false;
+	else
+		slot->tuned = false;
+	octeontx_mmc_set_output_bus_timing(mmc);
+	octeontx_mmc_set_input_bus_timing(mmc);
+	emm_timing.u = read_csr(mmc, CAVM_MIO_EMM_TIMING());
+	if (mmc->selected_mode == MMC_HS_200) {
+		slot->hs200_taps.s.cmd_out_tap = emm_timing.s.cmd_out_tap;
+		slot->hs200_taps.s.data_out_tap = emm_timing.s.data_out_tap;
+	} else {
+		slot->taps.s.cmd_out_tap = emm_timing.s.cmd_out_tap;
+		slot->taps.s.data_out_tap = emm_timing.s.data_out_tap;
+	}
+	octeontx_mmc_set_input_bus_timing(mmc);
+	octeontx_mmc_set_output_bus_timing(mmc);
+
+	for (a = adj; a->name; a++) {
+		debug("%s(%s): Testing: %s, mode: %s, opcode: %u\n", __func__,
+		      dev->name, a->name, mmc_mode_name(mmc->selected_mode),
+		      opcode);
+		/* Skip DDR only test when not in DDR mode */
+		if (a->ddr_only && !mmc->ddr_mode) {
+			debug("%s(%s): Skipping %s due to non-DDR mode\n",
+			      __func__, dev->name, a->name);
+			continue;
+		}
+		/* Skip hs200 tests in non-hs200 mode and
+		 * non-hs200 tests in hs200 mode
+		 */
+		if (is_hs200) {
+			if (a->not_hs200_only) {
+				debug("%s(%s): Skipping %s\n", __func__,
+				      dev->name, a->name);
+				continue;
+			}
+		} else {
+			if (a->hs200_only) {
+				debug("%s(%s): Skipping %s\n", __func__,
+				      dev->name, a->name);
+				continue;
+			}
+		}
+
+		err = octeontx_mmc_adjust_tuning(mmc, a,
+					a->opcode ? a->opcode : opcode);
+		if (err) {
+			pr_err("%s(%s, %u): tuning %s failed\n", __func__,
+			       dev->name, opcode, a->name);
+			return err;
+		}
+	}
+
+	octeontx_mmc_set_timing(mmc);
+	if (is_hs200)
+		slot->hs200_tuned = true;
+	else
+		slot->tuned = true;
+
+	return 0;
+}
+#endif /* defined(CONFIG_MMC_SUPPORTS_TUNING) || defined(MMC_SUPPORTS_TUNING) */
+
+/**
+ * Calculate the clock period with rounding up
+ *
+ * @param	mmc	mmc device
+ * @return	clock period in system clocks for clk_lo + clk_hi
+ */
+u32 octeontx_mmc_calc_clk_period(struct mmc *mmc)
+{
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	struct octeontx_mmc_host *host = slot->host;
+
+	return (host->sys_freq + (mmc->clock * 2) - 1) / mmc->clock;
+}
+
+static int octeontx_mmc_set_ios(struct udevice *dev)
+{
+	struct octeontx_mmc_slot *slot = dev_to_mmc_slot(dev);
+	struct mmc *mmc = &slot->mmc;
+	struct octeontx_mmc_host *host = slot->host;
+	union cavm_mio_emm_switch emm_switch;
+	union cavm_mio_emm_modex mode;
+	uint clock;
+	int bus_width = 0;
+	int clk_period = 0;
+	int power_class = 10;
+	int err = 0;
+	bool is_hs200 = false;
+
+	debug("%s(%s): Entry\n", __func__, dev->name);
+	debug("  clock: %u, bus width: %u, mode: %u\n", mmc->clock,
+	      mmc->bus_width, mmc->selected_mode);
+	debug("  host caps: 0x%x, card caps: 0x%x\n", mmc->host_caps,
+	      mmc->card_caps);
+	octeontx_mmc_switch_to(mmc);
+
+	clock = mmc->clock;
+	if (!clock)
+		clock = mmc->cfg->f_min;
+
+	switch (mmc->bus_width) {
+	case 8:
+		bus_width = 2;
+		break;
+	case 4:
+		bus_width = 1;
+		break;
+	case 1:
+		bus_width = 0;
+		break;
+	default:
+		pr_warn("%s(%s): Invalid bus width %d, defaulting to 1\n",
+			__func__, dev->name, mmc->bus_width);
+		bus_width = 0;
+	}
+
+	/* DDR is available for 4/8 bit bus width */
+	if (mmc->ddr_mode && bus_width)
+		bus_width |= 4;
+
+	debug("%s: sys_freq: %llu\n", __func__, host->sys_freq);
+	clk_period = octeontx_mmc_calc_clk_period(mmc);
+
+	emm_switch.u = 0;
+	emm_switch.s.bus_width = bus_width;
+	emm_switch.s.power_class = power_class;
+	emm_switch.s.clk_hi = clk_period / 2;
+	emm_switch.s.clk_lo = clk_period / 2;
+
+	debug("%s: last mode: %d, mode: %d, last clock: %u, clock: %u, ddr: %d\n",
+	      __func__, slot->last_mode, mmc->selected_mode,
+	      slot->last_clock, mmc->clock, mmc->ddr_mode);
+	switch (mmc->selected_mode) {
+	case MMC_LEGACY:
+	case SD_LEGACY:
+		break;
+	case MMC_HS:
+	case SD_HS:
+	case MMC_HS_52:
+		emm_switch.s.hs_timing = 1;
+		break;
+	case MMC_HS_200:
+		is_hs200 = true;
+		/* fall through */
+	case UHS_SDR12:
+	case UHS_SDR25:
+	case UHS_SDR50:
+	case UHS_SDR104:
+		emm_switch.s.hs200_timing = 1;
+		break;
+	case MMC_HS_400:
+		is_hs200 = true;
+		/* fall through */
+	case UHS_DDR50:
+	case MMC_DDR_52:
+		emm_switch.s.hs400_timing = 1;
+		break;
+	default:
+		pr_err("%s(%s): Unsupported mode 0x%x\n", __func__, dev->name,
+		       mmc->selected_mode);
+		return -1;
+	}
+	emm_switch.s.bus_id = slot->bus_id;
+
+	if (!is_hs200 &&
+	    (mmc->selected_mode != slot->last_mode ||
+	     mmc->clock != slot->last_clock) &&
+	    !mmc->ddr_mode) {
+		slot->tuned = false;
+		slot->last_mode = mmc->selected_mode;
+		slot->last_clock = mmc->clock;
+	}
+
+#if CONFIG_IS_ENABLED(MMC_VERBOSE) || defined(debug)
+	debug("%s(%s): Setting bus mode to %s\n", __func__, dev->name,
+	      mmc_mode_name(mmc->selected_mode));
+#else
+	debug("%s(%s): Setting bus mode to 0x%x\n", __func__, dev->name,
+	      mmc->selected_mode);
+#endif
+	debug(" Trying switch 0x%llx w%d hs:%d hs200:%d hs400:%d\n",
+	      emm_switch.u, emm_switch.s.bus_width, emm_switch.s.hs_timing,
+	      emm_switch.s.hs200_timing, emm_switch.s.hs400_timing);
+
+	set_wdog(mmc, 1000);
+	do_switch(mmc, emm_switch);
+	mdelay(100);
+	mode.u = read_csr(mmc, CAVM_MIO_EMM_MODEX(slot->bus_id));
+	debug("%s(%s): mode: 0x%llx w:%d, hs:%d, hs200:%d, hs400:%d\n",
+	      __func__, dev->name, mode.u, mode.s.bus_width,
+	      mode.s.hs_timing, mode.s.hs200_timing, mode.s.hs400_timing);
+
+	err = octeontx_mmc_configure_delay(mmc);
+
+	return err;
+}
+
+/**
+ * Gets the status of the card detect pin
+ */
+static int octeontx_mmc_get_cd(struct udevice *dev)
+{
+	struct octeontx_mmc_slot *slot = dev_to_mmc_slot(dev);
+	int val = 1;
+
+	if (dm_gpio_is_valid(&slot->cd_gpio)) {
+		val = dm_gpio_get_value(&slot->cd_gpio);
+		val ^= slot->cd_inverted;
+	}
+	debug("%s(%s): cd: %d\n", __func__, dev->name, val);
+	return val;
+}
+
+/**
+ * Gets the status of the write protect pin
+ */
+static int octeontx_mmc_get_wp(struct udevice *dev)
+{
+	struct octeontx_mmc_slot *slot = dev_to_mmc_slot(dev);
+	int val = 0;
+
+	if (dm_gpio_is_valid(&slot->wp_gpio)) {
+		val = dm_gpio_get_value(&slot->wp_gpio);
+		val ^= slot->wp_inverted;
+	}
+	debug("%s(%s): wp: %d\n", __func__, dev->name, val);
+	return val;
+}
+
+#if defined(CONFIG_MMC_SUPPORTS_TUNING) || defined(MMC_SUPPORTS_TUNING)
+static void octeontx_mmc_set_timing(struct mmc *mmc)
+{
+	union cavm_mio_emm_timing timing;
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+
+	if (mmc->selected_mode == MMC_HS_200 ||
+	    mmc->selected_mode == MMC_HS_400)
+		timing = slot->hs200_taps;
+	else
+		timing = slot->taps;
+
+	debug("%s(%s):\n  cmd_in_tap: %u\n  cmd_out_tap: %u\n  data_in_tap: %u\n  data_out_tap: %u\n",
+	      __func__, mmc->dev->name, timing.s.cmd_in_tap,
+	      timing.s.cmd_out_tap, timing.s.data_in_tap,
+	      timing.s.data_out_tap);
+
+	octeontx_mmc_set_emm_timing(mmc, timing);
+}
+#endif
+
+static int octeontx_mmc_configure_delay(struct mmc *mmc)
+{
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	bool __maybe_unused is_hs200;
+
+	debug("%s(%s)\n", __func__, mmc->dev->name);
+#if defined(CONFIG_ARCH_OCTEONTX)
+	{
+		union cavm_mio_emm_sample emm_sample;
+
+		emm_sample.u = 0;
+		emm_sample.s.cmd_cnt = slot->cmd_cnt;
+		emm_sample.s.dat_cnt = slot->dat_cnt;
+		write_csr(mmc, CAVM_MIO_EMM_SAMPLE(), emm_sample.u);
+	}
+#else
+	is_hs200 = ((mmc->selected_mode == MMC_HS_200) ||
+		    (mmc->selected_mode == MMC_HS_400));
+
+	if ((is_hs200 && slot->hs200_tuned) || (!is_hs200 && slot->tuned)) {
+		octeontx_mmc_set_output_bus_timing(mmc);
+	} else {
+		int half = MAX_NO_OF_TAPS / 2;
+		int dout, cout;
+
+		switch (mmc->selected_mode) {
+		case MMC_LEGACY:
+			cout = MMC_LEGACY_DEFAULT_CMD_OUT_TAP;
+			dout = MMC_LEGACY_DEFAULT_DATA_OUT_TAP;
+			break;
+		case SD_LEGACY:
+			cout = MMC_SD_LEGACY_DEFAULT_CMD_OUT_TAP;
+			dout = MMC_SD_LEGACY_DEFAULT_DATA_OUT_TAP;
+			break;
+		case MMC_HS:
+			cout = MMC_HS_CMD_OUT_TAP;
+			dout = MMC_HS_DATA_OUT_TAP;
+			break;
+		case SD_HS:
+		case UHS_SDR12:
+		case UHS_SDR25:
+		case UHS_SDR50:
+			cout = MMC_SD_HS_CMD_OUT_TAP;
+			dout = MMC_SD_HS_DATA_OUT_TAP;
+			break;
+		case UHS_SDR104:
+		case UHS_DDR50:
+		case MMC_HS_52:
+		case MMC_DDR_52:
+			cout = MMC_DEFAULT_CMD_OUT_TAP;
+			dout = MMC_DEFAULT_DATA_OUT_TAP;
+			break;
+		case MMC_HS_200:
+		case MMC_HS_400:
+			cout = MMC_DEFAULT_HS200_CMD_OUT_TAP;
+			dout = MMC_DEFAULT_HS200_DATA_OUT_TAP;
+			is_hs200 = true;
+			break;
+		default:
+			pr_err("%s(%s): Invalid mode %d\n", __func__,
+			       mmc->dev->name, mmc->selected_mode);
+			return -1;
+		}
+		debug("%s(%s): Not tuned, hs200: %d, hs200 tuned: %d, tuned: %d\n",
+		      __func__, mmc->dev->name, is_hs200, slot->hs200_tuned,
+		      slot->tuned);
+		if (!is_hs200) {
+			slot->taps.u = 0;
+			slot->taps.s.cmd_out_tap = cout;
+			slot->taps.s.data_out_tap = dout;
+			slot->taps.s.cmd_in_tap = half;
+			slot->taps.s.data_in_tap = half;
+		} else {
+			slot->hs200_taps.u = 0;
+			slot->hs200_taps.s.cmd_out_tap = cout;
+			slot->hs200_taps.s.data_out_tap = dout;
+			slot->hs200_taps.s.cmd_in_tap = half;
+			slot->hs200_taps.s.data_in_tap = half;
+		}
+	}
+
+	if (is_hs200)
+		debug("%s(%s): taps: ci: %u, co: %u, di: %u, do: %u\n",
+		      __func__, mmc->dev->name,
+		      slot->hs200_taps.s.cmd_in_tap,
+		      slot->hs200_taps.s.cmd_out_tap,
+		      slot->hs200_taps.s.data_in_tap,
+		      slot->hs200_taps.s.data_out_tap);
+	else
+		debug("%s(%s): taps: ci: %u, co: %u, di: %u, do: %u\n",
+		      __func__, mmc->dev->name, slot->taps.s.cmd_in_tap,
+		      slot->taps.s.cmd_out_tap, slot->taps.s.data_in_tap,
+		      slot->taps.s.data_out_tap);
+	octeontx_mmc_set_timing(mmc);
+#endif
+	return 0;
+}
+
+/**
+ * Sets the MMC watchdog timer in microseconds
+ *
+ * @param	mmc	mmc device
+ * @param	us	timeout in microseconds, 0 for maximum timeout
+ */
+static void set_wdog(struct mmc *mmc, u64 us)
+{
+	union cavm_mio_emm_wdog wdog;
+	u64 val;
+
+	val = (us * mmc->clock) / 1000000;
+	if (val >= (1 << 26) || !us) {
+		if (us)
+			pr_debug("%s: warning: timeout %llu exceeds max value %llu, truncating\n",
+				 __func__, us,
+				 (u64)(((1ULL << 26) - 1) * 1000000ULL) /
+					mmc->clock);
+		val = (1 << 26) - 1;
+	}
+	wdog.u = 0;
+	wdog.s.clk_cnt = val;
+	write_csr(mmc, CAVM_MIO_EMM_WDOG(), wdog.u);
+}
+
+/**
+ * Set the IO drive strength and slew
+ *
+ * @param	mmc	mmc device
+ */
+static void octeontx_mmc_io_drive_setup(struct mmc *mmc)
+{
+#if !defined(CONFIG_ARCH_OCTEONTX)
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	union cavm_mio_emm_io_ctl io_ctl;
+
+	if ((slot->drive < 0) || (slot->slew < 0))
+		return;
+	io_ctl.u = 0;
+	io_ctl.s.drive = slot->drive;
+	io_ctl.s.slew = slot->slew;
+	write_csr(mmc, CAVM_MIO_EMM_IO_CTL(), io_ctl.u);
+#endif
+}
+
+/**
+ * Print switch errors
+ *
+ * @param	mmc	mmc device
+ */
+static void check_switch_errors(struct mmc *mmc)
+{
+	union cavm_mio_emm_switch emm_switch;
+
+	emm_switch.u = read_csr(mmc, CAVM_MIO_EMM_SWITCH());
+	if (emm_switch.s.switch_err0)
+		pr_err("%s: Switch power class error\n", mmc->cfg->name);
+	if (emm_switch.s.switch_err1)
+		pr_err("%s: Switch HS timing error\n", mmc->cfg->name);
+	if (emm_switch.s.switch_err2)
+		pr_err("%s: Switch bus width error\n", mmc->cfg->name);
+}
+
+static void do_switch(struct mmc *mmc, union cavm_mio_emm_switch emm_switch)
+{
+	union cavm_mio_emm_rsp_sts rsp_sts;
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	int bus_id = emm_switch.s.bus_id;
+	ulong start;
+
+	if (emm_switch.s.bus_id != 0) {
+		emm_switch.s.bus_id = 0;
+		write_csr(mmc, CAVM_MIO_EMM_SWITCH(), emm_switch.u);
+		udelay(100);
+		emm_switch.s.bus_id = bus_id;
+	}
+	write_csr(mmc, CAVM_MIO_EMM_SWITCH(), emm_switch.u);
+
+	start = get_timer(0);
+	do {
+		rsp_sts.u = read_csr(mmc, CAVM_MIO_EMM_RSP_STS());
+		if (!rsp_sts.s.switch_val)
+			break;
+		udelay(100);
+	} while (get_timer(start) < 10);
+	if (rsp_sts.s.switch_val) {
+		pr_warn("%s(%s): Warning: writing 0x%llx to emm_switch timed out, status: 0x%llx\n",
+			__func__, mmc->dev->name, emm_switch.u, rsp_sts.u);
+	}
+	slot->cached_switch = emm_switch;
+	check_switch_errors(mmc);
+	slot->cached_switch.u = emm_switch.u;
+	debug("%s: emm_switch: 0x%llx, rsp_lo: 0x%llx\n",
+	      __func__, read_csr(mmc, CAVM_MIO_EMM_SWITCH()),
+				 read_csr(mmc, CAVM_MIO_EMM_RSP_LO()));
+}
+
+#ifndef CONFIG_ARCH_OCTEONTX
+/**
+ * Given a delay in ps, return the tap delay count
+ *
+ * @param	mmc	mmc data structure
+ * @param	delay	delay in picoseconds
+ *
+ * @return	Number of tap cycles or error if -1
+ */
+static int octeontx2_mmc_calc_delay(struct mmc *mmc, int delay)
+{
+	struct octeontx_mmc_host *host = mmc_to_host(mmc);
+
+	if (host->is_asim || host->is_emul)
+		return 63;
+
+	if (!host->timing_taps) {
+		pr_err("%s(%s): Error: host timing not calibrated\n",
+		       __func__, mmc->dev->name);
+		return -1;
+	}
+	debug("%s(%s, %d) timing taps: %llu\n", __func__, mmc->dev->name,
+	      delay, host->timing_taps);
+	return min((int)((delay + host->timing_taps - 1) / host->timing_taps),
+		   63);
+}
+
+/**
+ * Calibrates the delay based on the internal clock
+ *
+ * @param	mmc	Pointer to mmc data structure
+ *
+ * @return	0 for success or -ETIMEDOUT on error
+ *
+ * NOTE: On error a default value will be calculated.
+ */
+static int octeontx_mmc_calibrate_delay(struct mmc *mmc)
+{
+	union cavm_mio_emm_calb emm_calb;
+	union cavm_mio_emm_tap emm_tap;
+	union cavm_mio_emm_cfg emm_cfg;
+	union cavm_mio_emm_io_ctl emm_io_ctl;
+	union cavm_mio_emm_switch emm_switch;
+	union cavm_mio_emm_wdog emm_wdog;
+	union cavm_mio_emm_sts_mask emm_sts_mask;
+	union cavm_mio_emm_debug emm_debug;
+	union cavm_mio_emm_timing emm_timing;
+	struct octeontx_mmc_host *host = mmc_to_host(mmc);
+	ulong start;
+	u8 bus_id, bus_ena;
+
+	debug("%s: Calibrating delay\n", __func__);
+	if (host->is_asim || host->is_emul) {
+		debug("  No calibration for ASIM\n");
+		return 0;
+	}
+	emm_tap.u = 0;
+	if (host->calibrate_glitch) {
+		emm_tap.s.delay = MMC_DEFAULT_TAP_DELAY;
+	} else {
+		/* Save registers */
+		emm_cfg.u = read_csr(mmc, CAVM_MIO_EMM_CFG());
+		emm_io_ctl.u = read_csr(mmc, CAVM_MIO_EMM_IO_CTL());
+		emm_switch.u = read_csr(mmc, CAVM_MIO_EMM_SWITCH());
+		emm_wdog.u = read_csr(mmc, CAVM_MIO_EMM_WDOG());
+		emm_sts_mask.u = read_csr(mmc, CAVM_MIO_EMM_STS_MASK());
+		emm_debug.u = read_csr(mmc, CAVM_MIO_EMM_DEBUG());
+		emm_timing.u = read_csr(mmc, CAVM_MIO_EMM_TIMING());
+		bus_ena = emm_cfg.s.bus_ena;
+		bus_id = emm_switch.s.bus_id;
+		emm_cfg.s.bus_ena = 0;
+		write_csr(mmc, CAVM_MIO_EMM_CFG(), emm_cfg.u);
+		udelay(1);
+		emm_cfg.s.bus_ena = 1ULL << 3;
+		write_csr(mmc, CAVM_MIO_EMM_CFG(), emm_cfg.u);
+		mdelay(1);
+		emm_calb.u = 0;
+		write_csr(mmc, CAVM_MIO_EMM_CALB(), emm_calb.u);
+		emm_calb.s.start = 1;
+		write_csr(mmc, CAVM_MIO_EMM_CALB(), emm_calb.u);
+		start = get_timer(0);
+		/* This should only take 3 microseconds */
+		do {
+			udelay(5);
+			emm_tap.u = read_csr(mmc, CAVM_MIO_EMM_TAP());
+		} while (!emm_tap.s.delay && get_timer(start) < 10);
+
+		emm_calb.s.start = 0;
+		write_csr(mmc, CAVM_MIO_EMM_CALB(), emm_calb.u);
+
+		emm_cfg.s.bus_ena = 0;
+		write_csr(mmc, CAVM_MIO_EMM_CFG(), emm_cfg.u);
+		udelay(1);
+		/* Restore registers */
+		emm_cfg.s.bus_ena = bus_ena;
+		write_csr(mmc, CAVM_MIO_EMM_CFG(), emm_cfg.u);
+		write_csr(mmc, CAVM_MIO_EMM_TIMING(), emm_timing.u);
+		udelay(1);
+		write_csr(mmc, CAVM_MIO_EMM_IO_CTL(), emm_io_ctl.u);
+		bus_id = emm_switch.s.bus_id;
+		emm_switch.s.bus_id = 0;
+		write_csr(mmc, CAVM_MIO_EMM_SWITCH(), emm_switch.u);
+		emm_switch.s.bus_id = bus_id;
+		write_csr(mmc, CAVM_MIO_EMM_SWITCH(), emm_switch.u);
+		write_csr(mmc, CAVM_MIO_EMM_WDOG(), emm_wdog.u);
+		write_csr(mmc, CAVM_MIO_EMM_STS_MASK(), emm_sts_mask.u);
+		write_csr(mmc, CAVM_MIO_EMM_RCA(), mmc->rca);
+		write_csr(mmc, CAVM_MIO_EMM_DEBUG(), emm_debug.u);
+
+		if (!emm_tap.s.delay) {
+			pr_err("%s: Error: delay calibration failed, timed out.\n",
+			       __func__);
+			/* Set to default value if timed out */
+			emm_tap.s.delay = MMC_DEFAULT_TAP_DELAY;
+			return -ETIMEDOUT;
+		}
+	}
+	/* Round up */
+	host->timing_taps = ((10 * 1000 * emm_tap.s.delay) + 511) / 512;
+	debug("%s(%s): timing taps: %llu, delay: %u\n",
+	      __func__, mmc->dev->name, host->timing_taps, emm_tap.s.delay);
+	return 0;
+}
+#endif
+
+static int octeontx_mmc_set_input_bus_timing(struct mmc *mmc)
+{
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+
+#ifdef CONFIG_ARCH_OCTEONTX
+	union cavm_mio_emm_sample sample;
+
+	sample.u = 0;
+	sample.s.cmd_cnt = slot->cmd_clk_skew;
+	sample.s.dat_cnt = slot->dat_clk_skew;
+	write_csr(mmc, CAVM_MIO_EMM_SAMPLE(), sample.u);
+
+#else
+	union cavm_mio_emm_timing timing;
+
+	timing.u = read_csr(mmc, CAVM_MIO_EMM_TIMING());
+	if (mmc->selected_mode == MMC_HS_200 ||
+	    mmc->selected_mode == MMC_HS_400) {
+		if (slot->hs200_tuned) {
+			timing.s.cmd_in_tap = slot->hs200_taps.s.cmd_in_tap;
+			timing.s.data_in_tap = slot->hs200_taps.s.data_in_tap;
+		} else {
+			pr_warn("%s(%s): Warning: hs200 timing not tuned\n",
+				__func__, mmc->dev->name);
+			timing.s.cmd_in_tap = MMC_DEFAULT_HS200_CMD_IN_TAP;
+			timing.s.data_in_tap = MMC_DEFAULT_HS200_DATA_IN_TAP;
+		}
+	} else if (slot->tuned) {
+		timing.s.cmd_in_tap = slot->taps.s.cmd_in_tap;
+		timing.s.data_in_tap = slot->taps.s.data_in_tap;
+	} else {
+		timing.s.cmd_in_tap = MMC_DEFAULT_CMD_IN_TAP;
+		timing.s.data_in_tap = MMC_DEFAULT_DATA_IN_TAP;
+	}
+	octeontx_mmc_set_emm_timing(mmc, timing);
+#endif
+	return 0;
+}
+
+/**
+ * Sets the default bus timing for the current mode.
+ *
+ * @param	mmc	mmc data structure
+ *
+ * @return	0 for success, error otherwise
+ */
+static int octeontx_mmc_set_output_bus_timing(struct mmc *mmc)
+{
+#ifdef CONFIG_ARCH_OCTEONTX
+	return 0;
+#else
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	union cavm_mio_emm_timing timing;
+	int cout_bdelay, dout_bdelay;
+	unsigned int cout_delay, dout_delay;
+	char env_name[32];
+
+	debug("%s(%s)\n", __func__, mmc->dev->name);
+	if (slot->is_asim || slot->is_emul)
+		return 0;
+
+	octeontx_mmc_calibrate_delay(mmc);
+
+	if (mmc->clock < 26000000) {
+		cout_delay = 5000;
+		dout_delay = 5000;
+	} else if (mmc->clock <= 52000000) {
+		cout_delay = 2500;
+		dout_delay = 2500;
+	} else if (!mmc->ddr_mode) {
+		cout_delay = 2000;
+		dout_delay = 2000;
+	} else {
+		cout_delay = 2000;
+		dout_delay = 2000;
+	}
+
+	snprintf(env_name, sizeof(env_name), "mmc%d_hs200_dout_delay_ps",
+		 slot->bus_id);
+	dout_delay = env_get_ulong(env_name, 10, dout_delay);
+	debug("%s: dout_delay: %u\n", __func__, dout_delay);
+
+	cout_bdelay = octeontx2_mmc_calc_delay(mmc, cout_delay);
+	dout_bdelay = octeontx2_mmc_calc_delay(mmc, dout_delay);
+
+	debug("%s: cmd output delay: %u, data output delay: %u, cmd bdelay: %d, data bdelay: %d, clock: %d\n",
+	      __func__, cout_delay, dout_delay, cout_bdelay, dout_bdelay,
+	      mmc->clock);
+	if (cout_bdelay < 0 || dout_bdelay < 0) {
+		pr_err("%s: Error: could not calculate command and/or data clock skew\n",
+		       __func__);
+		return -1;
+	}
+	timing.u = read_csr(mmc, CAVM_MIO_EMM_TIMING());
+	timing.s.cmd_out_tap = cout_bdelay;
+	timing.s.data_out_tap = dout_bdelay;
+	if (mmc->selected_mode == MMC_HS_200 ||
+	    mmc->selected_mode == MMC_HS_400) {
+		slot->hs200_taps.s.cmd_out_tap = cout_bdelay;
+		slot->hs200_taps.s.data_out_tap = dout_bdelay;
+	} else {
+		slot->taps.s.cmd_out_tap = cout_bdelay;
+		slot->taps.s.data_out_tap = dout_bdelay;
+	}
+	octeontx_mmc_set_emm_timing(mmc, timing);
+	debug("%s(%s): bdelay: %d/%d, clock: %d, ddr: %s, timing taps: %llu, do: %d, di: %d, co: %d, ci: %d\n",
+	      __func__, mmc->dev->name, cout_bdelay, dout_bdelay, mmc->clock,
+	      mmc->ddr_mode ? "yes" : "no",
+	      mmc_to_host(mmc)->timing_taps,
+	      timing.s.data_out_tap,
+	      timing.s.data_in_tap,
+	      timing.s.cmd_out_tap,
+	      timing.s.cmd_in_tap);
+	return 0;
+#endif
+}
+
+static void octeontx_mmc_set_clock(struct mmc *mmc)
+{
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	uint clock;
+
+	clock = min(mmc->cfg->f_max, (uint)slot->clock);
+	clock = max(mmc->cfg->f_min, clock);
+	debug("%s(%s): f_min: %u, f_max: %u, clock: %u\n", __func__,
+	      mmc->dev->name, mmc->cfg->f_min, mmc->cfg->f_max, clock);
+	slot->clock = clock;
+	mmc->clock = clock;
+}
+
+/**
+ * This switches I/O power as needed when switching between slots.
+ *
+ * @param	mmc	mmc data structure
+ */
+static void octeontx_mmc_switch_io(struct mmc *mmc)
+{
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	struct octeontx_mmc_host *host = slot->host;
+	struct mmc *last_mmc = host->last_mmc;
+	static struct udevice *last_reg;
+	union cavm_mio_emm_cfg emm_cfg;
+	int bus;
+	static bool initialized;
+
+	/* First time? */
+	if (!initialized || (mmc != host->last_mmc)) {
+		struct mmc *ommc;
+
+		/* Switch to bus 3 which is unused */
+		emm_cfg.u = read_csr(mmc, CAVM_MIO_EMM_CFG());
+		emm_cfg.s.bus_ena = 1 << 3;
+		write_csr(mmc, CAVM_MIO_EMM_CFG(), emm_cfg.u);
+
+		/* Turn off all other I/O interfaces with first initialization
+		 * if at least one supply was found.
+		 */
+		for (bus = 0; bus <= OCTEONTX_MAX_MMC_SLOT; bus++) {
+			ommc = &host->slots[bus].mmc;
+
+			/* Handle self case later */
+			if ((ommc == mmc) || !ommc->vqmmc_supply)
+				continue;
+
+			/* Skip if we're not switching regulators */
+			if (last_reg == mmc->vqmmc_supply)
+				continue;
+
+			/* Turn off other regulators */
+			if (ommc->vqmmc_supply != mmc->vqmmc_supply)
+				regulator_set_enable(ommc->vqmmc_supply, false);
+		}
+		/* Turn ourself on */
+		if (mmc->vqmmc_supply && last_reg != mmc->vqmmc_supply)
+			regulator_set_enable(mmc->vqmmc_supply, true);
+		mdelay(1);	/* Settle time */
+		/* Switch to new bus */
+		emm_cfg.s.bus_ena = 1 << slot->bus_id;
+		write_csr(mmc, CAVM_MIO_EMM_CFG(), emm_cfg.u);
+		last_reg = mmc->vqmmc_supply;
+		initialized = true;
+		return;
+	}
+
+	/* No change in device */
+	if (last_mmc == mmc)
+		return;
+
+	if (!last_mmc) {
+		pr_warn("%s(%s): No previous slot detected in IO slot switch!\n",
+			__func__, mmc->dev->name);
+		return;
+	}
+
+	debug("%s(%s): last: %s, supply: %p\n", __func__, mmc->dev->name,
+	      last_mmc->dev->name, mmc->vqmmc_supply);
+
+	/* The supply is the same so we do nothing */
+	if (last_mmc->vqmmc_supply == mmc->vqmmc_supply)
+		return;
+
+	/* Turn off the old slot I/O supply */
+	if (last_mmc->vqmmc_supply) {
+		debug("%s(%s): Turning off IO to %s, supply: %s\n",
+		      __func__, mmc->dev->name, last_mmc->dev->name,
+		      last_mmc->vqmmc_supply->name);
+		regulator_set_enable(last_mmc->vqmmc_supply, false);
+	}
+	/* Turn on the new slot I/O supply */
+	if (mmc->vqmmc_supply)  {
+		debug("%s(%s): Turning on IO to slot %d, supply: %s\n",
+		      __func__, mmc->dev->name, slot->bus_id,
+		      mmc->vqmmc_supply->name);
+		regulator_set_enable(mmc->vqmmc_supply, true);
+	}
+	/* Allow power to settle */
+	mdelay(1);
+}
+
+/**
+ * Called to switch between mmc devices
+ *
+ * @param	mmc	new mmc device
+ */
+static void octeontx_mmc_switch_to(struct mmc *mmc)
+{
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	struct octeontx_mmc_slot *old_slot;
+	struct octeontx_mmc_host *host = slot->host;
+	union cavm_mio_emm_switch emm_switch;
+	union cavm_mio_emm_sts_mask emm_sts_mask;
+	union cavm_mio_emm_rca emm_rca;
+
+	if (slot->bus_id == host->last_slotid)
+		return;
+
+	debug("%s(%s) switching from slot %d to slot %d\n", __func__,
+	      mmc->dev->name, host->last_slotid, slot->bus_id);
+	octeontx_mmc_switch_io(mmc);
+
+	if (host->last_slotid >= 0 && slot->valid) {
+		old_slot = &host->slots[host->last_slotid];
+		old_slot->cached_switch.u = read_csr(mmc, CAVM_MIO_EMM_SWITCH());
+		old_slot->cached_rca.u = read_csr(mmc, CAVM_MIO_EMM_RCA());
+	}
+	if (mmc->rca)
+		write_csr(mmc, CAVM_MIO_EMM_RCA(), mmc->rca);
+	emm_switch = slot->cached_switch;
+	do_switch(mmc, emm_switch);
+	emm_rca.u = 0;
+	emm_rca.s.card_rca = mmc->rca;
+	write_csr(mmc, CAVM_MIO_EMM_RCA(), emm_rca.u);
+	mdelay(100);
+
+	set_wdog(mmc, 100000);
+	if (octeontx_mmc_set_output_bus_timing(mmc) ||
+	    octeontx_mmc_set_input_bus_timing(mmc))
+		pr_err("%s(%s): Error setting bus timing\n", __func__,
+		       mmc->dev->name);
+	octeontx_mmc_io_drive_setup(mmc);
+
+	emm_sts_mask.u = 0;
+	emm_sts_mask.s.sts_msk = 1 << 7 | 1 << 22 | 1 << 23 | 1 << 19;
+	write_csr(mmc, CAVM_MIO_EMM_STS_MASK(), emm_sts_mask.u);
+	host->last_slotid = slot->bus_id;
+	host->last_mmc = mmc;
+	mdelay(10);
+}
+
+#ifndef CONFIG_ARCH_OCTEONTX
+/**
+ * Perform initial timing configuration
+ *
+ * @param mmc	mmc device
+ *
+ * @return 0 for success
+ *
+ * NOTE: This will need to be updated when new silicon comes out
+ */
+static int octeontx_mmc_init_timing(struct mmc *mmc)
+{
+	union cavm_mio_emm_timing timing;
+
+	if (mmc_to_slot(mmc)->is_asim || mmc_to_slot(mmc)->is_emul)
+		return 0;
+
+	debug("%s(%s)\n", __func__, mmc->dev->name);
+	timing.u = 0;
+	timing.s.cmd_out_tap = MMC_DEFAULT_CMD_OUT_TAP;
+	timing.s.data_out_tap = MMC_DEFAULT_DATA_OUT_TAP;
+	timing.s.cmd_in_tap = MMC_DEFAULT_CMD_IN_TAP;
+	timing.s.data_in_tap = MMC_DEFAULT_DATA_IN_TAP;
+	octeontx_mmc_set_emm_timing(mmc, timing);
+	return 0;
+}
+#endif
+
+/**
+ * Perform low-level initialization
+ *
+ * @param	mmc	mmc device
+ *
+ * @return	0 for success, error otherwise
+ */
+static int octeontx_mmc_init_lowlevel(struct mmc *mmc)
+{
+	struct octeontx_mmc_slot *slot = mmc_to_slot(mmc);
+	struct octeontx_mmc_host *host = slot->host;
+	union cavm_mio_emm_switch emm_switch;
+	u32 clk_period;
+
+	debug("%s(%s): lowlevel init for slot %d\n", __func__,
+	      mmc->dev->name, slot->bus_id);
+	host->emm_cfg.s.bus_ena &= ~(1 << slot->bus_id);
+	write_csr(mmc, CAVM_MIO_EMM_CFG(), host->emm_cfg.u);
+	udelay(100);
+	host->emm_cfg.s.bus_ena |= 1 << slot->bus_id;
+	write_csr(mmc, CAVM_MIO_EMM_CFG(), host->emm_cfg.u);
+	udelay(10);
+	slot->clock = mmc->cfg->f_min;
+	octeontx_mmc_set_clock(&slot->mmc);
+#ifdef CONFIG_ARCH_OCTEONTX2
+	if (host->cond_clock_glitch) {
+		union cavm_mio_emm_debug emm_debug;
+
+		emm_debug.u = read_csr(mmc, CAVM_MIO_EMM_DEBUG());
+		emm_debug.s.clk_on = 1;
+		write_csr(mmc, CAVM_MIO_EMM_DEBUG(), emm_debug.u);
+	}
+	octeontx_mmc_calibrate_delay(&slot->mmc);
+#endif
+
+	clk_period = octeontx_mmc_calc_clk_period(mmc);
+	emm_switch.u = 0;
+	emm_switch.s.power_class = 10;
+	emm_switch.s.clk_lo = clk_period / 2;
+	emm_switch.s.clk_hi = clk_period / 2;
+
+	emm_switch.s.bus_id = slot->bus_id;
+	debug("%s: Performing switch\n", __func__);
+	do_switch(mmc, emm_switch);
+	slot->cached_switch.u = emm_switch.u;
+
+#ifndef CONFIG_ARCH_OCTEONTX
+	octeontx_mmc_init_timing(mmc);
+#endif
+
+	set_wdog(mmc, 1000000); /* Set to 1 second */
+	write_csr(mmc, CAVM_MIO_EMM_STS_MASK(), 0xe4390080ull);
+	write_csr(mmc, CAVM_MIO_EMM_RCA(), 1);
+	mdelay(10);
+	debug("%s: done\n", __func__);
+	return 0;
+}
+
+/**
+ * Translates a voltage number to bits in MMC register
+ *
+ * @param	voltage	voltage in microvolts
+ *
+ * @return	MMC register value for voltage
+ */
+static u32 xlate_voltage(u32 voltage)
+{
+	u32 volt = 0;
+
+	/* Convert to millivolts */
+	voltage /= 1000;
+	if (voltage >= 1650 && voltage <= 1950)
+		volt |= MMC_VDD_165_195;
+	if (voltage >= 2000 && voltage <= 2100)
+		volt |= MMC_VDD_20_21;
+	if (voltage >= 2100 && voltage <= 2200)
+		volt |= MMC_VDD_21_22;
+	if (voltage >= 2200 && voltage <= 2300)
+		volt |= MMC_VDD_22_23;
+	if (voltage >= 2300 && voltage <= 2400)
+		volt |= MMC_VDD_23_24;
+	if (voltage >= 2400 && voltage <= 2500)
+		volt |= MMC_VDD_24_25;
+	if (voltage >= 2500 && voltage <= 2600)
+		volt |= MMC_VDD_25_26;
+	if (voltage >= 2600 && voltage <= 2700)
+		volt |= MMC_VDD_26_27;
+	if (voltage >= 2700 && voltage <= 2800)
+		volt |= MMC_VDD_27_28;
+	if (voltage >= 2800 && voltage <= 2900)
+		volt |= MMC_VDD_28_29;
+	if (voltage >= 2900 && voltage <= 3000)
+		volt |= MMC_VDD_29_30;
+	if (voltage >= 3000 && voltage <= 3100)
+		volt |= MMC_VDD_30_31;
+	if (voltage >= 3100 && voltage <= 3200)
+		volt |= MMC_VDD_31_32;
+	if (voltage >= 3200 && voltage <= 3300)
+		volt |= MMC_VDD_32_33;
+	if (voltage >= 3300 && voltage <= 3400)
+		volt |= MMC_VDD_33_34;
+	if (voltage >= 3400 && voltage <= 3500)
+		volt |= MMC_VDD_34_35;
+	if (voltage >= 3500 && voltage <= 3600)
+		volt |= MMC_VDD_35_36;
+
+	return volt;
+}
+
+/**
+ * Check if a slot is valid in the device tree
+ *
+ * @param	dev	slot device to check
+ *
+ * @return	true if status reports "ok" or "okay" or if no status,
+ *		false otherwise.
+ */
+static bool octeontx_mmc_get_valid(struct udevice *dev)
+{
+	const char *stat = ofnode_read_string(dev->node, "status");
+
+	if (!stat || !strncmp(stat, "ok", 2))
+		return true;
+	else
+		return false;
+}
+
+/**
+ * Reads slot configuration from the device tree
+ *
+ * @param	dev	slot device
+ *
+ * @return	0 on success, otherwise error
+ */
+static int octeontx_mmc_get_config(struct udevice *dev)
+{
+	struct octeontx_mmc_slot *slot = dev_to_mmc_slot(dev);
+	uint voltages[2];
+	uint low, high;
+	char env_name[32];
+	int err;
+	ofnode node = dev->node;
+	int bus_width = 1;
+
+	debug("%s(%s)", __func__, dev->name);
+	slot->cfg.name = dev->name;
+
+	slot->cfg.f_max = ofnode_read_s32_default(dev->node, "max-frequency",
+						  26000000);
+	snprintf(env_name, sizeof(env_name), "mmc_max_frequency%d",
+		 slot->bus_id);
+
+	slot->cfg.f_max = min((uint)env_get_ulong(env_name, 10,
+						  slot->cfg.f_max),
+			      slot->cfg.f_max);
+	slot->cfg.f_min = 400000;
+	slot->cfg.b_max = CONFIG_SYS_MMC_MAX_BLK_COUNT;
+
+	err = ofnode_read_u32_array(dev->node, "voltage-ranges", voltages, 2);
+	if (err) {
+		slot->cfg.voltages = MMC_VDD_32_33 | MMC_VDD_33_34;
+	} else {
+		low = xlate_voltage(voltages[0]);
+		high = xlate_voltage(voltages[1]);
+		debug("  low voltage: 0x%x (%u), high: 0x%x (%u)\n",
+		      low, voltages[0], high, voltages[1]);
+		if (low > high || !low || !high) {
+			pr_err("Invalid MMC voltage range [%u-%u] specified for %s\n",
+			       low, high, dev->name);
+			return -1;
+		}
+		slot->cfg.voltages = 0;
+		do {
+			slot->cfg.voltages |= low;
+			low <<= 1;
+		} while (low <= high);
+	}
+	debug("%s: config voltages: 0x%x\n", __func__, slot->cfg.voltages);
+	slot->slew = ofnode_read_s32_default(node, "cavium,clk-slew", -1);
+	slot->drive = ofnode_read_s32_default(node, "cavium,drv-strength", -1);
+	gpio_request_by_name(dev, "cd-gpios", 0, &slot->cd_gpio, GPIOD_IS_IN);
+	slot->cd_inverted = ofnode_read_bool(node, "cd-inverted");
+	gpio_request_by_name(dev, "wp-gpios", 0, &slot->wp_gpio, GPIOD_IS_IN);
+	slot->wp_inverted = ofnode_read_bool(node, "wp-inverted");
+	if (slot->cfg.voltages & MMC_VDD_165_195) {
+		slot->is_1_8v = true;
+		slot->is_3_3v = false;
+	} else if (slot->cfg.voltages & (MMC_VDD_30_31 | MMC_VDD_31_32 |
+					 MMC_VDD_33_34 | MMC_VDD_34_35 |
+					 MMC_VDD_35_36)) {
+		slot->is_1_8v = false;
+		slot->is_3_3v = true;
+	}
+	bus_width = ofnode_read_u32_default(node, "bus-width", 1);
+	/* Note fall-through */
+	switch (bus_width) {
+	case 8:
+		slot->cfg.host_caps |= MMC_MODE_8BIT;
+	case 4:
+		slot->cfg.host_caps |= MMC_MODE_4BIT;
+	case 1:
+		slot->cfg.host_caps |= MMC_MODE_1BIT;
+		break;
+	}
+	if (ofnode_read_bool(node, "no-1-8-v")) {
+		slot->is_3_3v = true;
+		slot->is_1_8v = false;
+		if (!(slot->cfg.voltages & (MMC_VDD_32_33 | MMC_VDD_33_34)))
+			pr_warn("%s(%s): voltages indicate 3.3v but 3.3v not supported\n",
+				__func__, dev->name);
+	}
+	if (ofnode_read_bool(node, "mmc-ddr-3-3v")) {
+		slot->is_3_3v = true;
+		slot->is_1_8v = false;
+		if (!(slot->cfg.voltages & (MMC_VDD_32_33 | MMC_VDD_33_34)))
+			pr_warn("%s(%s): voltages indicate 3.3v but 3.3v not supported\n",
+				__func__, dev->name);
+	}
+	if (ofnode_read_bool(node, "cap-sd-highspeed") ||
+	    ofnode_read_bool(node, "cap-mmc-highspeed") ||
+	    ofnode_read_bool(node, "sd-uhs-sdr25"))
+		slot->cfg.host_caps |= MMC_MODE_HS;
+	if ((slot->cfg.f_max >= 50000000) &&
+	    (slot->cfg.host_caps & MMC_MODE_HS))
+		slot->cfg.host_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS;
+	if (ofnode_read_bool(node, "sd-uhs-sdr50"))
+		slot->cfg.host_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS;
+	if (ofnode_read_bool(node, "sd-uhs-ddr50"))
+		slot->cfg.host_caps |= MMC_MODE_HS | MMC_MODE_HS_52MHz |
+				       MMC_MODE_DDR_52MHz;
+#if !defined(CONFIG_ARCH_OCTEONTX)
+	if (!slot->is_asim && !slot->is_emul) {
+		if (ofnode_read_bool(node, "mmc-hs200-1_8v"))
+			slot->cfg.host_caps |= MMC_MODE_HS200 |
+					       MMC_MODE_HS_52MHz;
+		if (ofnode_read_bool(node, "mmc-hs400-1_8v"))
+			slot->cfg.host_caps |= MMC_MODE_HS400 |
+					       MMC_MODE_HS_52MHz |
+					       MMC_MODE_HS200 |
+					       MMC_MODE_DDR_52MHz;
+	}
+#endif
+	slot->disable_ddr = ofnode_read_bool(node, "marvell,disable-ddr");
+	slot->non_removable = ofnode_read_bool(node, "non-removable");
+	slot->cmd_clk_skew = ofnode_read_u32_default(node,
+						     "cavium,cmd-clk-skew", 0);
+	slot->dat_clk_skew = ofnode_read_u32_default(node,
+						     "cavium,dat-clk-skew", 0);
+	debug("%s(%s): host caps: 0x%x\n", __func__,
+	      dev->name, slot->cfg.host_caps);
+	return 0;
+}
+
+/**
+ * Probes a MMC slot
+ *
+ * @param	dev	mmc device
+ *
+ * @return	0 for success, error otherwise
+ */
+static int octeontx_mmc_slot_probe(struct udevice *dev)
+{
+	struct octeontx_mmc_slot *slot;
+	struct mmc *mmc;
+	int err;
+
+	debug("%s(%s)\n", __func__, dev->name);
+	if (!host_probed) {
+		pr_err("%s(%s): Error: host not probed yet\n",
+		       __func__, dev->name);
+	}
+	slot = dev_to_mmc_slot(dev);
+	mmc = &slot->mmc;
+	mmc->dev = dev;
+
+	slot->valid = false;
+	if (!octeontx_mmc_get_valid(dev)) {
+		debug("%s(%s): slot is invalid\n", __func__, dev->name);
+		return -ENODEV;
+	}
+
+	debug("%s(%s): Getting config\n", __func__, dev->name);
+	err = octeontx_mmc_get_config(dev);
+	if (err) {
+		pr_err("probe(%s): Error getting config\n", dev->name);
+		return err;
+	}
+	debug("%s(%s): mmc bind, mmc: %p\n", __func__, dev->name, &slot->mmc);
+	err = mmc_bind(dev, &slot->mmc, &slot->cfg);
+	if (err) {
+		pr_err("%s(%s): Error binding mmc\n", __func__, dev->name);
+		return -1;
+	}
+	/* For some reason, mmc_bind always assigns priv to the device */
+	slot->mmc.priv = slot;
+
+	debug("%s(%s): lowlevel init\n", __func__, dev->name);
+	err = octeontx_mmc_init_lowlevel(mmc);
+	if (err) {
+		pr_err("probe(%s): Low-level init failed\n", dev->name);
+		return err;
+	}
+	slot->valid = true;
+
+	if (!err) {
+		/* Initialize each device regulator */
+		err = mmc_power_init(&slot->mmc);
+		debug("%s: Initialized %s\n", __func__, dev->name);
+		/* Turn off all I/O supplies */
+		if (!err && slot->mmc.vqmmc_supply)
+			regulator_set_enable(slot->mmc.vqmmc_supply, false);
+	}
+
+	debug("%s(%s):\n"
+	      "  base address : %p\n"
+	      "  bus id       : %d\n", __func__, dev->name,
+		slot->base_addr, slot->bus_id);
+	return err;
+}
+
+/**
+ * MMC slot driver operations
+ */
+static const struct dm_mmc_ops octeontx_hsmmc_ops = {
+	.send_cmd = octeontx_mmc_dev_send_cmd,
+	.set_ios = octeontx_mmc_set_ios,
+	.get_cd = octeontx_mmc_get_cd,
+	.get_wp = octeontx_mmc_get_wp,
+#if defined(CONFIG_MMC_SUPPORTS_TUNING) || defined(MMC_SUPPORTS_TUNING)
+	.execute_tuning = octeontx_mmc_execute_tuning,
+#endif
+};
+
+static const struct udevice_id octeontx_hsmmc_ids[] = {
+	{ .compatible = "mmc-slot" },
+	{ }
+};
+
+U_BOOT_DRIVER(octeontx_hsmmc_slot) = {
+	.name	= "octeontx_hsmmc_slot",
+	.id	= UCLASS_MMC,
+	.of_match = of_match_ptr(octeontx_hsmmc_ids),
+	.probe = octeontx_mmc_slot_probe,
+	.ops = &octeontx_hsmmc_ops,
+};
+
+/*****************************************************************
+ * PCI host driver
+ *
+ * The PCI host driver contains the resources used by all of the
+ * slot drivers.
+ *
+ * The slot drivers are pseudo drivers.
+ */
+
+/**
+ * Probe the MMC host controller
+ *
+ * @param	dev	mmc host controller device
+ *
+ * @return	0 for success, -1 on error
+ */
+static int octeontx_mmc_host_probe(struct udevice *dev)
+{
+	size_t size;
+	pci_dev_t bdf = dm_pci_get_bdf(dev);
+	struct octeontx_mmc_host *host = dev_get_priv(dev);
+	union cavm_mio_emm_int emm_int;
+	const char *board_model;
+	ofnode node;
+#if defined(CONFIG_ARCH_OCTEONTX2)
+	u8 rev;
+#endif
+
+	debug("%s(%s): Entry host: %p\n", __func__, dev->name, host);
+
+	if (!octeontx_mmc_get_valid(dev)) {
+		debug("%s(%s): mmc host not valid\n", __func__, dev->name);
+		return -ENODEV;
+	}
+	memset(host, 0, sizeof(*host));
+	host->base_addr = dm_pci_map_bar(dev, 0, &size, PCI_REGION_MEM);
+	if (!host->base_addr) {
+		pr_err("%s: Error: MMC base address not found\n", __func__);
+		return -1;
+	}
+	host->dev = dev;
+	debug("%s(%s): Base address: %p\n", __func__, dev->name,
+	      host->base_addr);
+	if (!dev_has_of_node(dev)) {
+		pr_err("%s: No device tree information found\n", __func__);
+		return -1;
+	}
+	host->node = dev->node;
+	dev->req_seq = PCI_FUNC(bdf);
+	host->last_slotid = -1;
+	node = ofnode_path("/cavium,bdk");
+	if (ofnode_valid(node)) {
+		board_model = ofnode_read_string(node, "BOARD-MODEL");
+		if (board_model && !strncmp(board_model, "ASIM-", 5))
+			host->is_asim = true;
+		if (board_model && !strncmp(board_model, "EMUL-", 5))
+			host->is_emul = true;
+	}
+	/* Force reset of eMMC */
+	writeq(0, host->base_addr + CAVM_MIO_EMM_CFG());
+	debug("%s: Clearing MIO_EMM_CFG\n", __func__);
+	udelay(100);
+	emm_int.u = readq(host->base_addr + CAVM_MIO_EMM_INT());
+	debug("%s: Writing 0x%llx to MIO_EMM_INT\n", __func__, emm_int.u);
+	writeq(emm_int.u, host->base_addr + CAVM_MIO_EMM_INT());
+
+	debug("%s(%s): Getting I/O clock\n", __func__, dev->name);
+	host->sys_freq = octeontx_get_io_clock();
+	debug("%s(%s): I/O clock %llu\n", __func__, dev->name, host->sys_freq);
+
+#ifdef CONFIG_ARCH_OCTEONTX2
+	/* Flags for issues to work around */
+	dm_pci_read_config8(dev, PCI_REVISION_ID, &rev);
+	if (is_board_model(CN96XX)) {
+		switch (rev) {
+		case 0:
+			host->calibrate_glitch = true;
+			host->cond_clock_glitch = true;
+			break;
+		default:
+			break;
+		}
+	} else if (is_board_model(CN95XX)) {
+		if (!rev)
+			host->cond_clock_glitch = true;
+	}
+#endif
+	host_probed = true;
+
+	return 0;
+}
+
+static int octeontx_mmc_host_bind(struct udevice *parent)
+{
+	struct udevice *dev;
+	ofnode node;
+	int err;
+
+	debug("%s(%s): bind\n", __func__, parent->name);
+	dev_for_each_subnode(node, parent) {
+		struct uclass *uc;
+		int slot = ofnode_read_u32_default(node, "reg", -1);
+		char name[32];
+
+		if (slot < 0) {
+			pr_warn("Warning: mmc slot in device tree missing reg\n");
+			continue;
+		}
+		snprintf(name, sizeof(name), "octeontx-hsmmc%d", slot);
+		err = device_bind_driver_to_node(parent, "octeontx_hsmmc_slot",
+						 ofnode_get_name(node), node,
+						 &dev);
+		if (err) {
+			pr_err("%s(%s): Error %d binding slot %s\n", __func__,
+			       parent->name, err, name);
+			continue;
+		}
+		pr_info("%s: bound %s\n", parent->name, dev->name);
+		err = uclass_get(UCLASS_MMC, &uc);
+		if (err) {
+			pr_err("%s(%s: Could not get MMC uclass\n", __func__,
+			       parent->name);
+			continue;
+		}
+		dev->uclass = uc;
+		debug("  uclass priv: %p\n", uc->priv);
+	}
+
+	return 0;
+}
+
+/**
+ * This performs some initial setup before a probe occurs.
+ *
+ * @param dev:	MMC slot device
+ *
+ * @return 0 for success, -1 on failure
+ *
+ * Do some pre-initialization before probing a slot.
+ */
+static int octeontx_mmc_host_child_pre_probe(struct udevice *dev)
+{
+	struct octeontx_mmc_host *host = dev_get_priv(dev_get_parent(dev));
+	struct octeontx_mmc_slot *slot;
+	struct mmc_uclass_priv *upriv;
+	ofnode node = dev->node;
+	u32 bus_id;
+	char name[16];
+	int err;
+
+	debug("%s(%s) Pre-Probe\n", __func__, dev->name);
+	if (ofnode_read_u32(node, "reg", &bus_id)) {
+		pr_err("%s(%s): Error: \"reg\" not found in device tree\n",
+		       __func__, dev->name);
+		return -1;
+	}
+	if (bus_id > OCTEONTX_MAX_MMC_SLOT) {
+		pr_err("%s(%s): Error: \"reg\" out of range of 0..%d\n",
+		       __func__, dev->name, OCTEONTX_MAX_MMC_SLOT);
+		return -1;
+	}
+
+	slot = &host->slots[bus_id];
+	dev->priv = slot;
+	slot->host = host;
+	slot->bus_id = bus_id;
+	slot->dev = dev;
+	slot->base_addr = host->base_addr;
+	slot->is_asim = host->is_asim;
+	slot->is_emul = host->is_emul;
+
+	snprintf(name, sizeof(name), "octeontx-mmc%d", bus_id);
+	err = device_set_name(dev, name);
+
+	if (!dev->uclass_priv) {
+		debug("%s(%s): Allocating uclass priv\n", __func__,
+		      dev->name);
+		upriv = calloc(1, sizeof(struct mmc_uclass_priv));
+		if (!upriv)
+			return -ENOMEM;
+		dev->uclass_priv = upriv;
+		dev->uclass->priv = upriv;
+	} else {
+		upriv = dev->uclass_priv;
+	}
+	upriv->mmc = &slot->mmc;
+	debug("%s: uclass priv: %p, mmc: %p\n", dev->name, upriv, upriv->mmc);
+
+	debug("%s: ret: %d\n", __func__, err);
+	return err;
+}
+
+static const struct udevice_id octeontx_hsmmc_host_ids[] = {
+	{ .compatible = "cavium,thunder-8890-mmc" },
+	{ }
+};
+
+U_BOOT_DRIVER(octeontx_hsmmc_host) = {
+	.name	= "octeontx_hsmmc_host",
+	.id	= UCLASS_MISC,
+	.bind	= octeontx_mmc_host_bind,
+	.of_match = of_match_ptr(octeontx_hsmmc_host_ids),
+	.probe	= octeontx_mmc_host_probe,
+	.priv_auto_alloc_size = sizeof(struct octeontx_mmc_host),
+	.child_pre_probe = octeontx_mmc_host_child_pre_probe,
+	.flags	= DM_FLAG_PRE_RELOC,
+};
+
+#if 0	/* Do not use PCI device for now with pseudo device */
+static struct pci_device_id octeontx_mmc_host_supported[] = {
+	{ PCI_VDEVICE(CAVIUM, PCI_DEVICE_ID_OCTEONTX_EMMC) },
+	{ },
+};
+
+U_BOOT_PCI_DEVICE(octeontx_hsmmc_host, octeontx_mmc_host_supported);
+#endif
diff --git a/drivers/mmc/octeontx_hsmmc.h b/drivers/mmc/octeontx_hsmmc.h
new file mode 100644
index 0000000..e503f40
--- /dev/null
+++ b/drivers/mmc/octeontx_hsmmc.h
@@ -0,0 +1,189 @@
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+#ifndef __OCTEONTX_HSMMC_H__
+#define __OCTEONTX_HSMMC_H__
+#include <asm/gpio.h>
+
+/** Name of our driver */
+#define OCTEONTX_MMC_DRIVER_NAME	"octeontx-hsmmc"
+
+/** Maximum supported MMC slots */
+#define OCTEONTX_MAX_MMC_SLOT		3
+
+#define POWER_ON_TIME			40	/** See SD 4.1 spec figure 6-5 */
+
+/**
+ * Timeout used when waiting for commands to complete.  We need to keep this
+ * above the hardware watchdog timeout which is usually limited to 1000ms
+ */
+#define WATCHDOG_COUNT			(1100)	/* in msecs */
+
+/**
+ * Long timeout for commands which might take a while to complete.
+ */
+#define MMC_TIMEOUT_LONG		1000
+
+/**
+ * Short timeout used for most commands in msecs
+ */
+#define MMC_TIMEOUT_SHORT		20
+
+#define NSEC_PER_SEC			1000000000L
+
+#define MAX_NO_OF_TAPS			64
+
+struct octeontx_mmc_host;
+
+/** MMC/SD slot data structure */
+struct octeontx_mmc_slot {
+	struct mmc		mmc;
+	struct mmc_config	cfg;
+	struct octeontx_mmc_host *host;
+	struct udevice		*dev;
+	void			*base_addr;	/** Same as host base_addr */
+	int			bus_id;		/** slot number */
+	uint			bus_width;
+	uint			max_width;
+	u64			clock;
+	struct gpio_desc	cd_gpio;
+	struct gpio_desc	wp_gpio;
+	struct gpio_desc	power_gpio;
+	enum bus_mode		mode;
+	union cavm_mio_emm_switch	cached_switch;
+	union cavm_mio_emm_switch	want_switch;
+	union cavm_mio_emm_rca		cached_rca;
+	union cavm_mio_emm_timing	taps;	/* otx2: MIO_EMM_TIMING */
+	union cavm_mio_emm_timing	hs200_taps;
+	/* These are used to see if our tuning is still valid or not */
+	enum bus_mode		last_mode;
+	u32			last_clock;
+	u32			block_len;
+	u32			block_count;
+	int			cmd_clk_skew;
+	int			dat_clk_skew;
+	uint			cmd_cnt;	/* otx: sample cmd in delay */
+	uint			dat_cnt;	/* otx: sample data in delay */
+	uint			drive;		/* Current drive */
+	uint			slew;		/* clock skew */
+	uint			clk_period;
+	bool			valid:1;
+	bool			is_acmd:1;
+	bool			tuned:1;
+	bool			hs200_tuned:1;
+	bool			is_1_8v:1;
+	bool			is_3_3v:1;
+	bool			is_ddr:1;
+	bool			is_asim:1;
+	bool			is_emul:1;
+	bool			cd_inverted:1;
+	bool			wp_inverted:1;
+	bool			disable_ddr:1;
+	bool			non_removable:1;
+};
+
+struct octeontx_mmc_cr_mods {
+	u8 ctype_xor;
+	u8 rtype_xor;
+};
+
+struct octeontx_mmc_cr {
+	u8 c;
+	u8 r;
+};
+
+struct octeontx_sd_mods {
+	struct octeontx_mmc_cr mmc;
+	struct octeontx_mmc_cr sd;
+	struct octeontx_mmc_cr sdacmd;
+};
+
+/** Host controller data structure */
+struct octeontx_mmc_host {
+	struct		udevice *dev;
+	void		*base_addr;
+	struct octeontx_mmc_slot slots[OCTEONTX_MAX_MMC_SLOT + 1];
+	pci_dev_t	pdev;
+	u64		sys_freq;
+	union cavm_mio_emm_cfg emm_cfg;
+	u64		timing_taps;
+	struct mmc	*last_mmc;	/** Last mmc used */
+	ofnode		node;
+	int		cur_slotid;
+	int		last_slotid;
+	int		max_width;
+	uint		per_tap_delay;
+	uint		num_slots;
+	bool		initialized:1;
+	bool		is_asim:1;
+	bool		is_emul:1;
+	bool		calibrate_glitch:1;
+	bool		cond_clock_glitch:1;
+};
+
+/*
+ * NOTE: This was copied from the Linux kernel.
+ *
+ * MMC status in R1, for native mode (SPI bits are different)
+ * Type
+ *	e:error bit
+ *	s:status bit
+ *	r:detected and set for the actual command response
+ *	x:detected and set during command execution. the host must poll
+ *	    the card by sending status command in order to read these bits.
+ * Clear condition
+ *	a:according to the card state
+ *	b:always related to the previous command. Reception of
+ *	    a valid command will clear it (with a delay of one command)
+ *	c:clear by read
+ */
+#define R1_OUT_OF_RANGE		BIT(31)		/* er, c */
+#define R1_ADDRESS_ERROR	BIT(30)		/* erx, c */
+#define R1_BLOCK_LEN_ERROR	BIT(29)		/* er, c */
+#define R1_ERASE_SEQ_ERROR	BIT(28)		/* er, c */
+#define R1_ERASE_PARAM          BIT(27)		/* ex, c */
+#define R1_WP_VIOLATION		BIT(26)		/* erx, c */
+#define R1_CARD_IS_LOCKED	BIT(25)		/* sx, a */
+#define R1_LOCK_UNLOCK_FAILED	BIT(24)		/* erx, c */
+#define R1_COM_CRC_ERROR	BIT(23)		/* er, b */
+/*#define R1_ILLEGAL_COMMAND	BIT(22)*/		/* er, b */
+#define R1_CARD_ECC_FAILED	BIT(21)		/* ex, c */
+#define R1_CC_ERROR		BIT(20)		/* erx, c */
+#define R1_ERROR		BIT(19)		/* erx, c */
+#define R1_UNDERRUN		BIT(18)		/* ex, c */
+#define R1_OVERRUN		BIT(17)		/* ex, c */
+#define R1_CID_CSD_OVERWRITE	BIT(16)		/* erx, c, CID/CSD overwrite */
+#define R1_WP_ERASE_SKIP	BIT(15)		/* sx, c */
+#define R1_CARD_ECC_DISABLED	BIT(14)		/* sx, a */
+#define R1_ERASE_RESET		BIT(13)		/* sr, c */
+#define R1_STATUS(x)		(x & 0xFFFFE000)
+#define R1_CURRENT_STATE(x)	((x & 0x00001E00) >> 9) /* sx, b (4 bits) */
+#define R1_READY_FOR_DATA	BIT(8)		/* sx, a */
+#define R1_SWITCH_ERROR		BIT(7)		/* sx, c */
+
+#define R1_BLOCK_READ_MASK	R1_OUT_OF_RANGE |	\
+				R1_ADDRESS_ERROR |	\
+				R1_BLOCK_LEN_ERROR |	\
+				R1_CARD_IS_LOCKED |	\
+				R1_COM_CRC_ERROR |	\
+				R1_ILLEGAL_COMMAND |	\
+				R1_CARD_ECC_FAILED |	\
+				R1_CC_ERROR |		\
+				R1_ERROR
+#define R1_BLOCK_WRITE_MASK	R1_OUT_OF_RANGE |	\
+				R1_ADDRESS_ERROR |	\
+				R1_BLOCK_LEN_ERROR |	\
+				R1_WP_VIOLATION |	\
+				R1_CARD_IS_LOCKED |	\
+				R1_COM_CRC_ERROR |	\
+				R1_ILLEGAL_COMMAND |	\
+				R1_CARD_ECC_FAILED |	\
+				R1_CC_ERROR |		\
+				R1_ERROR |		\
+				R1_UNDERRUN |		\
+				R1_OVERRUN
+
+#endif /* __OCTEONTX_HSMMC_H__ */
diff --git a/drivers/mmc/sdhci.c b/drivers/mmc/sdhci.c
index d31793a..fdc3c3d 100644
--- a/drivers/mmc/sdhci.c
+++ b/drivers/mmc/sdhci.c
@@ -152,7 +152,7 @@ static int sdhci_send_command(struct mmc *mmc, struct mmc_cmd *cmd,
 	u32 mask, flags, mode;
 	unsigned int time = 0, start_addr = 0;
 	int mmc_dev = mmc_get_blk_desc(mmc)->devnum;
-	unsigned start = get_timer(0);
+	ulong start = get_timer(0);
 
 	/* Timeout unit - ms */
 	static unsigned int cmd_timeout = SDHCI_CMD_DEFAULT_TIMEOUT;
@@ -504,6 +504,42 @@ static int sdhci_init(struct mmc *mmc)
 }
 
 #ifdef CONFIG_DM_MMC
+
+#ifdef MMC_SUPPORTS_TUNING
+static int sdhci_execute_tuning(struct udevice *dev, uint32_t opcode)
+{
+	struct mmc *mmc = mmc_get_mmc_dev(dev);
+	struct sdhci_host *host = mmc->priv;
+	int err = 0;
+
+	if (host->ops->execute_tuning_pre) {
+		err = (*host->ops->execute_tuning_pre)(host, opcode);
+		if (err) {
+			printf("%s: error encountered running tuning_pre\n",
+			       __func__);
+			return err;
+		}
+	}
+
+	err = mmc_send_tuning(mmc, opcode, NULL);
+	if (err) {
+		printf("%s: error encountered during tuning\n", __func__);
+		return err;
+	}
+
+	if (host->ops->execute_tuning_post) {
+		err = (*host->ops->execute_tuning_post)(host, opcode);
+		if (err) {
+			printf("%s: error encountered running tuning_post\n",
+			       __func__);
+			return err;
+		}
+	}
+
+	return err;
+}
+#endif
+
 int sdhci_probe(struct udevice *dev)
 {
 	struct mmc *mmc = mmc_get_mmc_dev(dev);
@@ -514,6 +550,9 @@ int sdhci_probe(struct udevice *dev)
 const struct dm_mmc_ops sdhci_ops = {
 	.send_cmd	= sdhci_send_command,
 	.set_ios	= sdhci_set_ios,
+#ifdef MMC_SUPPORTS_TUNING
+	.execute_tuning	= sdhci_execute_tuning,
+#endif
 };
 #else
 static const struct mmc_ops sdhci_ops = {
diff --git a/drivers/mmc/xenon_sdhci.c b/drivers/mmc/xenon_sdhci.c
index 9427a24..d2a7622 100644
--- a/drivers/mmc/xenon_sdhci.c
+++ b/drivers/mmc/xenon_sdhci.c
@@ -21,6 +21,7 @@
 #include <linux/libfdt.h>
 #include <malloc.h>
 #include <sdhci.h>
+#include <power/regulator.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -41,6 +42,15 @@ DECLARE_GLOBAL_DATA_PTR;
 #define SDHC_SYS_EXT_OP_CTRL			0x010C
 #define MASK_CMD_CONFLICT_ERROR			BIT(8)
 
+#define SDHC_SLOT_EMMC_CTRL			0x0130
+#define ENABLE_DATA_STROBE_SHIFT		24
+#define ENABLE_DATA_STROBE			BIT(ENABLE_DATA_STROBE_SHIFT)
+#define SET_EMMC_RSTN_SHIFT			16
+#define EMMC_VCCQ_MASK				0x3
+#define EMMC_VCCQ_1_8V				0x1
+#define EMMC_VCCQ_1_2V				0x2
+#define	EMMC_VCCQ_3_3V				0x3
+
 #define SDHC_SLOT_RETUNING_REQ_CTRL		0x0144
 /* retuning compatible */
 #define RETUNING_COMPATIBLE			0x1
@@ -54,6 +64,7 @@ DECLARE_GLOBAL_DATA_PTR;
 #define OUTPUT_QSN_PHASE_SELECT			BIT(17)
 #define SAMPL_INV_QSP_PHASE_SELECT		BIT(18)
 #define SAMPL_INV_QSP_PHASE_SELECT_SHIFT	18
+#define EMMC_PHY_SDIO_MODE			BIT(28)
 #define EMMC_PHY_SLOW_MODE			BIT(29)
 #define PHY_INITIALIZAION			BIT(31)
 #define WAIT_CYCLE_BEFORE_USING_MASK		0xf
@@ -80,6 +91,7 @@ DECLARE_GLOBAL_DATA_PTR;
 #define FC_QSN_RECEN				BIT(27)
 #define OEN_QSN					BIT(28)
 #define AUTO_RECEN_CTRL				BIT(30)
+#define FC_ALL_CMOS_RECEIVER			(REC_EN_MASK << REC_EN_SHIFT)
 
 #define EMMC_PHY_PAD_CONTROL1			(EMMC_PHY_REG_BASE + 0xc)
 #define EMMC5_1_FC_QSP_PD			BIT(9)
@@ -89,10 +101,71 @@ DECLARE_GLOBAL_DATA_PTR;
 #define EMMC5_1_FC_DQ_PD			0xff
 #define EMMC5_1_FC_DQ_PU			(0xff << 16)
 
+#define EMMC_PHY_PAD_CONTROL2			(EMMC_PHY_REG_BASE + 0x10)
+#define ZNR_MASK				0x1F
+#define ZNR_SHIFT				8
+#define ZPR_MASK				0x1F
+
 #define SDHCI_RETUNE_EVT_INTSIG			0x00001000
 
+#define SDHCI_HOST_CONTROL2		0x3E
+#define  SDHCI_CTRL_UHS_MASK		0x0007
+#define   SDHCI_CTRL_UHS_SDR12		0x0000
+#define   SDHCI_CTRL_UHS_SDR25		0x0001
+#define   SDHCI_CTRL_UHS_SDR50		0x0002
+#define   SDHCI_CTRL_UHS_SDR104		0x0003
+#define   SDHCI_CTRL_UHS_DDR50		0x0004
+#define   SDHCI_CTRL_HS400		0x0005 /* Non-standard */
+#define   SDHCI_CTRL_HS200_ONLY		0x0005 /* Non-standard */
+#define   SDHCI_CTRL_HS400_ONLY		0x0006 /* Non-standard */
+#define  SDHCI_CTRL_VDD_180		0x0008
+#define  SDHCI_CTRL_DRV_TYPE_MASK	0x0030
+#define   SDHCI_CTRL_DRV_TYPE_B		0x0000
+#define   SDHCI_CTRL_DRV_TYPE_A		0x0010
+#define   SDHCI_CTRL_DRV_TYPE_C		0x0020
+#define   SDHCI_CTRL_DRV_TYPE_D		0x0030
+#define  SDHCI_CTRL_EXEC_TUNING		0x0040
+#define  SDHCI_CTRL_TUNED_CLK		0x0080
+#define  SDHCI_CTRL_PRESET_VAL_ENABLE	0x8000
+
+/*
+ * Config to eMMC PHY to prepare for tuning.
+ * Enable HW DLL and set the TUNING_STEP
+ */
+#define XENON_SLOT_DLL_CUR_DLY_VAL		0x0150
+
+#define XENON_SLOT_OP_STATUS_CTRL		0x0128
+#define XENON_TUN_CONSECUTIVE_TIMES_SHIFT	16
+#define XENON_TUN_CONSECUTIVE_TIMES_MASK	0x7
+#define XENON_TUN_CONSECUTIVE_TIMES		0x4
+#define XENON_TUNING_STEP_SHIFT			12
+#define XENON_TUNING_STEP_MASK			0xF
+#define XENON_TUNING_STEP_DIVIDER		BIT(6)
+
+#define XENON_EMMC_PHY_DLL_CONTROL		(EMMC_PHY_REG_BASE + 0x14)
+#define XENON_EMMC_5_0_PHY_DLL_CONTROL		\
+	(XENON_EMMC_5_0_PHY_REG_BASE + 0x10)
+#define XENON_DLL_ENABLE			BIT(31)
+#define XENON_DLL_UPDATE_STROBE_5_0		BIT(30)
+#define XENON_DLL_REFCLK_SEL			BIT(30)
+#define XENON_DLL_UPDATE			BIT(23)
+#define XENON_DLL_PHSEL1_SHIFT			24
+#define XENON_DLL_PHSEL0_SHIFT			16
+#define XENON_DLL_PHASE_MASK			0x3F
+#define XENON_DLL_PHASE_90_DEGREE		0x1F
+#define XENON_DLL_FAST_LOCK			BIT(5)
+#define XENON_DLL_GAIN2X			BIT(3)
+#define XENON_DLL_BYPASS_EN			BIT(0)
+
+#define XENON_SLOT_EXT_PRESENT_STATE		0x014C
+#define XENON_DLL_LOCK_STATE			0x1
+
 /* Hyperion only have one slot 0 */
 #define XENON_MMC_SLOT_ID_HYPERION		0
+#define SLOT_MASK(slot)				BIT(slot)
+
+#define XENON_EMMC_PHY_LOGIC_TIMING_ADJUST	(EMMC_PHY_REG_BASE + 0x18)
+#define XENON_LOGIC_TIMING_VALUE		0x00AA8977
 
 #define MMC_TIMING_LEGACY	0
 #define MMC_TIMING_MMC_HS	1
@@ -107,6 +180,8 @@ DECLARE_GLOBAL_DATA_PTR;
 #define MMC_TIMING_MMC_HS400	10
 
 #define XENON_MMC_MAX_CLK	400000000
+#define XENON_MMC_3V3_UV	3300000
+#define XENON_MMC_1V8_UV	1800000
 
 enum soc_pad_ctrl_type {
 	SOC_PAD_SD,
@@ -127,6 +202,8 @@ struct xenon_sdhci_priv {
 
 	void *pad_ctrl_reg;
 	int pad_type;
+
+	struct udevice *vqmmc;
 };
 
 static int xenon_mmc_phy_init(struct sdhci_host *host)
@@ -207,6 +284,221 @@ static void armada_3700_soc_pad_voltage_set(struct sdhci_host *host)
 		writel(ARMADA_3700_SOC_PAD_3_3V, priv->pad_ctrl_reg);
 }
 
+static int xenon_mmc_start_signal_voltage_switch(struct sdhci_host *host)
+{
+	struct xenon_sdhci_priv *priv = host->mmc->priv;
+	u8 voltage;
+	u32 ctrl;
+	int ret = 0;
+
+	/* If there is no vqmmc regulator, return */
+	if (!priv->vqmmc)
+		return 0;
+
+	if (priv->pad_type == SOC_PAD_FIXED_1_8V) {
+		/* Switch to 1.8v */
+		ret = regulator_set_value(priv->vqmmc,
+					  XENON_MMC_1V8_UV);
+	} else if (priv->pad_type == SOC_PAD_SD) {
+		/* Get voltage info */
+		voltage = sdhci_readb(host, SDHCI_POWER_CONTROL);
+		voltage &= ~SDHCI_POWER_ON;
+
+		if (voltage == SDHCI_POWER_330) {
+			/* Switch to 3.3v */
+			ret = regulator_set_value(priv->vqmmc,
+						  XENON_MMC_3V3_UV);
+		} else {
+			/* Switch to 1.8v */
+			ret = regulator_set_value(priv->vqmmc,
+						  XENON_MMC_1V8_UV);
+		}
+	}
+
+	/* Set VCCQ, eMMC mode: 1.8V; SD/SDIO mode: 3.3V */
+	ctrl = sdhci_readl(host, SDHC_SLOT_EMMC_CTRL);
+	if (IS_SD(host->mmc))
+		ctrl |= EMMC_VCCQ_3_3V;
+	else
+		ctrl |= EMMC_VCCQ_1_8V;
+	sdhci_writel(host, ctrl, SDHC_SLOT_EMMC_CTRL);
+
+	if (ret)
+		printf("Signal voltage switch fail\n");
+
+	return ret;
+}
+
+/*
+ * Xenon defines different values for HS200 and HS400
+ * in Host_Control_2
+ */
+static void xenon_set_uhs_signaling(struct sdhci_host *host,
+				    unsigned int timing)
+{
+	u16 ctrl_2;
+
+	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	/* Select Bus Speed Mode for host */
+	ctrl_2 &= ~SDHCI_CTRL_UHS_MASK;
+	if (timing == MMC_TIMING_MMC_HS200)
+		ctrl_2 |= SDHCI_CTRL_HS200_ONLY;
+	else if (timing == MMC_TIMING_UHS_SDR104)
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR104;
+	else if (timing == MMC_TIMING_UHS_SDR12)
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR12;
+	else if (timing == MMC_TIMING_UHS_SDR25)
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR25;
+	else if (timing == MMC_TIMING_UHS_SDR50)
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR50;
+	else if ((timing == MMC_TIMING_UHS_DDR50) ||
+		 (timing == MMC_TIMING_MMC_DDR52))
+		ctrl_2 |= SDHCI_CTRL_UHS_DDR50;
+	else if (timing == MMC_TIMING_MMC_HS400)
+		ctrl_2 |= SDHCI_CTRL_HS400_ONLY;
+	sdhci_writew(host, ctrl_2, SDHCI_HOST_CONTROL2);
+}
+
+/*
+ * If eMMC PHY Slow Mode is required in lower speed mode (SDCLK < 55MHz)
+ * in SDR mode, enable Slow Mode to bypass eMMC PHY.
+ * SDIO slower SDR mode also requires Slow Mode.
+ *
+ * If Slow Mode is enabled, return 0.
+ * Otherwise, return -EINVAL.
+ */
+static int xenon_emmc_phy_slow_mode(struct sdhci_host *host,
+				    unsigned char timing)
+{
+	u32 reg;
+	int ret = -EINVAL;
+
+	if (host->mmc->tran_speed > 52000000)
+		return -EINVAL;
+
+	reg = sdhci_readl(host, EMMC_PHY_TIMING_ADJUST);
+	/* When in slower SDR mode, enable Slow Mode for SDIO */
+	switch (timing) {
+	case MMC_TIMING_LEGACY:
+		/*
+		 * If Slow Mode is required, enable Slow Mode by default
+		 * in early init phase to avoid any potential issue.
+		 */
+		reg |= EMMC_PHY_SLOW_MODE;
+		ret = 0;
+		break;
+	case MMC_TIMING_UHS_SDR25:
+	case MMC_TIMING_UHS_SDR12:
+	case MMC_TIMING_SD_HS:
+	case MMC_TIMING_MMC_HS:
+		if (IS_SD(host->mmc)) {
+			reg |= EMMC_PHY_SLOW_MODE;
+			ret = 0;
+			break;
+		}
+	default:
+		reg &= ~EMMC_PHY_SLOW_MODE;
+		ret = -EINVAL;
+	}
+
+	sdhci_writel(host, reg, EMMC_PHY_TIMING_ADJUST);
+	return ret;
+}
+
+static void xenon_emmc_phy_disable_data_strobe(struct sdhci_host *host)
+{
+	u32 reg;
+
+	/* Disable SDHC Data Strobe */
+	reg = sdhci_readl(host, SDHC_SLOT_EMMC_CTRL);
+	reg &= ~ENABLE_DATA_STROBE;
+	sdhci_writel(host, reg, SDHC_SLOT_EMMC_CTRL);
+}
+
+/*
+ * Enable eMMC PHY HW DLL
+ * DLL should be enabled and stable before HS200/SDR104 tuning,
+ * and before HS400 data strobe setting.
+ */
+static int xenon_emmc_phy_enable_dll(struct sdhci_host *host)
+{
+	u32 reg;
+	u32 timeout;
+
+	if (host->mmc->tran_speed <= 52000000)
+		return -EINVAL;
+
+	reg = sdhci_readl(host, XENON_EMMC_PHY_DLL_CONTROL);
+	if (reg & XENON_DLL_ENABLE)
+		return 0;
+
+	/* Enable DLL */
+	reg = sdhci_readl(host, XENON_EMMC_PHY_DLL_CONTROL);
+	reg |= (XENON_DLL_ENABLE | XENON_DLL_FAST_LOCK);
+
+	/*
+	 * Set Phase as 90 degree, which is most common value.
+	 * Might set another value if necessary.
+	 * The granularity is 1 degree.
+	 */
+	reg &= ~((XENON_DLL_PHASE_MASK << XENON_DLL_PHSEL0_SHIFT) |
+		 (XENON_DLL_PHASE_MASK << XENON_DLL_PHSEL1_SHIFT));
+	reg |= ((XENON_DLL_PHASE_90_DEGREE << XENON_DLL_PHSEL0_SHIFT) |
+		(XENON_DLL_PHASE_90_DEGREE << XENON_DLL_PHSEL1_SHIFT));
+
+	reg &= ~(XENON_DLL_BYPASS_EN | XENON_DLL_REFCLK_SEL);
+	reg |= XENON_DLL_UPDATE;
+	sdhci_writel(host, reg, XENON_EMMC_PHY_DLL_CONTROL);
+
+	/* Wait max 32 ms */
+	timeout = 32;
+	while (!(sdhci_readw(host, XENON_SLOT_EXT_PRESENT_STATE) &
+		XENON_DLL_LOCK_STATE)) {
+		if (timeout > 32) {
+			printf("Wait for DLL Lock time-out\n");
+			return -ETIMEDOUT;
+		}
+		udelay(1000);
+		timeout++;
+	}
+	return 0;
+}
+
+static int xenon_emmc_phy_config_tuning(struct sdhci_host *host)
+{
+	u32 reg, tuning_step;
+	int ret;
+
+	if (host->mmc->tran_speed <= 52000000)
+		return -EINVAL;
+
+	ret = xenon_emmc_phy_enable_dll(host);
+	if (ret)
+		return ret;
+
+	/* Achieve TUNING_STEP with HW DLL help */
+	reg = sdhci_readl(host, XENON_SLOT_DLL_CUR_DLY_VAL);
+	tuning_step = reg / XENON_TUNING_STEP_DIVIDER;
+	if (unlikely(tuning_step > XENON_TUNING_STEP_MASK)) {
+		dev_warn(mmc_dev(host->mmc),
+			 "HS200 TUNING_STEP %d is larger than MAX value\n",
+			 tuning_step);
+		tuning_step = XENON_TUNING_STEP_MASK;
+	}
+
+	/* Set TUNING_STEP for later tuning */
+	reg = sdhci_readl(host, XENON_SLOT_OP_STATUS_CTRL);
+	reg &= ~(XENON_TUN_CONSECUTIVE_TIMES_MASK <<
+		 XENON_TUN_CONSECUTIVE_TIMES_SHIFT);
+	reg |= (XENON_TUN_CONSECUTIVE_TIMES <<
+		XENON_TUN_CONSECUTIVE_TIMES_SHIFT);
+	reg &= ~(XENON_TUNING_STEP_MASK << XENON_TUNING_STEP_SHIFT);
+	reg |= (tuning_step << XENON_TUNING_STEP_SHIFT);
+	sdhci_writel(host, reg, XENON_SLOT_OP_STATUS_CTRL);
+
+	return 0;
+}
+
 static void xenon_mmc_phy_set(struct sdhci_host *host)
 {
 	struct xenon_sdhci_priv *priv = host->mmc->priv;
@@ -214,8 +506,8 @@ static void xenon_mmc_phy_set(struct sdhci_host *host)
 
 	/* Setup pad, set bit[30], bit[28] and bits[26:24] */
 	var = sdhci_readl(host, EMMC_PHY_PAD_CONTROL);
-	var |= AUTO_RECEN_CTRL | OEN_QSN | FC_QSP_RECEN |
-		FC_CMD_RECEN | FC_DQ_RECEN;
+	var |= OEN_QSN | FC_QSP_RECEN | FC_CMD_RECEN | FC_DQ_RECEN |
+		FC_ALL_CMOS_RECEIVER;
 	sdhci_writel(host, var, EMMC_PHY_PAD_CONTROL);
 
 	/* Set CMD and DQ Pull Up */
@@ -225,20 +517,45 @@ static void xenon_mmc_phy_set(struct sdhci_host *host)
 	sdhci_writel(host, var, EMMC_PHY_PAD_CONTROL1);
 
 	/*
-	 * If timing belongs to high speed, set bit[17] of
+	 * If Timing belongs to high speed, clear bit[17] of
 	 * EMMC_PHY_TIMING_ADJUST register
 	 */
+	var = sdhci_readl(host, EMMC_PHY_TIMING_ADJUST);
 	if ((priv->timing == MMC_TIMING_MMC_HS400) ||
 	    (priv->timing == MMC_TIMING_MMC_HS200) ||
+	    (priv->timing == MMC_TIMING_MMC_DDR52) ||
 	    (priv->timing == MMC_TIMING_UHS_SDR50) ||
 	    (priv->timing == MMC_TIMING_UHS_SDR104) ||
 	    (priv->timing == MMC_TIMING_UHS_DDR50) ||
-	    (priv->timing == MMC_TIMING_UHS_SDR25) ||
-	    (priv->timing == MMC_TIMING_MMC_DDR52)) {
-		var = sdhci_readl(host, EMMC_PHY_TIMING_ADJUST);
-		var |= OUTPUT_QSN_PHASE_SELECT;
+	    (priv->timing == MMC_TIMING_UHS_SDR25)) {
+		var &= ~OUTPUT_QSN_PHASE_SELECT;
 		sdhci_writel(host, var, EMMC_PHY_TIMING_ADJUST);
 	}
+	if (priv->timing == MMC_TIMING_LEGACY) {
+		xenon_emmc_phy_slow_mode(host, priv->timing);
+		goto phy_init;
+	}
+
+	/*
+	 * If SDIO card, set SDIO Mode
+	 * Otherwise, clear SDIO Mode
+	 */
+	var = sdhci_readl(host, EMMC_PHY_TIMING_ADJUST);
+	if (IS_SD(host->mmc))
+		var |= EMMC_PHY_SDIO_MODE;
+	else
+		var &= ~EMMC_PHY_SDIO_MODE;
+	sdhci_writel(host, var, EMMC_PHY_TIMING_ADJUST);
+
+	/*
+	 * Set preferred ZNR and ZPR value
+	 * The ZNR and ZPR value vary between different boards.
+	 * Define them both in sdhci-xenon-emmc-phy.h.
+	 */
+	var = sdhci_readl(host, EMMC_PHY_PAD_CONTROL2);
+	var &= ~((ZNR_MASK << ZNR_SHIFT) | ZPR_MASK);
+	var |= ((0xf << ZNR_SHIFT) | 0xf);
+	sdhci_writel(host, var, EMMC_PHY_PAD_CONTROL2);
 
 	/*
 	 * When setting EMMC_PHY_FUNC_CONTROL register,
@@ -249,11 +566,21 @@ static void xenon_mmc_phy_set(struct sdhci_host *host)
 	sdhci_writew(host, var, SDHCI_CLOCK_CONTROL);
 
 	var = sdhci_readl(host, EMMC_PHY_FUNC_CONTROL);
-	if (host->mmc->ddr_mode) {
-		var |= (DQ_DDR_MODE_MASK << DQ_DDR_MODE_SHIFT) | CMD_DDR_MODE;
-	} else {
+	switch (priv->timing) {
+	case MMC_TIMING_MMC_HS400:
+		var |= (DQ_DDR_MODE_MASK << DQ_DDR_MODE_SHIFT) |
+		       CMD_DDR_MODE;
+		var &= ~DQ_ASYNC_MODE;
+		break;
+	case MMC_TIMING_UHS_DDR50:
+	case MMC_TIMING_MMC_DDR52:
+		var |= (DQ_DDR_MODE_MASK << DQ_DDR_MODE_SHIFT) |
+		       CMD_DDR_MODE | DQ_ASYNC_MODE;
+		break;
+	default:
 		var &= ~((DQ_DDR_MODE_MASK << DQ_DDR_MODE_SHIFT) |
 			 CMD_DDR_MODE);
+		var |= DQ_ASYNC_MODE;
 	}
 	sdhci_writel(host, var, EMMC_PHY_FUNC_CONTROL);
 
@@ -262,7 +589,26 @@ static void xenon_mmc_phy_set(struct sdhci_host *host)
 	var |= SDHCI_CLOCK_CARD_EN;
 	sdhci_writew(host, var, SDHCI_CLOCK_CONTROL);
 
+	udelay(1000);
+
+	/* Quirk, value suggested by hardware team */
+	if (priv->timing == MMC_TIMING_MMC_HS400)
+		/* Hardware team recommend a value for HS400 */
+		sdhci_writel(host, XENON_EMMC_PHY_LOGIC_TIMING_ADJUST,
+			     XENON_LOGIC_TIMING_VALUE);
+	else
+		xenon_emmc_phy_disable_data_strobe(host);
+
+phy_init:
+
+	xenon_set_uhs_signaling(host, priv->timing);
 	xenon_mmc_phy_init(host);
+
+	if ((priv->timing == MMC_TIMING_MMC_HS400) ||
+	    (priv->timing == MMC_TIMING_MMC_HS200)) {
+		if (xenon_emmc_phy_config_tuning(host) != 0)
+			printf("Error, failed to tune MMC PHY\n");
+	}
 }
 
 /* Enable/Disable the Auto Clock Gating function of this slot */
@@ -279,8 +625,6 @@ static void xenon_mmc_set_acg(struct sdhci_host *host, bool enable)
 	sdhci_writel(host, var, SDHC_SYS_OP_CTRL);
 }
 
-#define SLOT_MASK(slot)		BIT(slot)
-
 /* Enable specific slot */
 static void xenon_mmc_enable_slot(struct sdhci_host *host, u8 slot)
 {
@@ -332,6 +676,14 @@ static void xenon_sdhci_set_ios_post(struct sdhci_host *host)
 	struct xenon_sdhci_priv *priv = host->mmc->priv;
 	uint speed = host->mmc->tran_speed;
 	int pwr_18v = 0;
+	u32 reg;
+
+	/*
+	 * Signal Voltage Switching is only applicable for Host Controllers
+	 * v3.00 and above.
+	 */
+	if (SDHCI_GET_VERSION(host) >= SDHCI_SPEC_300)
+		xenon_mmc_start_signal_voltage_switch(host);
 
 	if ((sdhci_readb(host, SDHCI_POWER_CONTROL) & ~SDHCI_POWER_ON) ==
 	    SDHCI_POWER_180)
@@ -357,12 +709,22 @@ static void xenon_sdhci_set_ios_post(struct sdhci_host *host)
 		/* eMMC */
 		if (host->mmc->ddr_mode)
 			priv->timing = MMC_TIMING_MMC_DDR52;
+		else if (speed == 200000000)
+			priv->timing = MMC_TIMING_MMC_HS200;
 		else if (speed <= 26000000)
 			priv->timing = MMC_TIMING_LEGACY;
 		else
 			priv->timing = MMC_TIMING_MMC_HS;
 	}
 
+	if ((priv->timing == MMC_TIMING_MMC_HS400) ||
+	    (priv->timing == MMC_TIMING_MMC_HS200) ||
+	    (priv->timing == MMC_TIMING_MMC_HS)) {
+		reg = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+		reg &= ~SDHCI_CTRL_PRESET_VAL_ENABLE;
+		sdhci_writew(host, reg, SDHCI_HOST_CONTROL2);
+	}
+
 	/* Re-init the PHY */
 	xenon_mmc_phy_set(host);
 }
@@ -379,6 +741,7 @@ static int xenon_sdhci_probe(struct udevice *dev)
 	struct xenon_sdhci_priv *priv = dev_get_priv(dev);
 	struct sdhci_host *host = dev_get_priv(dev);
 	int ret;
+	int len;
 
 	host->mmc = &plat->mmc;
 	host->mmc->priv = host;
@@ -391,6 +754,18 @@ static int xenon_sdhci_probe(struct udevice *dev)
 	/* Set default timing */
 	priv->timing = MMC_TIMING_LEGACY;
 
+	/* Get the vqmmc regulator if there is */
+	device_get_supply_regulator(dev, "vqmmc-supply", &priv->vqmmc);
+	/* Set the initial voltage value to 3.3V if there is regulator */
+	if (priv->vqmmc) {
+		ret = regulator_set_value(priv->vqmmc,
+					  XENON_MMC_3V3_UV);
+		if (ret) {
+			printf("Failed to set VQMMC regulator to 3.3V\n");
+			return ret;
+		}
+	}
+
 	/* Disable auto clock gating during init */
 	xenon_mmc_set_acg(host, false);
 
@@ -420,10 +795,22 @@ static int xenon_sdhci_probe(struct udevice *dev)
 		return -EINVAL;
 	}
 
-	host->ops = &xenon_sdhci_ops;
+	/* Support for High Speed modes */
+	if (fdt_getprop(gd->fdt_blob,
+			dev_of_offset(dev), "mmc-hs400-1_8v", &len) != NULL) {
+		host->host_caps |= (MMC_MODE_HS400 | MMC_MODE_HS200);
+		sdhci_writeb(host,  SDHCI_POWER_180 |
+			     SDHCI_POWER_ON, SDHCI_POWER_CONTROL);
+	}
+	if (fdt_getprop(gd->fdt_blob,
+			dev_of_offset(dev), "mmc-hs200-1_8v", &len) != NULL) {
+		host->host_caps |= MMC_MODE_HS200;
+	}
 
+	host->ops = &xenon_sdhci_ops;
 	host->max_clk = XENON_MMC_MAX_CLK;
-	ret = sdhci_setup_cfg(&plat->cfg, host, 0, 0);
+
+	ret = sdhci_setup_cfg(&plat->cfg, host, XENON_MMC_MAX_CLK, 0);
 	if (ret)
 		return ret;
 
diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index a820af6..884b341 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -164,6 +164,12 @@ config NAND_ZYNQ_USE_BOOTLOADER1_TIMINGS
 	  This flag prevent U-boot reconfigure NAND flash controller and reuse
 	  the NAND timing from 1st stage bootloader.
 
+config NAND_OCTEONTX
+	bool "Support for OcteonTX NAND controller"
+	imply CMD_NAND
+	help
+	 This enables Nand flash controller found on the OcteonTX processors.
+
 comment "Generic NAND options"
 
 # Enhance depends when converting drivers to Kconfig which use this config
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index 9f7d9d6..56cd1d6 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -58,6 +58,8 @@ obj-$(CONFIG_NAND_VF610_NFC) += vf610_nfc.o
 obj-$(CONFIG_NAND_MXC) += mxc_nand.o
 obj-$(CONFIG_NAND_MXS) += mxs_nand.o
 obj-$(CONFIG_NAND_NDFC) += ndfc.o
+obj-$(CONFIG_NAND_OCTEONTX) += octeontx_nand.o
+obj-$(CONFIG_OCTEONTX_BCH) += octeontx_bch.o
 obj-$(CONFIG_NAND_PXA3XX) += pxa3xx_nand.o
 obj-$(CONFIG_NAND_SPEAR) += spr_nand.o
 obj-$(CONFIG_TEGRA_NAND) += tegra_nand.o
diff --git a/drivers/mtd/nand/octeontx_bch.c b/drivers/mtd/nand/octeontx_bch.c
new file mode 100644
index 0000000..e890188
--- /dev/null
+++ b/drivers/mtd/nand/octeontx_bch.c
@@ -0,0 +1,433 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#include <common.h>
+#include <malloc.h>
+#include <memalign.h>
+#include <pci.h>
+#include <nand.h>
+#include <dm.h>
+#include <dm/of_access.h>
+#include <linux/bitfield.h>
+#include <linux/ctype.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/ioport.h>
+#include <linux/libfdt.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand_bch.h>
+#include <linux/mtd/nand_ecc.h>
+#include <asm/io.h>
+#include <asm/types.h>
+#include <asm/dma-mapping.h>
+#include <asm/arch/clock.h>
+#include "octeontx_bch.h"
+
+#ifdef DEBUG
+# undef CONFIG_LOGLEVEL
+# define CONFIG_LOGLEVEL 8
+#endif
+
+LIST_HEAD(octeontx_bch_devices);
+static unsigned int num_vfs = BCH_NR_VF;
+static void *bch_pf;
+static void *bch_vf;
+static void *token;
+static bool bch_pf_initialized;
+static bool bch_vf_initialized;
+
+static int pci_enable_sriov(struct udevice *dev, int nr_virtfn)
+{
+	int ret;
+
+	ret = pci_sriov_init(dev, nr_virtfn);
+	if (ret)
+		printf("%s(%s): pci_sriov_init returned %d\n", __func__,
+		       dev->name, ret);
+	return ret;
+}
+
+void *octeontx_bch_getv(void)
+{
+	if (!bch_vf)
+		return NULL;
+	if (bch_vf_initialized && bch_pf_initialized)
+		return bch_vf;
+	else
+		return NULL;
+}
+
+void octeontx_bch_putv(void *token)
+{
+	bch_vf_initialized = !!token;
+	bch_vf = token;
+}
+
+void *octeontx_bch_getp(void)
+{
+	return token;
+}
+
+void octeontx_bch_putp(void *token)
+{
+	bch_pf = token;
+	bch_pf_initialized = !!token;
+}
+
+static int do_bch_init(struct bch_device *bch)
+{
+	return 0;
+}
+
+static void bch_reset(struct bch_device *bch)
+{
+	writeq(1, bch->reg_base + BCH_CTL);
+	mdelay(2);
+}
+
+static void bch_disable(struct bch_device *bch)
+{
+	writeq(~0ull, bch->reg_base + BCH_ERR_INT_ENA_W1C);
+	writeq(~0ull, bch->reg_base + BCH_ERR_INT);
+	bch_reset(bch);
+}
+
+static u32 bch_check_bist_status(struct bch_device *bch)
+{
+	return readq(bch->reg_base + BCH_BIST_RESULT);
+}
+
+static int bch_device_init(struct bch_device *bch)
+{
+	u64 bist;
+	int rc;
+
+	debug("%s: Resetting...\n", __func__);
+	/* Reset the PF when probed first */
+	bch_reset(bch);
+
+	debug("%s: Checking BIST...\n", __func__);
+	/* Check BIST status */
+	bist = (u64)bch_check_bist_status(bch);
+	if (bist) {
+		dev_err(dev, "BCH BIST failed with code 0x%llx\n", bist);
+		return -ENODEV;
+	}
+
+	/* Get max VQs/VFs supported by the device */
+
+	bch->max_vfs = pci_sriov_get_totalvfs(bch->dev);
+	debug("%s: %d vfs\n", __func__, bch->max_vfs);
+	if (num_vfs > bch->max_vfs) {
+		dev_warn(dev, "Num of VFs to enable %d is greater than max available.  Enabling %d VFs.\n",
+			 num_vfs, bch->max_vfs);
+		num_vfs = bch->max_vfs;
+	}
+	bch->vfs_enabled = bch->max_vfs;
+	/* Get number of VQs/VFs to be enabled */
+	/* TODO: Get CLK frequency */
+	/* Reset device parameters */
+
+	debug("%s: Doing initialization\n", __func__);
+	rc = do_bch_init(bch);
+
+	return rc;
+}
+
+static int bch_sriov_configure(struct udevice *dev, int numvfs)
+{
+	struct bch_device *bch = dev_get_priv(dev);
+	int ret = -EBUSY;
+
+	debug("%s(%s, %d), bch: %p, vfs_in_use: %d, enabled: %d\n", __func__,
+	      dev->name, numvfs, bch, bch->vfs_in_use, bch->vfs_enabled);
+	if (bch->vfs_in_use)
+		goto exit;
+
+	ret = 0;
+
+	if (numvfs > 0) {
+		debug("%s: Enabling sriov\n", __func__);
+		ret = pci_enable_sriov(dev, numvfs);
+		if (ret == 0) {
+			bch->flags |= BCH_FLAG_SRIOV_ENABLED;
+			ret = numvfs;
+			bch->vfs_enabled = numvfs;
+		}
+	}
+
+	dev_notice(bch->dev, "VFs enabled: %d\n", ret);
+exit:
+	debug("%s: Returning %d\n", __func__, ret);
+	return ret;
+}
+
+static int octeontx_pci_bchpf_probe(struct udevice *dev)
+{
+	struct bch_device *bch;
+	size_t size;
+	int ret;
+
+	debug("%s(%s)\n", __func__, dev->name);
+	bch = dev_get_priv(dev);
+	if (!bch)
+		return -ENOMEM;
+
+	bch->reg_base = dm_pci_map_bar(dev, 0, &size, PCI_REGION_MEM);
+	bch->dev = dev;
+
+	debug("%s: base address: %p\n", __func__, bch->reg_base);
+	ret = bch_device_init(bch);
+	if (ret) {
+		printf("%s(%s): init returned %d\n", __func__, dev->name, ret);
+		return ret;
+	}
+	INIT_LIST_HEAD(&bch->list);
+	list_add(&bch->list, &octeontx_bch_devices);
+	token = (void *)dev;
+
+	debug("%s: Configuring SRIOV\n", __func__);
+	bch_sriov_configure(dev, num_vfs);
+	debug("%s: Done.\n", __func__);
+	octeontx_bch_putp(bch);
+
+	return 0;
+}
+
+static const struct pci_device_id octeontx_bchpf_pci_id_table[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, BCH_PCI_PF_DEVICE_ID) },
+	{},
+};
+
+static const struct pci_device_id octeontx_bchvf_pci_id_table[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, BCH_PCI_VF_DEVICE_ID)},
+	{},
+};
+
+U_BOOT_DRIVER(octeontx_bchpf) = {
+	.name	= CAVIUM_BCHPF_DRIVER_NAME,
+	.id	= UCLASS_MISC,
+	.probe = octeontx_pci_bchpf_probe,
+};
+
+/**
+ * Given a data block calculate the ecc data and fill in the response
+ *
+ * @param[in] block	8-byte aligned pointer to data block to calculate ECC
+ * @param block_size	Size of block in bytes, must be a multiple of two.
+ * @param bch_level	Number of errors that must be corrected.  The number of
+ *			parity bytes is equal to ((15 * bch_level) + 7) / 8.
+ *			Must be 4, 8, 16, 24, 32, 40, 48, 56, 60 or 64.
+ * @param[out] ecc	8-byte aligned pointer to where ecc data should go
+ * @param[in] resp	pointer to where responses will be written.
+ *
+ * @return Zero on success, negative on failure.
+ */
+int octeontx_bch_encode(struct bch_vf *vf, dma_addr_t block, u16 block_size,
+			u8 bch_level, dma_addr_t ecc, dma_addr_t resp)
+{
+	union bch_cmd cmd;
+	int rc;
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.s.cword.ecc_gen = eg_gen;
+	cmd.s.cword.ecc_level = bch_level;
+	cmd.s.cword.size = block_size;
+
+	cmd.s.oword.ptr = ecc;
+	cmd.s.iword.ptr = block;
+	cmd.s.rword.ptr = resp;
+	rc = octeontx_cmd_queue_write(QID_BCH, 1,
+				      sizeof(cmd) / sizeof(uint64_t), cmd.u);
+	if (rc)
+		return -1;
+
+	octeontx_bch_write_doorbell(1, vf);
+
+	return 0;
+}
+
+/**
+ * Given a data block and ecc data correct the data block
+ *
+ * @param[in] block_ecc_in	8-byte aligned pointer to data block with ECC
+ *				data concatenated to the end to correct
+ * @param block_size		Size of block in bytes, must be a multiple of
+ *				two.
+ * @param bch_level		Number of errors that must be corrected.  The
+ *				number of parity bytes is equal to
+ *				((15 * bch_level) + 7) / 8.
+ *				Must be 4, 8, 16, 24, 32, 40, 48, 56, 60 or 64.
+ * @param[out] block_out	8-byte aligned pointer to corrected data buffer.
+ *				This should not be the same as block_ecc_in.
+ * @param[in] resp		pointer to where responses will be written.
+ *
+ * @return Zero on success, negative on failure.
+ */
+
+int octeontx_bch_decode(struct bch_vf *vf, dma_addr_t block_ecc_in,
+			u16 block_size, u8 bch_level,
+			dma_addr_t block_out, dma_addr_t resp)
+{
+	union bch_cmd cmd;
+	int rc;
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.s.cword.ecc_gen = eg_correct;
+	cmd.s.cword.ecc_level = bch_level;
+	cmd.s.cword.size = block_size;
+
+	cmd.s.oword.ptr = block_out;
+	cmd.s.iword.ptr = block_ecc_in;
+	cmd.s.rword.ptr = resp;
+	rc = octeontx_cmd_queue_write(QID_BCH, 1,
+				      sizeof(cmd) / sizeof(uint64_t), cmd.u);
+	if (rc)
+		return -1;
+
+	octeontx_bch_write_doorbell(1, vf);
+	return 0;
+}
+EXPORT_SYMBOL(octeontx_bch_decode);
+
+int octeontx_bch_wait(struct bch_vf *vf, union bch_resp *resp,
+		      dma_addr_t handle)
+{
+	ulong start = get_timer(0);
+
+	__iormb(); /* HW is updating *resp */
+	while (!resp->s.done && get_timer(start) < 10)
+		__iormb(); /* HW is updating *resp */
+
+	if (resp->s.done)
+		return 0;
+
+	return -ETIMEDOUT;
+}
+
+struct bch_q octeontx_bch_q[QID_MAX];
+
+static int octeontx_cmd_queue_initialize(struct udevice *dev, int queue_id,
+					 int max_depth, int fpa_pool,
+					 int pool_size)
+{
+	/* some params are for later merge with CPT or cn83xx */
+	struct bch_q *q = &octeontx_bch_q[queue_id];
+	unsigned long paddr;
+	union bch_cmd *qb;
+	int chunk = max_depth + 1;
+	int i, size;
+
+	if ((unsigned int)queue_id >= QID_MAX)
+		return -EINVAL;
+	if (max_depth & chunk) /* must be 2^N - 1 */
+		return -EINVAL;
+
+	size = NQS * chunk * sizeof(u64);
+	qb = dma_alloc_coherent(size, &paddr);
+	if (!qb)
+		return -ENOMEM;
+	q->base_paddr = paddr;
+	q->dev = dev;
+	q->index = 0;
+	q->max_depth = max_depth;
+	q->pool_size_m1 = pool_size;
+	q->base_vaddr = (u64 *)qb;
+
+	for (i = 0; i < NQS; i++) {
+		u64 *ixp;
+		int inext = (i + 1) * chunk - 1;
+		int j = (i + 1) % NQS;
+		int jnext = j * chunk;
+		dma_addr_t jbase = q->base_paddr + jnext * sizeof(u64);
+
+		ixp = &qb->u[inext];
+		*ixp = jbase;
+	}
+
+	return 0;
+}
+
+static int octeontx_pci_bchvf_probe(struct udevice *dev)
+{
+	struct bch_vf *vf;
+	union bch_vqx_ctl ctl;
+	union bch_vqx_cmd_buf cbuf;
+	int err;
+	size_t size;
+
+	debug("%s(%s)\n", __func__, dev->name);
+	vf = dev_get_priv(dev);
+	if (!vf)
+		return -ENOMEM;
+
+	vf->dev = dev;
+
+	/* Map PF's configuration registers */
+	vf->reg_base = dm_pci_map_bar(dev, 9, &size, PCI_REGION_MEM);
+	debug("%s: reg base: %p\n", __func__, vf->reg_base);
+
+	err = octeontx_cmd_queue_initialize(dev, QID_BCH, QDEPTH - 1, 0,
+					    sizeof(union bch_cmd) * QDEPTH);
+	if (err) {
+		dev_err(dev, "octeontx_cmd_queue_initialize() failed\n");
+		goto release;
+	}
+
+	ctl.u = readq(vf->reg_base + BCH_VQX_CTL(0));
+
+	cbuf.u = 0;
+	cbuf.s.ldwb = 1;
+	cbuf.s.dfb = 1;
+	cbuf.s.size = QDEPTH;
+	writeq(cbuf.u, vf->reg_base + BCH_VQX_CMD_BUF(0));
+
+	writeq(ctl.u, vf->reg_base + BCH_VQX_CTL(0));
+
+	writeq(octeontx_bch_q[QID_BCH].base_paddr,
+	       vf->reg_base + BCH_VQX_CMD_PTR(0));
+
+	octeontx_bch_putv(vf);
+
+	debug("%s: bch vf initialization complete\n", __func__);
+
+	if (octeontx_bch_getv())
+		return octeontx_pci_nand_deferred_probe();
+
+	return -1;
+
+release:
+	return err;
+}
+
+static int octeontx_pci_bchpf_remove(struct udevice *dev)
+{
+	struct bch_device *bch = dev_get_priv(dev);
+
+	bch_disable(bch);
+	return 0;
+}
+
+U_BOOT_DRIVER(octeontx_pci_bchpf) = {
+	.name	= CAVIUM_BCHPF_DRIVER_NAME,
+	.id	= UCLASS_MISC,
+	.probe	= octeontx_pci_bchpf_probe,
+	.remove = octeontx_pci_bchpf_remove,
+	.priv_auto_alloc_size = sizeof(struct bch_device),
+	.flags = DM_FLAG_OS_PREPARE,
+};
+
+U_BOOT_DRIVER(octeontx_pci_bchvf) = {
+	.name	= CAVIUM_BCHVF_DRIVER_NAME,
+	.id	= UCLASS_MISC,
+	.probe = octeontx_pci_bchvf_probe,
+	.priv_auto_alloc_size = sizeof(struct bch_vf),
+};
+
+U_BOOT_PCI_DEVICE(octeontx_pci_bchpf, octeontx_bchpf_pci_id_table);
+U_BOOT_PCI_DEVICE(octeontx_pci_bchvf, octeontx_bchvf_pci_id_table);
diff --git a/drivers/mtd/nand/octeontx_bch.h b/drivers/mtd/nand/octeontx_bch.h
new file mode 100644
index 0000000..3e4c9c0
--- /dev/null
+++ b/drivers/mtd/nand/octeontx_bch.h
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#ifndef __OCTEONTX_BCH_H__
+#define __OCTEONTX_BCH_H__
+
+#include "octeontx_bch_regs.h"
+
+/* Device ID */
+#define BCH_PCI_PF_DEVICE_ID		0xa043
+#define BCH_PCI_VF_DEVICE_ID		0xa044
+
+#define BCH_81XX_PCI_PF_SUBSYS_ID	0xa243
+#define BCH_81XX_PCI_VF_SUBSYS_ID	0xa244
+#define BCH_83XX_PCI_PF_SUBSYS_ID	0xa343
+#define BCH_83XX_PCI_VF_SUBSYS_ID	0xa344
+
+/* flags to indicate the features supported */
+#define BCH_FLAG_SRIOV_ENABLED		BIT(1)
+
+/*
+ * BCH Registers map for 81xx
+ */
+
+/* PF registers */
+#define BCH_CTL				0x0ull
+#define BCH_ERR_CFG			0x10ull
+#define BCH_BIST_RESULT			0x80ull
+#define BCH_ERR_INT			0x88ull
+#define BCH_ERR_INT_W1S			0x90ull
+#define BCH_ERR_INT_ENA_W1C		0xA0ull
+#define BCH_ERR_INT_ENA_W1S		0xA8ull
+
+/* VF registers */
+#define BCH_VQX_CTL(z)			0x0ull
+#define BCH_VQX_CMD_BUF(z)		0x8ull
+#define BCH_VQX_CMD_PTR(z)		0x20ull
+#define BCH_VQX_DOORBELL(z)		0x800ull
+
+#define CAVIUM_BCHPF_DRIVER_NAME	"cavium-bchpf"
+#define CAVIUM_BCHVF_DRIVER_NAME	"cavium-bchvf"
+
+struct bch_device {
+	struct list_head list;
+	u8 max_vfs;
+	u8 vfs_enabled;
+	u8 vfs_in_use;
+	u32 flags;
+	void __iomem *reg_base;
+	struct udevice *dev;
+};
+
+struct bch_vf {
+	u16 flags;
+	u8 vfid;
+	u8 node;
+	u8 priority;
+	struct udevice *dev;
+	void __iomem *reg_base;
+};
+
+struct buf_ptr {
+	u8 *vptr;
+	dma_addr_t dma_addr;
+	u16 size;
+};
+
+void *octeontx_bch_getv(void);
+void octeontx_bch_putv(void *token);
+void *octeontx_bch_getp(void);
+void octeontx_bch_putp(void *token);
+int octeontx_bch_wait(struct bch_vf *vf, union bch_resp *resp,
+		      dma_addr_t handle);
+/**
+ * Given a data block calculate the ecc data and fill in the response
+ *
+ * @param[in] block	8-byte aligned pointer to data block to calculate ECC
+ * @param block_size	Size of block in bytes, must be a multiple of two.
+ * @param bch_level	Number of errors that must be corrected.  The number of
+ *			parity bytes is equal to ((15 * bch_level) + 7) / 8.
+ *			Must be 4, 8, 16, 24, 32, 40, 48, 56, 60 or 64.
+ * @param[out] ecc	8-byte aligned pointer to where ecc data should go
+ * @param[in] resp	pointer to where responses will be written.
+ *
+ * @return Zero on success, negative on failure.
+ */
+int octeontx_bch_encode(struct bch_vf *vf, dma_addr_t block, u16 block_size,
+			u8 bch_level, dma_addr_t ecc, dma_addr_t resp);
+
+/**
+ * Given a data block and ecc data correct the data block
+ *
+ * @param[in] block_ecc_in	8-byte aligned pointer to data block with ECC
+ *				data concatenated to the end to correct
+ * @param block_size		Size of block in bytes, must be a multiple of
+ *				two.
+ * @param bch_level		Number of errors that must be corrected.  The
+ *				number of parity bytes is equal to
+ *				((15 * bch_level) + 7) / 8.
+ *				Must be 4, 8, 16, 24, 32, 40, 48, 56, 60 or 64.
+ * @param[out] block_out	8-byte aligned pointer to corrected data buffer.
+ *				This should not be the same as block_ecc_in.
+ * @param[in] resp		pointer to where responses will be written.
+ *
+ * @return Zero on success, negative on failure.
+ */
+
+int octeontx_bch_decode(struct bch_vf *vf, dma_addr_t block_ecc_in,
+			u16 block_size, u8 bch_level,
+			dma_addr_t block_out, dma_addr_t resp);
+
+/**
+ * Ring the BCH doorbell telling it that new commands are
+ * available.
+ *
+ * @param num_commands	Number of new commands
+ * @param vf		virtual function handle
+ */
+static inline void octeontx_bch_write_doorbell(u64 num_commands,
+					       struct bch_vf *vf)
+{
+	u64 num_words = num_commands * sizeof(union bch_cmd) / sizeof(uint64_t);
+
+	writeq(num_words, vf->reg_base + BCH_VQX_DOORBELL(0));
+}
+
+/**
+ * Since it's possible (and even likely) that the NAND device will be probed
+ * before the BCH device has been probed, we may need to defer the probing.
+ *
+ * In this case, the initial probe returns success but the actual probing
+ * is deferred until the BCH VF has been probed.
+ *
+ * @return	0 for success, otherwise error
+ */
+int octeontx_pci_nand_deferred_probe(void);
+
+#endif /* __OCTEONTX_BCH_H__ */
diff --git a/drivers/mtd/nand/octeontx_bch_regs.h b/drivers/mtd/nand/octeontx_bch_regs.h
new file mode 100644
index 0000000..ddd1949
--- /dev/null
+++ b/drivers/mtd/nand/octeontx_bch_regs.h
@@ -0,0 +1,169 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#ifndef __OCTEONTX_BCH_REGS_H__
+#define __OCTEONTX_BCH_REGS_H__
+
+#define BCH_NR_VF	1
+
+union bch_cmd {
+	u64 u[4];
+	struct fields {
+	    struct {
+		u64 size:12;
+		u64 reserved_12_31:20;
+		u64 ecc_level:4;
+		u64 reserved_36_61:26;
+		u64 ecc_gen:2;
+	    } cword;
+	    struct {
+		u64 ptr:49;
+		u64 reserved_49_55:7;
+		u64 nc:1;
+		u64 fw:1;
+		u64 reserved_58_63:6;
+	    } oword;
+	    struct {
+		u64 ptr:49;
+		u64 reserved_49_55:7;
+		u64 nc:1;
+		u64 reserved_57_63:7;
+	    } iword;
+	    struct {
+		u64 ptr:49;
+		u64 reserved_49_63:15;
+	    } rword;
+	} s;
+};
+
+enum ecc_gen {
+	eg_correct,
+	eg_copy,
+	eg_gen,
+	eg_copy3,
+};
+
+/** Response from BCH instruction */
+union bch_resp {
+	u16  u16;
+	struct {
+		u16	num_errors:7;	/** Number of errors in block */
+		u16	zero:6;		/** Always zero, ignore */
+		u16	erased:1;	/** Block is erased */
+		u16	uncorrectable:1;/** too many bits flipped */
+		u16	done:1;		/** Block is done */
+	} s;
+};
+
+union bch_vqx_ctl {
+	u64 u;
+	struct {
+		u64 reserved_0:1;
+		u64 cmd_be:1;
+		u64 max_read:4;
+		u64 reserved_6_15:10;
+		u64 erase_disable:1;
+		u64 one_cmd:1;
+		u64 early_term:4;
+		u64 reserved_22_63:42;
+	} s;
+};
+
+union bch_vqx_cmd_buf {
+	u64 u;
+	struct {
+		u64 reserved_0_32:33;
+		u64 size:13;
+		u64 dfb:1;
+		u64 ldwb:1;
+		u64 reserved_48_63:16;
+	} s;
+};
+
+/* keep queue state indexed, even though just one supported here,
+ * for later generalization to similarly-shaped queues on other Cavium devices
+ */
+enum {
+	QID_BCH,
+	QID_MAX
+};
+
+struct bch_q {
+	struct udevice *dev;
+	int index;
+	u16 max_depth;
+	u16 pool_size_m1;
+	u64 *base_vaddr;
+	dma_addr_t base_paddr;
+};
+
+extern struct bch_q octeontx_bch_q[QID_MAX];
+
+/* with one dma-mapped area, virt<->phys conversions by +/- (vaddr-paddr) */
+static inline dma_addr_t qphys(int qid, void *v)
+{
+	struct bch_q *q = &octeontx_bch_q[qid];
+	int off = (u8 *)v - (u8 *)q->base_vaddr;
+
+	return q->base_paddr + off;
+}
+
+#define octeontx_ptr_to_phys(v) qphys(QID_BCH, (v))
+
+static inline void *qvirt(int qid, dma_addr_t p)
+{
+	struct bch_q *q = &octeontx_bch_q[qid];
+	int off = p - q->base_paddr;
+
+	return q->base_vaddr + off;
+}
+
+#define octeontx_phys_to_ptr(p) qvirt(QID_BCH, (p))
+
+/* plenty for interleaved r/w on two planes with 16k page, ecc_size 1k */
+/* QDEPTH >= 16, as successive chunks must align on 128-byte boundaries */
+#define QDEPTH	256	/* u64s in a command queue chunk, incl next-pointer */
+#define NQS	1	/* linked chunks in the chain */
+
+/**
+ * Write an arbitrary number of command words to a command queue.
+ * This is a generic function; the fixed number of command word
+ * functions yield higher performance.
+ *
+ * Could merge with crypto version for FPA use on cn83xx
+ */
+static inline int octeontx_cmd_queue_write(int queue_id, bool use_locking,
+					   int cmd_count, const u64 *cmds)
+{
+	int ret = 0;
+	u64 *cmd_ptr;
+	struct bch_q *qptr = &octeontx_bch_q[queue_id];
+
+	if (unlikely((cmd_count < 1) || (cmd_count > 32)))
+		return -EINVAL;
+	if (unlikely(!cmds))
+		return -EINVAL;
+
+	cmd_ptr = qptr->base_vaddr;
+
+	while (cmd_count > 0) {
+		int slot = qptr->index % (QDEPTH * NQS);
+
+		if (slot % QDEPTH != QDEPTH - 1) {
+			cmd_ptr[slot] = *cmds++;
+			cmd_count--;
+		}
+
+		qptr->index++;
+	}
+
+	__iowmb();	/* flush commands before ringing bell */
+
+	return ret;
+}
+
+#endif /* __OCTEONTX_BCH_REGS_H__ */
diff --git a/drivers/mtd/nand/octeontx_nand.c b/drivers/mtd/nand/octeontx_nand.c
new file mode 100644
index 0000000..a411f3f
--- /dev/null
+++ b/drivers/mtd/nand/octeontx_nand.c
@@ -0,0 +1,2276 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <memalign.h>
+#include <pci.h>
+#include <nand.h>
+#include <dm.h>
+#include <dm/of_access.h>
+#include <dm/device-internal.h>
+#include <linux/bitfield.h>
+#include <linux/ctype.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/ioport.h>
+#include <linux/libfdt.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand_bch.h>
+#include <linux/mtd/nand_ecc.h>
+#include <asm/io.h>
+#include <asm/types.h>
+#include <asm/dma-mapping.h>
+#include <asm/arch/clock.h>
+#include "octeontx_bch.h"
+
+#ifdef DEBUG
+# undef CONFIG_LOGLEVEL
+# define CONFIG_LOGLEVEL 8
+#endif
+
+/*
+ * The NDF_CMD queue takes commands between 16 - 128 bit.
+ * All commands must be 16 bit aligned and are little endian.
+ * WAIT_STATUS commands must be 64 bit aligned.
+ * Commands are selected by the 4 bit opcode.
+ *
+ * Available Commands:
+ *
+ * 16 Bit:
+ *   NOP
+ *   WAIT
+ *   BUS_ACQ, BUS_REL
+ *   CHIP_EN, CHIP_DIS
+ *
+ * 32 Bit:
+ *   CLE_CMD
+ *   RD_CMD, RD_EDO_CMD
+ *   WR_CMD
+ *
+ * 64 Bit:
+ *   SET_TM_PAR
+ *
+ * 96 Bit:
+ *   ALE_CMD
+ *
+ * 128 Bit:
+ *   WAIT_STATUS, WAIT_STATUS_ALE
+ */
+
+/* NDF Register offsets */
+#define NDF_CMD			0x0
+#define NDF_MISC		0x8
+#define NDF_ECC_CNT		0x10
+#define NDF_DRBELL		0x30
+#define NDF_ST_REG		0x38	/* status */
+#define NDF_INT			0x40
+#define NDF_INT_W1S		0x48
+#define NDF_DMA_CFG		0x50
+#define NDF_DMA_ADR		0x58
+#define NDF_INT_ENA_W1C		0x60
+#define NDF_INT_ENA_W1S		0x68
+
+/* NDF command opcodes */
+#define NDF_OP_NOP		0x0
+#define NDF_OP_SET_TM_PAR	0x1
+#define NDF_OP_WAIT		0x2
+#define NDF_OP_CHIP_EN_DIS	0x3
+#define NDF_OP_CLE_CMD		0x4
+#define NDF_OP_ALE_CMD		0x5
+#define NDF_OP_WR_CMD		0x8
+#define NDF_OP_RD_CMD		0x9
+#define NDF_OP_RD_EDO_CMD	0xa
+#define NDF_OP_WAIT_STATUS	0xb	/* same opcode for WAIT_STATUS_ALE */
+#define NDF_OP_BUS_ACQ_REL	0xf
+
+#define NDF_BUS_ACQUIRE		1
+#define NDF_BUS_RELEASE		0
+
+#define DBGX_EDSCR(X)		(0x87A008000088 + (X) * 0x80000)
+
+struct ndf_nop_cmd {
+	u16 opcode:	4;
+	u16 nop:	12;
+};
+
+struct ndf_wait_cmd {
+	u16 opcode:4;
+	u16 r_b:1;		/* wait for one cycle or PBUS_WAIT deassert */
+	u16:3;
+	u16 wlen:3;		/* timing parameter select */
+	u16:5;
+};
+
+struct ndf_bus_cmd {
+	u16 opcode:4;
+	u16 direction:4;	/* 1 = acquire, 0 = release */
+	u16:8;
+};
+
+struct ndf_chip_cmd {
+	u16 opcode:4;
+	u16 chip:3;		/* select chip, 0 = disable */
+	u16 enable:1;		/* 1 = enable, 0 = disable */
+	u16 bus_width:2;	/* 10 = 16 bit, 01 = 8 bit */
+	u16:6;
+};
+
+struct ndf_cle_cmd {
+	u32 opcode:4;
+	u32:4;
+	u32 cmd_data:8;		/* command sent to the PBUS AD pins */
+	u32 clen1:3;		/* time between PBUS CLE and WE asserts */
+	u32 clen2:3;		/* time WE remains asserted */
+	u32 clen3:3;		/* time between WE deassert and CLE */
+	u32:7;
+};
+
+/* RD_EDO_CMD uses the same layout as RD_CMD */
+struct ndf_rd_cmd {
+	u32 opcode:4;
+	u32 data:16;		/* data bytes */
+	u32 rlen1:3;
+	u32 rlen2:3;
+	u32 rlen3:3;
+	u32 rlen4:3;
+};
+
+struct ndf_wr_cmd {
+	u32 opcode:4;
+	u32 data:16;		/* data bytes */
+	u32:4;
+	u32 wlen1:3;
+	u32 wlen2:3;
+	u32:3;
+};
+
+struct ndf_set_tm_par_cmd {
+	u64 opcode:4;
+	u64 tim_mult:4;	/* multiplier for the seven parameters */
+	u64 tm_par1:8;	/* --> Following are the 7 timing parameters that */
+	u64 tm_par2:8;	/*     specify the number of coprocessor cycles.  */
+	u64 tm_par3:8;	/*     A value of zero means one cycle.		  */
+	u64 tm_par4:8;	/*     All values are scaled by tim_mult	  */
+	u64 tm_par5:8;	/*     using tim_par * (2 ^ tim_mult).		  */
+	u64 tm_par6:8;
+	u64 tm_par7:8;
+};
+
+struct ndf_ale_cmd {
+	u32 opcode:4;
+	u32:4;
+	u32 adr_byte_num:4;	/* number of address bytes to be sent */
+	u32:4;
+	u32 alen1:3;
+	u32 alen2:3;
+	u32 alen3:3;
+	u32 alen4:3;
+	u32:4;
+	u8 adr_byt1;
+	u8 adr_byt2;
+	u8 adr_byt3;
+	u8 adr_byt4;
+	u8 adr_byt5;
+	u8 adr_byt6;
+	u8 adr_byt7;
+	u8 adr_byt8;
+};
+
+struct ndf_wait_status_cmd {
+	u32 opcode:4;
+	u32:4;
+	u32 data:8;		/** data */
+	u32 clen1:3;
+	u32 clen2:3;
+	u32 clen3:3;
+	u32:8;
+	/** set to 5 to select WAIT_STATUS_ALE command */
+	u32 ale_ind:8;
+	/** ALE only: number of address bytes to be sent */
+	u32 adr_byte_num:4;
+	u32:4;
+	u32 alen1:3;	/* ALE only */
+	u32 alen2:3;	/* ALE only */
+	u32 alen3:3;	/* ALE only */
+	u32 alen4:3;	/* ALE only */
+	u32:4;
+	u8 adr_byt[4];		/* ALE only */
+	u32 nine:4;	/* set to 9 */
+	u32 and_mask:8;
+	u32 comp_byte:8;
+	u32 rlen1:3;
+	u32 rlen2:3;
+	u32 rlen3:3;
+	u32 rlen4:3;
+};
+
+union ndf_cmd {
+	u64 val[2];
+	union {
+		struct ndf_nop_cmd		nop;
+		struct ndf_wait_cmd		wait;
+		struct ndf_bus_cmd		bus_acq_rel;
+		struct ndf_chip_cmd		chip_en_dis;
+		struct ndf_cle_cmd		cle_cmd;
+		struct ndf_rd_cmd		rd_cmd;
+		struct ndf_wr_cmd		wr_cmd;
+		struct ndf_set_tm_par_cmd	set_tm_par;
+		struct ndf_ale_cmd		ale_cmd;
+		struct ndf_wait_status_cmd	wait_status;
+	} u;
+};
+
+/** Disable multi-bit error hangs */
+#define NDF_MISC_MB_DIS		BIT_ULL(27)
+/** High watermark for NBR FIFO or load/store operations */
+#define NDF_MISC_NBR_HWM	GENMASK_ULL(26, 24)
+/** Wait input filter count */
+#define NDF_MISC_WAIT_CNT	GENMASK_ULL(23, 18)
+/** Unfilled NFD_CMD queue bytes */
+#define NDF_MISC_FR_BYTE	GENMASK_ULL(17, 7)
+/** Set by HW when it reads the last 8 bytes of NDF_CMD */
+#define NDF_MISC_RD_DONE	BIT_ULL(6)
+/** Set by HW when it reads. SW read of NDF_CMD clears it */
+#define NDF_MISC_RD_VAL		BIT_ULL(5)
+/** Let HW read NDF_CMD queue. Cleared on SW NDF_CMD write */
+#define NDF_MISC_RD_CMD		BIT_ULL(4)
+/** Boot disable */
+#define NDF_MISC_BT_DIS		BIT_ULL(2)
+/** Stop command execution after completing command queue */
+#define NDF_MISC_EX_DIS		BIT_ULL(1)
+/** Reset fifo */
+#define NDF_MISC_RST_FF		BIT_ULL(0)
+
+/** DMA engine enable */
+#define NDF_DMA_CFG_EN		BIT_ULL(63)
+/** Read or write */
+#define NDF_DMA_CFG_RW		BIT_ULL(62)
+/** Terminates DMA and clears enable bit */
+#define NDF_DMA_CFG_CLR		BIT_ULL(61)
+/** 32-bit swap enable */
+#define NDF_DMA_CFG_SWAP32	BIT_ULL(59)
+/** 16-bit swap enable */
+#define NDF_DMA_CFG_SWAP16	BIT_ULL(58)
+/** 8-bit swap enable */
+#define NDF_DMA_CFG_SWAP8	BIT_ULL(57)
+/** Endian mode */
+#define NDF_DMA_CFG_CMD_BE	BIT_ULL(56)
+/** Number of 64 bit transfers */
+#define NDF_DMA_CFG_SIZE	GENMASK_ULL(55, 36)
+
+/** Command execution status idle */
+#define NDF_ST_REG_EXE_IDLE	BIT_ULL(15)
+/** Command execution SM states */
+#define NDF_ST_REG_EXE_SM	GENMASK_ULL(14, 11)
+/** DMA and load SM states */
+#define NDF_ST_REG_BT_SM	GENMASK_ULL(10, 7)
+/** Queue read-back SM bad state */
+#define NDF_ST_REG_RD_FF_BAD	BIT_ULL(6)
+/** Queue read-back SM states */
+#define NDF_ST_REG_RD_FF	GENMASK_ULL(5, 4)
+/** Main SM is in a bad state */
+#define NDF_ST_REG_MAIN_BAD	BIT_ULL(3)
+/** Main SM states */
+#define NDF_ST_REG_MAIN_SM	GENMASK_ULL(2, 0)
+
+#define MAX_NAND_NAME_LEN	64
+#if (defined(NAND_MAX_PAGESIZE) && (NAND_MAX_PAGESIZE > 4096)) ||	\
+	!defined(NAND_MAX_PAGESIZE)
+# undef NAND_MAX_PAGESIZE
+# define NAND_MAX_PAGESIZE	4096
+#endif
+#if (defined(NAND_MAX_OOBSIZE) && (NAND_MAX_OOBSIZE > 256)) ||		\
+	!defined(NAND_MAX_OOBSIZE)
+# undef NAND_MAX_OOBSIZE
+# define NAND_MAX_OOBSIZE	256
+#endif
+
+#define OCTEONTX_NAND_DRIVER_NAME	"octeontx_nand"
+
+#define NDF_TIMEOUT		1000	/** Timeout in ms */
+#define USEC_PER_SEC		1000000	/** Linux compatibility */
+#ifndef NAND_MAX_CHIPS
+# define NAND_MAX_CHIPS		8	/** Linux compatibility */
+#endif
+
+struct octeontx_nand_chip {
+	struct list_head node;
+	struct nand_chip nand;
+	struct ndf_set_tm_par_cmd timings;
+	int cs;
+	int selected_page;
+	int iface_mode;
+	int row_bytes;
+	int col_bytes;
+	bool oob_only;
+	bool iface_set;
+};
+
+struct octeontx_nand_buf {
+	u8 *dmabuf;
+	dma_addr_t dmaaddr;
+	int dmabuflen;
+	int data_len;
+	int data_index;
+};
+
+/** NAND flash controller (NDF) related information */
+struct octeontx_nfc {
+	struct nand_hw_control controller;
+	struct udevice *dev;
+	void __iomem *base;
+	struct list_head chips;
+	int selected_chip;      /* Currently selected NAND chip number */
+
+	/*
+	 * Status is separate from octeontx_nand_buf because
+	 * it can be used in parallel and during init.
+	 */
+	u8 *stat;
+	dma_addr_t stat_addr;
+	bool use_status;
+
+	struct octeontx_nand_buf buf;
+	union bch_resp *bch_resp;
+	dma_addr_t bch_rhandle;
+
+	/* BCH of all-0xff, so erased pages read as error-free */
+	unsigned char *eccmask;
+};
+
+/* settable timings - 0..7 select timing of alen1..4/clen1..3/etc */
+enum tm_idx {
+	t0, /* fixed at 4<<mult cycles */
+	t1, t2, t3, t4, t5, t6, t7, /* settable per ONFI-timing mode */
+};
+
+#ifdef CONFIG_OCTEONTX_BCH
+struct octeontx_probe_device {
+	struct list_head list;
+	struct udevice *dev;
+};
+
+/** Deferred devices due to BCH not being ready */
+LIST_HEAD(octeontx_pci_nand_deferred_devices);
+#endif
+
+/** default parameters used for probing chips */
+#define MAX_ONFI_MODE	5
+
+static int default_onfi_timing;
+static int slew_ns = 2; /* default timing padding */
+static int def_ecc_size = 512; /* 1024 best for sw_bch, <= 4095 for hw_bch */
+static int default_width = 1; /* 8 bit */
+static int default_page_size = 2048;
+static struct ndf_set_tm_par_cmd default_timing_parms;
+
+/** Port from Linux */
+#define readq_poll_timeout(addr, val, cond, delay_us, timeout_us)	\
+({									\
+	ulong __start = get_timer(0);					\
+	void *__addr = (addr);						\
+	const ulong __timeout_ms = timeout_us / 1000;			\
+	do {								\
+		(val) = readq(__addr);					\
+		if (cond)						\
+			break;						\
+		if (timeout_us && get_timer(__start) > __timeout_ms) {	\
+			(val) = readq(__addr);				\
+			break;						\
+		}							\
+		if (delay_us)						\
+			udelay(delay_us);				\
+	} while (1);							\
+	(cond) ? 0 : -ETIMEDOUT;					\
+})
+
+/** Ported from Linux 4.9.0 include/linux/of.h for compatibility */
+static inline int of_get_child_count(const ofnode node)
+{
+	return fdtdec_get_child_count(gd->fdt_blob, ofnode_to_offset(node));
+}
+
+/**
+ * Linux compatibility from Linux 4.9.0 drivers/mtd/nand/nand_base.c
+ */
+static int nand_ooblayout_ecc_lp(struct mtd_info *mtd, int section,
+				 struct mtd_oob_region *oobregion)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct nand_ecc_ctrl *ecc = &chip->ecc;
+
+	if (section || !ecc->total)
+		return -ERANGE;
+
+	oobregion->length = ecc->total;
+	oobregion->offset = mtd->oobsize - oobregion->length;
+
+	return 0;
+}
+
+/**
+ * Linux compatibility from Linux 4.9.0 drivers/mtd/nand/nand_base.c
+ */
+static int nand_ooblayout_free_lp(struct mtd_info *mtd, int section,
+				  struct mtd_oob_region *oobregion)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct nand_ecc_ctrl *ecc = &chip->ecc;
+
+	if (section)
+		return -ERANGE;
+
+	oobregion->length = mtd->oobsize - ecc->total - 2;
+	oobregion->offset = 2;
+
+	return 0;
+}
+
+static const struct mtd_ooblayout_ops nand_ooblayout_lp_ops = {
+	.ecc = nand_ooblayout_ecc_lp,
+	.free = nand_ooblayout_free_lp,
+};
+
+static struct bch_vf *bch_vf;
+
+static inline struct octeontx_nand_chip *to_otx_nand(struct nand_chip *nand)
+{
+	return container_of(nand, struct octeontx_nand_chip, nand);
+}
+
+static inline struct octeontx_nfc *to_otx_nfc(struct nand_hw_control *ctrl)
+{
+	return container_of(ctrl, struct octeontx_nfc, controller);
+}
+
+/** Ported from Linux 4.9.0 include/linux/mtd/mtd.h for compatibility */
+static inline void mtd_set_of_node(struct mtd_info *mtd, ofnode node)
+{
+	mtd->dev->node = node;
+}
+
+/** Ported from Linux 4.9.0 include/linux/mtd/nand.h for compatibility */
+static inline void nand_set_flash_node(struct nand_chip *chip,
+				       ofnode node)
+{
+	mtd_set_of_node(&chip->mtd, node);
+	chip->flash_node = ofnode_to_offset(node);
+}
+
+static int octeontx_nand_calc_ecc_layout(struct nand_chip *nand)
+{
+	struct nand_ecclayout *layout = nand->ecc.layout;
+	struct octeontx_nfc *tn = to_otx_nfc(nand->controller);
+	struct mtd_info *mtd = &nand->mtd;
+	int oobsize = mtd->oobsize;
+	int i;
+	bool layout_alloc = false;
+
+	if (!layout) {
+		layout = devm_kzalloc(tn->dev, sizeof(*layout), GFP_KERNEL);
+		if (!layout)
+			return -ENOMEM;
+		nand->ecc.layout = layout;
+		layout_alloc = true;
+	}
+	layout->eccbytes = nand->ecc.steps * nand->ecc.bytes;
+	/* Reserve 2 bytes for bad block marker */
+	if (layout->eccbytes + 2 > oobsize) {
+		pr_err("No suitable oob scheme available for oobsize %d eccbytes %u\n",
+		       oobsize, layout->eccbytes);
+		goto fail;
+	}
+	/* put ecc bytes at oob tail */
+	for (i = 0; i < layout->eccbytes; i++)
+		layout->eccpos[i] = oobsize - layout->eccbytes + i;
+	layout->oobfree[0].offset = 2;
+	layout->oobfree[0].length = oobsize - 2 - layout->eccbytes;
+	nand->ecc.layout = layout;
+	return 0;
+
+fail:
+	if (layout_alloc)
+		kfree(layout);
+	return -1;
+}
+
+/*
+ * Read a single byte from the temporary buffer. Used after READID
+ * to get the NAND information and for STATUS.
+ */
+static u8 octeontx_nand_read_byte(struct mtd_info *mtd)
+{
+	struct nand_chip *nand = mtd_to_nand(mtd);
+	struct octeontx_nfc *tn = to_otx_nfc(nand->controller);
+
+	if (tn->use_status) {
+		tn->use_status = false;
+		return *tn->stat;
+	}
+
+	if (tn->buf.data_index < tn->buf.data_len)
+		return tn->buf.dmabuf[tn->buf.data_index++];
+
+	dev_err(tn->dev, "No data to read, idx: 0x%x, len: 0x%x\n",
+		tn->buf.data_index, tn->buf.data_len);
+
+	return 0xff;
+}
+
+/*
+ * Read a number of pending bytes from the temporary buffer. Used
+ * to get page and OOB data.
+ */
+static void octeontx_nand_read_buf(struct mtd_info *mtd, u8 *buf, int len)
+{
+	struct nand_chip *nand = mtd_to_nand(mtd);
+	struct octeontx_nfc *tn = to_otx_nfc(nand->controller);
+
+	if (len > tn->buf.data_len - tn->buf.data_index) {
+		dev_err(tn->dev, "Not enough data for read of %d bytes\n", len);
+		return;
+	}
+
+	memcpy(buf, tn->buf.dmabuf + tn->buf.data_index, len);
+	tn->buf.data_index += len;
+}
+
+static void octeontx_nand_write_buf(struct mtd_info *mtd,
+				    const u8 *buf, int len)
+{
+	struct nand_chip *nand = mtd_to_nand(mtd);
+	struct octeontx_nfc *tn = to_otx_nfc(nand->controller);
+
+	memcpy(tn->buf.dmabuf + tn->buf.data_len, buf, len);
+	tn->buf.data_len += len;
+}
+
+/* Overwrite default function to avoid sync abort on chip = -1. */
+static void octeontx_nand_select_chip(struct mtd_info *mtd, int chip)
+{
+}
+
+static inline int timing_to_cycle(u32 psec, unsigned long clock)
+{
+	unsigned int ns;
+	int ticks;
+
+	ns = DIV_ROUND_UP(psec, 1000);
+	ns += slew_ns;
+
+	/* no rounding needed since clock is multiple of 1MHz */
+	clock /= 1000000;
+	ns *= clock;
+
+	ticks = DIV_ROUND_UP(ns, 1000);
+
+	/* actual delay is (tm_parX+1)<<tim_mult */
+	if (ticks)
+		ticks--;
+
+	return ticks;
+}
+
+static void set_timings(struct octeontx_nand_chip *chip,
+			struct ndf_set_tm_par_cmd *tp,
+			const struct nand_sdr_timings *timings,
+			unsigned long sclk)
+{
+	/* scaled coprocessor-cycle values */
+	u32 sWH, sCLS, sCLH, sRP, sWB, sWC;
+
+	tp->tim_mult = 0;
+	sWH = timing_to_cycle(timings->tWH_min, sclk);
+	sCLS = timing_to_cycle(timings->tCLS_min, sclk);
+	sCLH = timing_to_cycle(timings->tCLH_min, sclk);
+	sRP = timing_to_cycle(timings->tRP_min, sclk);
+	sWB = timing_to_cycle(timings->tWB_max, sclk);
+	sWC = timing_to_cycle(timings->tWC_min, sclk);
+
+	tp->tm_par1 = sWH;
+	tp->tm_par2 = sCLH;
+	tp->tm_par3 = sRP + 1;
+	tp->tm_par4 = sCLS - sWH;
+	tp->tm_par5 = sWC - sWH + 1;
+	tp->tm_par6 = sWB;
+	tp->tm_par7 = 0;
+	tp->tim_mult++; /* overcompensate for bad math */
+
+	/* TODO: comment parameter re-use */
+
+	pr_debug("%s: tim_par: mult: %d  p1: %d  p2: %d  p3: %d\n",
+		 __func__, tp->tim_mult, tp->tm_par1, tp->tm_par2, tp->tm_par3);
+	pr_debug("                 p4: %d  p5: %d  p6: %d  p7: %d\n",
+		 tp->tm_par4, tp->tm_par5, tp->tm_par6, tp->tm_par7);
+}
+
+static int set_default_timings(struct octeontx_nfc *tn,
+			       const struct nand_sdr_timings *timings)
+{
+	unsigned long sclk = octeontx_get_io_clock();
+
+	set_timings(NULL, &default_timing_parms, timings, sclk);
+	return 0;
+}
+
+static int octeontx_nfc_chip_set_timings(struct octeontx_nand_chip *chip,
+					 const struct nand_sdr_timings *timings)
+{
+	/*struct octeontx_nfc *tn = to_otx_nfc(chip->nand.controller);*/
+	unsigned long sclk = octeontx_get_io_clock();
+
+	set_timings(chip, &chip->timings, timings, sclk);
+	return 0;
+}
+
+/* How many bytes are free in the NFD_CMD queue? */
+static int ndf_cmd_queue_free(struct octeontx_nfc *tn)
+{
+	u64 ndf_misc;
+
+	ndf_misc = readq(tn->base + NDF_MISC);
+	return FIELD_GET(NDF_MISC_FR_BYTE, ndf_misc);
+}
+
+/* Submit a command to the NAND command queue. */
+static int ndf_submit(struct octeontx_nfc *tn, union ndf_cmd *cmd)
+{
+	int opcode = cmd->val[0] & 0xf;
+
+	switch (opcode) {
+	/* All these commands fit in one 64bit word */
+	case NDF_OP_NOP:
+	case NDF_OP_SET_TM_PAR:
+	case NDF_OP_WAIT:
+	case NDF_OP_CHIP_EN_DIS:
+	case NDF_OP_CLE_CMD:
+	case NDF_OP_WR_CMD:
+	case NDF_OP_RD_CMD:
+	case NDF_OP_RD_EDO_CMD:
+	case NDF_OP_BUS_ACQ_REL:
+		if (ndf_cmd_queue_free(tn) < 8)
+			goto full;
+		writeq(cmd->val[0], tn->base + NDF_CMD);
+		break;
+	case NDF_OP_ALE_CMD:
+		/* ALE commands take either one or two 64bit words */
+		if (cmd->u.ale_cmd.adr_byte_num < 5) {
+			if (ndf_cmd_queue_free(tn) < 8)
+				goto full;
+			writeq(cmd->val[0], tn->base + NDF_CMD);
+		} else {
+			if (ndf_cmd_queue_free(tn) < 16)
+				goto full;
+			writeq(cmd->val[0], tn->base + NDF_CMD);
+			writeq(cmd->val[1], tn->base + NDF_CMD);
+		}
+		break;
+	case NDF_OP_WAIT_STATUS: /* Wait status commands take two 64bit words */
+		if (ndf_cmd_queue_free(tn) < 16)
+			goto full;
+		writeq(cmd->val[0], tn->base + NDF_CMD);
+		writeq(cmd->val[1], tn->base + NDF_CMD);
+		break;
+	default:
+		dev_err(tn->dev, "%s: unknown command: %u\n", __func__, opcode);
+		return -EINVAL;
+	}
+	return 0;
+
+full:
+	dev_err(tn->dev, "%s: no space left in command queue\n", __func__);
+	return -ENOMEM;
+}
+
+/**
+ * Wait for the ready/busy signal. First wait for busy to be valid,
+ * then wait for busy to de-assert.
+ */
+static int ndf_build_wait_busy(struct octeontx_nfc *tn)
+{
+	union ndf_cmd cmd;
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.u.wait.opcode = NDF_OP_WAIT;
+	cmd.u.wait.r_b = 1;
+	cmd.u.wait.wlen = t6;
+
+	if (ndf_submit(tn, &cmd))
+		return -ENOMEM;
+	return 0;
+}
+
+static bool ndf_dma_done(struct octeontx_nfc *tn)
+{
+	u64 dma_cfg;
+
+	/* Enable bit should be clear after a transfer */
+	dma_cfg = readq(tn->base + NDF_DMA_CFG);
+	if (!(dma_cfg & NDF_DMA_CFG_EN))
+		return true;
+
+	return false;
+}
+
+static int ndf_wait(struct octeontx_nfc *tn)
+{
+	ulong start = get_timer(0);
+	bool done;
+
+	while (!(done = ndf_dma_done(tn)) && get_timer(start) < NDF_TIMEOUT)
+		;
+
+	if (!done) {
+		dev_err(tn->dev, "%s: timeout error\n", __func__);
+		return -ETIMEDOUT;
+	}
+	return 0;
+}
+
+static int ndf_wait_idle(struct octeontx_nfc *tn)
+{
+	u64 val;
+	u64 dval = 0;
+	int rc;
+	int pause = 100;
+	u64 tot_us = USEC_PER_SEC / 10;
+
+	rc = readq_poll_timeout(tn->base + NDF_ST_REG,
+				val, val & NDF_ST_REG_EXE_IDLE, pause, tot_us);
+	if (!rc)
+		rc = readq_poll_timeout(tn->base + NDF_DMA_CFG,
+					dval, !(dval & NDF_DMA_CFG_EN),
+					pause, tot_us);
+
+	return rc;
+}
+
+/** Issue set timing parameters */
+static int ndf_queue_cmd_timing(struct octeontx_nfc *tn,
+				struct ndf_set_tm_par_cmd *timings)
+{
+	union ndf_cmd cmd;
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.u.set_tm_par.opcode = NDF_OP_SET_TM_PAR;
+	cmd.u.set_tm_par.tim_mult = timings->tim_mult;
+	cmd.u.set_tm_par.tm_par1 = timings->tm_par1;
+	cmd.u.set_tm_par.tm_par2 = timings->tm_par2;
+	cmd.u.set_tm_par.tm_par3 = timings->tm_par3;
+	cmd.u.set_tm_par.tm_par4 = timings->tm_par4;
+	cmd.u.set_tm_par.tm_par5 = timings->tm_par5;
+	cmd.u.set_tm_par.tm_par6 = timings->tm_par6;
+	cmd.u.set_tm_par.tm_par7 = timings->tm_par7;
+	return ndf_submit(tn, &cmd);
+}
+
+/** Issue bus acquire or release */
+static int ndf_queue_cmd_bus(struct octeontx_nfc *tn, int direction)
+{
+	union ndf_cmd cmd;
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.u.bus_acq_rel.opcode = NDF_OP_BUS_ACQ_REL;
+	cmd.u.bus_acq_rel.direction = direction;
+	return ndf_submit(tn, &cmd);
+}
+
+/* Issue chip select or deselect */
+static int ndf_queue_cmd_chip(struct octeontx_nfc *tn, int enable, int chip,
+			      int width)
+{
+	union ndf_cmd cmd;
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.u.chip_en_dis.opcode = NDF_OP_CHIP_EN_DIS;
+	cmd.u.chip_en_dis.chip = chip;
+	cmd.u.chip_en_dis.enable = enable;
+	cmd.u.chip_en_dis.bus_width = width;
+	return ndf_submit(tn, &cmd);
+}
+
+static int ndf_queue_cmd_wait(struct octeontx_nfc *tn, int t_delay)
+{
+	union ndf_cmd cmd;
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.u.wait.opcode = NDF_OP_WAIT;
+	cmd.u.wait.wlen = t_delay;
+	return ndf_submit(tn, &cmd);
+}
+
+static int ndf_queue_cmd_cle(struct octeontx_nfc *tn, int command)
+{
+	union ndf_cmd cmd;
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.u.cle_cmd.opcode = NDF_OP_CLE_CMD;
+	cmd.u.cle_cmd.cmd_data = command;
+	cmd.u.cle_cmd.clen1 = t4;
+	cmd.u.cle_cmd.clen2 = t1;
+	cmd.u.cle_cmd.clen3 = t2;
+	return ndf_submit(tn, &cmd);
+}
+
+static int ndf_queue_cmd_ale(struct octeontx_nfc *tn, int addr_bytes,
+			     struct nand_chip *nand, u64 page,
+			     u32 col, int page_size)
+{
+	struct octeontx_nand_chip *octeontx_nand = (nand) ?
+						to_otx_nand(nand) : NULL;
+	union ndf_cmd cmd;
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.u.ale_cmd.opcode = NDF_OP_ALE_CMD;
+	cmd.u.ale_cmd.adr_byte_num = addr_bytes;
+
+	/* set column bit for OOB area, assume OOB follows page */
+	if (octeontx_nand && octeontx_nand->oob_only)
+		col += page_size;
+
+	/* page is u64 for this generality, even if cmdfunc() passes int */
+	switch (addr_bytes) {
+	/* 4-8 bytes: page, then 2-byte col */
+	case 8:
+		cmd.u.ale_cmd.adr_byt8 = (page >> 40) & 0xff;
+		/* fall thru */
+	case 7:
+		cmd.u.ale_cmd.adr_byt7 = (page >> 32) & 0xff;
+		/* fall thru */
+	case 6:
+		cmd.u.ale_cmd.adr_byt6 = (page >> 24) & 0xff;
+		/* fall thru */
+	case 5:
+		cmd.u.ale_cmd.adr_byt5 = (page >> 16) & 0xff;
+		/* fall thru */
+	case 4:
+		cmd.u.ale_cmd.adr_byt4 = (page >> 8) & 0xff;
+		cmd.u.ale_cmd.adr_byt3 = page & 0xff;
+		cmd.u.ale_cmd.adr_byt2 = (col >> 8) & 0xff;
+		cmd.u.ale_cmd.adr_byt1 =  col & 0xff;
+		break;
+	/* 1-3 bytes: just the page address */
+	case 3:
+		cmd.u.ale_cmd.adr_byt3 = (page >> 16) & 0xff;
+		/* fall thru */
+	case 2:
+		cmd.u.ale_cmd.adr_byt2 = (page >> 8) & 0xff;
+		/* fall thru */
+	case 1:
+		cmd.u.ale_cmd.adr_byt1 = page & 0xff;
+		break;
+	default:
+		break;
+	}
+
+	cmd.u.ale_cmd.alen1 = t3;
+	cmd.u.ale_cmd.alen2 = t1;
+	cmd.u.ale_cmd.alen3 = t5;
+	cmd.u.ale_cmd.alen4 = t2;
+	return ndf_submit(tn, &cmd);
+}
+
+static int ndf_queue_cmd_write(struct octeontx_nfc *tn, int len)
+{
+	union ndf_cmd cmd;
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.u.wr_cmd.opcode = NDF_OP_WR_CMD;
+	cmd.u.wr_cmd.data = len;
+	cmd.u.wr_cmd.wlen1 = t3;
+	cmd.u.wr_cmd.wlen2 = t1;
+	return ndf_submit(tn, &cmd);
+}
+
+static int ndf_build_pre_cmd(struct octeontx_nfc *tn, int cmd1,
+			     int addr_bytes, u64 page, u32 col, int cmd2)
+{
+	struct nand_chip *nand = tn->controller.active;
+	struct octeontx_nand_chip *octeontx_nand;
+	struct ndf_set_tm_par_cmd *timings;
+	int width, page_size, rc;
+
+	/* Also called before chip probing is finished */
+	if (!nand) {
+		timings = &default_timing_parms;
+		page_size = default_page_size;
+		width = default_width;
+	} else {
+		octeontx_nand = to_otx_nand(nand);
+		timings = &octeontx_nand->timings;
+		page_size = nand->mtd.writesize;
+		if (nand->options & NAND_BUSWIDTH_16)
+			width = 2;
+		else
+			width = 1;
+	}
+	rc = ndf_queue_cmd_timing(tn, timings);
+	if (rc)
+		return rc;
+
+	rc = ndf_queue_cmd_bus(tn, NDF_BUS_ACQUIRE);
+	if (rc)
+		return rc;
+
+	rc = ndf_queue_cmd_chip(tn, 1, tn->selected_chip, width);
+	if (rc)
+		return rc;
+
+	rc = ndf_queue_cmd_wait(tn, t1);
+	if (rc)
+		return rc;
+
+	rc = ndf_queue_cmd_cle(tn, cmd1);
+	if (rc)
+		return rc;
+
+	if (addr_bytes) {
+		rc = ndf_build_wait_busy(tn);
+		if (rc)
+			return rc;
+
+		rc = ndf_queue_cmd_ale(tn, addr_bytes, nand,
+				       page, col, page_size);
+		if (rc)
+			return rc;
+	}
+
+	/* CLE 2 */
+	if (cmd2) {
+		rc = ndf_build_wait_busy(tn);
+		if (rc)
+			return rc;
+
+		rc = ndf_queue_cmd_cle(tn, cmd2);
+		if (rc)
+			return rc;
+	}
+	return 0;
+}
+
+static int ndf_build_post_cmd(struct octeontx_nfc *tn, int hold_time)
+{
+	int rc;
+
+	/* Deselect chip */
+	rc = ndf_queue_cmd_chip(tn, 0, 0, 0);
+	if (rc)
+		return rc;
+
+	rc = ndf_queue_cmd_wait(tn, t2);
+	if (rc)
+		return rc;
+
+	/* Release bus */
+	rc = ndf_queue_cmd_bus(tn, 0);
+	if (rc)
+		return rc;
+
+	rc = ndf_queue_cmd_wait(tn, hold_time);
+	if (rc)
+		return rc;
+
+	/*
+	 * Last action is ringing the doorbell with number of bus
+	 * acquire-releases cycles (currently 1).
+	 */
+	writeq(1, tn->base + NDF_DRBELL);
+	return 0;
+}
+
+/* Setup the NAND DMA engine for a transfer. */
+static void ndf_setup_dma(struct octeontx_nfc *tn, int is_write,
+			  dma_addr_t bus_addr, int len)
+{
+	u64 dma_cfg;
+
+	dma_cfg = FIELD_PREP(NDF_DMA_CFG_RW, is_write) |
+		  FIELD_PREP(NDF_DMA_CFG_SIZE, (len >> 3) - 1);
+	dma_cfg |= NDF_DMA_CFG_EN;
+	writeq(bus_addr, tn->base + NDF_DMA_ADR);
+	writeq(dma_cfg, tn->base + NDF_DMA_CFG);
+}
+
+static int octeontx_nand_reset(struct octeontx_nfc *tn)
+{
+	int rc;
+
+	rc = ndf_build_pre_cmd(tn, NAND_CMD_RESET, 0, 0, 0, 0);
+	if (rc)
+		return rc;
+
+	rc = ndf_build_wait_busy(tn);
+	if (rc)
+		return rc;
+
+	rc = ndf_build_post_cmd(tn, t2);
+	if (rc)
+		return rc;
+
+	return 0;
+}
+
+static int ndf_read(struct octeontx_nfc *tn, int cmd1, int addr_bytes,
+		    u64 page, u32 col, int cmd2, int len)
+{
+	dma_addr_t bus_addr = tn->use_status ? tn->stat_addr : tn->buf.dmaaddr;
+	struct nand_chip *nand = tn->controller.active;
+	int timing_mode, bytes, rc;
+	union ndf_cmd cmd;
+	u64 start, end;
+
+	pr_debug("%s(%p, 0x%x, 0x%x, 0x%llx, 0x%x, 0x%x, 0x%x)\n", __func__,
+		 tn, cmd1, addr_bytes, page, col, cmd2, len);
+	if (!nand)
+		timing_mode = default_onfi_timing;
+	else
+		timing_mode = nand->onfi_timing_mode_default;
+
+	/* Build the command and address cycles */
+	rc = ndf_build_pre_cmd(tn, cmd1, addr_bytes, page, col, cmd2);
+	if (rc) {
+		dev_err(tn->dev, "Build pre command failed\n");
+		return rc;
+	}
+
+	/* This waits for some time, then waits for busy to be de-asserted. */
+	rc = ndf_build_wait_busy(tn);
+	if (rc) {
+		dev_err(tn->dev, "Wait timeout\n");
+		return rc;
+	}
+
+	memset(&cmd, 0, sizeof(cmd));
+
+	if (timing_mode < 4)
+		cmd.u.rd_cmd.opcode = NDF_OP_RD_CMD;
+	else
+		cmd.u.rd_cmd.opcode = NDF_OP_RD_EDO_CMD;
+
+	cmd.u.rd_cmd.data = len;
+	cmd.u.rd_cmd.rlen1 = t7;
+	cmd.u.rd_cmd.rlen2 = t3;
+	cmd.u.rd_cmd.rlen3 = t1;
+	cmd.u.rd_cmd.rlen4 = t7;
+	rc = ndf_submit(tn, &cmd);
+	if (rc) {
+		dev_err(tn->dev, "Error submitting command\n");
+		return rc;
+	}
+
+	start = (u64)bus_addr;
+	ndf_setup_dma(tn, 0, bus_addr, len);
+
+	rc = ndf_build_post_cmd(tn, t2);
+	if (rc) {
+		dev_err(tn->dev, "Build post command failed\n");
+		return rc;
+	}
+
+	/* Wait for the DMA to complete */
+	rc = ndf_wait(tn);
+	if (rc) {
+		dev_err(tn->dev, "DMA timed out\n");
+		return rc;
+	}
+
+	end = readq(tn->base + NDF_DMA_ADR);
+	bytes = end - start;
+
+	/* Make sure NDF is really done */
+	rc = ndf_wait_idle(tn);
+	if (rc) {
+		dev_err(tn->dev, "poll idle failed\n");
+		return rc;
+	}
+
+	pr_debug("%s: Read %d bytes\n", __func__, bytes);
+	return bytes;
+}
+
+static int octeontx_nand_get_features(struct mtd_info *mtd,
+				      struct nand_chip *chip, int feature_addr,
+				      u8 *subfeature_para)
+{
+	struct nand_chip *nand = chip;
+	struct octeontx_nfc *tn = to_otx_nfc(nand->controller);
+	int len = 8;
+	int rc;
+
+	pr_debug("%s: feature addr: 0x%x\n", __func__, feature_addr);
+	memset(tn->buf.dmabuf, 0xff, len);
+	tn->buf.data_index = 0;
+	tn->buf.data_len = 0;
+	rc = ndf_read(tn, NAND_CMD_GET_FEATURES, 1, feature_addr, 0, 0, len);
+	if (rc)
+		return rc;
+
+	memcpy(subfeature_para, tn->buf.dmabuf, ONFI_SUBFEATURE_PARAM_LEN);
+
+	return 0;
+}
+
+static int octeontx_nand_set_features(struct mtd_info *mtd,
+				      struct nand_chip *chip, int feature_addr,
+				      u8 *subfeature_para)
+{
+	struct nand_chip *nand = chip;
+	struct octeontx_nfc *tn = to_otx_nfc(nand->controller);
+	const int len = ONFI_SUBFEATURE_PARAM_LEN;
+	int rc;
+
+	rc = ndf_build_pre_cmd(tn, NAND_CMD_SET_FEATURES,
+			       1, feature_addr, 0, 0);
+	if (rc)
+		return rc;
+
+	memcpy(tn->buf.dmabuf, subfeature_para, len);
+	memset(tn->buf.dmabuf + len, 0, 8 - len);
+
+	ndf_setup_dma(tn, 1, tn->buf.dmaaddr, 8);
+
+	rc = ndf_queue_cmd_write(tn, 8);
+	if (rc)
+		return rc;
+
+	rc = ndf_build_wait_busy(tn);
+	if (rc)
+		return rc;
+
+	rc = ndf_build_post_cmd(tn, t2);
+	if (rc)
+		return rc;
+
+	return 0;
+}
+
+/*
+ * Read a page from NAND. If the buffer has room, the out of band
+ * data will be included.
+ */
+static int ndf_page_read(struct octeontx_nfc *tn, u64 page, int col, int len)
+{
+	debug("%s(%p, 0x%llx, 0x%x, 0x%x) active: %p\n", __func__,
+	      tn, page, col, len, tn->controller.active);
+	struct nand_chip *nand = tn->controller.active;
+	struct octeontx_nand_chip *chip = to_otx_nand(nand);
+	int addr_bytes = chip->row_bytes + chip->col_bytes;
+
+	memset(tn->buf.dmabuf, 0xff, len);
+	return ndf_read(tn, NAND_CMD_READ0, addr_bytes,
+		    page, col, NAND_CMD_READSTART, len);
+}
+
+/* Erase a NAND block */
+static int ndf_block_erase(struct octeontx_nfc *tn, u64 page_addr)
+{
+	struct nand_chip *nand = tn->controller.active;
+	struct octeontx_nand_chip *chip = to_otx_nand(nand);
+	int addr_bytes = chip->row_bytes;
+	int rc;
+
+	rc = ndf_build_pre_cmd(tn, NAND_CMD_ERASE1, addr_bytes,
+			       page_addr, 0, NAND_CMD_ERASE2);
+	if (rc)
+		return rc;
+
+	/* Wait for R_B to signal erase is complete  */
+	rc = ndf_build_wait_busy(tn);
+	if (rc)
+		return rc;
+
+	rc = ndf_build_post_cmd(tn, t2);
+	if (rc)
+		return rc;
+
+	/* Wait until the command queue is idle */
+	return ndf_wait_idle(tn);
+}
+
+/*
+ * Write a page (or less) to NAND.
+ */
+static int ndf_page_write(struct octeontx_nfc *tn, int page)
+{
+	int len, rc;
+	struct nand_chip *nand = tn->controller.active;
+	struct octeontx_nand_chip *chip = to_otx_nand(nand);
+	int addr_bytes = chip->row_bytes + chip->col_bytes;
+
+	len = tn->buf.data_len - tn->buf.data_index;
+	chip->oob_only = (tn->buf.data_index >= nand->mtd.writesize);
+	WARN_ON_ONCE(len & 0x7);
+
+	ndf_setup_dma(tn, 1, tn->buf.dmaaddr + tn->buf.data_index, len);
+	rc = ndf_build_pre_cmd(tn, NAND_CMD_SEQIN, addr_bytes, page, 0, 0);
+	if (rc)
+		return rc;
+
+	rc = ndf_queue_cmd_write(tn, len);
+	if (rc)
+		return rc;
+
+	rc = ndf_queue_cmd_cle(tn, NAND_CMD_PAGEPROG);
+	if (rc)
+		return rc;
+
+	/* Wait for R_B to signal program is complete  */
+	rc = ndf_build_wait_busy(tn);
+	if (rc)
+		return rc;
+
+	rc = ndf_build_post_cmd(tn, t2);
+	if (rc)
+		return rc;
+
+	/* Wait for the DMA to complete */
+	rc = ndf_wait(tn);
+	if (rc)
+		return rc;
+
+	/* Data transfer is done but NDF is not, it is waiting for R/B# */
+	return ndf_wait_idle(tn);
+}
+
+static void octeontx_nand_cmdfunc(struct mtd_info *mtd, unsigned int command,
+				  int column, int page_addr)
+{
+	struct nand_chip *nand = mtd_to_nand(mtd);
+	struct octeontx_nand_chip *octeontx_nand = to_otx_nand(nand);
+	struct octeontx_nfc *tn = to_otx_nfc(nand->controller);
+	int rc;
+
+	tn->selected_chip = octeontx_nand->cs;
+	if (tn->selected_chip < 0 || tn->selected_chip >= NAND_MAX_CHIPS) {
+		dev_err(tn->dev, "invalid chip select\n");
+		return;
+	}
+
+	tn->use_status = false;
+
+	pr_debug("%s(%p, 0x%x, 0x%x, 0x%x) cs: %d\n", __func__, mtd, command,
+		 column, page_addr, tn->selected_chip);
+	switch (command) {
+	case NAND_CMD_READID:
+		tn->buf.data_index = 0;
+		octeontx_nand->oob_only = false;
+		rc = ndf_read(tn, command, 1, column, 0, 0, 8);
+		if (rc < 0)
+			dev_err(tn->dev, "READID failed with %d\n", rc);
+		else
+			tn->buf.data_len = rc;
+		break;
+
+	case NAND_CMD_READOOB:
+		octeontx_nand->oob_only = true;
+		tn->buf.data_index = 0;
+		tn->buf.data_len = 0;
+		rc = ndf_page_read(tn, page_addr, column, mtd->oobsize);
+		if (rc < mtd->oobsize)
+			dev_err(tn->dev, "READOOB failed with %d\n",
+				tn->buf.data_len);
+		else
+			tn->buf.data_len = rc;
+		break;
+
+	case NAND_CMD_READ0:
+		octeontx_nand->oob_only = false;
+		tn->buf.data_index = 0;
+		tn->buf.data_len = 0;
+		rc = ndf_page_read(tn, page_addr, column,
+				   mtd->writesize + mtd->oobsize);
+
+		if (rc < mtd->writesize + mtd->oobsize)
+			dev_err(tn->dev, "READ0 failed with %d\n", rc);
+		else
+			tn->buf.data_len = rc;
+		break;
+
+	case NAND_CMD_STATUS:
+		/* used in oob/not states */
+		tn->use_status = true;
+		rc = ndf_read(tn, command, 0, 0, 0, 0, 8);
+		if (rc < 0)
+			dev_err(tn->dev, "STATUS failed with %d\n", rc);
+		break;
+
+	case NAND_CMD_RESET:
+		/* used in oob/not states */
+		rc = octeontx_nand_reset(tn);
+		if (rc < 0)
+			dev_err(tn->dev, "RESET failed with %d\n", rc);
+		break;
+
+	case NAND_CMD_PARAM:
+		octeontx_nand->oob_only = false;
+		tn->buf.data_index = 0;
+		rc = ndf_read(tn, command, 1, 0, 0, 0,
+			      min(tn->buf.dmabuflen, 3 * 512));
+		if (rc < 0)
+			dev_err(tn->dev, "PARAM failed with %d\n", rc);
+		else
+			tn->buf.data_len = rc;
+		break;
+
+	case NAND_CMD_RNDOUT:
+		tn->buf.data_index = column;
+		break;
+
+	case NAND_CMD_ERASE1:
+		if (ndf_block_erase(tn, page_addr))
+			dev_err(tn->dev, "ERASE1 failed\n");
+		break;
+
+	case NAND_CMD_ERASE2:
+		/* We do all erase processing in the first command, so ignore
+		 * this one.
+		 */
+		break;
+
+	case NAND_CMD_SEQIN:
+		octeontx_nand->oob_only = (column >= mtd->writesize);
+		tn->buf.data_index = column;
+		tn->buf.data_len = column;
+
+		octeontx_nand->selected_page = page_addr;
+		break;
+
+	case NAND_CMD_PAGEPROG:
+		rc = ndf_page_write(tn, octeontx_nand->selected_page);
+		if (rc)
+			dev_err(tn->dev, "PAGEPROG failed with %d\n", rc);
+		break;
+
+	case NAND_CMD_SET_FEATURES:
+		octeontx_nand->oob_only = false;
+		/* assume tn->buf.data_len == 4 of data has been set there */
+		rc = octeontx_nand_set_features(mtd, nand,
+						page_addr, tn->buf.dmabuf);
+		if (rc)
+			dev_err(tn->dev, "SET_FEATURES failed with %d\n", rc);
+		break;
+
+	case NAND_CMD_GET_FEATURES:
+		octeontx_nand->oob_only = false;
+		rc = octeontx_nand_get_features(mtd, nand,
+						page_addr, tn->buf.dmabuf);
+		if (!rc) {
+			tn->buf.data_index = 0;
+			tn->buf.data_len = 4;
+		} else {
+			dev_err(tn->dev, "GET_FEATURES failed with %d\n", rc);
+		}
+		break;
+
+	default:
+		WARN_ON_ONCE(1);
+		dev_err(tn->dev, "unhandled nand cmd: %x\n", command);
+	}
+}
+
+static int octeontx_nand_waitfunc(struct mtd_info *mtd, struct nand_chip *chip)
+{
+	struct octeontx_nfc *tn = to_otx_nfc(chip->controller);
+	int ret;
+
+	ret = ndf_wait_idle(tn);
+	return (ret < 0) ? -EIO : 0;
+}
+
+/* check compatibility with ONFI timing mode#N, and optionally apply */
+/* TODO: Implement chipnr support? */
+static int octeontx_nand_setup_data_interface(struct mtd_info *mtd, int chipnr,
+	const struct nand_data_interface *conf)
+{
+	static const bool check_only;
+	struct nand_chip *nand = mtd_to_nand(mtd);
+	struct octeontx_nand_chip *chip = to_otx_nand(nand);
+	int rc;
+	static u64 tWC_N[MAX_ONFI_MODE + 2]; /* cache a mode signature */
+	int mode; /* deduced mode number, for reporting and restricting */
+
+	/*
+	 * Cache timing modes for reporting, and reducing needless change.
+	 *
+	 * Challenge: caller does not pass ONFI mode#, but reporting the mode
+	 * and restricting to a maximum, or a list, are useful for diagnosing
+	 * new hardware.  So use tWC_min, distinct and monotonic across modes,
+	 * to discover the requested/accepted mode number
+	 */
+	for (mode = MAX_ONFI_MODE; mode >= 0 && !tWC_N[0]; mode--) {
+		const struct nand_sdr_timings *t;
+
+		t = onfi_async_timing_mode_to_sdr_timings(mode);
+		if (!t)
+			continue;
+		tWC_N[mode] = t->tWC_min;
+	}
+
+	if (!conf) {
+		rc = -EINVAL;
+	} else if (check_only) {
+		rc = 0;
+	} else if (nand->data_interface &&
+			chip->iface_set && chip->iface_mode == mode) {
+		/*
+		 * Cases:
+		 * - called from nand_reset, which clears DDR timing
+		 *   mode back to SDR.  BUT if we're already in SDR,
+		 *   timing mode persists over resets.
+		 *   While mtd/nand layer only supports SDR,
+		 *   this is always safe. And this driver only supports SDR.
+		 *
+		 * - called from post-power-event nand_reset (maybe
+		 *   NFC+flash power down, or system hibernate.
+		 *   Address this when CONFIG_PM support added
+		 */
+		rc = 0;
+	} else {
+		rc = octeontx_nfc_chip_set_timings(chip, &conf->timings.sdr);
+		if (!rc) {
+			chip->iface_mode = mode;
+			chip->iface_set = true;
+		}
+	}
+	return rc;
+}
+
+#if defined(CONFIG_OCTEONTX_BCH)
+
+static void octeontx_bch_reset(void)
+{
+}
+
+/*
+ * Given a page, calculate the ECC code
+ *
+ * chip:	Pointer to NAND chip data structure
+ * buf:		Buffer to calculate ECC on
+ * code:	Buffer to hold ECC data
+ *
+ * Return 0 on success or -1 on failure
+ */
+static int octeontx_nand_bch_calculate_ecc_internal(struct mtd_info *mtd,
+						   dma_addr_t ihandle,
+						   u8 *code)
+{
+	struct nand_chip *nand = mtd_to_nand(mtd);
+	struct octeontx_nfc *tn = to_otx_nfc(nand->controller);
+	int rc;
+	int i;
+	static u8 *ecc_buffer;
+	static int ecc_size;
+	static unsigned long ecc_handle;
+	union bch_resp *r = tn->bch_resp;
+
+	if (!ecc_buffer || ecc_size < nand->ecc.size) {
+		ecc_size = nand->ecc.size;
+		ecc_buffer = dma_alloc_coherent(ecc_size,
+						(unsigned long *)&ecc_handle);
+	}
+
+	memset(ecc_buffer, 0, nand->ecc.bytes);
+
+	r->u16 = 0;
+	__iowmb(); /* flush done=0 before making request */
+
+	rc = octeontx_bch_encode(bch_vf, ihandle, nand->ecc.size,
+				 nand->ecc.strength,
+				 (dma_addr_t)ecc_handle, tn->bch_rhandle);
+
+	if (!rc) {
+		octeontx_bch_wait(bch_vf, r, tn->bch_rhandle);
+	} else {
+		dev_err(tn->dev, "octeontx_bch_encode failed\n");
+		return -1;
+	}
+
+	if (!r->s.done || r->s.uncorrectable) {
+		dev_err(tn->dev,
+			"%s timeout, done:%d uncorr:%d corr:%d erased:%d\n",
+			__func__, r->s.done, r->s.uncorrectable,
+			r->s.num_errors, r->s.erased);
+		octeontx_bch_reset();
+		return -1;
+	}
+
+	memcpy(code, ecc_buffer, nand->ecc.bytes);
+
+	for (i = 0; i < nand->ecc.bytes; i++)
+		code[i] ^= tn->eccmask[i];
+
+	return tn->bch_resp->s.num_errors;
+}
+
+/*
+ * Given a page, calculate the ECC code
+ *
+ * mtd:        MTD block structure
+ * dat:        raw data (unused)
+ * ecc_code:   buffer for ECC
+ */
+static int octeontx_nand_bch_calculate(struct mtd_info *mtd,
+				       const u8 *dat, u8 *ecc_code)
+{
+	struct nand_chip *nand = mtd_to_nand(mtd);
+	dma_addr_t handle = dma_map_single((u8 *)dat,
+					   nand->ecc.size, DMA_TO_DEVICE);
+	int ret;
+
+	ret = octeontx_nand_bch_calculate_ecc_internal(
+			mtd, handle, (void *)ecc_code);
+
+	return ret;
+}
+
+/*
+ * Detect and correct multi-bit ECC for a page
+ *
+ * mtd:        MTD block structure
+ * dat:        raw data read from the chip
+ * read_ecc:   ECC from the chip (unused)
+ * isnull:     unused
+ *
+ * Returns number of bits corrected or -1 if unrecoverable
+ */
+static int octeontx_nand_bch_correct(struct mtd_info *mtd, u_char *dat,
+				     u_char *read_ecc, u_char *isnull)
+{
+	struct nand_chip *nand = mtd_to_nand(mtd);
+	struct octeontx_nfc *tn = to_otx_nfc(nand->controller);
+	int i = nand->ecc.size + nand->ecc.bytes;
+	static u8 *data_buffer;
+	static dma_addr_t ihandle;
+	static int buffer_size;
+	dma_addr_t ohandle;
+	union bch_resp *r = tn->bch_resp;
+	int rc;
+
+	if (i > buffer_size) {
+		if (buffer_size)
+			free(data_buffer);
+		data_buffer = dma_alloc_coherent(i,
+						 (unsigned long *)&ihandle);
+		if (!data_buffer) {
+			dev_err(tn->dev,
+				"%s: Could not allocate %d bytes for buffer\n",
+				__func__, i);
+			goto error;
+		}
+		buffer_size = i;
+	}
+
+	memcpy(data_buffer, dat, nand->ecc.size);
+	memcpy(data_buffer + nand->ecc.size,
+			read_ecc, nand->ecc.bytes);
+
+	for (i = 0; i < nand->ecc.bytes; i++)
+		data_buffer[nand->ecc.size + i] ^= tn->eccmask[i];
+
+	r->u16 = 0;
+	__iowmb(); /* flush done=0 before making request */
+
+	ohandle = dma_map_single(dat, nand->ecc.size, DMA_FROM_DEVICE);
+	rc = octeontx_bch_decode(bch_vf, ihandle, nand->ecc.size,
+				 nand->ecc.strength, ohandle, tn->bch_rhandle);
+
+	if (!rc)
+		octeontx_bch_wait(bch_vf, r, tn->bch_rhandle);
+
+	if (rc) {
+		dev_err(tn->dev, "octeontx_bch_decode failed\n");
+		goto error;
+	}
+
+	if (!r->s.done) {
+		dev_err(tn->dev, "Error: BCH engine timeout\n");
+		octeontx_bch_reset();
+		goto error;
+	}
+
+	if (r->s.erased) {
+		debug("Info: BCH block is erased\n");
+		return 0;
+	}
+
+	if (r->s.uncorrectable) {
+		debug("Cannot correct NAND block, response: 0x%x\n",
+		      r->u16);
+		goto error;
+	}
+
+	return r->s.num_errors;
+
+error:
+	debug("Error performing bch correction\n");
+	return -1;
+}
+
+void octeontx_nand_bch_hwctl(struct mtd_info *mtd, int mode)
+{
+	/* Do nothing. */
+}
+
+static int octeontx_nand_hw_bch_read_page(struct mtd_info *mtd,
+					  struct nand_chip *chip, u8 *buf,
+					  int oob_required, int page)
+{
+	struct nand_chip *nand = mtd_to_nand(mtd);
+	struct octeontx_nfc *tn = to_otx_nfc(nand->controller);
+	int i, eccsize = chip->ecc.size, ret;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	u8 *p;
+	u8 *ecc_code = chip->buffers->ecccode;
+	unsigned int max_bitflips = 0;
+
+	/* chip->read_buf() insists on sequential order, we do OOB first */
+	memcpy(chip->oob_poi, tn->buf.dmabuf + mtd->writesize, mtd->oobsize);
+
+	/* Use private buffer as input for ECC correction */
+	p = tn->buf.dmabuf;
+
+	ret = mtd_ooblayout_get_eccbytes(mtd, ecc_code, chip->oob_poi, 0,
+					 chip->ecc.total);
+	if (ret)
+		return ret;
+
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		int stat;
+
+		debug("Correcting block offset %lx, ecc offset %x\n",
+		      p - buf, i);
+		stat = chip->ecc.correct(mtd, p, &ecc_code[i], NULL);
+
+		if (stat < 0) {
+			mtd->ecc_stats.failed++;
+			debug("Cannot correct NAND page %d\n", page);
+		} else {
+			mtd->ecc_stats.corrected += stat;
+			max_bitflips = max_t(unsigned int, max_bitflips, stat);
+		}
+	}
+
+	/* Copy corrected data to caller's buffer now */
+	memcpy(buf, tn->buf.dmabuf, mtd->writesize);
+
+	return max_bitflips;
+}
+
+static int octeontx_nand_hw_bch_write_page(struct mtd_info *mtd,
+					   struct nand_chip *chip,
+					   const u8 *buf, int oob_required,
+					   int page)
+{
+	struct octeontx_nfc *tn = to_otx_nfc(chip->controller);
+	int i, eccsize = chip->ecc.size, ret;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	const u8 *p;
+	u8 *ecc_calc = chip->buffers->ecccalc;
+
+	debug("%s(buf?%p, oob%d p%x)\n",
+	      __func__, buf, oob_required, page);
+	for (i = 0; i < chip->ecc.total; i++)
+		ecc_calc[i] = 0xFF;
+
+	/* Copy the page data from caller's buffers to private buffer */
+	chip->write_buf(mtd, buf, mtd->writesize);
+	/* Use private date as source for ECC calculation */
+	p = tn->buf.dmabuf;
+
+	/* Hardware ECC calculation */
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		int ret;
+
+		ret = chip->ecc.calculate(mtd, p, &ecc_calc[i]);
+
+		if (ret < 0)
+			debug("calculate(mtd, p?%p, &ecc_calc[%d]?%p) returned %d\n",
+			      p, i, &ecc_calc[i], ret);
+
+		debug("block offset %lx, ecc offset %x\n", p - buf, i);
+	}
+
+	ret = mtd_ooblayout_set_eccbytes(mtd, ecc_calc, chip->oob_poi, 0,
+					 chip->ecc.total);
+	if (ret)
+		return ret;
+
+	/* Store resulting OOB into private buffer, will be sent to HW */
+	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	return 0;
+}
+
+/**
+ * nand_write_page_raw - [INTERN] raw page write function
+ * @mtd: mtd info structure
+ * @chip: nand chip info structure
+ * @buf: data buffer
+ * @oob_required: must write chip->oob_poi to OOB
+ * @page: page number to write
+ *
+ * Not for syndrome calculating ECC controllers, which use a special oob layout.
+ */
+static int octeontx_nand_write_page_raw(struct mtd_info *mtd,
+					struct nand_chip *chip,
+					const u8 *buf, int oob_required,
+					int page)
+{
+	chip->write_buf(mtd, buf, mtd->writesize);
+	if (oob_required)
+		chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	return 0;
+}
+
+/**
+ * octeontx_nand_write_oob_std - [REPLACEABLE] the most common OOB data write
+ *                             function
+ * @mtd: mtd info structure
+ * @chip: nand chip info structure
+ * @page: page number to write
+ */
+static int octeontx_nand_write_oob_std(struct mtd_info *mtd,
+				       struct nand_chip *chip,
+				       int page)
+{
+	int status = 0;
+	const u8 *buf = chip->oob_poi;
+	int length = mtd->oobsize;
+
+	chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
+	chip->write_buf(mtd, buf, length);
+	/* Send command to program the OOB data */
+	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+	status = chip->waitfunc(mtd, chip);
+
+	return status & NAND_STATUS_FAIL ? -EIO : 0;
+}
+
+/**
+ * octeontx_nand_read_page_raw - [INTERN] read raw page data without ecc
+ * @mtd: mtd info structure
+ * @chip: nand chip info structure
+ * @buf: buffer to store read data
+ * @oob_required: caller requires OOB data read to chip->oob_poi
+ * @page: page number to read
+ *
+ * Not for syndrome calculating ECC controllers, which use a special oob layout.
+ */
+static int octeontx_nand_read_page_raw(struct mtd_info *mtd,
+				       struct nand_chip *chip,
+				       u8 *buf, int oob_required, int page)
+{
+	chip->read_buf(mtd, buf, mtd->writesize);
+	if (oob_required)
+		chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+	return 0;
+}
+
+static int octeontx_nand_read_oob_std(struct mtd_info *mtd,
+				      struct nand_chip *chip,
+				      int page)
+
+{
+	chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+	return 0;
+}
+
+static int octeontx_nand_calc_bch_ecc_strength(struct nand_chip *nand)
+{
+	struct mtd_info *mtd = nand_to_mtd(nand);
+	struct nand_ecc_ctrl *ecc = &nand->ecc;
+	struct octeontx_nfc *tn = to_otx_nfc(nand->controller);
+	int nsteps = mtd->writesize / ecc->size;
+	int oobchunk = mtd->oobsize / nsteps;
+
+	/* ecc->strength determines ecc_level and OOB's ecc_bytes. */
+	const u8 strengths[]  = {4, 8, 16, 24, 32, 40, 48, 56, 60, 64};
+	/* first set the desired ecc_level to match strengths[] */
+	int index = ARRAY_SIZE(strengths) - 1;
+	int need;
+
+	while (index > 0 && !(ecc->options & NAND_ECC_MAXIMIZE) &&
+			strengths[index - 1] >= ecc->strength)
+		index--;
+
+	do {
+		need = DIV_ROUND_UP(15 * strengths[index], 8);
+		if (need <= oobchunk - 2)
+			break;
+	} while (index > 0);
+
+	debug("%s: steps ds: %d, strength ds: %d\n", __func__,
+	      nand->ecc_step_ds, nand->ecc_strength_ds);
+	ecc->strength = strengths[index];
+	ecc->bytes = need;
+	debug("%s: strength: %d, bytes: %d\n", __func__, ecc->strength,
+	      ecc->bytes);
+
+	if (!tn->eccmask)
+		tn->eccmask = devm_kzalloc(tn->dev, ecc->bytes, GFP_KERNEL);
+	if (!tn->eccmask)
+		return -ENOMEM;
+
+	return 0;
+}
+
+/* sample the BCH signature of an erased (all 0xff) page,
+ * to XOR into all page traffic, so erased pages have no ECC errors
+ */
+static int octeontx_bch_save_empty_eccmask(struct nand_chip *nand)
+{
+	struct mtd_info *mtd = nand_to_mtd(nand);
+	struct octeontx_nfc *tn = to_otx_nfc(nand->controller);
+	unsigned int eccsize = nand->ecc.size;
+	unsigned int eccbytes = nand->ecc.bytes;
+	u8 erased_ecc[eccbytes];
+	unsigned long erased_handle;
+	unsigned char *erased_page = dma_alloc_coherent(eccsize,
+							&erased_handle);
+	int i;
+	int rc = 0;
+
+	if (!erased_page)
+		return -ENOMEM;
+
+	memset(erased_page, 0xff, eccsize);
+	memset(erased_ecc, 0, eccbytes);
+
+	rc = octeontx_nand_bch_calculate_ecc_internal(mtd,
+						      (dma_addr_t)erased_handle,
+						      erased_ecc);
+
+	free(erased_page);
+
+	for (i = 0; i < eccbytes; i++)
+		tn->eccmask[i] = erased_ecc[i] ^ 0xff;
+
+	return rc;
+}
+#endif /*CONFIG_OCTEONTX_BCH*/
+
+static void octeontx_nfc_chip_sizing(struct nand_chip *nand)
+{
+	struct octeontx_nand_chip *chip = to_otx_nand(nand);
+	struct mtd_info *mtd = nand_to_mtd(nand);
+	struct nand_ecc_ctrl *ecc = &nand->ecc;
+
+	chip->row_bytes = nand->onfi_params.addr_cycles & 0xf;
+	chip->col_bytes = nand->onfi_params.addr_cycles >> 4;
+	debug("%s(%p) row bytes: %d, col bytes: %d, ecc mode: %d\n",
+	      __func__, nand, chip->row_bytes, chip->col_bytes, ecc->mode);
+
+	/*
+	 * HW_BCH using Cavium BCH engine, or SOFT_BCH laid out in
+	 * HW_BCH-compatible fashion, depending on devtree advice
+	 * and kernel config.
+	 * BCH/NFC hardware capable of subpage ops, not implemented.
+	 */
+	mtd_set_ooblayout(mtd, &nand_ooblayout_lp_ops);
+	nand->options |= NAND_NO_SUBPAGE_WRITE;
+	debug("%s: start steps: %d, size: %d, bytes: %d\n",
+	      __func__, ecc->steps, ecc->size, ecc->bytes);
+	debug("%s: step ds: %d, strength ds: %d\n", __func__,
+	      nand->ecc_step_ds, nand->ecc_strength_ds);
+
+	if (ecc->mode != NAND_ECC_NONE) {
+		int nsteps = ecc->steps ? ecc->steps : 1;
+
+		if (ecc->size && ecc->size != mtd->writesize)
+			nsteps = mtd->writesize / ecc->size;
+		else if (mtd->writesize > def_ecc_size &&
+				!(mtd->writesize & (def_ecc_size - 1)))
+			nsteps = mtd->writesize / def_ecc_size;
+		ecc->steps = nsteps;
+		ecc->size = mtd->writesize / nsteps;
+		ecc->bytes = mtd->oobsize / nsteps;
+
+		if (nand->ecc_strength_ds)
+			ecc->strength = nand->ecc_strength_ds;
+		if (nand->ecc_step_ds)
+			ecc->size = nand->ecc_step_ds;
+		/*
+		 * no subpage ops, but set subpage-shift to match ecc->steps
+		 * so mtd_nandbiterrs tests appropriate boundaries
+		 */
+		if (!mtd->subpage_sft && !(ecc->steps & (ecc->steps - 1)))
+			mtd->subpage_sft = fls(ecc->steps) - 1;
+
+#if defined(CONFIG_OCTEONTX_BCH)
+		debug("%s: ecc mode: %d\n", __func__, ecc->mode);
+		if (ecc->mode != NAND_ECC_SOFT &&
+		    !octeontx_nand_calc_bch_ecc_strength(nand)) {
+			struct octeontx_nfc *tn = to_otx_nfc(nand->controller);
+
+			debug("Using hardware BCH engine support\n");
+			ecc->mode = NAND_ECC_HW_SYNDROME;
+			ecc->read_page = octeontx_nand_hw_bch_read_page;
+			ecc->write_page = octeontx_nand_hw_bch_write_page;
+			ecc->read_page_raw = octeontx_nand_read_page_raw;
+			ecc->write_page_raw = octeontx_nand_write_page_raw;
+			ecc->read_oob = octeontx_nand_read_oob_std;
+			ecc->write_oob = octeontx_nand_write_oob_std;
+
+			ecc->calculate = octeontx_nand_bch_calculate;
+			ecc->correct = octeontx_nand_bch_correct;
+			ecc->hwctl = octeontx_nand_bch_hwctl;
+
+			debug("NAND chip %d using hw_bch\n",
+			      tn->selected_chip);
+			debug(" %d bytes ECC per %d byte block\n",
+			      ecc->bytes, ecc->size);
+			debug(" for %d bits of correction per block.",
+			      ecc->strength);
+			octeontx_nand_calc_ecc_layout(nand);
+			octeontx_bch_save_empty_eccmask(nand);
+		}
+#endif /*CONFIG_OCTEONTX_BCH*/
+	}
+}
+
+static int octeontx_nfc_chip_init(struct octeontx_nfc *tn, struct udevice *dev,
+				  ofnode node)
+{
+	struct octeontx_nand_chip *chip;
+	struct nand_chip *nand;
+	struct mtd_info *mtd;
+	int ret;
+
+	chip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+
+	debug("%s: Getting chip select\n", __func__);
+	ret = ofnode_read_s32(node, "reg", &chip->cs);
+	if (ret) {
+		dev_err(dev, "could not retrieve reg property: %d\n", ret);
+		return ret;
+	}
+
+	if (chip->cs >= NAND_MAX_CHIPS) {
+		dev_err(dev, "invalid reg value: %u (max CS = 7)\n", chip->cs);
+		return -EINVAL;
+	}
+	debug("%s: chip select: %d\n", __func__, chip->cs);
+	nand = &chip->nand;
+	nand->controller = &tn->controller;
+	if (!tn->controller.active)
+		tn->controller.active = nand;
+
+	debug("%s: Setting flash node\n", __func__);
+	nand_set_flash_node(nand, node);
+
+	nand->options = 0;
+	nand->select_chip = octeontx_nand_select_chip;
+	nand->cmdfunc = octeontx_nand_cmdfunc;
+	nand->waitfunc = octeontx_nand_waitfunc;
+	nand->read_byte = octeontx_nand_read_byte;
+	nand->read_buf = octeontx_nand_read_buf;
+	nand->write_buf = octeontx_nand_write_buf;
+	nand->onfi_set_features = octeontx_nand_set_features;
+	nand->onfi_get_features = octeontx_nand_get_features;
+	nand->setup_data_interface = octeontx_nand_setup_data_interface;
+
+	mtd = nand_to_mtd(nand);
+	debug("%s: mtd: %p\n", __func__, mtd);
+	mtd->dev->parent = dev;
+
+	debug("%s: NDF_MISC: 0x%llx\n", __func__,
+	      readq(tn->base + NDF_MISC));
+
+	/* TODO: support more then 1 chip */
+	debug("%s: Scanning identification\n", __func__);
+	ret = nand_scan_ident(mtd, 1, NULL);
+	if (ret)
+		return ret;
+
+	debug("%s: Sizing chip\n", __func__);
+	octeontx_nfc_chip_sizing(nand);
+
+	debug("%s: Scanning tail\n", __func__);
+	ret = nand_scan_tail(mtd);
+	if (ret) {
+		dev_err(dev, "nand_scan_tail failed: %d\n", ret);
+		return ret;
+	}
+
+	debug("%s: Registering mtd\n", __func__);
+	ret = nand_register(0, mtd);
+
+	debug("%s: Adding tail\n", __func__);
+	list_add_tail(&chip->node, &tn->chips);
+	return 0;
+}
+
+static int octeontx_nfc_chips_init(struct octeontx_nfc *tn)
+{
+	struct udevice *dev = tn->dev;
+	ofnode node = dev->node;
+	ofnode nand_node;
+	int nr_chips = of_get_child_count(node);
+	int ret;
+
+	debug("%s: node: %s\n", __func__, ofnode_get_name(node));
+	debug("%s: %d chips\n", __func__, nr_chips);
+	if (nr_chips > NAND_MAX_CHIPS) {
+		dev_err(dev, "too many NAND chips: %d\n", nr_chips);
+		return -EINVAL;
+	}
+
+	if (!nr_chips) {
+		debug("no DT NAND chips found\n");
+		return -ENODEV;
+	}
+
+	pr_info("%s: scanning %d chips DTs\n", __func__, nr_chips);
+
+	ofnode_for_each_subnode(nand_node, node) {
+		debug("%s: Calling octeontx_nfc_chip_init(%p, %s, %ld)\n",
+		      __func__, tn, dev->name, nand_node.of_offset);
+		ret = octeontx_nfc_chip_init(tn, dev, nand_node);
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
+
+/* Reset NFC and initialize registers. */
+static int octeontx_nfc_init(struct octeontx_nfc *tn)
+{
+	const struct nand_sdr_timings *timings;
+	u64 ndf_misc;
+	int rc;
+
+	/* Initialize values and reset the fifo */
+	ndf_misc = readq(tn->base + NDF_MISC);
+
+	ndf_misc &= ~NDF_MISC_EX_DIS;
+	ndf_misc |= (NDF_MISC_BT_DIS | NDF_MISC_RST_FF);
+	writeq(ndf_misc, tn->base + NDF_MISC);
+	debug("%s: NDF_MISC: 0x%llx\n", __func__, readq(tn->base + NDF_MISC));
+
+	/* Bring the fifo out of reset */
+	ndf_misc &= ~(NDF_MISC_RST_FF);
+
+	/* Maximum of co-processor cycles for glitch filtering */
+	ndf_misc |= FIELD_PREP(NDF_MISC_WAIT_CNT, 0x3f);
+
+	writeq(ndf_misc, tn->base + NDF_MISC);
+
+	/* Set timing parameters to onfi mode 0 for probing */
+	timings = onfi_async_timing_mode_to_sdr_timings(0);
+	if (IS_ERR(timings))
+		return PTR_ERR(timings);
+	rc = set_default_timings(tn, timings);
+	if (rc)
+		return rc;
+
+	return 0;
+}
+
+static int octeontx_pci_nand_probe(struct udevice *dev)
+{
+	struct octeontx_nfc *tn = dev_get_priv(dev);
+	int ret;
+	size_t size;
+	static bool probe_done;
+
+	debug("%s(%s) tn: %p\n", __func__, dev->name, tn);
+	if (probe_done)
+		return 0;
+
+#ifdef CONFIG_OCTEONTX_BCH
+	bch_vf = octeontx_bch_getv();
+	if (!bch_vf) {
+		struct octeontx_probe_device *probe_dev;
+
+		debug("%s: bch not yet initialized\n", __func__);
+		probe_dev = calloc(sizeof(*probe_dev), 1);
+		if (!probe_dev) {
+			printf("%s: Out of memory\n", __func__);
+			return -ENOMEM;
+		}
+		probe_dev->dev = dev;
+		INIT_LIST_HEAD(&probe_dev->list);
+		list_add_tail(&probe_dev->list,
+			      &octeontx_pci_nand_deferred_devices);
+		debug("%s: Defering probe until after BCH initialization\n",
+		      __func__);
+		return 0;
+	}
+#endif
+
+	tn->dev = dev;
+	INIT_LIST_HEAD(&tn->chips);
+
+	tn->base = dm_pci_map_bar(dev, 0, &size, PCI_REGION_MEM);
+	if (!tn->base) {
+		ret = -EINVAL;
+		goto release;
+	}
+	debug("%s: bar at %p\n", __func__, tn->base);
+	tn->buf.dmabuflen = NAND_MAX_PAGESIZE + NAND_MAX_OOBSIZE;
+	tn->buf.dmabuf = dma_alloc_coherent(tn->buf.dmabuflen,
+					    (unsigned long *)&tn->buf.dmaaddr);
+	if (!tn->buf.dmabuf) {
+		ret = -ENOMEM;
+		debug("%s: Could not allocate DMA buffer\n", __func__);
+		goto unclk;
+	}
+
+	/* one hw-bch response, for one outstanding transaction */
+	tn->bch_resp = dma_alloc_coherent(sizeof(*tn->bch_resp),
+					  (unsigned long *)&tn->bch_rhandle);
+
+	tn->stat = dma_alloc_coherent(8, (unsigned long *)&tn->stat_addr);
+	if (!tn->stat || !tn->bch_resp) {
+		debug("%s: Could not allocate bch status or response\n",
+		      __func__);
+		ret = -ENOMEM;
+		goto unclk;
+	}
+
+	debug("%s: Calling octeontx_nfc_init()\n", __func__);
+	octeontx_nfc_init(tn);
+	debug("%s: Initializing chips\n", __func__);
+	ret = octeontx_nfc_chips_init(tn);
+	debug("%s: init chips ret: %d\n", __func__, ret);
+	if (ret) {
+		if (ret != -ENODEV)
+			dev_err(dev, "failed to init nand chips\n");
+		goto unclk;
+	}
+	dev_info(dev, "probed\n");
+	return 0;
+
+unclk:
+release:
+	return ret;
+}
+
+int octeontx_pci_nand_disable(struct udevice *dev)
+{
+	struct octeontx_nfc *tn = dev_get_priv(dev);
+	u64 dma_cfg;
+	u64 ndf_misc;
+
+	debug("%s: Disabling NAND device %s\n", __func__, dev->name);
+	dma_cfg = readq(tn->base + NDF_DMA_CFG);
+	dma_cfg &= ~NDF_DMA_CFG_EN;
+	dma_cfg |= NDF_DMA_CFG_CLR;
+	writeq(dma_cfg, tn->base + NDF_DMA_CFG);
+
+	/* Disable execution and put FIFO in reset mode */
+	ndf_misc = readq(tn->base + NDF_MISC);
+	ndf_misc |= NDF_MISC_EX_DIS | NDF_MISC_RST_FF;
+	writeq(ndf_misc, tn->base + NDF_MISC);
+	ndf_misc &= ~NDF_MISC_RST_FF;
+	writeq(ndf_misc, tn->base + NDF_MISC);
+#ifdef DEBUG
+	printf("%s: NDF_MISC: 0x%llx\n", __func__, readq(tn->base + NDF_MISC));
+#endif
+	/* Clear any interrupts and enable bits */
+	writeq(~0ull, tn->base + NDF_INT_ENA_W1C);
+	writeq(~0ull, tn->base + NDF_INT);
+	debug("%s: NDF_ST_REG: 0x%llx\n", __func__,
+	      readq(tn->base + NDF_ST_REG));
+	return 0;
+}
+
+#ifdef CONFIG_OCTEONTX_BCH
+/**
+ * Since it's possible (and even likely) that the NAND device will be probed
+ * before the BCH device has been probed, we may need to defer the probing.
+ *
+ * In this case, the initial probe returns success but the actual probing
+ * is deferred until the BCH VF has been probed.
+ *
+ * @return	0 for success, otherwise error
+ */
+int octeontx_pci_nand_deferred_probe(void)
+{
+	int rc = 0;
+	struct octeontx_probe_device *pdev;
+
+	debug("%s: Performing deferred probing\n", __func__);
+	list_for_each_entry(pdev, &octeontx_pci_nand_deferred_devices, list) {
+		debug("%s: Probing %s\n", __func__, pdev->dev->name);
+		pdev->dev->flags &= ~DM_FLAG_ACTIVATED;
+		rc = device_probe(pdev->dev);
+		if (rc && rc != -ENODEV) {
+			printf("%s: Error %d with deferred probe of %s\n",
+			       __func__, rc, pdev->dev->name);
+			break;
+		}
+	}
+	return rc;
+}
+#endif
+
+static const struct pci_device_id octeontx_nfc_pci_id_table[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, 0xa04f) },
+	{}
+};
+
+static int octeontx_nand_ofdata_to_platdata(struct udevice *dev)
+{
+	return 0;
+}
+
+static const struct udevice_id octeontx_nand_ids[] = {
+	{ .compatible = "cavium,cn8130-nand" },
+	{ },
+};
+
+U_BOOT_DRIVER(octeontx_pci_nand) = {
+	.name	= OCTEONTX_NAND_DRIVER_NAME,
+	.id	= UCLASS_MTD,
+	.of_match = of_match_ptr(octeontx_nand_ids),
+	.ofdata_to_platdata = octeontx_nand_ofdata_to_platdata,
+	.probe = octeontx_pci_nand_probe,
+	.priv_auto_alloc_size = sizeof(struct octeontx_nfc),
+	.remove = octeontx_pci_nand_disable,
+	.flags = DM_FLAG_OS_PREPARE,
+};
+
+U_BOOT_PCI_DEVICE(octeontx_pci_nand, octeontx_nfc_pci_id_table);
+
+void board_nand_init(void)
+{
+	struct udevice *dev;
+	int ret;
+
+#ifdef CONFIG_OCTEONTX_BCH
+	ret = uclass_get_device_by_driver(UCLASS_MISC,
+					  DM_GET_DRIVER(octeontx_pci_bchpf),
+					  &dev);
+	if (ret && ret != -ENODEV) {
+		pr_err("Failed to initialize OcteonTX BCH PF controller. (error %d)\n",
+		       ret);
+	}
+	ret = uclass_get_device_by_driver(UCLASS_MISC,
+					  DM_GET_DRIVER(octeontx_pci_bchvf),
+					  &dev);
+	if (ret && ret != -ENODEV) {
+		pr_err("Failed to initialize OcteonTX BCH VF controller. (error %d)\n",
+		       ret);
+	}
+#endif
+
+	ret = uclass_get_device_by_driver(UCLASS_MTD,
+					  DM_GET_DRIVER(octeontx_pci_nand),
+					  &dev);
+	if (ret && ret != -ENODEV)
+		pr_err("Failed to initialize OcteonTX NAND controller. (error %d)\n",
+		       ret);
+}
diff --git a/drivers/mtd/nand/pxa3xx_nand.c b/drivers/mtd/nand/pxa3xx_nand.c
index a3ca337..ae2eaab 100644
--- a/drivers/mtd/nand/pxa3xx_nand.c
+++ b/drivers/mtd/nand/pxa3xx_nand.c
@@ -25,14 +25,16 @@ DECLARE_GLOBAL_DATA_PTR;
 #define TIMEOUT_DRAIN_FIFO	5	/* in ms */
 #define	CHIP_DELAY_TIMEOUT	200
 #define NAND_STOP_DELAY		40
-#define PAGE_CHUNK_SIZE		(2048)
 
 /*
  * Define a buffer size for the initial command that detects the flash device:
- * STATUS, READID and PARAM. The largest of these is the PARAM command,
- * needing 256 bytes.
+ * STATUS, READID and PARAM.
+ * ONFI param page is 256 bytes, and there are three redundant copies
+ * to be read. JEDEC param page is 512 bytes, and there are also three
+ * redundant copies to be read.
+ * Hence this buffer should be at least 512 x 3. Let's pick 2048.
  */
-#define INIT_BUFFER_SIZE	256
+#define INIT_BUFFER_SIZE	2048
 
 /* registers and bit definitions */
 #define NDCR		(0x00) /* Control register */
@@ -59,7 +61,7 @@ DECLARE_GLOBAL_DATA_PTR;
 #define NDCR_ND_MODE		(0x3 << 21)
 #define NDCR_NAND_MODE		(0x0)
 #define NDCR_CLR_PG_CNT		(0x1 << 20)
-#define NDCR_STOP_ON_UNCOR	(0x1 << 19)
+#define NFCV1_NDCR_ARB_CNTL	(0x1 << 19)
 #define NDCR_RD_ID_CNT_MASK	(0x7 << 16)
 #define NDCR_RD_ID_CNT(x)	(((x) << 16) & NDCR_RD_ID_CNT_MASK)
 
@@ -110,6 +112,13 @@ DECLARE_GLOBAL_DATA_PTR;
 #define EXT_CMD_TYPE_LAST_RW	1 /* Last naked read/write */
 #define EXT_CMD_TYPE_MONO	0 /* Monolithic read/write */
 
+/*
+ * This should be large enough to read 'ONFI' and 'JEDEC'.
+ * Let's use 7 bytes, which is the maximum ID count supported
+ * by the controller (see NDCR_RD_ID_CNT_MASK).
+ */
+#define READ_ID_BYTES		7
+
 /* macros for registers read/write */
 #define nand_writel(info, off, val)	\
 	writel((val), (info)->mmio_base + (off))
@@ -140,89 +149,34 @@ enum {
 	STATE_READY,
 };
 
-enum pxa3xx_nand_variant {
-	PXA3XX_NAND_VARIANT_PXA,
-	PXA3XX_NAND_VARIANT_ARMADA370,
-};
-
-struct pxa3xx_nand_host {
-	struct nand_chip	chip;
-	struct mtd_info         *mtd;
-	void			*info_data;
-
-	/* page size of attached chip */
-	int			use_ecc;
-	int			cs;
-
-	/* calculated from pxa3xx_nand_flash data */
-	unsigned int		col_addr_cycles;
-	unsigned int		row_addr_cycles;
-	size_t			read_id_bytes;
-
-};
-
-struct pxa3xx_nand_info {
-	struct nand_hw_control	controller;
-	struct pxa3xx_nand_platform_data *pdata;
-
-	struct clk		*clk;
-	void __iomem		*mmio_base;
-	unsigned long		mmio_phys;
-	int			cmd_complete, dev_ready;
-
-	unsigned int		buf_start;
-	unsigned int		buf_count;
-	unsigned int		buf_size;
-	unsigned int		data_buff_pos;
-	unsigned int		oob_buff_pos;
-
-	unsigned char		*data_buff;
-	unsigned char		*oob_buff;
-
-	struct pxa3xx_nand_host *host[NUM_CHIP_SELECT];
-	unsigned int		state;
-
+static struct pxa3xx_nand_timing timing[] = {
 	/*
-	 * This driver supports NFCv1 (as found in PXA SoC)
-	 * and NFCv2 (as found in Armada 370/XP SoC).
+	 * tCH	Enable signal hold time
+	 * tCS	Enable signal setup time
+	 * tWH	ND_nWE high duration
+	 * tWP	ND_nWE pulse time
+	 * tRH	ND_nRE high duration
+	 * tRP	ND_nRE pulse width
+	 * tR	ND_nWE high to ND_nRE low for read
+	 * tWHR	ND_nWE high to ND_nRE low for status read
+	 * tAR	ND_ALE low to ND_nRE low delay
 	 */
-	enum pxa3xx_nand_variant variant;
-
-	int			cs;
-	int			use_ecc;	/* use HW ECC ? */
-	int			ecc_bch;	/* using BCH ECC? */
-	int			use_spare;	/* use spare ? */
-	int			need_wait;
-
-	unsigned int		data_size;	/* data to be read from FIFO */
-	unsigned int		chunk_size;	/* split commands chunk size */
-	unsigned int		oob_size;
-	unsigned int		spare_size;
-	unsigned int		ecc_size;
-	unsigned int		ecc_err_cnt;
-	unsigned int		max_bitflips;
-	int			retcode;
-
-	/* cached register value */
-	uint32_t		reg_ndcr;
-	uint32_t		ndtr0cs0;
-	uint32_t		ndtr1cs0;
-
-	/* generated NDCBx register values */
-	uint32_t		ndcb0;
-	uint32_t		ndcb1;
-	uint32_t		ndcb2;
-	uint32_t		ndcb3;
-};
-
-static struct pxa3xx_nand_timing timing[] = {
+	/*ch  cs  wh  wp   rh  rp   r      whr  ar */
 	{ 40, 80, 60, 100, 80, 100, 90000, 400, 40, },
 	{ 10,  0, 20,  40, 30,  40, 11123, 110, 10, },
 	{ 10, 25, 15,  25, 15,  30, 25000,  60, 10, },
 	{ 10, 35, 15,  25, 15,  25, 25000,  60, 10, },
+	{  5, 20, 10,  12, 10,  12, 25000,  60, 10, },
 };
 
 static struct pxa3xx_nand_flash builtin_flash_types[] = {
+	/*
+	 * chip_id
+	 * flash_width	Width of Flash memory (DWIDTH_M)
+	 * dfc_width	Width of flash controller(DWIDTH_C)
+	 * *timing
+	 * http://www.linux-mtd.infradead.org/nand-data/nanddata.html
+	 */
 	{ 0x46ec, 16, 16, &timing[1] },
 	{ 0xdaec,  8,  8, &timing[1] },
 	{ 0xd7ec,  8,  8, &timing[1] },
@@ -231,6 +185,7 @@ static struct pxa3xx_nand_flash builtin_flash_types[] = {
 	{ 0xdc2c,  8,  8, &timing[2] },
 	{ 0xcc2c, 16, 16, &timing[2] },
 	{ 0xba20, 16, 16, &timing[3] },
+	{ 0xda98,  8,  8, &timing[4] },
 };
 
 #ifdef CONFIG_SYS_NAND_USE_FLASH_BBT
@@ -268,6 +223,20 @@ static struct nand_ecclayout ecc_layout_2KB_bch4bit = {
 	.oobfree = { {2, 30} }
 };
 
+static struct nand_ecclayout ecc_layout_2KB_bch8bit = {
+	.eccbytes = 64,
+	.eccpos = {
+		64,  65,  66,  67,  68,  69,  70,  71,
+		72,  73,  74,  75,  76,  77,  78,  79,
+		80,  81,  82,  83,  84,  85,  86,  87,
+		88,  89,  90,  91,  92,  93,  94,  95,
+		96,  97,  98,  99,  100, 101, 102, 103,
+		104, 105, 106, 107, 108, 109, 110, 111,
+		112, 113, 114, 115, 116, 117, 118, 119,
+		120, 121, 122, 123, 124, 125, 126, 127},
+	.oobfree = { {1, 4}, {6, 26} }
+};
+
 static struct nand_ecclayout ecc_layout_4KB_bch4bit = {
 	.eccbytes = 64,
 	.eccpos = {
@@ -283,6 +252,33 @@ static struct nand_ecclayout ecc_layout_4KB_bch4bit = {
 	.oobfree = { {6, 26}, { 64, 32} }
 };
 
+static struct nand_ecclayout ecc_layout_8KB_bch4bit = {
+	.eccbytes = 128,
+	.eccpos = {
+		32,  33,  34,  35,  36,  37,  38,  39,
+		40,  41,  42,  43,  44,  45,  46,  47,
+		48,  49,  50,  51,  52,  53,  54,  55,
+		56,  57,  58,  59,  60,  61,  62,  63,
+
+		96,  97,  98,  99,  100, 101, 102, 103,
+		104, 105, 106, 107, 108, 109, 110, 111,
+		112, 113, 114, 115, 116, 117, 118, 119,
+		120, 121, 122, 123, 124, 125, 126, 127,
+
+		160, 161, 162, 163, 164, 165, 166, 167,
+		168, 169, 170, 171, 172, 173, 174, 175,
+		176, 177, 178, 179, 180, 181, 182, 183,
+		184, 185, 186, 187, 188, 189, 190, 191,
+
+		224, 225, 226, 227, 228, 229, 230, 231,
+		232, 233, 234, 235, 236, 237, 238, 239,
+		240, 241, 242, 243, 244, 245, 246, 247,
+		248, 249, 250, 251, 252, 253, 254, 255},
+
+	/* Bootrom looks in bytes 0 & 5 for bad blocks */
+	.oobfree = { {1, 4}, {6, 26}, { 64, 32}, {128, 32}, {192, 32} }
+};
+
 static struct nand_ecclayout ecc_layout_4KB_bch8bit = {
 	.eccbytes = 128,
 	.eccpos = {
@@ -293,6 +289,13 @@ static struct nand_ecclayout ecc_layout_4KB_bch8bit = {
 	.oobfree = { }
 };
 
+static struct nand_ecclayout ecc_layout_8KB_bch8bit = {
+	.eccbytes = 256,
+	.eccpos = {},
+	/* HW ECC handles all ECC data and all spare area is free for OOB */
+	.oobfree = {{0, 160} }
+};
+
 #define NDTR0_tCH(c)	(min((c), 7) << 19)
 #define NDTR0_tCS(c)	(min((c), 7) << 16)
 #define NDTR0_tWH(c)	(min((c), 7) << 11)
@@ -313,13 +316,20 @@ static enum pxa3xx_nand_variant pxa3xx_nand_get_variant(void)
 	return PXA3XX_NAND_VARIANT_ARMADA370;
 }
 
-static void pxa3xx_nand_set_timing(struct pxa3xx_nand_host *host,
-				   const struct pxa3xx_nand_timing *t)
+static int pxa3xx_nand_set_timing(struct pxa3xx_nand_host *host,
+				  const struct pxa3xx_nand_timing *t)
 {
 	struct pxa3xx_nand_info *info = host->info_data;
-	unsigned long nand_clk = mvebu_get_nand_clock();
+	unsigned long nand_clk;
 	uint32_t ndtr0, ndtr1;
 
+	nand_clk = mvebu_get_nand_clock(info->nand_flash_clk_ctrl_reg);
+	if (!nand_clk) {
+		dev_err(&host->info->pdev->dev,
+			"Missinig flash clock register\n");
+		return -EINVAL;
+	}
+
 	ndtr0 = NDTR0_tCH(ns2cycle(t->tCH, nand_clk)) |
 		NDTR0_tCS(ns2cycle(t->tCS, nand_clk)) |
 		NDTR0_tWH(ns2cycle(t->tWH, nand_clk)) |
@@ -335,26 +345,35 @@ static void pxa3xx_nand_set_timing(struct pxa3xx_nand_host *host,
 	info->ndtr1cs0 = ndtr1;
 	nand_writel(info, NDTR0CS0, ndtr0);
 	nand_writel(info, NDTR1CS0, ndtr1);
+
+	return 0;
 }
 
-static void pxa3xx_nand_set_sdr_timing(struct pxa3xx_nand_host *host,
-				       const struct nand_sdr_timings *t)
+static int pxa3xx_nand_set_sdr_timing(struct pxa3xx_nand_host *host,
+				      const struct nand_sdr_timings *t)
 {
 	struct pxa3xx_nand_info *info = host->info_data;
 	struct nand_chip *chip = &host->chip;
-	unsigned long nand_clk = mvebu_get_nand_clock();
+	unsigned long nand_clk;
 	uint32_t ndtr0, ndtr1;
 
 	u32 tCH_min = DIV_ROUND_UP(t->tCH_min, 1000);
 	u32 tCS_min = DIV_ROUND_UP(t->tCS_min, 1000);
 	u32 tWH_min = DIV_ROUND_UP(t->tWH_min, 1000);
-	u32 tWP_min = DIV_ROUND_UP(t->tWC_min - tWH_min, 1000);
+	u32 tWP_min = DIV_ROUND_UP(t->tWC_min - t->tWH_min, 1000);
 	u32 tREH_min = DIV_ROUND_UP(t->tREH_min, 1000);
-	u32 tRP_min = DIV_ROUND_UP(t->tRC_min - tREH_min, 1000);
+	u32 tRP_min = DIV_ROUND_UP(t->tRC_min - t->tREH_min, 1000);
 	u32 tR = chip->chip_delay * 1000;
 	u32 tWHR_min = DIV_ROUND_UP(t->tWHR_min, 1000);
 	u32 tAR_min = DIV_ROUND_UP(t->tAR_min, 1000);
 
+	nand_clk = mvebu_get_nand_clock(info->nand_flash_clk_ctrl_reg);
+	if (!nand_clk) {
+		dev_err(&host->info->pdev->dev,
+			"Missinig flash clock register\n");
+		return -EINVAL;
+	}
+
 	/* fallback to a default value if tR = 0 */
 	if (!tR)
 		tR = 20000;
@@ -374,6 +393,8 @@ static void pxa3xx_nand_set_sdr_timing(struct pxa3xx_nand_host *host,
 	info->ndtr1cs0 = ndtr1;
 	nand_writel(info, NDTR0CS0, ndtr0);
 	nand_writel(info, NDTR1CS0, ndtr1);
+
+	return 0;
 }
 
 static int pxa3xx_nand_init_timings(struct pxa3xx_nand_host *host)
@@ -382,16 +403,17 @@ static int pxa3xx_nand_init_timings(struct pxa3xx_nand_host *host)
 	struct nand_chip *chip = &host->chip;
 	struct pxa3xx_nand_info *info = host->info_data;
 	const struct pxa3xx_nand_flash *f = NULL;
-	int mode, id, ntypes, i;
+	struct mtd_info *mtd = nand_to_mtd(&host->chip);
+	int mode, id, ntypes, i, ret;
 
 	mode = onfi_get_async_timing_mode(chip);
 	if (mode == ONFI_TIMING_MODE_UNKNOWN) {
 		ntypes = ARRAY_SIZE(builtin_flash_types);
 
-		chip->cmdfunc(host->mtd, NAND_CMD_READID, 0x00, -1);
+		chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
 
-		id = chip->read_byte(host->mtd);
-		id |= chip->read_byte(host->mtd) << 0x8;
+		id = chip->read_byte(mtd);
+		id |= chip->read_byte(mtd) << 0x8;
 
 		for (i = 0; i < ntypes; i++) {
 			f = &builtin_flash_types[i];
@@ -405,7 +427,9 @@ static int pxa3xx_nand_init_timings(struct pxa3xx_nand_host *host)
 			return -EINVAL;
 		}
 
-		pxa3xx_nand_set_timing(host, f->timing);
+		ret = pxa3xx_nand_set_timing(host, f->timing);
+		if (ret)
+			return ret;
 
 		if (f->flash_width == 16) {
 			info->reg_ndcr |= NDCR_DWIDTH_M;
@@ -422,31 +446,14 @@ static int pxa3xx_nand_init_timings(struct pxa3xx_nand_host *host)
 		if (IS_ERR(timings))
 			return PTR_ERR(timings);
 
-		pxa3xx_nand_set_sdr_timing(host, timings);
+		ret = pxa3xx_nand_set_sdr_timing(host, timings);
+		if (ret)
+			return ret;
 	}
 
 	return 0;
 }
 
-/*
- * Set the data and OOB size, depending on the selected
- * spare and ECC configuration.
- * Only applicable to READ0, READOOB and PAGEPROG commands.
- */
-static void pxa3xx_set_datasize(struct pxa3xx_nand_info *info,
-				struct mtd_info *mtd)
-{
-	int oob_enable = info->reg_ndcr & NDCR_SPARE_EN;
-
-	info->data_size = mtd->writesize;
-	if (!oob_enable)
-		return;
-
-	info->oob_size = info->spare_size;
-	if (!info->use_ecc)
-		info->oob_size += info->ecc_size;
-}
-
 /**
  * NOTE: it is a must to set ND_RUN first, then write
  * command buffer, otherwise, it does not work.
@@ -479,8 +486,8 @@ static void pxa3xx_nand_start(struct pxa3xx_nand_info *info)
 	ndcr |= NDCR_ND_RUN;
 
 	/* clear status bits and run */
-	nand_writel(info, NDCR, 0);
 	nand_writel(info, NDSR, NDSR_MASK);
+	nand_writel(info, NDCR, 0);
 	nand_writel(info, NDCR, ndcr);
 }
 
@@ -527,39 +534,38 @@ static void drain_fifo(struct pxa3xx_nand_info *info, void *data, int len)
 
 static void handle_data_pio(struct pxa3xx_nand_info *info)
 {
-	unsigned int do_bytes = min(info->data_size, info->chunk_size);
-
 	switch (info->state) {
 	case STATE_PIO_WRITING:
-		writesl(info->mmio_base + NDDB,
-			info->data_buff + info->data_buff_pos,
-			DIV_ROUND_UP(do_bytes, 4));
+		if (info->step_chunk_size)
+			writesl(info->mmio_base + NDDB,
+				info->data_buff + info->data_buff_pos,
+				DIV_ROUND_UP(info->step_chunk_size, 4));
 
-		if (info->oob_size > 0)
+		if (info->step_spare_size)
 			writesl(info->mmio_base + NDDB,
 				info->oob_buff + info->oob_buff_pos,
-				DIV_ROUND_UP(info->oob_size, 4));
+				DIV_ROUND_UP(info->step_spare_size, 4));
 		break;
 	case STATE_PIO_READING:
-		drain_fifo(info,
-			   info->data_buff + info->data_buff_pos,
-			   DIV_ROUND_UP(do_bytes, 4));
+		if (info->step_chunk_size)
+			drain_fifo(info,
+				   info->data_buff + info->data_buff_pos,
+				   DIV_ROUND_UP(info->step_chunk_size, 4));
 
-		if (info->oob_size > 0)
+		if (info->step_spare_size)
 			drain_fifo(info,
 				   info->oob_buff + info->oob_buff_pos,
-				   DIV_ROUND_UP(info->oob_size, 4));
+				   DIV_ROUND_UP(info->step_spare_size, 4));
 		break;
 	default:
 		dev_err(&info->pdev->dev, "%s: invalid state %d\n", __func__,
-			info->state);
+				info->state);
 		BUG();
 	}
 
 	/* Update buffer pointers for multi-page read/write */
-	info->data_buff_pos += do_bytes;
-	info->oob_buff_pos += info->oob_size;
-	info->data_size -= do_bytes;
+	info->data_buff_pos += info->step_chunk_size;
+	info->oob_buff_pos += info->step_spare_size;
 }
 
 static void pxa3xx_nand_irq_thread(struct pxa3xx_nand_info *info)
@@ -584,6 +590,9 @@ static irqreturn_t pxa3xx_nand_irq(struct pxa3xx_nand_info *info)
 		cmd_done        = NDSR_CS1_CMDD;
 	}
 
+	/* TODO - find out why we need the delay during write operation. */
+	ndelay(1);
+
 	status = nand_readl(info, NDSR);
 
 	if (status & NDSR_UNCORERR)
@@ -621,8 +630,14 @@ static irqreturn_t pxa3xx_nand_irq(struct pxa3xx_nand_info *info)
 		is_ready = 1;
 	}
 
+	/*
+	 * Clear all status bit before issuing the next command, which
+	 * can and will alter the status bits and will deserve a new
+	 * interrupt on its own. This lets the controller exit the IRQ
+	 */
+	nand_writel(info, NDSR, status);
+
 	if (status & NDSR_WRCMDREQ) {
-		nand_writel(info, NDSR, NDSR_WRCMDREQ);
 		status &= ~NDSR_WRCMDREQ;
 		info->state = STATE_CMD_HANDLE;
 
@@ -643,8 +658,6 @@ static irqreturn_t pxa3xx_nand_irq(struct pxa3xx_nand_info *info)
 			nand_writel(info, NDCB0, info->ndcb3);
 	}
 
-	/* clear NDSR to let the controller exit the IRQ */
-	nand_writel(info, NDSR, status);
 	if (is_completed)
 		info->cmd_complete = 1;
 	if (is_ready)
@@ -665,7 +678,7 @@ static void set_command_address(struct pxa3xx_nand_info *info,
 		unsigned int page_size, uint16_t column, int page_addr)
 {
 	/* small page addr setting */
-	if (page_size < PAGE_CHUNK_SIZE) {
+	if (page_size < info->chunk_size) {
 		info->ndcb1 = ((page_addr & 0xFFFFFF) << 8)
 				| (column & 0xFF);
 
@@ -684,14 +697,16 @@ static void set_command_address(struct pxa3xx_nand_info *info,
 static void prepare_start_command(struct pxa3xx_nand_info *info, int command)
 {
 	struct pxa3xx_nand_host *host = info->host[info->cs];
-	struct mtd_info *mtd = host->mtd;
+	struct mtd_info *mtd = nand_to_mtd(&host->chip);
 
 	/* reset data and oob column point to handle data */
 	info->buf_start		= 0;
 	info->buf_count		= 0;
-	info->oob_size		= 0;
 	info->data_buff_pos	= 0;
 	info->oob_buff_pos	= 0;
+	info->step_chunk_size   = 0;
+	info->step_spare_size   = 0;
+	info->cur_chunk         = 0;
 	info->use_ecc		= 0;
 	info->use_spare		= 1;
 	info->retcode		= ERR_NONE;
@@ -701,10 +716,9 @@ static void prepare_start_command(struct pxa3xx_nand_info *info, int command)
 
 	switch (command) {
 	case NAND_CMD_READ0:
+	case NAND_CMD_READOOB:
 	case NAND_CMD_PAGEPROG:
 		info->use_ecc = 1;
-	case NAND_CMD_READOOB:
-		pxa3xx_set_datasize(info, mtd);
 		break;
 	case NAND_CMD_PARAM:
 		info->use_spare = 0;
@@ -735,7 +749,7 @@ static int prepare_set_command(struct pxa3xx_nand_info *info, int command,
 	struct mtd_info *mtd;
 
 	host = info->host[info->cs];
-	mtd = host->mtd;
+	mtd = nand_to_mtd(&host->chip);
 	addr_cycle = 0;
 	exec_cmd = 1;
 
@@ -761,19 +775,27 @@ static int prepare_set_command(struct pxa3xx_nand_info *info, int command,
 		if (command == NAND_CMD_READOOB)
 			info->buf_start += mtd->writesize;
 
+		if (info->cur_chunk < info->nfullchunks) {
+			info->step_chunk_size = info->chunk_size;
+			info->step_spare_size = info->spare_size;
+		} else {
+			info->step_chunk_size = info->last_chunk_size;
+			info->step_spare_size = info->last_spare_size;
+		}
+
 		/*
 		 * Multiple page read needs an 'extended command type' field,
 		 * which is either naked-read or last-read according to the
 		 * state.
 		 */
-		if (mtd->writesize == PAGE_CHUNK_SIZE) {
+		if (mtd->writesize == info->chunk_size) {
 			info->ndcb0 |= NDCB0_DBC | (NAND_CMD_READSTART << 8);
-		} else if (mtd->writesize > PAGE_CHUNK_SIZE) {
+		} else if (mtd->writesize > info->chunk_size) {
 			info->ndcb0 |= NDCB0_DBC | (NAND_CMD_READSTART << 8)
 					| NDCB0_LEN_OVRD
 					| NDCB0_EXT_CMD_TYPE(ext_cmd_type);
-			info->ndcb3 = info->chunk_size +
-				      info->oob_size;
+			info->ndcb3 = info->step_chunk_size +
+				info->step_spare_size;
 		}
 
 		set_command_address(info, mtd->writesize, column, page_addr);
@@ -788,13 +810,11 @@ static int prepare_set_command(struct pxa3xx_nand_info *info, int command,
 		 * Multiple page programming needs to execute the initial
 		 * SEQIN command that sets the page address.
 		 */
-		if (mtd->writesize > PAGE_CHUNK_SIZE) {
+		if (mtd->writesize > info->chunk_size) {
 			info->ndcb0 |= NDCB0_CMD_TYPE(0x1)
 				| NDCB0_EXT_CMD_TYPE(ext_cmd_type)
 				| addr_cycle
 				| command;
-			/* No data transfer in this case */
-			info->data_size = 0;
 			exec_cmd = 1;
 		}
 		break;
@@ -806,8 +826,16 @@ static int prepare_set_command(struct pxa3xx_nand_info *info, int command,
 			break;
 		}
 
+		if (info->cur_chunk < info->nfullchunks) {
+			info->step_chunk_size = info->chunk_size;
+			info->step_spare_size = info->spare_size;
+		} else {
+			info->step_chunk_size = info->last_chunk_size;
+			info->step_spare_size = info->last_spare_size;
+		}
+
 		/* Second command setting for large pages */
-		if (mtd->writesize > PAGE_CHUNK_SIZE) {
+		if (mtd->writesize > info->chunk_size) {
 			/*
 			 * Multiple page write uses the 'extended command'
 			 * field. This can be used to issue a command dispatch
@@ -816,14 +844,14 @@ static int prepare_set_command(struct pxa3xx_nand_info *info, int command,
 			info->ndcb0 |= NDCB0_CMD_TYPE(0x1)
 					| NDCB0_LEN_OVRD
 					| NDCB0_EXT_CMD_TYPE(ext_cmd_type);
-			info->ndcb3 = info->chunk_size +
-				      info->oob_size;
+			info->ndcb3 = info->step_chunk_size +
+				      info->step_spare_size;
 
 			/*
 			 * This is the command dispatch that completes a chunked
 			 * page program operation.
 			 */
-			if (info->data_size == 0) {
+			if (info->cur_chunk == info->ntotalchunks) {
 				info->ndcb0 = NDCB0_CMD_TYPE(0x1)
 					| NDCB0_EXT_CMD_TYPE(ext_cmd_type)
 					| command;
@@ -843,24 +871,24 @@ static int prepare_set_command(struct pxa3xx_nand_info *info, int command,
 		break;
 
 	case NAND_CMD_PARAM:
-		info->buf_count = 256;
+		info->buf_count = INIT_BUFFER_SIZE;
 		info->ndcb0 |= NDCB0_CMD_TYPE(0)
 				| NDCB0_ADDR_CYC(1)
 				| NDCB0_LEN_OVRD
 				| command;
 		info->ndcb1 = (column & 0xFF);
-		info->ndcb3 = 256;
-		info->data_size = 256;
+		info->ndcb3 = INIT_BUFFER_SIZE;
+		info->step_chunk_size = INIT_BUFFER_SIZE;
 		break;
 
 	case NAND_CMD_READID:
-		info->buf_count = host->read_id_bytes;
+		info->buf_count = READ_ID_BYTES;
 		info->ndcb0 |= NDCB0_CMD_TYPE(3)
 				| NDCB0_ADDR_CYC(1)
 				| command;
 		info->ndcb1 = (column & 0xFF);
 
-		info->data_size = 8;
+		info->step_chunk_size = 8;
 		break;
 	case NAND_CMD_STATUS:
 		info->buf_count = 1;
@@ -868,7 +896,7 @@ static int prepare_set_command(struct pxa3xx_nand_info *info, int command,
 				| NDCB0_ADDR_CYC(1)
 				| command;
 
-		info->data_size = 8;
+		info->step_chunk_size = 8;
 		break;
 
 	case NAND_CMD_ERASE1:
@@ -1052,22 +1080,31 @@ static void nand_cmdfunc_extended(struct mtd_info *mtd,
 			}
 		}
 
+		/* Only a few commands need several steps */
+		if (command != NAND_CMD_PAGEPROG &&
+		    command != NAND_CMD_READ0    &&
+		    command != NAND_CMD_READOOB)
+			break;
+
+		info->cur_chunk++;
+
 		/* Check if the sequence is complete */
-		if (info->data_size == 0 && command != NAND_CMD_PAGEPROG)
+		if (info->cur_chunk == info->ntotalchunks &&
+		    command != NAND_CMD_PAGEPROG)
 			break;
 
 		/*
 		 * After a splitted program command sequence has issued
 		 * the command dispatch, the command sequence is complete.
 		 */
-		if (info->data_size == 0 &&
+		if (info->cur_chunk == (info->ntotalchunks + 1) &&
 		    command == NAND_CMD_PAGEPROG &&
 		    ext_cmd_type == EXT_CMD_TYPE_DISPATCH)
 			break;
 
 		if (command == NAND_CMD_READ0 || command == NAND_CMD_READOOB) {
 			/* Last read: issue a 'last naked read' */
-			if (info->data_size == info->chunk_size)
+			if (info->cur_chunk == info->ntotalchunks - 1)
 				ext_cmd_type = EXT_CMD_TYPE_LAST_RW;
 			else
 				ext_cmd_type = EXT_CMD_TYPE_NAKED_RW;
@@ -1077,7 +1114,7 @@ static void nand_cmdfunc_extended(struct mtd_info *mtd,
 		 * the command dispatch must be issued to complete.
 		 */
 		} else if (command == NAND_CMD_PAGEPROG &&
-			   info->data_size == 0) {
+			   info->cur_chunk == info->ntotalchunks) {
 				ext_cmd_type = EXT_CMD_TYPE_DISPATCH;
 		}
 	} while (1);
@@ -1219,42 +1256,42 @@ static int pxa3xx_nand_waitfunc(struct mtd_info *mtd, struct nand_chip *this)
 	return NAND_STATUS_READY;
 }
 
-static int pxa3xx_nand_config_flash(struct pxa3xx_nand_info *info)
+static int pxa3xx_nand_config_ident(struct pxa3xx_nand_info *info)
+{
+	struct pxa3xx_nand_platform_data *pdata = info->pdata;
+
+	/* Configure default flash values */
+	info->reg_ndcr = 0x0; /* enable all interrupts */
+	info->reg_ndcr |= (pdata->enable_arbiter) ? NDCR_ND_ARB_EN : 0;
+	info->reg_ndcr |= NDCR_RD_ID_CNT(READ_ID_BYTES);
+	info->reg_ndcr |= NDCR_SPARE_EN;
+
+	return 0;
+}
+
+static void pxa3xx_nand_config_tail(struct pxa3xx_nand_info *info)
 {
 	struct pxa3xx_nand_host *host = info->host[info->cs];
-	struct mtd_info *mtd = host->mtd;
+	struct mtd_info *mtd = nand_to_mtd(&info->host[info->cs]->chip);
 	struct nand_chip *chip = mtd_to_nand(mtd);
 
 	info->reg_ndcr |= (host->col_addr_cycles == 2) ? NDCR_RA_START : 0;
 	info->reg_ndcr |= (chip->page_shift == 6) ? NDCR_PG_PER_BLK : 0;
 	info->reg_ndcr |= (mtd->writesize == 2048) ? NDCR_PAGE_SZ : 0;
-
-	return 0;
 }
 
-static int pxa3xx_nand_detect_config(struct pxa3xx_nand_info *info)
+static void pxa3xx_nand_detect_config(struct pxa3xx_nand_info *info)
 {
-	/*
-	 * We set 0 by hard coding here, for we don't support keep_config
-	 * when there is more than one chip attached to the controller
-	 */
-	struct pxa3xx_nand_host *host = info->host[0];
+	struct pxa3xx_nand_platform_data *pdata = info->pdata;
 	uint32_t ndcr = nand_readl(info, NDCR);
 
-	if (ndcr & NDCR_PAGE_SZ) {
-		/* Controller's FIFO size */
-		info->chunk_size = 2048;
-		host->read_id_bytes = 4;
-	} else {
-		info->chunk_size = 512;
-		host->read_id_bytes = 2;
-	}
-
 	/* Set an initial chunk size */
-	info->reg_ndcr = ndcr & ~NDCR_INT_MASK;
+	info->chunk_size = ndcr & NDCR_PAGE_SZ ? 2048 : 512;
+	info->reg_ndcr = ndcr &
+		~(NDCR_INT_MASK | NDCR_ND_ARB_EN | NFCV1_NDCR_ARB_CNTL);
+	info->reg_ndcr |= (pdata->enable_arbiter) ? NDCR_ND_ARB_EN : 0;
 	info->ndtr0cs0 = nand_readl(info, NDTR0CS0);
 	info->ndtr1cs0 = nand_readl(info, NDTR1CS0);
-	return 0;
 }
 
 static int pxa3xx_nand_init_buff(struct pxa3xx_nand_info *info)
@@ -1274,13 +1311,13 @@ static int pxa3xx_nand_sensing(struct pxa3xx_nand_host *host)
 	const struct nand_sdr_timings *timings;
 	int ret;
 
-	mtd = info->host[info->cs]->mtd;
+	mtd = nand_to_mtd(&info->host[info->cs]->chip);
 	chip = mtd_to_nand(mtd);
 
 	/* configure default flash values */
 	info->reg_ndcr = 0x0; /* enable all interrupts */
 	info->reg_ndcr |= (pdata->enable_arbiter) ? NDCR_ND_ARB_EN : 0;
-	info->reg_ndcr |= NDCR_RD_ID_CNT(host->read_id_bytes);
+	info->reg_ndcr |= NDCR_RD_ID_CNT(READ_ID_BYTES);
 	info->reg_ndcr |= NDCR_SPARE_EN; /* enable spare by default */
 
 	/* use the common timing to make a try */
@@ -1303,6 +1340,8 @@ static int pxa_ecc_init(struct pxa3xx_nand_info *info,
 			int strength, int ecc_stepsize, int page_size)
 {
 	if (strength == 1 && ecc_stepsize == 512 && page_size == 2048) {
+		info->nfullchunks = 1;
+		info->ntotalchunks = 1;
 		info->chunk_size = 2048;
 		info->spare_size = 40;
 		info->ecc_size = 24;
@@ -1311,6 +1350,8 @@ static int pxa_ecc_init(struct pxa3xx_nand_info *info,
 		ecc->strength = 1;
 
 	} else if (strength == 1 && ecc_stepsize == 512 && page_size == 512) {
+		info->nfullchunks = 1;
+		info->ntotalchunks = 1;
 		info->chunk_size = 512;
 		info->spare_size = 8;
 		info->ecc_size = 8;
@@ -1324,6 +1365,8 @@ static int pxa_ecc_init(struct pxa3xx_nand_info *info,
 	 */
 	} else if (strength == 4 && ecc_stepsize == 512 && page_size == 2048) {
 		info->ecc_bch = 1;
+		info->nfullchunks = 1;
+		info->ntotalchunks = 1;
 		info->chunk_size = 2048;
 		info->spare_size = 32;
 		info->ecc_size = 32;
@@ -1334,6 +1377,8 @@ static int pxa_ecc_init(struct pxa3xx_nand_info *info,
 
 	} else if (strength == 4 && ecc_stepsize == 512 && page_size == 4096) {
 		info->ecc_bch = 1;
+		info->nfullchunks = 2;
+		info->ntotalchunks = 2;
 		info->chunk_size = 2048;
 		info->spare_size = 32;
 		info->ecc_size = 32;
@@ -1342,19 +1387,64 @@ static int pxa_ecc_init(struct pxa3xx_nand_info *info,
 		ecc->layout = &ecc_layout_4KB_bch4bit;
 		ecc->strength = 16;
 
+	} else if (strength == 4 && ecc_stepsize == 512 && page_size == 8192) {
+		info->ecc_bch = 1;
+		info->nfullchunks = 4;
+		info->ntotalchunks = 4;
+		info->chunk_size = 2048;
+		info->spare_size = 32;
+		info->ecc_size = 32;
+		ecc->mode = NAND_ECC_HW;
+		ecc->size = info->chunk_size;
+		ecc->layout = &ecc_layout_8KB_bch4bit;
+		ecc->strength = 16;
+
 	/*
 	 * Required ECC: 8-bit correction per 512 bytes
 	 * Select: 16-bit correction per 1024 bytes
 	 */
+	} else if (strength == 8 && ecc_stepsize == 512 && page_size == 2048) {
+		info->ecc_bch = 1;
+		info->nfullchunks = 1;
+		info->ntotalchunks = 2;
+		info->chunk_size = 1024;
+		info->spare_size = 0;
+		info->last_chunk_size = 1024;
+		info->last_spare_size = 64;
+		info->ecc_size = 32;
+		ecc->mode = NAND_ECC_HW;
+		ecc->size = info->chunk_size;
+		ecc->layout = &ecc_layout_2KB_bch8bit;
+		ecc->strength = 16;
+
 	} else if (strength == 8 && ecc_stepsize == 512 && page_size == 4096) {
 		info->ecc_bch = 1;
+		info->nfullchunks = 4;
+		info->ntotalchunks = 5;
 		info->chunk_size = 1024;
 		info->spare_size = 0;
+		info->last_chunk_size = 0;
+		info->last_spare_size = 64;
 		info->ecc_size = 32;
 		ecc->mode = NAND_ECC_HW;
 		ecc->size = info->chunk_size;
 		ecc->layout = &ecc_layout_4KB_bch8bit;
 		ecc->strength = 16;
+
+	} else if (strength == 8 && ecc_stepsize == 512 && page_size == 8192) {
+		info->ecc_bch = 1;
+		info->nfullchunks = 8;
+		info->ntotalchunks = 9;
+		info->chunk_size = 1024;
+		info->spare_size = 0;
+		info->last_chunk_size = 0;
+		info->last_spare_size = 160;
+		info->ecc_size = 32;
+		ecc->mode = NAND_ECC_HW;
+		ecc->size = info->chunk_size;
+		ecc->layout = &ecc_layout_8KB_bch8bit;
+		ecc->strength = 16;
+
 	} else {
 		dev_err(&info->pdev->dev,
 			"ECC strength %d at page size %d is not supported\n",
@@ -1374,21 +1464,21 @@ static int pxa3xx_nand_scan(struct mtd_info *mtd)
 	int ret;
 	uint16_t ecc_strength, ecc_step;
 
-	if (pdata->keep_config && !pxa3xx_nand_detect_config(info))
-		goto KEEP_CONFIG;
-
-	/* Set a default chunk size */
-	info->chunk_size = 512;
-
-	ret = pxa3xx_nand_sensing(host);
-	if (ret) {
-		dev_info(&info->pdev->dev, "There is no chip on cs %d!\n",
-			 info->cs);
-
-		return ret;
+	if (pdata->keep_config) {
+		pxa3xx_nand_detect_config(info);
+	} else {
+		ret = pxa3xx_nand_config_ident(info);
+		if (ret)
+			return ret;
+		ret = pxa3xx_nand_sensing(host);
+		if (ret) {
+			dev_info(&info->pdev->dev,
+				 "There is no chip on cs %d!\n",
+				 info->cs);
+			return ret;
+		}
 	}
 
-KEEP_CONFIG:
 	/* Device detection must be done with ECC disabled */
 	if (info->variant == PXA3XX_NAND_VARIANT_ARMADA370)
 		nand_writel(info, NDECCCTRL, 0x0);
@@ -1405,10 +1495,6 @@ KEEP_CONFIG:
 		}
 	}
 
-	ret = pxa3xx_nand_config_flash(info);
-	if (ret)
-		return ret;
-
 #ifdef CONFIG_SYS_NAND_USE_FLASH_BBT
 	/*
 	 * We'll use a bad block table stored in-flash and don't
@@ -1419,21 +1505,6 @@ KEEP_CONFIG:
 	chip->bbt_md = &bbt_mirror_descr;
 #endif
 
-	/*
-	 * If the page size is bigger than the FIFO size, let's check
-	 * we are given the right variant and then switch to the extended
-	 * (aka splitted) command handling,
-	 */
-	if (mtd->writesize > PAGE_CHUNK_SIZE) {
-		if (info->variant == PXA3XX_NAND_VARIANT_ARMADA370) {
-			chip->cmdfunc = nand_cmdfunc_extended;
-		} else {
-			dev_err(&info->pdev->dev,
-				"unsupported page size on this variant\n");
-			return -ENODEV;
-		}
-	}
-
 	if (pdata->ecc_strength && pdata->ecc_step_size) {
 		ecc_strength = pdata->ecc_strength;
 		ecc_step = pdata->ecc_step_size;
@@ -1453,6 +1524,21 @@ KEEP_CONFIG:
 	if (ret)
 		return ret;
 
+	/*
+	 * If the page size is bigger than the FIFO size, let's check
+	 * we are given the right variant and then switch to the extended
+	 * (aka split) command handling,
+	 */
+	if (mtd->writesize > info->chunk_size) {
+		if (info->variant == PXA3XX_NAND_VARIANT_ARMADA370) {
+			chip->cmdfunc = nand_cmdfunc_extended;
+		} else {
+			dev_err(&info->pdev->dev,
+				"unsupported page size on this variant\n");
+			return -ENODEV;
+		}
+	}
+
 	/* calculate addressing information */
 	if (mtd->writesize >= 2048)
 		host->col_addr_cycles = 2;
@@ -1473,6 +1559,10 @@ KEEP_CONFIG:
 		host->row_addr_cycles = 3;
 	else
 		host->row_addr_cycles = 2;
+
+	if (!pdata->keep_config)
+		pxa3xx_nand_config_tail(info);
+
 	return nand_scan_tail(mtd);
 }
 
@@ -1495,10 +1585,8 @@ static int alloc_nand_resource(struct pxa3xx_nand_info *info)
 		mtd = nand_to_mtd(chip);
 		host = (struct pxa3xx_nand_host *)chip;
 		info->host[cs] = host;
-		host->mtd = mtd;
 		host->cs = cs;
 		host->info_data = info;
-		host->read_id_bytes = 4;
 		mtd->owner = THIS_MODULE;
 
 		nand_set_controller_data(chip, host);
@@ -1538,6 +1626,8 @@ static int pxa3xx_nand_probe_dt(struct pxa3xx_nand_info *info)
 	struct pxa3xx_nand_platform_data *pdata;
 	const void *blob = gd->fdt_blob;
 	int node = -1;
+	int index;
+	fdt_addr_t addr;
 
 	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
 	if (!pdata)
@@ -1559,6 +1649,26 @@ static int pxa3xx_nand_probe_dt(struct pxa3xx_nand_info *info)
 			(void __iomem *)fdtdec_get_addr_size_auto_noparent(
 					blob, node, "reg", 0, NULL, true);
 
+		index = fdt_stringlist_search(blob, node, "reg-names",
+					      "flash_clock");
+		if (index > 0) {
+			addr = fdtdec_get_addr_size_auto_noparent(
+					blob, node, "reg", index, NULL, true);
+			if (addr != FDT_ADDR_T_NONE)
+				info->nand_flash_clk_ctrl_reg =
+					(void __iomem *)addr;
+		}
+
+		index = fdt_stringlist_search(blob, node, "reg-names",
+					      "dev_mux");
+		if (index > 0) {
+			addr = fdtdec_get_addr_size_auto_noparent(
+					blob, node, "reg", index, NULL, true);
+			if (addr != FDT_ADDR_T_NONE)
+				info->soc_dev_multiplex_reg =
+					(void __iomem *)addr;
+		}
+
 		pdata->num_cs = fdtdec_get_int(blob, node, "num-cs", 1);
 		if (pdata->num_cs != 1) {
 			pr_err("pxa3xx driver supports single CS only\n");
@@ -1605,6 +1715,14 @@ static int pxa3xx_nand_probe(struct pxa3xx_nand_info *info)
 
 	pdata = info->pdata;
 
+	/* If the NAND flash is enabled in DT, but the boot image is not
+	 * running from NAND, it may be needed to enable NAND on SOC
+	 * DEVBUS MUX level.
+	 * When the boot device is NAND, such configuration is done
+	 * in the BootROM.
+	 */
+	mvebu_nand_select(info->soc_dev_multiplex_reg);
+
 	ret = alloc_nand_resource(info);
 	if (ret) {
 		dev_err(&pdev->dev, "alloc nand resource failed\n");
@@ -1613,7 +1731,7 @@ static int pxa3xx_nand_probe(struct pxa3xx_nand_info *info)
 
 	probe_success = 0;
 	for (cs = 0; cs < pdata->num_cs; cs++) {
-		struct mtd_info *mtd = info->host[cs]->mtd;
+		struct mtd_info *mtd = nand_to_mtd(&info->host[cs]->chip);
 
 		/*
 		 * The mtd name matches the one used in 'mtdparts' kernel
diff --git a/drivers/mtd/nand/pxa3xx_nand.h b/drivers/mtd/nand/pxa3xx_nand.h
index 8f24ae6..a375ad0 100644
--- a/drivers/mtd/nand/pxa3xx_nand.h
+++ b/drivers/mtd/nand/pxa3xx_nand.h
@@ -61,4 +61,110 @@ struct pxa3xx_nand_platform_data {
 	const struct pxa3xx_nand_flash		*flash;
 	size_t					num_flash;
 };
+
+enum pxa3xx_nand_variant {
+	PXA3XX_NAND_VARIANT_PXA,
+	PXA3XX_NAND_VARIANT_ARMADA370,
+};
+
+struct pxa3xx_nand_host {
+	struct nand_chip	chip;
+	void			*info_data;
+
+	/* page size of attached chip */
+	int			use_ecc;
+	int			cs;
+
+	/* calculated from pxa3xx_nand_flash data */
+	unsigned int		col_addr_cycles;
+	unsigned int		row_addr_cycles;
+};
+
+struct pxa3xx_nand_info {
+	struct nand_hw_control	controller;
+	struct pxa3xx_nand_platform_data *pdata;
+
+	struct clk		*clk;
+	void __iomem		*mmio_base;
+	unsigned long		mmio_phys;
+	int			cmd_complete, dev_ready;
+
+	unsigned int		buf_start;
+	unsigned int		buf_count;
+	unsigned int		buf_size;
+	unsigned int		data_buff_pos;
+	unsigned int		oob_buff_pos;
+
+	unsigned char		*data_buff;
+	unsigned char		*oob_buff;
+
+	struct pxa3xx_nand_host *host[NUM_CHIP_SELECT];
+	unsigned int		state;
+
+	/*
+	 * This driver supports NFCv1 (as found in PXA SoC)
+	 * and NFCv2 (as found in Armada 370/XP SoC).
+	 */
+	enum pxa3xx_nand_variant variant;
+
+	int			cs;
+	int			use_ecc;	/* use HW ECC ? */
+	int			ecc_bch;	/* using BCH ECC? */
+	int			use_spare;	/* use spare ? */
+	int			need_wait;
+
+	/* Amount of real data per full chunk */
+	unsigned int		chunk_size;
+
+	/* Amount of spare data per full chunk */
+	unsigned int		spare_size;
+
+	/* Number of full chunks (i.e chunk_size + spare_size) */
+	unsigned int            nfullchunks;
+
+	/*
+	 * Total number of chunks. If equal to nfullchunks, then there
+	 * are only full chunks. Otherwise, there is one last chunk of
+	 * size (last_chunk_size + last_spare_size)
+	 */
+	unsigned int            ntotalchunks;
+
+	/* Amount of real data in the last chunk */
+	unsigned int		last_chunk_size;
+
+	/* Amount of spare data in the last chunk */
+	unsigned int		last_spare_size;
+
+	unsigned int		ecc_size;
+	unsigned int		ecc_err_cnt;
+	unsigned int		max_bitflips;
+	int			retcode;
+
+	/*
+	 * Variables only valid during command
+	 * execution. step_chunk_size and step_spare_size is the
+	 * amount of real data and spare data in the current
+	 * chunk. cur_chunk is the current chunk being
+	 * read/programmed.
+	 */
+	unsigned int		step_chunk_size;
+	unsigned int		step_spare_size;
+	unsigned int            cur_chunk;
+
+	/* cached register value */
+	uint32_t		reg_ndcr;
+	uint32_t		ndtr0cs0;
+	uint32_t		ndtr1cs0;
+
+	/* generated NDCBx register values */
+	uint32_t		ndcb0;
+	uint32_t		ndcb1;
+	uint32_t		ndcb2;
+	uint32_t		ndcb3;
+
+	/* SOC related registers for nand */
+	void __iomem		*nand_flash_clk_ctrl_reg;
+	void __iomem		*soc_dev_multiplex_reg;
+};
+
 #endif /* __ASM_ARCH_PXA3XX_NAND_H */
diff --git a/drivers/mtd/spi/Kconfig b/drivers/mtd/spi/Kconfig
index 6ba255d..5635de3 100644
--- a/drivers/mtd/spi/Kconfig
+++ b/drivers/mtd/spi/Kconfig
@@ -34,14 +34,28 @@ config SPI_FLASH
 
 	  If unsure, say N
 
+choice
+	prompt "Support SPI flash above 16MiB"
+	depends on SPI_FLASH
+	optional
+
 config SPI_FLASH_BAR
 	bool "SPI flash Bank/Extended address register support"
-	depends on SPI_FLASH
 	help
 	  Enable the SPI flash Bank/Extended address register support.
 	  Bank/Extended address registers are used to access the flash
 	  which has size > 16MiB in 3-byte addressing.
 
+config SPI_FLASH_4BAIS
+	bool "SPI flash 4-byte address instruction set support"
+	help
+	  Convert the selected 3-byte address op codes into their associated
+	  4-byte address op codes. Using this instruction set does not change
+	  the internal state of the SPI flash device.
+
+endchoice
+
+
 config SF_DUAL_FLASH
 	bool "SPI DUAL flash memory support"
 	depends on SPI_FLASH
@@ -91,6 +105,11 @@ config SPI_FLASH_WINBOND
 	help
 	  Add support for various Winbond SPI flash chips (W25xxx)
 
+config SPI_FLASH_ISSI
+	bool "ISSI SPI flash support"
+	help
+	  Add support for various ISSI SPI flash chips (is25xxx)
+
 endif
 
 config SPI_FLASH_USE_4K_SECTORS
diff --git a/drivers/mtd/spi/sf.c b/drivers/mtd/spi/sf.c
index d5e175c..b746b29 100644
--- a/drivers/mtd/spi/sf.c
+++ b/drivers/mtd/spi/sf.c
@@ -9,46 +9,98 @@
 
 #include <common.h>
 #include <spi.h>
+#include <spi_flash.h>
 
-static int spi_flash_read_write(struct spi_slave *spi,
-				const u8 *cmd, size_t cmd_len,
-				const u8 *data_out, u8 *data_in,
-				size_t data_len)
+#include "sf_internal.h"
+
+static void spi_flash_addr(u32 addr, u8 addr_len, u8 *cmd_buf)
+{
+	u8 i;
+
+	for (i = 0; i < addr_len; i++)
+		cmd_buf[i] = addr >> ((addr_len - 1 - i) * 8);
+}
+
+static u8 spi_compute_num_dummy_bytes(enum spi_flash_protocol proto,
+				      u8 num_dummy_clock_cycles)
 {
+	int shift = fls(spi_flash_protocol_get_addr_nbits(proto)) - 1;
+
+	if (shift < 0)
+		shift = 0;
+	return (num_dummy_clock_cycles << shift) >> 3;
+}
+
+static int spi_flash_exec(struct spi_flash *flash,
+			  const struct spi_flash_command *cmd)
+{
+	struct spi_slave *spi = flash->spi;
+	u8 cmd_buf[SPI_FLASH_CMD_LEN];
+	size_t cmd_len, num_dummy_bytes;
 	unsigned long flags = SPI_XFER_BEGIN;
 	int ret;
 
-	if (data_len == 0)
+	if (spi_is_flash_command_supported(spi, cmd))
+		return spi_exec_flash_command(spi, cmd);
+
+	if (cmd->data_len == 0)
 		flags |= SPI_XFER_END;
 
-	ret = spi_xfer(spi, cmd_len * 8, cmd, NULL, flags);
+	cmd_buf[0] = cmd->inst;
+	spi_flash_addr(cmd->addr, cmd->addr_len, cmd_buf + 1);
+	cmd_len = 1 + cmd->addr_len;
+
+	num_dummy_bytes = spi_compute_num_dummy_bytes(cmd->proto,
+						      cmd->num_mode_cycles +
+						      cmd->num_wait_states);
+	memset(cmd_buf + cmd_len, 0xff, num_dummy_bytes);
+	cmd_len += num_dummy_bytes;
+
+	ret = spi_xfer(spi, cmd_len * 8, cmd_buf, NULL, flags);
 	if (ret) {
 		debug("SF: Failed to send command (%zu bytes): %d\n",
 		      cmd_len, ret);
-	} else if (data_len != 0) {
-		ret = spi_xfer(spi, data_len * 8, data_out, data_in,
-					SPI_XFER_END);
+	} else if (cmd->data_len != 0) {
+		flags = SPI_XFER_END;
+
+		if (cmd->inst == CMD_READ_QUAD_OUTPUT_FAST ||
+		    cmd->inst == CMD_READ_QUAD_OUTPUT_FAST_4B ||
+		    cmd->inst == CMD_PAGE_PROGRAM_1_1_4_4B ||
+		    cmd->inst == CMD_QUAD_PAGE_PROGRAM)
+			flags |= SPI_XFER_QUAD;
+		else if (cmd->inst == CMD_READ_DUAL_OUTPUT_FAST)
+			flags |= SPI_XFER_DUAL;
+
+		ret = spi_xfer(spi, cmd->data_len * 8,
+			       cmd->tx_data, cmd->rx_data,
+			       flags);
 		if (ret)
 			debug("SF: Failed to transfer %zu bytes of data: %d\n",
-			      data_len, ret);
+			      cmd->data_len, ret);
 	}
 
 	return ret;
 }
 
-int spi_flash_cmd_read(struct spi_slave *spi, const u8 *cmd,
-		size_t cmd_len, void *data, size_t data_len)
+int spi_flash_cmd_read(struct spi_flash *flash,
+		       const struct spi_flash_command *cmd)
 {
-	return spi_flash_read_write(spi, cmd, cmd_len, NULL, data, data_len);
+	return spi_flash_exec(flash, cmd);
 }
 
-int spi_flash_cmd(struct spi_slave *spi, u8 cmd, void *response, size_t len)
+int spi_flash_cmd(struct spi_flash *flash, u8 instr, void *response, size_t len)
 {
-	return spi_flash_cmd_read(spi, &cmd, 1, response, len);
+	struct spi_flash_command cmd;
+	u8 flags = (response && len) ? SPI_FCMD_READ_REG : SPI_FCMD_WRITE_REG;
+
+	spi_flash_command_init(&cmd, instr, 0, flags);
+	cmd.data_len = len;
+	cmd.rx_data = response;
+	return spi_flash_exec(flash, &cmd);
 }
 
-int spi_flash_cmd_write(struct spi_slave *spi, const u8 *cmd, size_t cmd_len,
-		const void *data, size_t data_len)
+int spi_flash_cmd_write(struct spi_flash *flash,
+			const struct spi_flash_command *cmd)
 {
-	return spi_flash_read_write(spi, cmd, cmd_len, data, NULL, data_len);
+	return spi_flash_exec(flash, cmd);
 }
diff --git a/drivers/mtd/spi/sf_dataflash.c b/drivers/mtd/spi/sf_dataflash.c
index e5c0e12..a1a79a4 100644
--- a/drivers/mtd/spi/sf_dataflash.c
+++ b/drivers/mtd/spi/sf_dataflash.c
@@ -73,7 +73,7 @@ struct dataflash {
 };
 
 /* Return the status of the DataFlash device */
-static inline int dataflash_status(struct spi_slave *spi)
+static inline int dataflash_status(struct spi_flash *spi_flash)
 {
 	int ret;
 	u8 status;
@@ -81,7 +81,7 @@ static inline int dataflash_status(struct spi_slave *spi)
 	 * NOTE:  at45db321c over 25 MHz wants to write
 	 * a dummy byte after the opcode...
 	 */
-	ret = spi_flash_cmd(spi, OP_READ_STATUS, &status, 1);
+	ret = spi_flash_cmd(spi_flash, OP_READ_STATUS, &status, 1);
 	return ret ? -EIO : status;
 }
 
@@ -90,7 +90,7 @@ static inline int dataflash_status(struct spi_slave *spi)
  * This usually takes 5-20 msec or so; more for sector erase.
  * ready: return > 0
  */
-static int dataflash_waitready(struct spi_slave *spi)
+static int dataflash_waitready(struct spi_flash *spi_flash)
 {
 	int status;
 	int timeout = 2 * CONFIG_SYS_HZ;
@@ -98,7 +98,7 @@ static int dataflash_waitready(struct spi_slave *spi)
 
 	timebase = get_timer(0);
 	do {
-		status = dataflash_status(spi);
+		status = dataflash_status(spi_flash);
 		if (status < 0)
 			status = 0;
 
@@ -114,11 +114,11 @@ static int dataflash_waitready(struct spi_slave *spi)
 /* Erase pages of flash */
 static int spi_dataflash_erase(struct udevice *dev, u32 offset, size_t len)
 {
+	struct spi_flash_command	cmd;
 	struct dataflash	*dataflash;
 	struct spi_flash	*spi_flash;
 	struct spi_slave	*spi;
 	unsigned		blocksize;
-	uint8_t			*command;
 	uint32_t		rem;
 	int			status;
 
@@ -128,9 +128,6 @@ static int spi_dataflash_erase(struct udevice *dev, u32 offset, size_t len)
 
 	blocksize = spi_flash->page_size << 3;
 
-	memset(dataflash->command, 0 , sizeof(dataflash->command));
-	command = dataflash->command;
-
 	debug("%s: erase addr=0x%x len 0x%x\n", dev->name, offset, len);
 
 	div_u64_rem(len, spi_flash->page_size, &rem);
@@ -152,6 +149,8 @@ static int spi_dataflash_erase(struct udevice *dev, u32 offset, size_t len)
 		return status;
 	}
 
+	spi_flash_command_init(&cmd, OP_ERASE_BLOCK, SPI_FLASH_3B_ADDR_LEN,
+			       SPI_FCMD_ERASE);
 	while (len > 0) {
 		unsigned int	pageaddr;
 		int		do_block;
@@ -163,23 +162,24 @@ static int spi_dataflash_erase(struct udevice *dev, u32 offset, size_t len)
 		do_block = (pageaddr & 0x7) == 0 && len >= blocksize;
 		pageaddr = pageaddr << dataflash->page_offset;
 
-		command[0] = do_block ? OP_ERASE_BLOCK : OP_ERASE_PAGE;
-		command[1] = (uint8_t)(pageaddr >> 16);
-		command[2] = (uint8_t)(pageaddr >> 8);
-		command[3] = 0;
+		cmd.inst = do_block ? OP_ERASE_BLOCK : OP_ERASE_PAGE;
+		cmd.addr = pageaddr & 0x00FFFF00;
 
 		debug("%s ERASE %s: (%x) %x %x %x [%d]\n",
 		      dev->name, do_block ? "block" : "page",
-		      command[0], command[1], command[2], command[3],
+		      cmd.inst,
+		      (cmd.addr >> 16) & 0xff,
+		      (cmd.addr >>  8) & 0xff,
+		      (cmd.addr >>  0) & 0xff,
 		      pageaddr);
 
-		status = spi_flash_cmd_write(spi, command, 4, NULL, 0);
+		status = spi_flash_cmd_write(spi_flash, &cmd);
 		if (status < 0) {
 			debug("%s: erase send command error!\n", dev->name);
 			return -EIO;
 		}
 
-		status = dataflash_waitready(spi);
+		status = dataflash_waitready(spi_flash);
 		if (status < 0) {
 			debug("%s: erase waitready error!\n", dev->name);
 			return status;
@@ -208,23 +208,18 @@ static int spi_dataflash_erase(struct udevice *dev, u32 offset, size_t len)
 static int spi_dataflash_read(struct udevice *dev, u32 offset, size_t len,
 			      void *buf)
 {
+	struct spi_flash_command	cmd;
 	struct dataflash	*dataflash;
 	struct spi_flash	*spi_flash;
 	struct spi_slave	*spi;
 	unsigned int		addr;
-	uint8_t			*command;
 	int			status;
 
 	dataflash = dev_get_priv(dev);
 	spi_flash = dev_get_uclass_priv(dev);
 	spi = spi_flash->spi;
 
-	memset(dataflash->command, 0 , sizeof(dataflash->command));
-	command = dataflash->command;
-
-	debug("%s: erase addr=0x%x len 0x%x\n", dev->name, offset, len);
-	debug("READ: (%x) %x %x %x\n",
-	      command[0], command[1], command[2], command[3]);
+	debug("%s: read addr=0x%x len 0x%x\n", dev->name, offset, len);
 
 	/* Calculate flash page/byte address */
 	addr = (((unsigned)offset / spi_flash->page_size)
@@ -242,13 +237,15 @@ static int spi_dataflash_read(struct udevice *dev, u32 offset, size_t len,
 	 * the peak rate available.  Some chips support commands with
 	 * fewer "don't care" bytes.  Both buffers stay unchanged.
 	 */
-	command[0] = OP_READ_CONTINUOUS;
-	command[1] = (uint8_t)(addr >> 16);
-	command[2] = (uint8_t)(addr >> 8);
-	command[3] = (uint8_t)(addr >> 0);
+	spi_flash_command_init(&cmd, OP_READ_CONTINUOUS, SPI_FLASH_3B_ADDR_LEN,
+			       SPI_FCMD_READ);
+	cmd.addr = addr;
+	cmd.num_wait_states = 4 * 8; /* 4 "don't care" bytes */
+	cmd.data_len = len;
+	cmd.rx_data = buf;
 
 	/* plus 4 "don't care" bytes, command len: 4 + 4 "don't care" bytes */
-	status = spi_flash_cmd_read(spi, command, 8, buf, len);
+	status = spi_flash_cmd_read(spi_flash, &cmd);
 
 	spi_release_bus(spi);
 
@@ -264,10 +261,10 @@ static int spi_dataflash_read(struct udevice *dev, u32 offset, size_t len,
 int spi_dataflash_write(struct udevice *dev, u32 offset, size_t len,
 			const void *buf)
 {
+	struct spi_flash_command	cmd;
 	struct dataflash	*dataflash;
 	struct spi_flash	*spi_flash;
 	struct spi_slave	*spi;
-	uint8_t			*command;
 	unsigned int		pageaddr, addr, to, writelen;
 	size_t			remaining = len;
 	u_char			*writebuf = (u_char *)buf;
@@ -277,9 +274,6 @@ int spi_dataflash_write(struct udevice *dev, u32 offset, size_t len,
 	spi_flash = dev_get_uclass_priv(dev);
 	spi = spi_flash->spi;
 
-	memset(dataflash->command, 0 , sizeof(dataflash->command));
-	command = dataflash->command;
-
 	debug("%s: write 0x%x..0x%x\n", dev->name, offset, (offset + len));
 
 	pageaddr = ((unsigned)offset / spi_flash->page_size);
@@ -295,6 +289,8 @@ int spi_dataflash_write(struct udevice *dev, u32 offset, size_t len,
 		return status;
 	}
 
+	spi_flash_command_init(&cmd, OP_TRANSFER_BUF1, SPI_FLASH_3B_ADDR_LEN,
+			       SPI_FCMD_WRITE);
 	while (remaining > 0) {
 		debug("write @ %d:%d len=%d\n", pageaddr, to, writelen);
 
@@ -319,22 +315,25 @@ int spi_dataflash_write(struct udevice *dev, u32 offset, size_t len,
 
 		/* (1) Maybe transfer partial page to Buffer1 */
 		if (writelen != spi_flash->page_size) {
-			command[0] = OP_TRANSFER_BUF1;
-			command[1] = (addr & 0x00FF0000) >> 16;
-			command[2] = (addr & 0x0000FF00) >> 8;
-			command[3] = 0;
+			cmd.inst = OP_TRANSFER_BUF1;
+			cmd.addr = (addr & 0x00FFFF00);
+			cmd.data_len = 0;
+			cmd.tx_data = NULL;
 
 			debug("TRANSFER: (%x) %x %x %x\n",
-			      command[0], command[1], command[2], command[3]);
+			      cmd.inst,
+			      (cmd.addr >> 16) & 0xff,
+			      (cmd.addr >>  8) & 0xff,
+			      (cmd.addr >>  0) & 0xff);
 
-			status = spi_flash_cmd_write(spi, command, 4, NULL, 0);
+			status = spi_flash_cmd_write(spi_flash, &cmd);
 			if (status < 0) {
 				debug("%s: write(<pagesize) command error!\n",
 				      dev->name);
 				return -EIO;
 			}
 
-			status = dataflash_waitready(spi);
+			status = dataflash_waitready(spi_flash);
 			if (status < 0) {
 				debug("%s: write(<pagesize) waitready error!\n",
 				      dev->name);
@@ -344,22 +343,24 @@ int spi_dataflash_write(struct udevice *dev, u32 offset, size_t len,
 
 		/* (2) Program full page via Buffer1 */
 		addr += to;
-		command[0] = OP_PROGRAM_VIA_BUF1;
-		command[1] = (addr & 0x00FF0000) >> 16;
-		command[2] = (addr & 0x0000FF00) >> 8;
-		command[3] = (addr & 0x000000FF);
+		cmd.inst = OP_PROGRAM_VIA_BUF1;
+		cmd.addr = addr;
+		cmd.data_len = writelen;
+		cmd.tx_data = writebuf;
 
 		debug("PROGRAM: (%x) %x %x %x\n",
-		      command[0], command[1], command[2], command[3]);
+		      cmd.inst,
+		      (cmd.addr >> 16) & 0xff,
+		      (cmd.addr >>  8) & 0xff,
+		      (cmd.addr >>  0) & 0xff);
 
-		status = spi_flash_cmd_write(spi, command,
-					     4, writebuf, writelen);
+		status = spi_flash_cmd_write(spi_flash, &cmd);
 		if (status < 0) {
 			debug("%s: write send command error!\n", dev->name);
 			return -EIO;
 		}
 
-		status = dataflash_waitready(spi);
+		status = dataflash_waitready(spi_flash);
 		if (status < 0) {
 			debug("%s: write waitready error!\n", dev->name);
 			return status;
@@ -368,16 +369,18 @@ int spi_dataflash_write(struct udevice *dev, u32 offset, size_t len,
 #ifdef CONFIG_SPI_DATAFLASH_WRITE_VERIFY
 		/* (3) Compare to Buffer1 */
 		addr = pageaddr << dataflash->page_offset;
-		command[0] = OP_COMPARE_BUF1;
-		command[1] = (addr & 0x00FF0000) >> 16;
-		command[2] = (addr & 0x0000FF00) >> 8;
-		command[3] = 0;
+		cmd.inst = OP_COMPARE_BUF1;
+		cmd.addr = addr & 0x00FFFF00;
+		cmd.data_len = writelen;
+		cmd.tx_data = writebuf;
 
 		debug("COMPARE: (%x) %x %x %x\n",
-		      command[0], command[1], command[2], command[3]);
+		      cmd.inst,
+		      (cmd.addr >> 16) & 0xff,
+		      (cmd.addr >>  8) & 0xff,
+		      (cmd.addr >>  0) & 0xff);
 
-		status = spi_flash_cmd_write(spi, command,
-					     4, writebuf, writelen);
+		status = spi_flash_cmd_write(spi, &cmd);
 		if (status < 0) {
 			debug("%s: write(compare) send command error!\n",
 			      dev->name);
@@ -502,7 +505,7 @@ static struct flash_info dataflash_data[] = {
 	{ "at45db642d",  0x1f2800, 8192, 1024, 10, SUP_POW2PS | IS_POW2PS},
 };
 
-static struct flash_info *jedec_probe(struct spi_slave *spi)
+static struct flash_info *jedec_probe(struct spi_flash *spi_flash)
 {
 	int			tmp;
 	uint8_t			id[5];
@@ -519,7 +522,7 @@ static struct flash_info *jedec_probe(struct spi_slave *spi)
 	 * That's not an error; only rev C and newer chips handle it, and
 	 * only Atmel sells these chips.
 	 */
-	tmp = spi_flash_cmd(spi, CMD_READ_ID, id, sizeof(id));
+	tmp = spi_flash_cmd(spi_flash, CMD_READ_ID, id, sizeof(id));
 	if (tmp < 0) {
 		printf("dataflash: error %d reading JEDEC ID\n", tmp);
 		return ERR_PTR(tmp);
@@ -538,7 +541,7 @@ static struct flash_info *jedec_probe(struct spi_slave *spi)
 			tmp++, info++) {
 		if (info->jedec_id == jedec) {
 			if (info->flags & SUP_POW2PS) {
-				status = dataflash_status(spi);
+				status = dataflash_status(spi_flash);
 				if (status < 0) {
 					debug("dataflash: status error %d\n",
 					      status);
@@ -602,7 +605,7 @@ static int spi_dataflash_probe(struct udevice *dev)
 	 * Both support the security register, though with different
 	 * write procedures.
 	 */
-	info = jedec_probe(spi);
+	info = jedec_probe(spi_flash);
 	if (IS_ERR(info))
 		goto err_jedec_probe;
 	if (info != NULL) {
@@ -617,7 +620,7 @@ static int spi_dataflash_probe(struct udevice *dev)
 	* Older chips support only legacy commands, identifing
 	* capacity using bits in the status byte.
 	*/
-	status = dataflash_status(spi);
+	status = dataflash_status(spi_flash);
 	if (status <= 0 || status == 0xff) {
 		printf("dataflash: read status error %d\n", status);
 		if (status == 0 || status == 0xff)
diff --git a/drivers/mtd/spi/sf_internal.h b/drivers/mtd/spi/sf_internal.h
index 839cdbe..a7bd97a 100644
--- a/drivers/mtd/spi/sf_internal.h
+++ b/drivers/mtd/spi/sf_internal.h
@@ -27,7 +27,8 @@ enum spi_nor_option_flags {
 };
 
 #define SPI_FLASH_3B_ADDR_LEN		3
-#define SPI_FLASH_CMD_LEN		(1 + SPI_FLASH_3B_ADDR_LEN)
+#define SPI_FLASH_4B_ADDR_LEN		4
+#define SPI_FLASH_CMD_LEN		(1 + SPI_FLASH_3B_ADDR_LEN + 16)
 #define SPI_FLASH_16MB_BOUN		0x1000000
 
 /* CFI Manufacture ID's */
@@ -48,6 +49,8 @@ enum spi_nor_option_flags {
 #define CMD_PAGE_PROGRAM		0x02
 #define CMD_WRITE_DISABLE		0x04
 #define CMD_WRITE_ENABLE		0x06
+#define CMD_PAGE_PROGRAM_1_1_4		0x32
+#define CMD_PAGE_PROGRAM_1_4_4		0x38
 #define CMD_QUAD_PAGE_PROGRAM		0x32
 
 /* Read commands */
@@ -63,6 +66,19 @@ enum spi_nor_option_flags {
 #define CMD_READ_CONFIG			0x35
 #define CMD_FLAG_STATUS			0x70
 
+/* 4-byte address instruction set */
+#define CMD_READ_ARRAY_SLOW_4B		0x13
+#define CMD_READ_ARRAY_FAST_4B		0x0c
+#define CMD_READ_DUAL_OUTPUT_FAST_4B	0x3c
+#define CMD_READ_DUAL_IO_FAST_4B	0xbc
+#define CMD_READ_QUAD_OUTPUT_FAST_4B	0x6c
+#define CMD_READ_QUAD_IO_FAST_4B	0xec
+#define CMD_PAGE_PROGRAM_4B		0x12
+#define CMD_PAGE_PROGRAM_1_1_4_4B	0x34
+#define CMD_PAGE_PROGRAM_1_4_4_4B	0x3e
+#define CMD_ERASE_4K_4B			0x21
+#define CMD_ERASE_64K_4B		0xdc
+
 /* Bank addr access commands */
 #ifdef CONFIG_SPI_FLASH_BAR
 # define CMD_BANKADDR_BRWR		0x17
@@ -132,26 +148,30 @@ struct spi_flash_info {
 #define RD_QUADIO		BIT(6)	/* use Quad IO Read */
 #define RD_DUALIO		BIT(7)	/* use Dual IO Read */
 #define RD_FULL			(RD_QUAD | RD_DUAL | RD_QUADIO | RD_DUALIO)
+#define NO_4BAIS		BIT(8)	/*
+					 * 4-byte address instruction set
+					 * NOT supported
+					 */
 };
 
 extern const struct spi_flash_info spi_flash_ids[];
 
 /* Send a single-byte command to the device and read the response */
-int spi_flash_cmd(struct spi_slave *spi, u8 cmd, void *response, size_t len);
+int spi_flash_cmd(struct spi_flash *flash, u8 instr, void *response, size_t len);
 
 /*
  * Send a multi-byte command to the device and read the response. Used
  * for flash array reads, etc.
  */
-int spi_flash_cmd_read(struct spi_slave *spi, const u8 *cmd,
-		size_t cmd_len, void *data, size_t data_len);
+int spi_flash_cmd_read(struct spi_flash *flash,
+		       const struct spi_flash_command *cmd);
 
 /*
  * Send a multi-byte command to the device followed by (optional)
  * data. Used for programming the flash array, etc.
  */
-int spi_flash_cmd_write(struct spi_slave *spi, const u8 *cmd, size_t cmd_len,
-		const void *data, size_t data_len);
+int spi_flash_cmd_write(struct spi_flash *flash,
+			const struct spi_flash_command *cmd);
 
 
 /* Flash erase(sectors) operation, support all possible erase commands */
@@ -169,13 +189,13 @@ int stm_is_locked(struct spi_flash *flash, u32 ofs, size_t len);
 /* Enable writing on the SPI flash */
 static inline int spi_flash_cmd_write_enable(struct spi_flash *flash)
 {
-	return spi_flash_cmd(flash->spi, CMD_WRITE_ENABLE, NULL, 0);
+	return spi_flash_cmd(flash, CMD_WRITE_ENABLE, NULL, 0);
 }
 
 /* Disable writing on the SPI flash */
 static inline int spi_flash_cmd_write_disable(struct spi_flash *flash)
 {
-	return spi_flash_cmd(flash->spi, CMD_WRITE_DISABLE, NULL, 0);
+	return spi_flash_cmd(flash, CMD_WRITE_DISABLE, NULL, 0);
 }
 
 /*
@@ -186,8 +206,8 @@ static inline int spi_flash_cmd_write_disable(struct spi_flash *flash)
  * - spi_flash_wait_till_ready
  * - SPI release
  */
-int spi_flash_write_common(struct spi_flash *flash, const u8 *cmd,
-		size_t cmd_len, const void *buf, size_t buf_len);
+int spi_flash_write_common(struct spi_flash *flash,
+			   const struct spi_flash_command *cmd);
 
 /*
  * Flash write operation, support all possible write commands.
@@ -201,8 +221,8 @@ int spi_flash_cmd_write_ops(struct spi_flash *flash, u32 offset,
  * Same as spi_flash_cmd_read() except it also claims/releases the SPI
  * bus. Used as common part of the ->read() operation.
  */
-int spi_flash_read_common(struct spi_flash *flash, const u8 *cmd,
-		size_t cmd_len, void *data, size_t data_len);
+int spi_flash_read_common(struct spi_flash *flash,
+			  const struct spi_flash_command *cmd);
 
 /* Flash read operation, support all possible read commands */
 int spi_flash_cmd_read_ops(struct spi_flash *flash, u32 offset,
diff --git a/drivers/mtd/spi/spi_flash.c b/drivers/mtd/spi/spi_flash.c
index 294d9f9..8c24603 100644
--- a/drivers/mtd/spi/spi_flash.c
+++ b/drivers/mtd/spi/spi_flash.c
@@ -22,21 +22,15 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
-static void spi_flash_addr(u32 addr, u8 *cmd)
-{
-	/* cmd[0] is actual command */
-	cmd[1] = addr >> 16;
-	cmd[2] = addr >> 8;
-	cmd[3] = addr >> 0;
-}
-
 static int read_sr(struct spi_flash *flash, u8 *rs)
 {
+	struct spi_flash_command cmd;
 	int ret;
-	u8 cmd;
 
-	cmd = CMD_READ_STATUS;
-	ret = spi_flash_read_common(flash, &cmd, 1, rs, 1);
+	spi_flash_command_init(&cmd, CMD_READ_STATUS, 0, SPI_FCMD_READ_REG);
+	cmd.data_len = 1;
+	cmd.rx_data = rs;
+	ret = spi_flash_read_common(flash, &cmd);
 	if (ret < 0) {
 		debug("SF: fail to read status register\n");
 		return ret;
@@ -47,10 +41,13 @@ static int read_sr(struct spi_flash *flash, u8 *rs)
 
 static int read_fsr(struct spi_flash *flash, u8 *fsr)
 {
+	struct spi_flash_command cmd;
 	int ret;
-	const u8 cmd = CMD_FLAG_STATUS;
 
-	ret = spi_flash_read_common(flash, &cmd, 1, fsr, 1);
+	spi_flash_command_init(&cmd, CMD_FLAG_STATUS, 0, SPI_FCMD_READ_REG);
+	cmd.data_len = 1;
+	cmd.rx_data = fsr;
+	ret = spi_flash_read_common(flash, &cmd);
 	if (ret < 0) {
 		debug("SF: fail to read flag status register\n");
 		return ret;
@@ -61,11 +58,13 @@ static int read_fsr(struct spi_flash *flash, u8 *fsr)
 
 static int write_sr(struct spi_flash *flash, u8 ws)
 {
-	u8 cmd;
+	struct spi_flash_command cmd;
 	int ret;
 
-	cmd = CMD_WRITE_STATUS;
-	ret = spi_flash_write_common(flash, &cmd, 1, &ws, 1);
+	spi_flash_command_init(&cmd, CMD_WRITE_STATUS, 0, SPI_FCMD_WRITE_REG);
+	cmd.data_len = 1;
+	cmd.tx_data = &ws;
+	ret = spi_flash_write_common(flash, &cmd);
 	if (ret < 0) {
 		debug("SF: fail to write status register\n");
 		return ret;
@@ -77,11 +76,13 @@ static int write_sr(struct spi_flash *flash, u8 ws)
 #if defined(CONFIG_SPI_FLASH_SPANSION) || defined(CONFIG_SPI_FLASH_WINBOND)
 static int read_cr(struct spi_flash *flash, u8 *rc)
 {
+	struct spi_flash_command cmd;
 	int ret;
-	u8 cmd;
 
-	cmd = CMD_READ_CONFIG;
-	ret = spi_flash_read_common(flash, &cmd, 1, rc, 1);
+	spi_flash_command_init(&cmd, CMD_READ_CONFIG, 0, SPI_FCMD_READ_REG);
+	cmd.data_len = 1;
+	cmd.rx_data = rc;
+	ret = spi_flash_read_common(flash, &cmd);
 	if (ret < 0) {
 		debug("SF: fail to read config register\n");
 		return ret;
@@ -92,17 +93,19 @@ static int read_cr(struct spi_flash *flash, u8 *rc)
 
 static int write_cr(struct spi_flash *flash, u8 wc)
 {
+	struct spi_flash_command cmd;
 	u8 data[2];
-	u8 cmd;
 	int ret;
 
 	ret = read_sr(flash, &data[0]);
 	if (ret < 0)
 		return ret;
 
-	cmd = CMD_WRITE_STATUS;
+	spi_flash_command_init(&cmd, CMD_WRITE_STATUS, 0, SPI_FCMD_WRITE_REG);
+	cmd.data_len = 2;
+	cmd.tx_data = data;
 	data[1] = wc;
-	ret = spi_flash_write_common(flash, &cmd, 1, &data, 2);
+	ret = spi_flash_write_common(flash, &cmd);
 	if (ret) {
 		debug("SF: fail to write config register\n");
 		return ret;
@@ -136,15 +139,19 @@ static int clean_bar(struct spi_flash *flash)
 
 static int write_bar(struct spi_flash *flash, u32 offset)
 {
-	u8 cmd, bank_sel;
+	struct spi_flash_command cmd;
+	u8 bank_sel;
 	int ret;
 
 	bank_sel = offset / (SPI_FLASH_16MB_BOUN << flash->shift);
 	if (bank_sel == flash->bank_curr)
 		goto bar_end;
 
-	cmd = flash->bank_write_cmd;
-	ret = spi_flash_write_common(flash, &cmd, 1, &bank_sel, 1);
+	spi_flash_command_init(&cmd, flash->bank_write_cmd, 0,
+			       SPI_FCMD_WRITE_REG);
+	cmd.data_len = 1;
+	cmd.tx_data = &bank_sel;
+	ret = spi_flash_write_common(flash, &cmd);
 	if (ret < 0) {
 		debug("SF: fail to write bank register\n");
 		return ret;
@@ -157,6 +164,7 @@ bar_end:
 
 static int read_bar(struct spi_flash *flash, const struct spi_flash_info *info)
 {
+	struct spi_flash_command cmd;
 	u8 curr_bank = 0;
 	int ret;
 
@@ -173,8 +181,11 @@ static int read_bar(struct spi_flash *flash, const struct spi_flash_info *info)
 		flash->bank_write_cmd = CMD_EXTNADDR_WREAR;
 	}
 
-	ret = spi_flash_read_common(flash, &flash->bank_read_cmd, 1,
-				    &curr_bank, 1);
+	spi_flash_command_init(&cmd, flash->bank_read_cmd, 0,
+			       SPI_FCMD_READ_REG);
+	cmd.data_len = 1;
+	cmd.rx_data = &curr_bank;
+	ret = spi_flash_read_common(flash, &cmd);
 	if (ret) {
 		debug("SF: fail to read bank addr register\n");
 		return ret;
@@ -186,6 +197,67 @@ bar_end:
 }
 #endif
 
+#ifdef CONFIG_SPI_FLASH_4BAIS
+static u8 spi_flash_convert_opcode(u8 opcode, const u8 table[][2], size_t size)
+{
+	size_t i;
+
+	for (i = 0; i < size; i++)
+		if (table[i][0] == opcode)
+			return table[i][1];
+
+	/* No conversion found, keep input op code. */
+	return opcode;
+}
+
+static u8 spi_flash_convert_3to4_read(u8 opcode)
+{
+	static const u8 spi_flash_3to4_read[][2] = {
+		{CMD_READ_ARRAY_SLOW,		CMD_READ_ARRAY_SLOW_4B},
+		{CMD_READ_ARRAY_FAST,		CMD_READ_ARRAY_FAST_4B},
+		{CMD_READ_DUAL_OUTPUT_FAST,	CMD_READ_DUAL_OUTPUT_FAST_4B},
+		{CMD_READ_DUAL_IO_FAST,		CMD_READ_DUAL_IO_FAST_4B},
+		{CMD_READ_QUAD_OUTPUT_FAST,	CMD_READ_QUAD_OUTPUT_FAST_4B},
+		{CMD_READ_QUAD_IO_FAST,		CMD_READ_QUAD_IO_FAST_4B},
+	};
+
+	return spi_flash_convert_opcode(opcode, spi_flash_3to4_read,
+					ARRAY_SIZE(spi_flash_3to4_read));
+}
+
+static u8 spi_flash_convert_3to4_write(u8 opcode)
+{
+	static const u8 spi_flash_3to4_write[][2] = {
+		{CMD_PAGE_PROGRAM,		CMD_PAGE_PROGRAM_4B},
+		{CMD_PAGE_PROGRAM_1_1_4,	CMD_PAGE_PROGRAM_1_1_4_4B},
+		{CMD_PAGE_PROGRAM_1_4_4,	CMD_PAGE_PROGRAM_1_4_4_4B},
+	};
+
+	return spi_flash_convert_opcode(opcode, spi_flash_3to4_write,
+					ARRAY_SIZE(spi_flash_3to4_write));
+}
+
+static u8 spi_flash_convert_3to4_erase(u8 opcode)
+{
+	static const u8 spi_flash_3to4_erase[][2] = {
+		{CMD_ERASE_4K,	CMD_ERASE_4K_4B},
+		{CMD_ERASE_64K,	CMD_ERASE_64K_4B},
+	};
+
+	return spi_flash_convert_opcode(opcode, spi_flash_3to4_erase,
+					ARRAY_SIZE(spi_flash_3to4_erase));
+}
+
+static void spi_flash_set_4byte_addr_opcodes(struct spi_flash *flash,
+					     const struct spi_flash_info *info)
+{
+	flash->read_cmd = spi_flash_convert_3to4_read(flash->read_cmd);
+	flash->write_cmd = spi_flash_convert_3to4_write(flash->write_cmd);
+	flash->erase_cmd = spi_flash_convert_3to4_erase(flash->erase_cmd);
+	flash->addr_len = SPI_FLASH_4B_ADDR_LEN;
+}
+#endif
+
 #ifdef CONFIG_SF_DUAL_FLASH
 static void spi_flash_dual(struct spi_flash *flash, u32 *addr)
 {
@@ -271,14 +343,14 @@ static int spi_flash_wait_till_ready(struct spi_flash *flash,
 	return -ETIMEDOUT;
 }
 
-int spi_flash_write_common(struct spi_flash *flash, const u8 *cmd,
-		size_t cmd_len, const void *buf, size_t buf_len)
+int spi_flash_write_common(struct spi_flash *flash,
+			   const struct spi_flash_command *cmd)
 {
 	struct spi_slave *spi = flash->spi;
 	unsigned long timeout = SPI_FLASH_PROG_TIMEOUT;
 	int ret;
 
-	if (buf == NULL)
+	if (cmd->tx_data == NULL)
 		timeout = SPI_FLASH_PAGE_ERASE_TIMEOUT;
 
 	ret = spi_claim_bus(spi);
@@ -293,7 +365,7 @@ int spi_flash_write_common(struct spi_flash *flash, const u8 *cmd,
 		return ret;
 	}
 
-	ret = spi_flash_cmd_write(spi, cmd, cmd_len, buf, buf_len);
+	ret = spi_flash_cmd_write(flash, cmd);
 	if (ret < 0) {
 		debug("SF: write cmd failed\n");
 		return ret;
@@ -314,8 +386,8 @@ int spi_flash_write_common(struct spi_flash *flash, const u8 *cmd,
 
 int spi_flash_cmd_erase_ops(struct spi_flash *flash, u32 offset, size_t len)
 {
+	struct spi_flash_command cmd;
 	u32 erase_size, erase_addr;
-	u8 cmd[SPI_FLASH_CMD_LEN];
 	int ret = -1;
 
 	erase_size = flash->erase_size;
@@ -332,7 +404,8 @@ int spi_flash_cmd_erase_ops(struct spi_flash *flash, u32 offset, size_t len)
 		}
 	}
 
-	cmd[0] = flash->erase_cmd;
+	spi_flash_command_init(&cmd, flash->erase_cmd, flash->addr_len,
+			       SPI_FCMD_ERASE);
 	while (len) {
 		erase_addr = offset;
 
@@ -345,12 +418,15 @@ int spi_flash_cmd_erase_ops(struct spi_flash *flash, u32 offset, size_t len)
 		if (ret < 0)
 			return ret;
 #endif
-		spi_flash_addr(erase_addr, cmd);
+		cmd.addr = erase_addr;
 
-		debug("SF: erase %2x %2x %2x %2x (%x)\n", cmd[0], cmd[1],
-		      cmd[2], cmd[3], erase_addr);
+		debug("SF: erase %2x %2x %2x %2x (%x)\n", cmd.inst,
+		      (cmd.addr >> 16) & 0xff,
+		      (cmd.addr >>  8) & 0xff,
+		      (cmd.addr >>  0) & 0xff,
+		      erase_addr);
 
-		ret = spi_flash_write_common(flash, cmd, sizeof(cmd), NULL, 0);
+		ret = spi_flash_write_common(flash, &cmd);
 		if (ret < 0) {
 			debug("SF: erase failed\n");
 			break;
@@ -371,10 +447,10 @@ int spi_flash_cmd_write_ops(struct spi_flash *flash, u32 offset,
 		size_t len, const void *buf)
 {
 	struct spi_slave *spi = flash->spi;
+	struct spi_flash_command cmd;
 	unsigned long byte_addr, page_size;
 	u32 write_addr;
 	size_t chunk_len, actual;
-	u8 cmd[SPI_FLASH_CMD_LEN];
 	int ret = -1;
 
 	page_size = flash->page_size;
@@ -387,7 +463,9 @@ int spi_flash_cmd_write_ops(struct spi_flash *flash, u32 offset,
 		}
 	}
 
-	cmd[0] = flash->write_cmd;
+	spi_flash_command_init(&cmd, flash->write_cmd, flash->addr_len,
+			       SPI_FCMD_WRITE);
+	cmd.proto = flash->write_proto;
 	for (actual = 0; actual < len; actual += chunk_len) {
 		write_addr = offset;
 
@@ -407,13 +485,18 @@ int spi_flash_cmd_write_ops(struct spi_flash *flash, u32 offset,
 			chunk_len = min(chunk_len,
 					spi->max_write_size - sizeof(cmd));
 
-		spi_flash_addr(write_addr, cmd);
+		cmd.addr = write_addr;
+		cmd.data_len = chunk_len;
+		cmd.tx_data = buf + actual;
 
 		debug("SF: 0x%p => cmd = { 0x%02x 0x%02x%02x%02x } chunk_len = %zu\n",
-		      buf + actual, cmd[0], cmd[1], cmd[2], cmd[3], chunk_len);
+		      buf + actual, cmd.inst,
+		      (cmd.addr >> 16) & 0xff,
+		      (cmd.addr >>  8) & 0xff,
+		      (cmd.addr >>  0) & 0xff,
+		      chunk_len);
 
-		ret = spi_flash_write_common(flash, cmd, sizeof(cmd),
-					buf + actual, chunk_len);
+		ret = spi_flash_write_common(flash, &cmd);
 		if (ret < 0) {
 			debug("SF: write failed\n");
 			break;
@@ -429,8 +512,8 @@ int spi_flash_cmd_write_ops(struct spi_flash *flash, u32 offset,
 	return ret;
 }
 
-int spi_flash_read_common(struct spi_flash *flash, const u8 *cmd,
-		size_t cmd_len, void *data, size_t data_len)
+int spi_flash_read_common(struct spi_flash *flash,
+			  const struct spi_flash_command *cmd)
 {
 	struct spi_slave *spi = flash->spi;
 	int ret;
@@ -441,7 +524,7 @@ int spi_flash_read_common(struct spi_flash *flash, const u8 *cmd,
 		return ret;
 	}
 
-	ret = spi_flash_cmd_read(spi, cmd, cmd_len, data, data_len);
+	ret = spi_flash_cmd_read(flash, cmd);
 	if (ret < 0) {
 		debug("SF: read cmd failed\n");
 		return ret;
@@ -469,9 +552,12 @@ int spi_flash_cmd_read_ops(struct spi_flash *flash, u32 offset,
 		size_t len, void *data)
 {
 	struct spi_slave *spi = flash->spi;
-	u8 *cmd, cmdsz;
-	u32 remain_len, read_len, read_addr;
+	struct spi_flash_command cmd;
+	u32 read_len, read_addr;
+#ifdef CONFIG_SPI_FLASH_BAR
+	u32 remain_len;
 	int bank_sel = 0;
+#endif
 	int ret = -1;
 
 	/* Handle memory-mapped SPI */
@@ -488,14 +574,10 @@ int spi_flash_cmd_read_ops(struct spi_flash *flash, u32 offset,
 		return 0;
 	}
 
-	cmdsz = SPI_FLASH_CMD_LEN + flash->dummy_byte;
-	cmd = calloc(1, cmdsz);
-	if (!cmd) {
-		debug("SF: Failed to allocate cmd\n");
-		return -ENOMEM;
-	}
-
-	cmd[0] = flash->read_cmd;
+	spi_flash_command_init(&cmd, flash->read_cmd, flash->addr_len,
+			       SPI_FCMD_READ);
+	cmd.proto = flash->read_proto;
+	cmd.num_wait_states = flash->dummy_byte * 8;
 	while (len) {
 		read_addr = offset;
 
@@ -508,20 +590,23 @@ int spi_flash_cmd_read_ops(struct spi_flash *flash, u32 offset,
 		if (ret < 0)
 			return ret;
 		bank_sel = flash->bank_curr;
-#endif
 		remain_len = ((SPI_FLASH_16MB_BOUN << flash->shift) *
 				(bank_sel + 1)) - offset;
 		if (len < remain_len)
 			read_len = len;
 		else
 			read_len = remain_len;
+#else
+		read_len = len;
+#endif
 
 		if (spi->max_read_size)
 			read_len = min(read_len, spi->max_read_size);
 
-		spi_flash_addr(read_addr, cmd);
-
-		ret = spi_flash_read_common(flash, cmd, cmdsz, data, read_len);
+		cmd.addr = read_addr;
+		cmd.data_len = read_len;
+		cmd.rx_data = data;
+		ret = spi_flash_read_common(flash, &cmd);
 		if (ret < 0) {
 			debug("SF: read failed\n");
 			break;
@@ -536,30 +621,33 @@ int spi_flash_cmd_read_ops(struct spi_flash *flash, u32 offset,
 	ret = clean_bar(flash);
 #endif
 
-	free(cmd);
 	return ret;
 }
 
 #ifdef CONFIG_SPI_FLASH_SST
 static int sst_byte_write(struct spi_flash *flash, u32 offset, const void *buf)
 {
-	struct spi_slave *spi = flash->spi;
+	struct spi_flash_command cmd;
 	int ret;
-	u8 cmd[4] = {
-		CMD_SST_BP,
-		offset >> 16,
-		offset >> 8,
-		offset,
-	};
+	u8 sr = 0xFFu;
 
+	spi_flash_command_init(&cmd, CMD_SST_BP, flash->addr_len,
+			       SPI_FCMD_WRITE);
+	cmd.addr = offset;
+	cmd.data_len = 1;
+	cmd.tx_data = buf;
+
+#ifdef DEBUG
+	read_sr(flash, &sr);
+#endif
 	debug("BP[%02x]: 0x%p => cmd = { 0x%02x 0x%06x }\n",
-	      spi_w8r8(spi, CMD_READ_STATUS), buf, cmd[0], offset);
+	      sr, buf, cmd.inst, offset);
 
 	ret = spi_flash_cmd_write_enable(flash);
 	if (ret)
 		return ret;
 
-	ret = spi_flash_cmd_write(spi, cmd, sizeof(cmd), buf, 1);
+	ret = spi_flash_cmd_write(flash, &cmd);
 	if (ret)
 		return ret;
 
@@ -570,9 +658,10 @@ int sst_write_wp(struct spi_flash *flash, u32 offset, size_t len,
 		const void *buf)
 {
 	struct spi_slave *spi = flash->spi;
-	size_t actual, cmd_len;
+	struct spi_flash_command cmd;
+	size_t actual;
 	int ret;
-	u8 cmd[4];
+	u8 sr = 0xFFu;
 
 	ret = spi_claim_bus(spi);
 	if (ret) {
@@ -593,19 +682,20 @@ int sst_write_wp(struct spi_flash *flash, u32 offset, size_t len,
 	if (ret)
 		goto done;
 
-	cmd_len = 4;
-	cmd[0] = CMD_SST_AAI_WP;
-	cmd[1] = offset >> 16;
-	cmd[2] = offset >> 8;
-	cmd[3] = offset;
+	spi_flash_command_init(&cmd, CMD_SST_AAI_WP, flash->addr_len,
+			       SPI_FCMD_WRITE);
+	cmd.addr = offset;
+	cmd.data_len = 2;
 
 	for (; actual < len - 1; actual += 2) {
+#ifdef DEBUG
+		read_sr(flash, &sr);
+#endif
 		debug("WP[%02x]: 0x%p => cmd = { 0x%02x 0x%06x }\n",
-		      spi_w8r8(spi, CMD_READ_STATUS), buf + actual,
-		      cmd[0], offset);
+		      sr, buf + actual, cmd.inst, offset);
 
-		ret = spi_flash_cmd_write(spi, cmd, cmd_len,
-					buf + actual, 2);
+		cmd.tx_data = buf + actual;
+		ret = spi_flash_cmd_write(flash, &cmd);
 		if (ret) {
 			debug("SF: sst word program failed\n");
 			break;
@@ -615,7 +705,7 @@ int sst_write_wp(struct spi_flash *flash, u32 offset, size_t len,
 		if (ret)
 			break;
 
-		cmd_len = 1;
+		cmd.addr_len = 0;
 		offset += 2;
 	}
 
@@ -905,7 +995,7 @@ static const struct spi_flash_info *spi_flash_read_id(struct spi_flash *flash)
 	u8				id[SPI_FLASH_MAX_ID_LEN];
 	const struct spi_flash_info	*info;
 
-	tmp = spi_flash_cmd(flash->spi, CMD_READ_ID, id, SPI_FLASH_MAX_ID_LEN);
+	tmp = spi_flash_cmd(flash, CMD_READ_ID, id, SPI_FLASH_MAX_ID_LEN);
 	if (tmp < 0) {
 		printf("SF: error %d reading JEDEC ID\n", tmp);
 		return ERR_PTR(tmp);
@@ -977,6 +1067,7 @@ int spi_flash_scan(struct spi_flash *flash)
 {
 	struct spi_slave *spi = flash->spi;
 	const struct spi_flash_info *info = NULL;
+	bool above_16MB;
 	int ret;
 
 	info = spi_flash_read_id(flash);
@@ -1072,24 +1163,30 @@ int spi_flash_scan(struct spi_flash *flash)
 
 	/* Look for read commands */
 	flash->read_cmd = CMD_READ_ARRAY_FAST;
-	if (spi->mode & SPI_RX_SLOW)
+	flash->read_proto = SPI_FPROTO_1_1_1;
+	if (spi->mode & SPI_RX_SLOW) {
 		flash->read_cmd = CMD_READ_ARRAY_SLOW;
-	else if (spi->mode & SPI_RX_QUAD && info->flags & RD_QUAD)
+	} else if (spi->mode & SPI_RX_QUAD && info->flags & RD_QUAD) {
 		flash->read_cmd = CMD_READ_QUAD_OUTPUT_FAST;
-	else if (spi->mode & SPI_RX_DUAL && info->flags & RD_DUAL)
+		flash->read_proto = SPI_FPROTO_1_1_4;
+	} else if (spi->mode & SPI_RX_DUAL && info->flags & RD_DUAL) {
 		flash->read_cmd = CMD_READ_DUAL_OUTPUT_FAST;
+		flash->read_proto = SPI_FPROTO_1_1_2;
+	}
 
 	/* Look for write commands */
-	if (info->flags & WR_QPP && spi->mode & SPI_TX_QUAD)
-		flash->write_cmd = CMD_QUAD_PAGE_PROGRAM;
-	else
+	if (info->flags & WR_QPP && spi->mode & SPI_TX_QUAD) {
+		flash->write_cmd = CMD_PAGE_PROGRAM_1_1_4;
+		flash->write_proto = SPI_FPROTO_1_1_4;
+	} else {
 		/* Go for default supported write cmd */
 		flash->write_cmd = CMD_PAGE_PROGRAM;
+		flash->write_proto = SPI_FPROTO_1_1_1;
+	}
 
 	/* Set the quad enable bit - only for quad commands */
-	if ((flash->read_cmd == CMD_READ_QUAD_OUTPUT_FAST) ||
-	    (flash->read_cmd == CMD_READ_QUAD_IO_FAST) ||
-	    (flash->write_cmd == CMD_QUAD_PAGE_PROGRAM)) {
+	if (spi_flash_protocol_get_data_nbits(flash->read_proto) == 4 ||
+	    spi_flash_protocol_get_data_nbits(flash->write_proto) == 4) {
 		ret = set_quad_mode(flash, info);
 		if (ret) {
 			debug("SF: Fail to set QEB for %02x\n",
@@ -1122,6 +1219,29 @@ int spi_flash_scan(struct spi_flash *flash)
 		flash->flags |= SNOR_F_USE_FSR;
 #endif
 
+	/* Set the address length */
+	flash->addr_len = SPI_FLASH_3B_ADDR_LEN;
+
+	above_16MB = ((flash->dual_flash == SF_SINGLE_FLASH) &&
+		      (flash->size > SPI_FLASH_16MB_BOUN)) ||
+		     ((flash->dual_flash > SF_SINGLE_FLASH) &&
+		      (flash->size > SPI_FLASH_16MB_BOUN << 1));
+
+	/*
+	 * replace the selected 3-byte address op codes with the associated
+	 * 4-byte address op codes, if needed (flash->size > 16 MiB)
+	 */
+#ifdef CONFIG_SPI_FLASH_4BAIS
+	if (above_16MB) {
+		if (info->flags & NO_4BAIS) {
+			puts("SF: Warning - Only lower 16MiB accessible,");
+			puts(" 4-byte address instruction set not supported\n");
+		} else {
+			spi_flash_set_4byte_addr_opcodes(flash, info);
+		}
+	}
+#endif
+
 	/* Configure the BAR - discover bank cmds and read current bank */
 #ifdef CONFIG_SPI_FLASH_BAR
 	ret = read_bar(flash, info);
@@ -1147,13 +1267,11 @@ int spi_flash_scan(struct spi_flash *flash)
 	puts("\n");
 #endif
 
-#ifndef CONFIG_SPI_FLASH_BAR
-	if (((flash->dual_flash == SF_SINGLE_FLASH) &&
-	     (flash->size > SPI_FLASH_16MB_BOUN)) ||
-	     ((flash->dual_flash > SF_SINGLE_FLASH) &&
-	     (flash->size > SPI_FLASH_16MB_BOUN << 1))) {
+#if !defined(CONFIG_SPI_FLASH_BAR) && !defined(CONFIG_SPI_FLASH_4BAIS)
+	if (above_16MB) {
 		puts("SF: Warning - Only lower 16MiB accessible,");
-		puts(" Full access #define CONFIG_SPI_FLASH_BAR\n");
+		puts(" Full access #define CONFIG_SPI_FLASH_BAR");
+		puts(" or CONFIG_SPI_FLASH_4BAIS\n");
 	}
 #endif
 
diff --git a/drivers/mtd/spi/spi_flash_ids.c b/drivers/mtd/spi/spi_flash_ids.c
index b789219..8468db4 100644
--- a/drivers/mtd/spi/spi_flash_ids.c
+++ b/drivers/mtd/spi/spi_flash_ids.c
@@ -69,6 +69,7 @@ const struct spi_flash_info spi_flash_ids[] = {
 #ifdef CONFIG_SPI_FLASH_ISSI		/* ISSI */
 	{"is25lq040b",	   INFO(0x9d4013, 0x0, 64 * 1024,    8, 0)  },
 	{"is25lp032",	   INFO(0x9d6016, 0x0, 64 * 1024,    64, 0) },
+	{"is25wp032",	   INFO(0x9d7016, 0x0, 64 * 1024,    64, 0) },
 	{"is25lp064",	   INFO(0x9d6017, 0x0, 64 * 1024,   128, 0) },
 	{"is25lp128",	   INFO(0x9d6018, 0x0, 64 * 1024,   256, 0) },
 	{"is25lp256",	   INFO(0x9d6019, 0x0, 64 * 1024,   512, 0) },
@@ -83,6 +84,7 @@ const struct spi_flash_info spi_flash_ids[] = {
 	{"mx25l12805",	   INFO(0xc22018, 0x0, 64 * 1024,   256, RD_FULL | WR_QPP) },
 	{"mx25l25635f",	   INFO(0xc22019, 0x0, 64 * 1024,   512, RD_FULL | WR_QPP) },
 	{"mx25l51235f",	   INFO(0xc2201a, 0x0, 64 * 1024,  1024, RD_FULL | WR_QPP) },
+	{"mx25u3235f",     INFO(0xc22536, 0x0, 64 * 1024,    64, RD_FULL | WR_QPP) },
 	{"mx25u6435f",	   INFO(0xc22537, 0x0, 64 * 1024,   128, RD_FULL | WR_QPP) },
 	{"mx25l12855e",	   INFO(0xc22618, 0x0, 64 * 1024,   256, RD_FULL | WR_QPP) },
 	{"mx25u1635e",     INFO(0xc22535, 0x0, 64 * 1024,  32, SECT_4K) },
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index de1947c..187a863 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -171,6 +171,7 @@ config MVPP2
 	bool "Marvell Armada 375/7K/8K network interface support"
 	depends on ARMADA_375 || ARMADA_8K
 	select PHYLIB
+	select MVMDIO
 	help
 	  This driver supports the network interface units in the
 	  Marvell ARMADA 375, 7K and 8K SoCs.
@@ -192,6 +193,36 @@ config MACB_ZYNQ
 	  The Cadence MACB ethernet interface was used on Zynq platform.
 	  Say Y to enable support for the MACB/GEM in Zynq chip.
 
+config NET_OCTEONTX
+	bool "OcteonTX Ethernet support"
+	depends on ARCH_OCTEONTX
+	help
+	  You must select Y to enable network device support for
+	  OcteonTX SoCs. If unsure, say n
+
+config NET_OCTEONTX2
+	bool "OcteonTX2 Ethernet support"
+	depends on ARCH_OCTEONTX2
+	select OCTEONTX2_CGX_INTF
+	help
+	  You must select Y to enable network device support for
+	  OcteonTX2 SoCs. If unsure, say n
+
+config OCTEONTX_SMI
+	bool "OcteonTX SMI Device support"
+	depends on ARCH_OCTEONTX || ARCH_OCTEONTX2
+	help
+	  You must select Y to enable SMI controller support for
+	  OcteonTX or OcteonTX2 SoCs. If unsure, say n
+
+config OCTEONTX2_CGX_INTF
+	bool "OcteonTX2 CGX ATF interface support"
+	depends on ARCH_OCTEONTX2
+	default y if ARCH_OCTEONTX2
+	help
+	  You must select Y to enable CGX ATF interface support for
+	  OcteonTX2 SoCs. If unsure, say n
+
 config PCH_GBE
 	bool "Intel Platform Controller Hub EG20T GMAC driver"
 	depends on DM_ETH && DM_PCI
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 4a16c62..883688b 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -59,6 +59,10 @@ obj-$(CONFIG_SMC91111) += smc91111.o
 obj-$(CONFIG_SMC911X) += smc911x.o
 obj-$(CONFIG_DRIVER_TI_EMAC) += davinci_emac.o
 obj-$(CONFIG_TSEC_ENET) += tsec.o fsl_mdio.o
+obj-$(CONFIG_NET_OCTEONTX) += octeontx/
+obj-$(CONFIG_NET_OCTEONTX2) += octeontx2/
+obj-$(CONFIG_OCTEONTX_SMI) += octeontx/octeontx_smi.o
+obj-$(CONFIG_OCTEONTX2_CGX_INTF) += octeontx2/cgx_intf.o
 obj-$(CONFIG_DRIVER_TI_CPSW) += cpsw.o cpsw-common.o
 obj-$(CONFIG_FMAN_ENET) += fsl_mdio.o
 obj-$(CONFIG_TSI108_ETH) += tsi108_eth.o
diff --git a/drivers/net/e1000.c b/drivers/net/e1000.c
index 5cc54ef..b773a9e 100644
--- a/drivers/net/e1000.c
+++ b/drivers/net/e1000.c
@@ -4571,11 +4571,21 @@ e1000_get_phy_cfg_done(struct e1000_hw *hw)
 			mdelay(1);
 			timeout--;
 		}
+
 		if (!timeout) {
 			DEBUGOUT("MNG configuration cycle has not "
 					"completed.\n");
-			return -E1000_ERR_RESET;
+			/*
+			 * Temporarely WA for PHY HW reset timeout on
+			 * MACCHIATOBin board.
+			 * The reason for the timeout is unknown, adding
+			 * delays before and after PCIe reset line release
+			 * did not help to solve the issue.
+			 *
+			 * return -E1000_ERR_RESET;
+			 */
 		}
+
 		break;
 	}
 
@@ -5139,7 +5149,7 @@ fill_rx(struct e1000_hw *hw)
 	rd = rx_base + rx_tail;
 	rx_tail = (rx_tail + 1) % 8;
 	memset(rd, 0, 16);
-	rd->buffer_addr = cpu_to_le64((unsigned long)packet);
+	rd->buffer_addr = cpu_to_le64((uintptr_t)packet);
 
 	/*
 	 * Make sure there are no stale data in WB over this area, which
@@ -5228,7 +5238,6 @@ e1000_configure_tx(struct e1000_hw *hw)
 		E1000_WRITE_REG(hw, TARC1, tarc);
 	}
 
-
 	e1000_config_collision_dist(hw);
 	/* Setup Transmit Descriptor Settings for eop descriptor */
 	hw->txd_cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_IFCS;
@@ -5239,7 +5248,6 @@ e1000_configure_tx(struct e1000_hw *hw)
 	else
 		hw->txd_cmd |= E1000_TXD_CMD_RS;
 
-
 	if (hw->mac_type == e1000_igb) {
 		E1000_WRITE_REG(hw, TCTL_EXT, 0x42 << 10);
 
@@ -5249,11 +5257,7 @@ e1000_configure_tx(struct e1000_hw *hw)
 		mdelay(20);
 	}
 
-
-
 	E1000_WRITE_REG(hw, TCTL, tctl);
-
-
 }
 
 /**
@@ -5358,7 +5362,7 @@ _e1000_poll(struct e1000_hw *hw)
 
 	if (!(rd->status & E1000_RXD_STAT_DD))
 		return 0;
-	/* DEBUGOUT("recv: packet len=%d\n", rd->length); */
+	DEBUGOUT("recv: packet len=%d\n", rd->length);
 	/* Packet received, make sure the data are re-loaded from RAM. */
 	len = le16_to_cpu(rd->length);
 	invalidate_dcache_range((unsigned long)packet,
@@ -5504,6 +5508,8 @@ static int e1000_init_one(struct e1000_hw *hw, int cardnum, pci_dev_t devno,
 
 	/* Assign the passed-in values */
 #ifdef CONFIG_DM_ETH
+	size_t size;
+
 	hw->pdev = devno;
 #else
 	hw->pdev = devno;
@@ -5551,8 +5557,7 @@ static int e1000_init_one(struct e1000_hw *hw, int cardnum, pci_dev_t devno,
 	hw->eeprom_semaphore_present = true;
 #endif
 #ifdef CONFIG_DM_ETH
-	hw->hw_addr = dm_pci_map_bar(devno,	PCI_BASE_ADDRESS_0,
-						PCI_REGION_MEM);
+	hw->hw_addr = dm_pci_map_bar(devno, 0, &size, PCI_REGION_MEM);
 #else
 	hw->hw_addr = pci_map_bar(devno,	PCI_BASE_ADDRESS_0,
 						PCI_REGION_MEM);
@@ -5786,6 +5791,7 @@ static int do_e1000(cmd_tbl_t *cmdtp, int flag,
 		plat = dev_get_platdata(dev);
 		mac = plat->enetaddr;
 	}
+	hw = dev_get_priv(dev);
 #else
 	hw = e1000_find_card(cardnum);
 	if (hw)
diff --git a/drivers/net/e1000_spi.c b/drivers/net/e1000_spi.c
index cb5f93d..6f3a5a5 100644
--- a/drivers/net/e1000_spi.c
+++ b/drivers/net/e1000_spi.c
@@ -109,14 +109,14 @@ struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
 	}
 
 	/* TODO: Use max_hz somehow */
-	E1000_DBG(hw->nic, "EEPROM SPI access requested\n");
+	E1000_DBG(hw, "EEPROM SPI access requested\n");
 	return &hw->spi;
 }
 
 void spi_free_slave(struct spi_slave *spi)
 {
 	__maybe_unused struct e1000_hw *hw = e1000_hw_from_spi(spi);
-	E1000_DBG(hw->nic, "EEPROM SPI access released\n");
+	E1000_DBG(hw, "EEPROM SPI access released\n");
 }
 
 int spi_claim_bus(struct spi_slave *spi)
diff --git a/drivers/net/mvneta.c b/drivers/net/mvneta.c
index 83e3153..dfdd664 100644
--- a/drivers/net/mvneta.c
+++ b/drivers/net/mvneta.c
@@ -524,8 +524,17 @@ static void mvneta_rxq_desc_num_update(struct mvneta_port *pp,
 static struct mvneta_rx_desc *
 mvneta_rxq_next_desc_get(struct mvneta_rx_queue *rxq)
 {
+	struct mvneta_rx_desc *curr;
 	int rx_desc = rxq->next_desc_to_proc;
 
+	/* validate RX descriptor */
+	curr = rxq->descs + rx_desc;
+	if (curr->data_size == 0) {
+		/* do it to read real descriptor next time */
+		DSB;
+		return NULL;
+	}
+
 	rxq->next_desc_to_proc = MVNETA_QUEUE_NEXT_DESC(rxq, rx_desc);
 	return rxq->descs + rx_desc;
 }
@@ -1635,11 +1644,15 @@ static int mvneta_recv(struct udevice *dev, int flags, uchar **packetp)
 		 */
 		rx_desc = mvneta_rxq_next_desc_get(rxq);
 
+		if (!rx_desc)
+			return 0;
+
 		rx_status = rx_desc->status;
 		if (!mvneta_rxq_desc_is_first_last(rx_status) ||
 		    (rx_status & MVNETA_RXD_ERR_SUMMARY)) {
 			mvneta_rx_error(pp, rx_desc);
-			/* leave the descriptor untouched */
+			/* invalidate the descriptor */
+			rx_desc->data_size = 0;
 			return -EIO;
 		}
 
@@ -1659,6 +1672,8 @@ static int mvneta_recv(struct udevice *dev, int flags, uchar **packetp)
 		 * since only one was processed
 		 */
 		mvneta_rxq_desc_num_update(pp, rxq, 1, 1);
+		/* invalidate the descriptor */
+		rx_desc->data_size = 0;
 	}
 
 	return rx_bytes;
diff --git a/drivers/net/mvpp2.c b/drivers/net/mvpp2.c
index e3d31a5..18890db 100644
--- a/drivers/net/mvpp2.c
+++ b/drivers/net/mvpp2.c
@@ -32,6 +32,7 @@
 #include <linux/mbus.h>
 #include <asm-generic/gpio.h>
 #include <fdt_support.h>
+#include <mdio.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -75,8 +76,6 @@ do {									\
 #define MTU			1500
 #define RX_BUFFER_SIZE		(ALIGN(MTU + WRAP, ARCH_DMA_MINALIGN))
 
-#define MVPP2_SMI_TIMEOUT			10000
-
 /* RX Fifo Registers */
 #define MVPP2_RX_DATA_FIFO_SIZE_REG(port)	(0x00 + 4 * (port))
 #define MVPP2_RX_ATTR_FIFO_SIZE_REG(port)	(0x20 + 4 * (port))
@@ -426,8 +425,6 @@ do {									\
 #define      MVPP22_XLG_CTRL3_MACMODESELECT_10GMAC	(1 << 13)
 /* Port Mac Control4 */
 #define MVPP22_XLG_CTRL4_REG			0x184
-#define      MVPP22_XLG_FORWARD_802_3X_FC_EN	BIT(5)
-#define      MVPP22_XLG_FORWARD_PFC_EN		BIT(6)
 #define      MVPP22_XLG_MODE_DMA_1G		BIT(12)
 #define      MVPP22_XLG_EN_IDLE_CHECK_FOR_LINK	BIT(14)
 
@@ -503,23 +500,8 @@ do {									\
 #define MVPP2_QUEUE_NEXT_DESC(q, index) \
 	(((index) < (q)->last_desc) ? ((index) + 1) : 0)
 
-/* SMI: 0xc0054 -> offset 0x54 to lms_base */
-#define MVPP21_SMI				0x0054
 /* PP2.2: SMI: 0x12a200 -> offset 0x1200 to iface_base */
 #define MVPP22_SMI				0x1200
-#define     MVPP2_PHY_REG_MASK			0x1f
-/* SMI register fields */
-#define     MVPP2_SMI_DATA_OFFS			0	/* Data */
-#define     MVPP2_SMI_DATA_MASK			(0xffff << MVPP2_SMI_DATA_OFFS)
-#define     MVPP2_SMI_DEV_ADDR_OFFS		16	/* PHY device address */
-#define     MVPP2_SMI_REG_ADDR_OFFS		21	/* PHY device reg addr*/
-#define     MVPP2_SMI_OPCODE_OFFS		26	/* Write/Read opcode */
-#define     MVPP2_SMI_OPCODE_READ		(1 << MVPP2_SMI_OPCODE_OFFS)
-#define     MVPP2_SMI_READ_VALID		(1 << 27)	/* Read Valid */
-#define     MVPP2_SMI_BUSY			(1 << 28)	/* Busy */
-
-#define     MVPP2_PHY_ADDR_MASK			0x1f
-#define     MVPP2_PHY_REG_MASK			0x1f
 
 /* Additional PPv2.2 offsets */
 #define MVPP22_MPCS				0x007000
@@ -539,8 +521,9 @@ do {									\
 /* Net Complex */
 enum mv_netc_topology {
 	MV_NETC_GE_MAC2_SGMII		=	BIT(0),
-	MV_NETC_GE_MAC3_SGMII		=	BIT(1),
-	MV_NETC_GE_MAC3_RGMII		=	BIT(2),
+	MV_NETC_GE_MAC2_RGMII		=	BIT(1),
+	MV_NETC_GE_MAC3_SGMII		=	BIT(2),
+	MV_NETC_GE_MAC3_RGMII		=	BIT(3),
 };
 
 enum mv_netc_phase {
@@ -910,7 +893,6 @@ struct mvpp2 {
 	void __iomem *base;
 	void __iomem *lms_base;
 	void __iomem *iface_base;
-	void __iomem *mdio_base;
 
 	void __iomem *mpcs_base;
 	void __iomem *xpcs_base;
@@ -941,8 +923,6 @@ struct mvpp2 {
 	/* Maximum number of RXQs per port */
 	unsigned int max_port_rxqs;
 
-	struct mii_dev *bus;
-
 	int probe_done;
 	u8 num_ports;
 };
@@ -988,8 +968,8 @@ struct mvpp2_port {
 
 	struct phy_device *phy_dev;
 	phy_interface_t phy_interface;
-	int phy_node;
 	int phyaddr;
+	struct mii_dev *bus;
 #ifdef CONFIG_DM_GPIO
 	struct gpio_desc phy_reset_gpio;
 	struct gpio_desc phy_tx_disable_gpio;
@@ -1600,7 +1580,6 @@ static void mvpp2_prs_sram_ai_update(struct mvpp2_prs_entry *pe,
 	int ai_off = MVPP2_PRS_SRAM_AI_OFFS;
 
 	for (i = 0; i < MVPP2_PRS_SRAM_AI_CTRL_BITS; i++) {
-
 		if (!(mask & BIT(i)))
 			continue;
 
@@ -2650,7 +2629,8 @@ static int mvpp2_bm_pool_destroy(struct udevice *dev,
 
 	mvpp2_bm_bufs_free(dev, priv, bm_pool);
 	if (bm_pool->buf_num) {
-		dev_err(dev, "cannot free all buffers in pool %d\n", bm_pool->id);
+		dev_err(dev, "cannot free all buffers in pool %d\n",
+			bm_pool->id);
 		return 0;
 	}
 
@@ -2804,7 +2784,6 @@ static int mvpp2_bm_bufs_add(struct mvpp2_port *port,
 		mvpp2_bm_pool_put(port, bm_pool->id,
 				  (dma_addr_t)buffer_loc.rx_buffer[i],
 				  (unsigned long)buffer_loc.rx_buffer[i]);
-
 	}
 
 	/* Update BM driver with number of buffers added to pool */
@@ -2898,6 +2877,10 @@ static void mvpp2_port_mii_set(struct mvpp2_port *port)
 	case PHY_INTERFACE_MODE_SGMII:
 		val |= MVPP2_GMAC_INBAND_AN_MASK;
 		break;
+	case PHY_INTERFACE_MODE_1000BASEX:
+	case PHY_INTERFACE_MODE_2500BASEX:
+		val &= ~MVPP2_GMAC_INBAND_AN_MASK;
+		break;
 	case PHY_INTERFACE_MODE_RGMII:
 	case PHY_INTERFACE_MODE_RGMII_ID:
 		val |= MVPP2_GMAC_PORT_RGMII_MASK;
@@ -2958,7 +2941,9 @@ static void mvpp2_port_loopback_set(struct mvpp2_port *port)
 	else
 		val &= ~MVPP2_GMAC_GMII_LB_EN_MASK;
 
-	if (port->phy_interface == PHY_INTERFACE_MODE_SGMII)
+	if (port->phy_interface == PHY_INTERFACE_MODE_SGMII ||
+	    port->phy_interface == PHY_INTERFACE_MODE_1000BASEX ||
+	    port->phy_interface == PHY_INTERFACE_MODE_2500BASEX)
 		val |= MVPP2_GMAC_PCS_LB_EN_MASK;
 	else
 		val &= ~MVPP2_GMAC_PCS_LB_EN_MASK;
@@ -3069,10 +3054,10 @@ static void gop_gmac_sgmii2_5_cfg(struct mvpp2_port *port)
 
 	val = readl(port->base + MVPP2_GMAC_CTRL_0_REG);
 	/*
-	 * Configure GIG MAC to 1000Base-X mode connected to a fiber
+	 * Configure GIG MAC to SGMII mode connected to a fiber
 	 * transceiver
 	 */
-	val |= MVPP2_GMAC_PORT_TYPE_MASK;
+	val &= ~MVPP2_GMAC_PORT_TYPE_MASK;
 	writel(val, port->base + MVPP2_GMAC_CTRL_0_REG);
 
 	/* configure AN 0x9268 */
@@ -3124,6 +3109,89 @@ static void gop_gmac_sgmii_cfg(struct mvpp2_port *port)
 	writel(val, port->base + MVPP2_GMAC_AUTONEG_CONFIG);
 }
 
+static void gop_gmac_2500basex_cfg(struct mvpp2_port *port)
+{
+	u32 val, thresh;
+
+	/*
+	 * Configure minimal level of the Tx FIFO before the lower part
+	 * starts to read a packet
+	 */
+	thresh = MVPP2_SGMII2_5_TX_FIFO_MIN_TH;
+	val = readl(port->base + MVPP2_GMAC_PORT_FIFO_CFG_1_REG);
+	val &= ~MVPP2_GMAC_TX_FIFO_MIN_TH_ALL_MASK;
+	val |= MVPP2_GMAC_TX_FIFO_MIN_TH_MASK(thresh);
+	writel(val, port->base + MVPP2_GMAC_PORT_FIFO_CFG_1_REG);
+
+	/* Disable bypass of sync module */
+	val = readl(port->base + MVPP2_GMAC_CTRL_4_REG);
+	val |= MVPP2_GMAC_CTRL4_SYNC_BYPASS_MASK;
+	/* configure DP clock select according to mode */
+	val |= MVPP2_GMAC_CTRL4_DP_CLK_SEL_MASK;
+	/* configure QSGMII bypass according to mode */
+	val |= MVPP2_GMAC_CTRL4_QSGMII_BYPASS_ACTIVE_MASK;
+	writel(val, port->base + MVPP2_GMAC_CTRL_4_REG);
+
+	val = readl(port->base + MVPP2_GMAC_CTRL_0_REG);
+	/*
+	 * Configure GIG MAC to 2500Base-X mode connected to a fiber
+	 * transceiver
+	 */
+	val |= MVPP2_GMAC_PORT_TYPE_MASK;
+	writel(val, port->base + MVPP2_GMAC_CTRL_0_REG);
+
+	/* In 2500BaseX mode, we can't negotiate speed
+	 * and we do not want InBand autoneg
+	 * bypass enabled (link interrupt storm risk
+	 * otherwise).
+	 */
+	val = MVPP2_GMAC_EN_PCS_AN |
+		MVPP2_GMAC_CONFIG_GMII_SPEED  |
+		MVPP2_GMAC_CONFIG_FULL_DUPLEX |
+		MVPP2_GMAC_CHOOSE_SAMPLE_TX_CONFIG;
+	writel(val, port->base + MVPP2_GMAC_AUTONEG_CONFIG);
+}
+
+static void gop_gmac_1000basex_cfg(struct mvpp2_port *port)
+{
+	u32 val, thresh;
+
+	/*
+	 * Configure minimal level of the Tx FIFO before the lower part
+	 * starts to read a packet
+	 */
+	thresh = MVPP2_SGMII_TX_FIFO_MIN_TH;
+	val = readl(port->base + MVPP2_GMAC_PORT_FIFO_CFG_1_REG);
+	val &= ~MVPP2_GMAC_TX_FIFO_MIN_TH_ALL_MASK;
+	val |= MVPP2_GMAC_TX_FIFO_MIN_TH_MASK(thresh);
+	writel(val, port->base + MVPP2_GMAC_PORT_FIFO_CFG_1_REG);
+
+	/* Disable bypass of sync module */
+	val = readl(port->base + MVPP2_GMAC_CTRL_4_REG);
+	val |= MVPP2_GMAC_CTRL4_SYNC_BYPASS_MASK;
+	/* configure DP clock select according to mode */
+	val &= ~MVPP2_GMAC_CTRL4_DP_CLK_SEL_MASK;
+	/* configure QSGMII bypass according to mode */
+	val |= MVPP2_GMAC_CTRL4_QSGMII_BYPASS_ACTIVE_MASK;
+	writel(val, port->base + MVPP2_GMAC_CTRL_4_REG);
+
+	val = readl(port->base + MVPP2_GMAC_CTRL_0_REG);
+	/* configure GIG MAC to 1000BASEX mode */
+	val |= MVPP2_GMAC_PORT_TYPE_MASK;
+	writel(val, port->base + MVPP2_GMAC_CTRL_0_REG);
+
+	/* In 1000BaseX mode, we can't negotiate speed (it's
+	 * only 1000), and we do not want InBand autoneg
+	 * bypass enabled (link interrupt storm risk
+	 * otherwise).
+	 */
+	val = MVPP2_GMAC_EN_PCS_AN |
+		MVPP2_GMAC_CONFIG_GMII_SPEED  |
+		MVPP2_GMAC_CONFIG_FULL_DUPLEX |
+		MVPP2_GMAC_CHOOSE_SAMPLE_TX_CONFIG;
+	writel(val, port->base + MVPP2_GMAC_AUTONEG_CONFIG);
+}
+
 static void gop_gmac_rgmii_cfg(struct mvpp2_port *port)
 {
 	u32 val, thresh;
@@ -3175,6 +3243,12 @@ static int gop_gmac_mode_cfg(struct mvpp2_port *port)
 			gop_gmac_sgmii_cfg(port);
 		break;
 
+	case PHY_INTERFACE_MODE_1000BASEX:
+		gop_gmac_1000basex_cfg(port);
+
+	case PHY_INTERFACE_MODE_2500BASEX:
+		gop_gmac_2500basex_cfg(port);
+
 	case PHY_INTERFACE_MODE_RGMII:
 	case PHY_INTERFACE_MODE_RGMII_ID:
 		gop_gmac_rgmii_cfg(port);
@@ -3227,56 +3301,31 @@ static int gop_gpcs_reset(struct mvpp2_port *port, int reset)
 	return 0;
 }
 
-/* Set the internal mux's to the required PCS in the PI */
-static int gop_xpcs_mode(struct mvpp2_port *port, int num_of_lanes)
-{
-	u32 val;
-	int lane;
-
-	switch (num_of_lanes) {
-	case 1:
-		lane = 0;
-		break;
-	case 2:
-		lane = 1;
-		break;
-	case 4:
-		lane = 2;
-		break;
-	default:
-		return -1;
-	}
-
-	/* configure XG MAC mode */
-	val = readl(port->priv->xpcs_base + MVPP22_XPCS_GLOBAL_CFG_0_REG);
-	val &= ~MVPP22_XPCS_PCSMODE_MASK;
-	val &= ~MVPP22_XPCS_LANEACTIVE_MASK;
-	val |= (2 * lane) << MVPP22_XPCS_LANEACTIVE_OFFS;
-	writel(val, port->priv->xpcs_base + MVPP22_XPCS_GLOBAL_CFG_0_REG);
-
-	return 0;
-}
-
 static int gop_mpcs_mode(struct mvpp2_port *port)
 {
 	u32 val;
 
 	/* configure PCS40G COMMON CONTROL */
-	val = readl(port->priv->mpcs_base + PCS40G_COMMON_CONTROL);
+	val = readl(port->priv->mpcs_base + port->gop_id * MVPP22_PORT_OFFSET +
+		    PCS40G_COMMON_CONTROL);
 	val &= ~FORWARD_ERROR_CORRECTION_MASK;
-	writel(val, port->priv->mpcs_base + PCS40G_COMMON_CONTROL);
+	writel(val, port->priv->mpcs_base + port->gop_id * MVPP22_PORT_OFFSET +
+	       PCS40G_COMMON_CONTROL);
 
 	/* configure PCS CLOCK RESET */
-	val = readl(port->priv->mpcs_base + PCS_CLOCK_RESET);
+	val = readl(port->priv->mpcs_base + port->gop_id * MVPP22_PORT_OFFSET +
+		    PCS_CLOCK_RESET);
 	val &= ~CLK_DIVISION_RATIO_MASK;
 	val |= 1 << CLK_DIVISION_RATIO_OFFS;
-	writel(val, port->priv->mpcs_base + PCS_CLOCK_RESET);
+	writel(val, port->priv->mpcs_base + port->gop_id * MVPP22_PORT_OFFSET +
+	       PCS_CLOCK_RESET);
 
 	val &= ~CLK_DIV_PHASE_SET_MASK;
 	val |= MAC_CLK_RESET_MASK;
 	val |= RX_SD_CLK_RESET_MASK;
 	val |= TX_SD_CLK_RESET_MASK;
-	writel(val, port->priv->mpcs_base + PCS_CLOCK_RESET);
+	writel(val, port->priv->mpcs_base + port->gop_id * MVPP22_PORT_OFFSET +
+	       PCS_CLOCK_RESET);
 
 	return 0;
 }
@@ -3299,8 +3348,6 @@ static int gop_xlg_mac_mode_cfg(struct mvpp2_port *port, int num_of_act_lanes)
 	/* read - modify - write */
 	val = readl(port->base + MVPP22_XLG_CTRL4_REG);
 	val &= ~MVPP22_XLG_MODE_DMA_1G;
-	val |= MVPP22_XLG_FORWARD_PFC_EN;
-	val |= MVPP22_XLG_FORWARD_802_3X_FC_EN;
 	val &= ~MVPP22_XLG_EN_IDLE_CHECK_FOR_LINK;
 	writel(val, port->base + MVPP22_XLG_CTRL4_REG);
 
@@ -3319,22 +3366,6 @@ static int gop_xlg_mac_mode_cfg(struct mvpp2_port *port, int num_of_act_lanes)
 	return 0;
 }
 
-/* Set PCS to reset or exit from reset */
-static int gop_xpcs_reset(struct mvpp2_port *port, int reset)
-{
-	u32 val;
-
-	/* read - modify - write */
-	val = readl(port->priv->xpcs_base + MVPP22_XPCS_GLOBAL_CFG_0_REG);
-	if (reset)
-		val &= ~MVPP22_XPCS_PCSRESET;
-	else
-		val |= MVPP22_XPCS_PCSRESET;
-	writel(val, port->priv->xpcs_base + MVPP22_XPCS_GLOBAL_CFG_0_REG);
-
-	return 0;
-}
-
 /* Set the MAC to reset or exit from reset */
 static int gop_xlg_mac_reset(struct mvpp2_port *port, int reset)
 {
@@ -3389,6 +3420,8 @@ static int gop_port_init(struct mvpp2_port *port)
 		break;
 
 	case PHY_INTERFACE_MODE_SGMII:
+	case PHY_INTERFACE_MODE_1000BASEX:
+	case PHY_INTERFACE_MODE_2500BASEX:
 		/* configure PCS */
 		gop_gpcs_mode_cfg(port, 1);
 
@@ -3407,18 +3440,17 @@ static int gop_port_init(struct mvpp2_port *port)
 		num_of_act_lanes = 2;
 		mac_num = 0;
 		/* configure PCS */
-		gop_xpcs_mode(port, num_of_act_lanes);
 		gop_mpcs_mode(port);
 		/* configure MAC */
 		gop_xlg_mac_mode_cfg(port, num_of_act_lanes);
 
-		/* pcs unreset */
-		gop_xpcs_reset(port, 0);
-
 		/* mac unreset */
 		gop_xlg_mac_reset(port, 0);
 		break;
 
+	case PHY_INTERFACE_MODE_AP:
+		break;
+
 	default:
 		netdev_err(NULL, "%s: Requested port mode (%d) not supported\n",
 			   __func__, port->phy_interface);
@@ -3450,6 +3482,8 @@ static void gop_port_enable(struct mvpp2_port *port, int enable)
 	case PHY_INTERFACE_MODE_RGMII:
 	case PHY_INTERFACE_MODE_RGMII_ID:
 	case PHY_INTERFACE_MODE_SGMII:
+	case PHY_INTERFACE_MODE_1000BASEX:
+	case PHY_INTERFACE_MODE_2500BASEX:
 		if (enable)
 			mvpp2_port_enable(port);
 		else
@@ -3460,6 +3494,8 @@ static void gop_port_enable(struct mvpp2_port *port, int enable)
 		gop_xlg_mac_port_enable(port, enable);
 
 		break;
+	case PHY_INTERFACE_MODE_AP:
+		break;
 	default:
 		netdev_err(NULL, "%s: Wrong port mode (%d)\n", __func__,
 			   port->phy_interface);
@@ -3483,12 +3519,19 @@ static u32 mvpp2_netc_cfg_create(int gop_id, phy_interface_t phy_type)
 	u32 val = 0;
 
 	if (gop_id == 2) {
-		if (phy_type == PHY_INTERFACE_MODE_SGMII)
+		if (phy_type == PHY_INTERFACE_MODE_SGMII ||
+		    phy_type == PHY_INTERFACE_MODE_1000BASEX ||
+		    phy_type == PHY_INTERFACE_MODE_2500BASEX)
 			val |= MV_NETC_GE_MAC2_SGMII;
+		else if (phy_type == PHY_INTERFACE_MODE_RGMII ||
+			 phy_type == PHY_INTERFACE_MODE_RGMII_ID)
+			val |= MV_NETC_GE_MAC2_RGMII;
 	}
 
 	if (gop_id == 3) {
-		if (phy_type == PHY_INTERFACE_MODE_SGMII)
+		if (phy_type == PHY_INTERFACE_MODE_SGMII ||
+		    phy_type == PHY_INTERFACE_MODE_1000BASEX ||
+		    phy_type == PHY_INTERFACE_MODE_2500BASEX)
 			val |= MV_NETC_GE_MAC3_SGMII;
 		else if (phy_type == PHY_INTERFACE_MODE_RGMII ||
 			 phy_type == PHY_INTERFACE_MODE_RGMII_ID)
@@ -3676,7 +3719,7 @@ static int gop_netc_init(struct mvpp2 *priv, enum mv_netc_phase phase)
 
 	if (c & MV_NETC_GE_MAC2_SGMII)
 		gop_netc_mac_to_sgmii(priv, 2, phase);
-	else
+	else if (c & MV_NETC_GE_MAC2_RGMII)
 		gop_netc_mac_to_xgmii(priv, 2, phase);
 
 	if (c & MV_NETC_GE_MAC3_SGMII) {
@@ -4481,6 +4524,8 @@ static void mvpp2_start_dev(struct mvpp2_port *port)
 	case PHY_INTERFACE_MODE_RGMII:
 	case PHY_INTERFACE_MODE_RGMII_ID:
 	case PHY_INTERFACE_MODE_SGMII:
+	case PHY_INTERFACE_MODE_1000BASEX:
+	case PHY_INTERFACE_MODE_2500BASEX:
 		mvpp2_gmac_max_rx_size_set(port);
 	default:
 		break;
@@ -4508,17 +4553,38 @@ static void mvpp2_stop_dev(struct mvpp2_port *port)
 		gop_port_enable(port, 0);
 }
 
-static int mvpp2_phy_connect(struct udevice *dev, struct mvpp2_port *port)
+static void mvpp2_phy_connect(struct udevice *dev, struct mvpp2_port *port)
 {
 	struct phy_device *phy_dev;
 
 	if (!port->init || port->link == 0) {
-		phy_dev = phy_connect(port->priv->bus, port->phyaddr, dev,
+		phy_dev = phy_connect(port->bus, port->phyaddr, dev,
 				      port->phy_interface);
+
+		/* If the phy doesn't match with any existing u-boot drivers the
+		 * phy framework will connect it to generic one which
+		 * uid == 0xffffffff. In this case act as if the phy wouldn't be
+		 * declared in dts. Otherwise in case of 3310 (for which the
+		 * driver doesn't exist) the link will not be correctly
+		 * detected. Removing phy entry from dts in case of 3310 is not
+		 * an option because it is required for the phy_fw_down
+		 * procedure.
+		 */
+		if (phy_dev->drv->uid == 0xffffffff) {/* Generic phy */
+			netdev_warn(port->dev,
+				    "Marking phy as invalid, link will not be checked\n");
+			/* set phy_addr to invalid value */
+			port->phyaddr = PHY_MAX_ADDR;
+			mvpp2_egress_enable(port);
+			mvpp2_ingress_enable(port);
+
+			return;
+		}
+
 		port->phy_dev = phy_dev;
 		if (!phy_dev) {
 			netdev_err(port->dev, "cannot connect to phy\n");
-			return -ENODEV;
+			return;
 		}
 		phy_dev->supported &= PHY_GBIT_FEATURES;
 		phy_dev->advertising = phy_dev->supported;
@@ -4530,18 +4596,14 @@ static int mvpp2_phy_connect(struct udevice *dev, struct mvpp2_port *port)
 
 		phy_config(phy_dev);
 		phy_startup(phy_dev);
-		if (!phy_dev->link) {
+		if (!phy_dev->link)
 			printf("%s: No link\n", phy_dev->dev->name);
-			return -1;
-		}
-
-		port->init = 1;
+		else
+			port->init = 1;
 	} else {
 		mvpp2_egress_enable(port);
 		mvpp2_ingress_enable(port);
 	}
-
-	return 0;
 }
 
 static int mvpp2_open(struct udevice *dev, struct mvpp2_port *port)
@@ -4580,11 +4642,8 @@ static int mvpp2_open(struct udevice *dev, struct mvpp2_port *port)
 		return err;
 	}
 
-	if (port->phy_node) {
-		err = mvpp2_phy_connect(dev, port);
-		if (err < 0)
-			return err;
-
+	if (port->phyaddr < PHY_MAX_ADDR) {
+		mvpp2_phy_connect(dev, port);
 		mvpp2_link_event(port);
 	} else {
 		mvpp2_egress_enable(port);
@@ -4718,44 +4777,31 @@ static int phy_info_parse(struct udevice *dev, struct mvpp2_port *port)
 {
 	int port_node = dev_of_offset(dev);
 	const char *phy_mode_str;
-	int phy_node, mdio_off, cp_node;
+	int phy_node;
 	u32 id;
 	u32 phyaddr = 0;
 	int phy_mode = -1;
-	phys_addr_t mdio_addr;
+	int ret;
+	int fixed_link = 0;
 
 	phy_node = fdtdec_lookup_phandle(gd->fdt_blob, port_node, "phy");
+	fixed_link = fdt_subnode_offset(gd->fdt_blob, port_node, "fixed-link");
 
 	if (phy_node > 0) {
-		phyaddr = fdtdec_get_int(gd->fdt_blob, phy_node, "reg", 0);
-		if (phyaddr < 0) {
-			dev_err(&pdev->dev, "could not find phy address\n");
-			return -1;
+		if (fixed_link != -FDT_ERR_NOTFOUND) {
+			/* phy_addr is set to invalid value for fixed links */
+			phyaddr = PHY_MAX_ADDR;
+		} else {
+			phyaddr = fdtdec_get_int(gd->fdt_blob, phy_node,
+						 "reg", 0);
 		}
-		mdio_off = fdt_parent_offset(gd->fdt_blob, phy_node);
-
-		/* TODO: This WA for mdio issue. U-boot 2017 don't have
-		 * mdio driver and on MACHIATOBin board ports from CP1
-		 * connected to mdio on CP0.
-		 * WA is to get mdio address from phy handler parent
-		 * base address. WA should be removed after
-		 * mdio driver implementation.
-		 */
-		mdio_addr = fdtdec_get_uint(gd->fdt_blob,
-					    mdio_off, "reg", 0);
-
-		cp_node = fdt_parent_offset(gd->fdt_blob, mdio_off);
-		mdio_addr |= fdt_get_base_address((void *)gd->fdt_blob,
-						  cp_node);
 
-		port->priv->mdio_base = (void *)mdio_addr;
-
-		if (port->priv->mdio_base < 0) {
-			dev_err(&pdev->dev, "could not find mdio base address\n");
-			return -1;
-		}
+		ret = mdio_mii_bus_get_from_phy(phy_node, &port->bus);
+		if (ret)
+			return ret;
 	} else {
-		phy_node = 0;
+		/* phy_addr is set to invalid value */
+		phyaddr = PHY_MAX_ADDR;
 	}
 
 	phy_mode_str = fdt_getprop(gd->fdt_blob, port_node, "phy-mode", NULL);
@@ -4793,7 +4839,6 @@ static int phy_info_parse(struct udevice *dev, struct mvpp2_port *port)
 		port->first_rxq = port->id * rxq_number;
 	else
 		port->first_rxq = port->id * port->priv->max_port_rxqs;
-	port->phy_node = phy_node;
 	port->phy_interface = phy_mode;
 	port->phyaddr = phyaddr;
 
@@ -4892,10 +4937,12 @@ static void mvpp2_rx_fifo_init(struct mvpp2 *priv)
 			} else if (port == 1) {
 				mvpp2_write(priv,
 					    MVPP2_RX_DATA_FIFO_SIZE_REG(port),
-					    MVPP22_RX_FIFO_2_5GB_PORT_DATA_SIZE);
+					    MVPP22_RX_FIFO_2_5GB_PORT_DATA_SIZE
+					    );
 				mvpp2_write(priv,
 					    MVPP2_RX_ATTR_FIFO_SIZE_REG(port),
-					    MVPP22_RX_FIFO_2_5GB_PORT_ATTR_SIZE);
+					    MVPP22_RX_FIFO_2_5GB_PORT_ATTR_SIZE
+					    );
 			} else {
 				mvpp2_write(priv,
 					    MVPP2_RX_DATA_FIFO_SIZE_REG(port),
@@ -5003,9 +5050,9 @@ static int mvpp2_init(struct udevice *dev, struct mvpp2 *priv)
 		return -EINVAL;
 	}
 
-	if (priv->hw_version == MVPP22)
+	if (priv->hw_version == MVPP22) {
 		mvpp2_axi_init(priv);
-	else {
+	} else {
 		/* MBUS windows configuration */
 		dram_target_info = mvebu_mbus_dram_info();
 		if (dram_target_info)
@@ -5070,118 +5117,6 @@ static int mvpp2_init(struct udevice *dev, struct mvpp2 *priv)
 	return 0;
 }
 
-/* SMI / MDIO functions */
-
-static int smi_wait_ready(struct mvpp2 *priv)
-{
-	u32 timeout = MVPP2_SMI_TIMEOUT;
-	u32 smi_reg;
-
-	/* wait till the SMI is not busy */
-	do {
-		/* read smi register */
-		smi_reg = readl(priv->mdio_base);
-		if (timeout-- == 0) {
-			printf("Error: SMI busy timeout\n");
-			return -EFAULT;
-		}
-	} while (smi_reg & MVPP2_SMI_BUSY);
-
-	return 0;
-}
-
-/*
- * mpp2_mdio_read - miiphy_read callback function.
- *
- * Returns 16bit phy register value, or 0xffff on error
- */
-static int mpp2_mdio_read(struct mii_dev *bus, int addr, int devad, int reg)
-{
-	struct mvpp2 *priv = bus->priv;
-	u32 smi_reg;
-	u32 timeout;
-
-	/* check parameters */
-	if (addr > MVPP2_PHY_ADDR_MASK) {
-		printf("Error: Invalid PHY address %d\n", addr);
-		return -EFAULT;
-	}
-
-	if (reg > MVPP2_PHY_REG_MASK) {
-		printf("Err: Invalid register offset %d\n", reg);
-		return -EFAULT;
-	}
-
-	/* wait till the SMI is not busy */
-	if (smi_wait_ready(priv) < 0)
-		return -EFAULT;
-
-	/* fill the phy address and regiser offset and read opcode */
-	smi_reg = (addr << MVPP2_SMI_DEV_ADDR_OFFS)
-		| (reg << MVPP2_SMI_REG_ADDR_OFFS)
-		| MVPP2_SMI_OPCODE_READ;
-
-	/* write the smi register */
-	writel(smi_reg, priv->mdio_base);
-
-	/* wait till read value is ready */
-	timeout = MVPP2_SMI_TIMEOUT;
-
-	do {
-		/* read smi register */
-		smi_reg = readl(priv->mdio_base);
-		if (timeout-- == 0) {
-			printf("Err: SMI read ready timeout\n");
-			return -EFAULT;
-		}
-	} while (!(smi_reg & MVPP2_SMI_READ_VALID));
-
-	/* Wait for the data to update in the SMI register */
-	for (timeout = 0; timeout < MVPP2_SMI_TIMEOUT; timeout++)
-		;
-
-	return readl(priv->mdio_base) & MVPP2_SMI_DATA_MASK;
-}
-
-/*
- * mpp2_mdio_write - miiphy_write callback function.
- *
- * Returns 0 if write succeed, -EINVAL on bad parameters
- * -ETIME on timeout
- */
-static int mpp2_mdio_write(struct mii_dev *bus, int addr, int devad, int reg,
-			   u16 value)
-{
-	struct mvpp2 *priv = bus->priv;
-	u32 smi_reg;
-
-	/* check parameters */
-	if (addr > MVPP2_PHY_ADDR_MASK) {
-		printf("Error: Invalid PHY address %d\n", addr);
-		return -EFAULT;
-	}
-
-	if (reg > MVPP2_PHY_REG_MASK) {
-		printf("Err: Invalid register offset %d\n", reg);
-		return -EFAULT;
-	}
-
-	/* wait till the SMI is not busy */
-	if (smi_wait_ready(priv) < 0)
-		return -EFAULT;
-
-	/* fill the phy addr and reg offset and write opcode and data */
-	smi_reg = value << MVPP2_SMI_DATA_OFFS;
-	smi_reg |= (addr << MVPP2_SMI_DEV_ADDR_OFFS)
-		| (reg << MVPP2_SMI_REG_ADDR_OFFS);
-	smi_reg &= ~MVPP2_SMI_OPCODE_READ;
-
-	/* write the smi register */
-	writel(smi_reg, priv->mdio_base);
-
-	return 0;
-}
-
 static int mvpp2_recv(struct udevice *dev, int flags, uchar **packetp)
 {
 	struct mvpp2_port *port = dev_get_priv(dev);
@@ -5194,6 +5129,10 @@ static int mvpp2_recv(struct udevice *dev, int flags, uchar **packetp)
 	struct mvpp2_rx_queue *rxq;
 	u8 *data;
 
+	if (port->phyaddr < PHY_MAX_ADDR)
+		if (!port->phy_dev->link)
+			return 0;
+
 	/* Process RX packets */
 	rxq = port->rxqs[0];
 
@@ -5259,6 +5198,10 @@ static int mvpp2_send(struct udevice *dev, void *packet, int length)
 	int tx_done;
 	int timeout;
 
+	if (port->phyaddr < PHY_MAX_ADDR)
+		if (!port->phy_dev->link)
+			return 0;
+
 	txq = port->txqs[0];
 	aggr_txq = &port->priv->aggr_txqs[smp_processor_id()];
 
@@ -5321,6 +5264,8 @@ static int mvpp2_start(struct udevice *dev)
 	case PHY_INTERFACE_MODE_RGMII:
 	case PHY_INTERFACE_MODE_RGMII_ID:
 	case PHY_INTERFACE_MODE_SGMII:
+	case PHY_INTERFACE_MODE_1000BASEX:
+	case PHY_INTERFACE_MODE_2500BASEX:
 		mvpp2_port_power_up(port);
 	default:
 		break;
@@ -5351,7 +5296,6 @@ static int mvpp22_smi_phy_addr_cfg(struct mvpp2_port *port)
 static int mvpp2_base_probe(struct udevice *dev)
 {
 	struct mvpp2 *priv = dev_get_priv(dev);
-	struct mii_dev *bus;
 	void *bd_space;
 	u32 size = 0;
 	int i;
@@ -5410,15 +5354,11 @@ static int mvpp2_base_probe(struct udevice *dev)
 		priv->lms_base = (void *)devfdt_get_addr_index(dev, 1);
 		if (IS_ERR(priv->lms_base))
 			return PTR_ERR(priv->lms_base);
-
-		priv->mdio_base = priv->lms_base + MVPP21_SMI;
 	} else {
 		priv->iface_base = (void *)devfdt_get_addr_index(dev, 1);
 		if (IS_ERR(priv->iface_base))
 			return PTR_ERR(priv->iface_base);
 
-		priv->mdio_base = priv->iface_base + MVPP22_SMI;
-
 		/* Store common base addresses for all ports */
 		priv->mpcs_base = priv->iface_base + MVPP22_MPCS;
 		priv->xpcs_base = priv->iface_base + MVPP22_XPCS;
@@ -5430,20 +5370,7 @@ static int mvpp2_base_probe(struct udevice *dev)
 	else
 		priv->max_port_rxqs = 32;
 
-	/* Finally create and register the MDIO bus driver */
-	bus = mdio_alloc();
-	if (!bus) {
-		printf("Failed to allocate MDIO bus\n");
-		return -ENOMEM;
-	}
-
-	bus->read = mpp2_mdio_read;
-	bus->write = mpp2_mdio_write;
-	snprintf(bus->name, sizeof(bus->name), dev->name);
-	bus->priv = (void *)priv;
-	priv->bus = bus;
-
-	return mdio_register(bus);
+	return 0;
 }
 
 static int mvpp2_probe(struct udevice *dev)
@@ -5485,7 +5412,7 @@ static int mvpp2_probe(struct udevice *dev)
 			port->gop_id * MVPP22_PORT_OFFSET;
 
 		/* Set phy address of the port */
-		if(port->phy_node)
+		if (port->phyaddr < PHY_MAX_ADDR)
 			mvpp22_smi_phy_addr_cfg(port);
 
 		/* GoP Init */
diff --git a/drivers/net/octeontx/Makefile b/drivers/net/octeontx/Makefile
new file mode 100644
index 0000000..0596617
--- /dev/null
+++ b/drivers/net/octeontx/Makefile
@@ -0,0 +1,10 @@
+#/*
+# * Copyright (C) 2018 Marvell International Ltd.
+# *
+# * SPDX-License-Identifier:    GPL-2.0
+# * https://spdx.org/licenses
+# */
+
+
+obj-$(CONFIG_NET_OCTEONTX) += octeontx_bgx.o nic_main.o nicvf_queues.o \
+		nicvf_main.o octeontx_xcv.o
diff --git a/drivers/net/octeontx/nic.h b/drivers/net/octeontx/nic.h
new file mode 100644
index 0000000..b26976c
--- /dev/null
+++ b/drivers/net/octeontx/nic.h
@@ -0,0 +1,518 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#ifndef NIC_H
+#define	NIC_H
+
+#include <linux/netdevice.h>
+#include "octeontx_bgx.h"
+
+/**
+ * Macro to get the physical address of a CSR on a node
+ */
+#define CSR_PA(node, csr) ((csr) | ((uint64_t)(node) << 44))
+
+/* PCI device IDs */
+#define	PCI_DEVICE_ID_OCTEONTX_NIC_PF	0xA01E
+#define	PCI_DEVICE_ID_OCTEONTX_NIC_VF_1	0x0011
+#define PCI_DEVICE_ID_OCTEONTX_NIC_VF_2	0xA034
+
+/* Subsystem device IDs */
+#define PCI_SUBSYS_DEVID_88XX_NIC_PF		0xA11E
+#define PCI_SUBSYS_DEVID_81XX_NIC_PF		0xA21E
+#define PCI_SUBSYS_DEVID_83XX_NIC_PF		0xA31E
+
+#define PCI_SUBSYS_DEVID_88XX_PASS1_NIC_VF	0xA11E
+#define PCI_SUBSYS_DEVID_88XX_NIC_VF		0xA134
+#define PCI_SUBSYS_DEVID_81XX_NIC_VF		0xA234
+#define PCI_SUBSYS_DEVID_83XX_NIC_VF		0xA334
+
+#define	NIC_INTF_COUNT			2  /* Interfaces btw VNIC and TNS/BGX */
+#define	NIC_CHANS_PER_INF		128
+#define	NIC_MAX_CHANS			(NIC_INTF_COUNT * NIC_CHANS_PER_INF)
+
+/* PCI BAR nos */
+#define	PCI_CFG_REG_BAR_NUM		0
+#define	PCI_MSIX_REG_BAR_NUM		4
+
+/* NIC SRIOV VF count */
+#define	MAX_NUM_VFS_SUPPORTED		128
+#define	DEFAULT_NUM_VF_ENABLED		8
+
+#define	NIC_TNS_BYPASS_MODE		0
+#define	NIC_TNS_MODE			1
+
+/* NIC priv flags */
+#define	NIC_SRIOV_ENABLED		(1 << 0)
+#define	NIC_TNS_ENABLED			(1 << 1)
+
+/* VNIC HW optimiation features */
+#define	VNIC_RX_CSUM_OFFLOAD_SUPPORT
+#undef	VNIC_TX_CSUM_OFFLOAD_SUPPORT
+#undef	VNIC_SG_SUPPORT
+#undef	VNIC_TSO_SUPPORT
+#undef	VNIC_LRO_SUPPORT
+#undef  VNIC_RSS_SUPPORT
+
+/* TSO not supported in Thunder pass1 */
+#ifdef	VNIC_TSO_SUPPORT
+#define	VNIC_SW_TSO_SUPPORT
+#undef	VNIC_HW_TSO_SUPPORT
+#endif
+
+/* ETHTOOL enable or disable, undef this to disable */
+#define	NICVF_ETHTOOL_ENABLE
+
+/* Min/Max packet size */
+#define	NIC_HW_MIN_FRS			64
+#define	NIC_HW_MAX_FRS			9200 /* 9216 max packet including FCS */
+
+/* Max pkinds */
+#define	NIC_MAX_PKIND			16
+
+/* Max when CPI_ALG is IP diffserv */
+#define	NIC_MAX_CPI_PER_LMAC		64
+
+/* NIC VF Interrupts */
+#define	NICVF_INTR_CQ			0
+#define	NICVF_INTR_SQ			1
+#define	NICVF_INTR_RBDR			2
+#define	NICVF_INTR_PKT_DROP		3
+#define	NICVF_INTR_TCP_TIMER	4
+#define	NICVF_INTR_MBOX			5
+#define	NICVF_INTR_QS_ERR		6
+
+#define	NICVF_INTR_CQ_SHIFT			0
+#define	NICVF_INTR_SQ_SHIFT			8
+#define	NICVF_INTR_RBDR_SHIFT		16
+#define	NICVF_INTR_PKT_DROP_SHIFT	20
+#define	NICVF_INTR_TCP_TIMER_SHIFT	21
+#define	NICVF_INTR_MBOX_SHIFT		22
+#define	NICVF_INTR_QS_ERR_SHIFT		23
+
+#define	NICVF_INTR_CQ_MASK		(0xFF << NICVF_INTR_CQ_SHIFT)
+#define	NICVF_INTR_SQ_MASK		(0xFF << NICVF_INTR_SQ_SHIFT)
+#define	NICVF_INTR_RBDR_MASK		(0x03 << NICVF_INTR_RBDR_SHIFT)
+#define	NICVF_INTR_PKT_DROP_MASK	(1 << NICVF_INTR_PKT_DROP_SHIFT)
+#define	NICVF_INTR_TCP_TIMER_MASK	(1 << NICVF_INTR_TCP_TIMER_SHIFT)
+#define	NICVF_INTR_MBOX_MASK		(1 << NICVF_INTR_MBOX_SHIFT)
+#define	NICVF_INTR_QS_ERR_MASK		(1 << NICVF_INTR_QS_ERR_SHIFT)
+
+/* MSI-X interrupts */
+#define	NIC_PF_MSIX_VECTORS		10
+#define	NIC_VF_MSIX_VECTORS		20
+
+#define NIC_PF_INTR_ID_ECC0_SBE		0
+#define NIC_PF_INTR_ID_ECC0_DBE		1
+#define NIC_PF_INTR_ID_ECC1_SBE		2
+#define NIC_PF_INTR_ID_ECC1_DBE		3
+#define NIC_PF_INTR_ID_ECC2_SBE		4
+#define NIC_PF_INTR_ID_ECC2_DBE		5
+#define NIC_PF_INTR_ID_ECC3_SBE		6
+#define NIC_PF_INTR_ID_ECC3_DBE		7
+#define NIC_PF_INTR_ID_MBOX0		8
+#define NIC_PF_INTR_ID_MBOX1		9
+
+/* Global timer for CQ timer thresh interrupts
+ * Calculated for SCLK of 700Mhz
+ * value written should be a 1/16thof what is expected
+ *
+ * 1 tick per ms
+ */
+#define NICPF_CLK_PER_INT_TICK		43750
+
+struct nicvf_cq_poll {
+	uint8_t	cq_idx;		/* Completion queue index */
+};
+
+#define NIC_MAX_RSS_HASH_BITS		8
+#define NIC_MAX_RSS_IDR_TBL_SIZE	(1 << NIC_MAX_RSS_HASH_BITS)
+#define RSS_HASH_KEY_SIZE		5 /* 320 bit key */
+
+#ifdef VNIC_RSS_SUPPORT
+struct nicvf_rss_info {
+	bool enable;
+#define	RSS_L2_EXTENDED_HASH_ENA	(1 << 0)
+#define	RSS_IP_HASH_ENA			(1 << 1)
+#define	RSS_TCP_HASH_ENA		(1 << 2)
+#define	RSS_TCP_SYN_DIS			(1 << 3)
+#define	RSS_UDP_HASH_ENA		(1 << 4)
+#define RSS_L4_EXTENDED_HASH_ENA	(1 << 5)
+#define	RSS_ROCE_ENA			(1 << 6)
+#define	RSS_L3_BI_DIRECTION_ENA		(1 << 7)
+#define	RSS_L4_BI_DIRECTION_ENA		(1 << 8)
+	uint64_t cfg;
+	uint8_t  hash_bits;
+	uint16_t rss_size;
+	uint8_t  ind_tbl[NIC_MAX_RSS_IDR_TBL_SIZE];
+	uint64_t key[RSS_HASH_KEY_SIZE];
+};
+#endif
+
+enum rx_stats_reg_offset {
+	RX_OCTS = 0x0,
+	RX_UCAST = 0x1,
+	RX_BCAST = 0x2,
+	RX_MCAST = 0x3,
+	RX_RED = 0x4,
+	RX_RED_OCTS = 0x5,
+	RX_ORUN = 0x6,
+	RX_ORUN_OCTS = 0x7,
+	RX_FCS = 0x8,
+	RX_L2ERR = 0x9,
+	RX_DRP_BCAST = 0xa,
+	RX_DRP_MCAST = 0xb,
+	RX_DRP_L3BCAST = 0xc,
+	RX_DRP_L3MCAST = 0xd,
+	RX_STATS_ENUM_LAST,
+};
+
+enum tx_stats_reg_offset {
+	TX_OCTS = 0x0,
+	TX_UCAST = 0x1,
+	TX_BCAST = 0x2,
+	TX_MCAST = 0x3,
+	TX_DROP = 0x4,
+	TX_STATS_ENUM_LAST,
+};
+
+struct nicvf_hw_stats {
+	u64 rx_bytes_ok;
+	u64 rx_ucast_frames_ok;
+	u64 rx_bcast_frames_ok;
+	u64 rx_mcast_frames_ok;
+	u64 rx_fcs_errors;
+	u64 rx_l2_errors;
+	u64 rx_drop_red;
+	u64 rx_drop_red_bytes;
+	u64 rx_drop_overrun;
+	u64 rx_drop_overrun_bytes;
+	u64 rx_drop_bcast;
+	u64 rx_drop_mcast;
+	u64 rx_drop_l3_bcast;
+	u64 rx_drop_l3_mcast;
+	u64 tx_bytes_ok;
+	u64 tx_ucast_frames_ok;
+	u64 tx_bcast_frames_ok;
+	u64 tx_mcast_frames_ok;
+	u64 tx_drops;
+};
+
+struct nicvf_drv_stats {
+	/* Rx */
+	u64 rx_frames_ok;
+	u64 rx_frames_64;
+	u64 rx_frames_127;
+	u64 rx_frames_255;
+	u64 rx_frames_511;
+	u64 rx_frames_1023;
+	u64 rx_frames_1518;
+	u64 rx_frames_jumbo;
+	u64 rx_drops;
+	/* Tx */
+	u64 tx_frames_ok;
+	u64 tx_drops;
+	u64 tx_busy;
+	u64 tx_tso;
+};
+
+struct hw_info {
+	u8		bgx_cnt;
+	u8		chans_per_lmac;
+	u8		chans_per_bgx; /* Rx/Tx chans */
+	u8		chans_per_rgx;
+	u8		chans_per_lbk;
+	u16		cpi_cnt;
+	u16		rssi_cnt;
+	u16		rss_ind_tbl_size;
+	u16		tl4_cnt;
+	u16		tl3_cnt;
+	u8		tl2_cnt;
+	u8		tl1_cnt;
+	bool		tl1_per_bgx; /* TL1 per BGX or per LMAC */
+	u8		model_id;
+};
+
+struct nicvf {
+	struct udevice		*dev;
+	uint8_t			vf_id;
+	bool			sqs_mode:1;
+	bool			loopback_supported:1;
+	uint8_t			tns_mode;
+	uint8_t			node;
+	uint16_t		mtu;
+	struct queue_set	*qs;
+#define		MAX_SQS_PER_VF_SINGLE_NODE	5
+#define		MAX_SQS_PER_VF			11
+	uint8_t			num_qs;
+	void			*addnl_qs;
+	uint16_t		vf_mtu;
+	void __iomem		*reg_base;
+#define	MAX_QUEUES_PER_QSET			8
+	struct nicvf_cq_poll	*napi[8];
+
+	uint8_t			cpi_alg;
+
+	struct nicvf_hw_stats	stats;
+	struct nicvf_drv_stats	drv_stats;
+
+	struct nicpf		*nicpf;
+
+	/* VF <-> PF mailbox communication */
+	bool			pf_acked;
+	bool			pf_nacked;
+	bool			set_mac_pending;
+
+	bool			link_up;
+	uint8_t			duplex;
+	uint32_t		speed;
+	uint8_t			rev_id;
+	uint8_t			rx_queues;
+	uint8_t			tx_queues;
+
+	bool			open;
+	bool			rb_alloc_fail;
+	void			*rcv_buf;
+	bool			hw_tso;
+};
+
+static inline int node_id(void *addr)
+{
+	return ((uintptr_t)addr >> 44) & 0x3;
+}
+
+struct nicpf {
+	struct udevice		*udev;
+	struct hw_info		*hw;
+	uint8_t			node;
+	unsigned int		flags;
+	uint16_t		total_vf_cnt;	/* Total num of VF supported */
+	uint16_t		num_vf_en;	/* No of VF enabled */
+	void __iomem		*reg_base;	/* Register start address */
+	u16			rss_ind_tbl_size;
+	u8			num_sqs_en;	/* Secondary qsets enabled */
+	u64			nicvf[MAX_NUM_VFS_SUPPORTED];
+	u8			vf_sqs[MAX_NUM_VFS_SUPPORTED][MAX_SQS_PER_VF];
+	u8			pqs_vf[MAX_NUM_VFS_SUPPORTED];
+	bool			sqs_used[MAX_NUM_VFS_SUPPORTED];
+	struct pkind_cfg	pkind;
+	uint8_t			bgx_cnt;
+	uint8_t			rev_id;
+#define	NIC_SET_VF_LMAC_MAP(bgx, lmac)	(((bgx & 0xF) << 4) | (lmac & 0xF))
+#define	NIC_GET_BGX_FROM_VF_LMAC_MAP(map)	((map >> 4) & 0xF)
+#define	NIC_GET_LMAC_FROM_VF_LMAC_MAP(map)	(map & 0xF)
+	uint8_t			vf_lmac_map[MAX_LMAC];
+	uint16_t		cpi_base[MAX_NUM_VFS_SUPPORTED];
+	uint64_t		mac[MAX_NUM_VFS_SUPPORTED];
+	bool			mbx_lock[MAX_NUM_VFS_SUPPORTED];
+	uint8_t			link[MAX_LMAC];
+	uint8_t			duplex[MAX_LMAC];
+	uint32_t		speed[MAX_LMAC];
+	bool			vf_enabled[MAX_NUM_VFS_SUPPORTED];
+	uint16_t		rssi_base[MAX_NUM_VFS_SUPPORTED];
+	uint8_t			lmac_cnt;
+};
+
+/* PF <--> VF Mailbox communication
+ * Eight 64bit registers are shared between PF and VF.
+ * Separate set for each VF.
+ * Writing '1' into last register mbx7 means end of message.
+ */
+
+/* PF <--> VF mailbox communication */
+#define	NIC_PF_VF_MAILBOX_SIZE		2
+#define	NIC_PF_VF_MBX_TIMEOUT		2000 /* ms */
+
+/* Mailbox message types */
+#define	NIC_MBOX_MSG_READY		0x01	/* Is PF ready to rcv msgs */
+#define	NIC_MBOX_MSG_ACK		0x02	/* ACK the message received */
+#define	NIC_MBOX_MSG_NACK		0x03	/* NACK the message received */
+#define	NIC_MBOX_MSG_QS_CFG		0x04	/* Configure Qset */
+#define	NIC_MBOX_MSG_RQ_CFG		0x05	/* Configure receive queue */
+#define	NIC_MBOX_MSG_SQ_CFG		0x06	/* Configure Send queue */
+#define	NIC_MBOX_MSG_RQ_DROP_CFG	0x07	/* Configure receive queue */
+#define	NIC_MBOX_MSG_SET_MAC		0x08	/* Add MAC ID to DMAC filter */
+#define	NIC_MBOX_MSG_SET_MAX_FRS	0x09	/* Set max frame size */
+#define	NIC_MBOX_MSG_CPI_CFG		0x0A	/* Config CPI, RSSI */
+#define	NIC_MBOX_MSG_RSS_SIZE		0x0B	/* Get RSS indir_tbl size */
+#define	NIC_MBOX_MSG_RSS_CFG		0x0C	/* Config RSS table */
+#define	NIC_MBOX_MSG_RSS_CFG_CONT	0x0D	/* RSS config continuation */
+#define	NIC_MBOX_MSG_RQ_BP_CFG		0x0E	/* RQ backpressure config */
+#define	NIC_MBOX_MSG_RQ_SW_SYNC		0x0F	/* Flush inflight pkts to RQ */
+#define	NIC_MBOX_MSG_BGX_STATS		0x10	/* Get stats from BGX */
+#define	NIC_MBOX_MSG_BGX_LINK_CHANGE	0x11	/* BGX:LMAC link status */
+#define	NIC_MBOX_MSG_ALLOC_SQS		0x12	/* Allocate secondary Qset */
+#define	NIC_MBOX_MSG_NICVF_PTR		0x13	/* Send nicvf ptr to PF */
+#define	NIC_MBOX_MSG_PNICVF_PTR		0x14	/* Get primary qset nicvf ptr */
+#define	NIC_MBOX_MSG_SNICVF_PTR		0x15	/* Send sqet nicvf ptr to PVF */
+#define	NIC_MBOX_MSG_LOOPBACK		0x16	/* Set interface in loopback */
+#define	NIC_MBOX_MSG_CFG_DONE		0xF0	/* VF configuration done */
+#define	NIC_MBOX_MSG_SHUTDOWN		0xF1	/* VF is being shutdown */
+
+struct nic_cfg_msg {
+	u8    msg;
+	u8    vf_id;
+	u8    node_id;
+	bool  tns_mode:1;
+	bool  sqs_mode:1;
+	bool  loopback_supported:1;
+	u8    mac_addr[6];
+};
+
+/* Qset configuration */
+struct qs_cfg_msg {
+	u8    msg;
+	u8    num;
+	u8    sqs_count;
+	u64   cfg;
+};
+
+/* Receive queue configuration */
+struct rq_cfg_msg {
+	u8    msg;
+	u8    qs_num;
+	u8    rq_num;
+	u64   cfg;
+};
+
+/* Send queue configuration */
+struct sq_cfg_msg {
+	u8    msg;
+	u8    qs_num;
+	u8    sq_num;
+	bool  sqs_mode;
+	u64   cfg;
+};
+
+/* Set VF's MAC address */
+struct set_mac_msg {
+	u8    msg;
+	u8    vf_id;
+	u8    mac_addr[6];
+};
+
+/* Set Maximum frame size */
+struct set_frs_msg {
+	u8    msg;
+	u8    vf_id;
+	u16   max_frs;
+};
+
+/* Set CPI algorithm type */
+struct cpi_cfg_msg {
+	u8    msg;
+	u8    vf_id;
+	u8    rq_cnt;
+	u8    cpi_alg;
+};
+
+/* Get RSS table size */
+struct rss_sz_msg {
+	u8    msg;
+	u8    vf_id;
+	u16   ind_tbl_size;
+};
+
+/* Set RSS configuration */
+struct rss_cfg_msg {
+	u8    msg;
+	u8    vf_id;
+	u8    hash_bits;
+	u8    tbl_len;
+	u8    tbl_offset;
+#define RSS_IND_TBL_LEN_PER_MBX_MSG	8
+	u8    ind_tbl[RSS_IND_TBL_LEN_PER_MBX_MSG];
+};
+
+struct bgx_stats_msg {
+	u8    msg;
+	u8    vf_id;
+	u8    rx;
+	u8    idx;
+	u64   stats;
+};
+
+/* Physical interface link status */
+struct bgx_link_status {
+	u8    msg;
+	u8    link_up;
+	u8    duplex;
+	u32   speed;
+};
+
+#ifdef VNIC_MULTI_QSET_SUPPORT
+/* Get Extra Qset IDs */
+struct sqs_alloc {
+	u8    msg;
+	u8    vf_id;
+	u8    qs_count;
+};
+
+struct nicvf_ptr {
+	u8    msg;
+	u8    vf_id;
+	bool  sqs_mode;
+	u8    sqs_id;
+	u64   nicvf;
+};
+#endif
+
+/* Set interface in loopback mode */
+struct set_loopback {
+	u8    msg;
+	u8    vf_id;
+	bool  enable;
+};
+/* 128 bit shared memory between PF and each VF */
+union nic_mbx {
+	struct { u8 msg; }	msg;
+	struct nic_cfg_msg	nic_cfg;
+	struct qs_cfg_msg	qs;
+	struct rq_cfg_msg	rq;
+	struct sq_cfg_msg	sq;
+	struct set_mac_msg	mac;
+	struct set_frs_msg	frs;
+	struct cpi_cfg_msg	cpi_cfg;
+	struct rss_sz_msg	rss_size;
+	struct rss_cfg_msg	rss_cfg;
+	struct bgx_stats_msg    bgx_stats;
+	struct bgx_link_status  link_status;
+#ifdef VNIC_MULTI_QSET_SUPPORT
+	struct sqs_alloc        sqs_alloc;
+	struct nicvf_ptr	nicvf;
+#endif
+	struct set_loopback	lbk;
+};
+
+int nicvf_set_real_num_queues(struct udevice *dev,
+			      int tx_queues, int rx_queues);
+int nicvf_open(struct udevice *dev);
+void nicvf_stop(struct udevice *dev);
+int nicvf_send_msg_to_pf(struct nicvf *vf, union nic_mbx *mbx);
+void nicvf_update_stats(struct nicvf *nic);
+
+void nic_handle_mbx_intr(struct nicpf *nic, int vf);
+
+int bgx_poll_for_link(int node, int bgx_idx, int lmacid);
+const u8 *bgx_get_lmac_mac(int node, int bgx_idx, int lmacid);
+void bgx_set_lmac_mac(int node, int bgx_idx, int lmacid, const u8 *mac);
+void bgx_lmac_rx_tx_enable(int node, int bgx_idx, int lmacid, bool enable);
+void bgx_lmac_internal_loopback(int node, int bgx_idx,
+				int lmac_idx, bool enable);
+
+static inline bool pass1_silicon(unsigned int revision, int model_id)
+{
+	return ((revision < 8) && (model_id == 0x88));
+}
+
+static inline bool pass2_silicon(unsigned int revision, int model_id)
+{
+	return ((revision >= 8) && (model_id == 0x88));
+}
+
+#endif /* NIC_H */
diff --git a/drivers/net/octeontx/nic_main.c b/drivers/net/octeontx/nic_main.c
new file mode 100644
index 0000000..99f65ee
--- /dev/null
+++ b/drivers/net/octeontx/nic_main.c
@@ -0,0 +1,798 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#include <config.h>
+#include <common.h>
+#include <net.h>
+#include <netdev.h>
+#include <malloc.h>
+#include <miiphy.h>
+#include <dm.h>
+#include <misc.h>
+#include <pci.h>
+#include <asm/io.h>
+
+#include <asm/arch/octeontx_vnic.h>
+
+#include "nic_reg.h"
+#include "nic.h"
+#include "q_struct.h"
+#include "octeontx_bgx.h"
+
+#define ETH_HLEN 6
+
+unsigned long rounddown_pow_of_two(unsigned long n)
+{
+	n |= n >> 1;
+	n |= n >> 2;
+	n |= n >> 4;
+	n |= n >> 8;
+	n |= n >> 16;
+	n |= n >> 32;
+
+	return(n + 1);
+}
+
+static void nic_config_cpi(struct nicpf *nic, struct cpi_cfg_msg *cfg);
+static void nic_tx_channel_cfg(struct nicpf *nic, u8 vnic,
+			       struct sq_cfg_msg *sq);
+static int nic_update_hw_frs(struct nicpf *nic, int new_frs, int vf);
+static int nic_rcv_queue_sw_sync(struct nicpf *nic);
+
+/* Register read/write APIs */
+static void nic_reg_write(struct nicpf *nic, uint64_t offset, uint64_t val)
+{
+	writeq(val, nic->reg_base + offset);
+}
+
+static uint64_t nic_reg_read(struct nicpf *nic, uint64_t offset)
+{
+	return readq(nic->reg_base + offset);
+}
+
+static u64 nic_get_mbx_addr(int vf)
+{
+	return NIC_PF_VF_0_127_MAILBOX_0_1 + (vf << NIC_VF_NUM_SHIFT);
+}
+
+
+static void nic_send_msg_to_vf(struct nicpf *nic, int vf, union nic_mbx *mbx)
+{
+	void __iomem *mbx_addr = (void *)(nic->reg_base + nic_get_mbx_addr(vf));
+	u64 *msg = (u64 *)mbx;
+
+	/* In first revision HW, mbox interrupt is triggerred
+	 * when PF writes to MBOX(1), in next revisions when
+	 * PF writes to MBOX(0)
+	 */
+	if (pass1_silicon(nic->rev_id, nic->hw->model_id)) {
+		/* see the comment for nic_reg_write()/nic_reg_read()
+		 * functions above
+		 */
+		writeq(msg[0], mbx_addr);
+		writeq(msg[1], mbx_addr + 8);
+	} else {
+		writeq(msg[1], mbx_addr + 8);
+		writeq(msg[0], mbx_addr);
+	}
+}
+
+static void nic_mbx_send_ready(struct nicpf *nic, int vf)
+{
+	union nic_mbx mbx = {};
+	int bgx_idx, lmac, timeout = 5, link = -1;
+	const u8 *mac;
+
+	mbx.nic_cfg.msg = NIC_MBOX_MSG_READY;
+	mbx.nic_cfg.vf_id = vf;
+
+	if (nic->flags & NIC_TNS_ENABLED)
+		mbx.nic_cfg.tns_mode = NIC_TNS_MODE;
+	else
+		mbx.nic_cfg.tns_mode = NIC_TNS_BYPASS_MODE;
+
+	if (vf < nic->num_vf_en) {
+		bgx_idx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);
+		lmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);
+
+		mac = bgx_get_lmac_mac(nic->node, bgx_idx, lmac);
+		if (mac)
+			memcpy((u8 *)&mbx.nic_cfg.mac_addr, mac, 6);
+
+		while (timeout-- && (link <= 0)){
+			link = bgx_poll_for_link(nic->node, bgx_idx, lmac);
+			debug("Link status: %d\n", link);
+			if (link <= 0)
+				mdelay(2000);
+		}
+	}
+#ifdef VNIC_MULTI_QSET_SUPPORT
+	mbx.nic_cfg.sqs_mode = (vf >= nic->num_vf_en) ? true : false;
+#endif
+	mbx.nic_cfg.node_id = nic->node;
+
+	mbx.nic_cfg.loopback_supported = vf < nic->num_vf_en;
+
+	nic_send_msg_to_vf(nic, vf, &mbx);
+}
+
+
+/* ACKs VF's mailbox message
+ * @vf: VF to which ACK to be sent
+ */
+static void nic_mbx_send_ack(struct nicpf *nic, int vf)
+{
+	union nic_mbx mbx = {};
+
+	mbx.msg.msg = NIC_MBOX_MSG_ACK;
+	nic_send_msg_to_vf(nic, vf, &mbx);
+}
+
+/* NACKs VF's mailbox message that PF is not able to
+ * complete the action
+ * @vf: VF to which ACK to be sent
+ */
+static void nic_mbx_send_nack(struct nicpf *nic, int vf)
+{
+	union nic_mbx mbx = {};
+
+	mbx.msg.msg = NIC_MBOX_MSG_NACK;
+	nic_send_msg_to_vf(nic, vf, &mbx);
+}
+
+static int nic_config_loopback(struct nicpf *nic, struct set_loopback *lbk)
+{
+	int bgx_idx, lmac_idx;
+
+	if (lbk->vf_id > nic->num_vf_en)
+		return -1;
+
+	bgx_idx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[lbk->vf_id]);
+	lmac_idx = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[lbk->vf_id]);
+
+	bgx_lmac_internal_loopback(nic->node, bgx_idx, lmac_idx, lbk->enable);
+
+	return 0;
+}
+
+/* Interrupt handler to handle mailbox messages from VFs */
+void nic_handle_mbx_intr(struct nicpf *nic, int vf)
+{
+	union nic_mbx mbx = {};
+	u64 *mbx_data;
+	u64 mbx_addr;
+	u64 reg_addr;
+	u64 cfg;
+	int bgx, lmac;
+	int i;
+	int ret = 0;
+
+	nic->mbx_lock[vf] = true;
+
+	mbx_addr = nic_get_mbx_addr(vf);
+	mbx_data = (u64 *)&mbx;
+
+	for (i = 0; i < NIC_PF_VF_MAILBOX_SIZE; i++) {
+		*mbx_data = nic_reg_read(nic, mbx_addr);
+		mbx_data++;
+		mbx_addr += sizeof(u64);
+	}
+
+	debug("%s: Mailbox msg %d from VF%d\n",
+		__func__, mbx.msg.msg, vf);
+	switch (mbx.msg.msg) {
+	case NIC_MBOX_MSG_READY:
+		nic_mbx_send_ready(nic, vf);
+		if (vf < nic->num_vf_en) {
+			nic->link[vf] = 0;
+			nic->duplex[vf] = 0;
+			nic->speed[vf] = 0;
+		}
+		ret = 1;
+		break;
+	case NIC_MBOX_MSG_QS_CFG:
+		reg_addr = NIC_PF_QSET_0_127_CFG |
+			   (mbx.qs.num << NIC_QS_ID_SHIFT);
+		cfg = mbx.qs.cfg;
+#ifdef VNIC_MULTI_QSET_SUPPORT
+		/* Check if its a secondary Qset */
+		if (vf >= nic->num_vf_en) {
+			cfg = cfg & (~0x7FULL);
+			/* Assign this Qset to primary Qset's VF */
+			cfg |= nic->pqs_vf[vf];
+		}
+#endif
+		nic_reg_write(nic, reg_addr, cfg);
+		break;
+	case NIC_MBOX_MSG_RQ_CFG:
+		reg_addr = NIC_PF_QSET_0_127_RQ_0_7_CFG |
+			   (mbx.rq.qs_num << NIC_QS_ID_SHIFT) |
+			   (mbx.rq.rq_num << NIC_Q_NUM_SHIFT);
+		nic_reg_write(nic, reg_addr, mbx.rq.cfg);
+		/* Enable CQE_RX2_S extension in CQE_RX descriptor.
+		 * This gets appended by default on 81xx/83xx chips,
+		 * for consistency enabling the same on 88xx pass2
+		 * where this is introduced.
+		 */
+		if (pass2_silicon(nic->rev_id, nic->hw->model_id))
+			nic_reg_write(nic, NIC_PF_RX_CFG, 0x01);
+		break;
+	case NIC_MBOX_MSG_RQ_BP_CFG:
+		reg_addr = NIC_PF_QSET_0_127_RQ_0_7_BP_CFG |
+			   (mbx.rq.qs_num << NIC_QS_ID_SHIFT) |
+			   (mbx.rq.rq_num << NIC_Q_NUM_SHIFT);
+		nic_reg_write(nic, reg_addr, mbx.rq.cfg);
+		break;
+	case NIC_MBOX_MSG_RQ_SW_SYNC:
+		ret = nic_rcv_queue_sw_sync(nic);
+		break;
+	case NIC_MBOX_MSG_RQ_DROP_CFG:
+		reg_addr = NIC_PF_QSET_0_127_RQ_0_7_DROP_CFG |
+			   (mbx.rq.qs_num << NIC_QS_ID_SHIFT) |
+			   (mbx.rq.rq_num << NIC_Q_NUM_SHIFT);
+		nic_reg_write(nic, reg_addr, mbx.rq.cfg);
+		break;
+	case NIC_MBOX_MSG_SQ_CFG:
+		reg_addr = NIC_PF_QSET_0_127_SQ_0_7_CFG |
+			   (mbx.sq.qs_num << NIC_QS_ID_SHIFT) |
+			   (mbx.sq.sq_num << NIC_Q_NUM_SHIFT);
+		nic_reg_write(nic, reg_addr, mbx.sq.cfg);
+		nic_tx_channel_cfg(nic, mbx.qs.num, (struct sq_cfg_msg*)&mbx.sq);
+		break;
+	case NIC_MBOX_MSG_SET_MAC:
+#ifdef VNIC_MULTI_QSET_SUPPORT
+		if (vf >= nic->num_vf_en)
+			break;
+#endif
+		lmac = mbx.mac.vf_id;
+		bgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[lmac]);
+		lmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[lmac]);
+		bgx_set_lmac_mac(nic->node, bgx, lmac, mbx.mac.mac_addr);
+		break;
+	case NIC_MBOX_MSG_SET_MAX_FRS:
+		ret = nic_update_hw_frs(nic, mbx.frs.max_frs,
+					mbx.frs.vf_id);
+		break;
+	case NIC_MBOX_MSG_CPI_CFG:
+		nic_config_cpi(nic, &mbx.cpi_cfg);
+		break;
+#ifdef VNIC_RSS_SUPPORT
+	case NIC_MBOX_MSG_RSS_SIZE:
+		nic_send_rss_size(nic, vf);
+		goto unlock;
+	case NIC_MBOX_MSG_RSS_CFG:
+	case NIC_MBOX_MSG_RSS_CFG_CONT:
+		nic_config_rss(nic, &mbx.rss_cfg);
+		break;
+#endif
+	case NIC_MBOX_MSG_CFG_DONE:
+		/* Last message of VF config msg sequence */
+		nic->vf_enabled[vf] = true;
+		if (vf >= nic->lmac_cnt)
+			goto unlock;
+
+		bgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);
+		lmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);
+
+		bgx_lmac_rx_tx_enable(nic->node, bgx, lmac, true);
+		goto unlock;
+	case NIC_MBOX_MSG_SHUTDOWN:
+		/* First msg in VF teardown sequence */
+		nic->vf_enabled[vf] = false;
+#ifdef VNIC_MULTI_QSET_SUPPORT
+		if (vf >= nic->num_vf_en)
+			nic->sqs_used[vf - nic->num_vf_en] = false;
+		nic->pqs_vf[vf] = 0;
+#endif
+		if (vf >= nic->lmac_cnt)
+			break;
+
+		bgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);
+		lmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vf]);
+
+		bgx_lmac_rx_tx_enable(nic->node, bgx, lmac, false);
+		break;
+#ifdef VNIC_MULTI_QSET_SUPPORT
+	case NIC_MBOX_MSG_ALLOC_SQS:
+		nic_alloc_sqs(nic, &mbx.sqs_alloc);
+		goto unlock;
+	case NIC_MBOX_MSG_NICVF_PTR:
+		nic->nicvf[vf] = mbx.nicvf.nicvf;
+		break;
+	case NIC_MBOX_MSG_PNICVF_PTR:
+		nic_send_pnicvf(nic, vf);
+		goto unlock;
+	case NIC_MBOX_MSG_SNICVF_PTR:
+		nic_send_snicvf(nic, &mbx.nicvf);
+		goto unlock;
+#endif
+	case NIC_MBOX_MSG_LOOPBACK:
+		ret = nic_config_loopback(nic, &mbx.lbk);
+		break;
+	default:
+		printf("Invalid msg from VF%d, msg 0x%x\n", vf, mbx.msg.msg);
+		break;
+	}
+
+	if (!ret)
+		nic_mbx_send_ack(nic, vf);
+	else if (mbx.msg.msg != NIC_MBOX_MSG_READY)
+		nic_mbx_send_nack(nic, vf);
+unlock:
+	nic->mbx_lock[vf] = false;
+}
+
+
+static int nic_rcv_queue_sw_sync(struct nicpf *nic)
+{
+	int timeout = 20;
+
+	nic_reg_write(nic, NIC_PF_SW_SYNC_RX, 0x01);
+	while (timeout) {
+		if (nic_reg_read(nic, NIC_PF_SW_SYNC_RX_DONE) & 0x1)
+			break;
+		udelay(2000);
+		timeout--;
+	}
+	nic_reg_write(nic, NIC_PF_SW_SYNC_RX, 0x00);
+	if (!timeout) {
+		printf("Recevie queue software sync failed");
+		return 1;
+	}
+	return 0;
+}
+
+static int nic_update_hw_frs(struct nicpf *nic, int new_frs, int vf)
+{
+	uint64_t *pkind = (uint64_t *)&nic->pkind;
+	if ((new_frs > NIC_HW_MAX_FRS) || (new_frs < NIC_HW_MIN_FRS)) {
+		printf("Invalid MTU setting from VF%d rejected, should be between %d and %d\n",
+				vf, NIC_HW_MIN_FRS, NIC_HW_MAX_FRS);
+		return 1;
+	}
+	new_frs += ETH_HLEN;
+	if (new_frs <= nic->pkind.maxlen)
+		return 0;
+
+	nic->pkind.maxlen = new_frs;
+
+	nic_reg_write(nic, NIC_PF_PKIND_0_15_CFG, *pkind);
+	return 0;
+}
+
+/* Set minimum transmit packet size */
+static void nic_set_tx_pkt_pad(struct nicpf *nic, int size)
+{
+	int lmac;
+	uint64_t lmac_cfg;
+	struct hw_info *hw = nic->hw;
+	int max_lmac = nic->hw->bgx_cnt * MAX_LMAC_PER_BGX;
+
+	/* Max value that can be set is 60 */
+	if (size > 52)
+		size = 52;
+
+	/* CN81XX has RGX configured as FAKE BGX, adjust mac_lmac accordingly */
+	if (hw->chans_per_rgx)
+		max_lmac = ((nic->hw->bgx_cnt - 1) * MAX_LMAC_PER_BGX) + 1;
+
+	for (lmac = 0; lmac < max_lmac; lmac++) {
+		lmac_cfg = nic_reg_read(nic, NIC_PF_LMAC_0_7_CFG | (lmac << 3));
+		lmac_cfg &= ~(0xF << 2);
+		lmac_cfg |= ((size / 4) << 2);
+		nic_reg_write(nic, NIC_PF_LMAC_0_7_CFG | (lmac << 3), lmac_cfg);
+	}
+}
+
+/* Function to check number of LMACs present and set VF to LMAC mapping.
+ * Mapping will be used while initializing channels.
+ */
+static void nic_set_lmac_vf_mapping(struct nicpf *nic)
+{
+	int bgx, bgx_count, next_bgx_lmac = 0;
+	int lmac, lmac_cnt = 0;
+	uint64_t lmac_credit;
+
+	nic->num_vf_en = 0;
+	if (nic->flags & NIC_TNS_ENABLED) {
+		nic->num_vf_en = DEFAULT_NUM_VF_ENABLED;
+		return;
+	}
+
+	bgx_get_count(nic->node, &bgx_count);
+	debug("bgx_count: %d\n", bgx_count);
+
+	for (bgx = 0; bgx < nic->hw->bgx_cnt; bgx++) {
+		if (!(bgx_count & (1 << bgx)))
+			continue;
+		nic->bgx_cnt++;
+		lmac_cnt = bgx_get_lmac_count(nic->node, bgx);
+		debug("lmac_cnt: %d for BGX%d\n", lmac_cnt, bgx);
+		for (lmac = 0; lmac < lmac_cnt; lmac++)
+			nic->vf_lmac_map[next_bgx_lmac++] =
+						NIC_SET_VF_LMAC_MAP(bgx, lmac);
+		nic->num_vf_en += lmac_cnt;
+
+		/* Program LMAC credits */
+		lmac_credit = (1ull << 1); /* chennel credit enable */
+		lmac_credit |= (0x1ff << 2);
+		lmac_credit |= (((((48 * 1024) / lmac_cnt) -
+				NIC_HW_MAX_FRS) / 16) << 12);
+		lmac = bgx * MAX_LMAC_PER_BGX;
+		for (; lmac < lmac_cnt + (bgx * MAX_LMAC_PER_BGX); lmac++)
+			nic_reg_write(nic,
+				NIC_PF_LMAC_0_7_CREDIT + (lmac * 8), lmac_credit);
+	}
+}
+
+static void nic_get_hw_info(struct nicpf *nic)
+{
+	u16 sdevid;
+	struct hw_info *hw = nic->hw;
+
+	dm_pci_read_config16(nic->udev, PCI_SUBSYSTEM_ID, &sdevid);
+
+	switch (sdevid) {
+	case PCI_SUBSYS_DEVID_88XX_NIC_PF:
+		hw->bgx_cnt = CONFIG_MAX_BGX_PER_NODE;
+		hw->chans_per_lmac = 16;
+		hw->chans_per_bgx = 128;
+		hw->cpi_cnt = 2048;
+		hw->rssi_cnt = 4096;
+		hw->rss_ind_tbl_size = NIC_MAX_RSS_IDR_TBL_SIZE;
+		hw->tl3_cnt = 256;
+		hw->tl2_cnt = 64;
+		hw->tl1_cnt = 2;
+		hw->tl1_per_bgx = true;
+		hw->model_id = 0x88;
+		break;
+	case PCI_SUBSYS_DEVID_81XX_NIC_PF:
+		hw->bgx_cnt = CONFIG_MAX_BGX_PER_NODE;
+		hw->chans_per_lmac = 8;
+		hw->chans_per_bgx = 32;
+		hw->chans_per_rgx = 8;
+		hw->chans_per_lbk = 24;
+		hw->cpi_cnt = 512;
+		hw->rssi_cnt = 256;
+		hw->rss_ind_tbl_size = 32; /* Max RSSI / Max interfaces */
+		hw->tl3_cnt = 64;
+		hw->tl2_cnt = 16;
+		hw->tl1_cnt = 10;
+		hw->tl1_per_bgx = false;
+		hw->model_id = 0x81;
+		break;
+	case PCI_SUBSYS_DEVID_83XX_NIC_PF:
+		hw->bgx_cnt = CONFIG_MAX_BGX_PER_NODE;
+		hw->chans_per_lmac = 8;
+		hw->chans_per_bgx = 32;
+		hw->chans_per_lbk = 64;
+		hw->cpi_cnt = 2048;
+		hw->rssi_cnt = 1024;
+		hw->rss_ind_tbl_size = 64; /* Max RSSI / Max interfaces */
+		hw->tl3_cnt = 256;
+		hw->tl2_cnt = 64;
+		hw->tl1_cnt = 18;
+		hw->tl1_per_bgx = false;
+		hw->model_id = 0x83;
+		break;
+	}
+
+	hw->tl4_cnt = MAX_QUEUES_PER_QSET * pci_sriov_get_totalvfs(nic->udev);
+}
+
+static void nic_init_hw(struct nicpf *nic)
+{
+	int i;
+	uint64_t reg;
+	uint64_t *pkind = (uint64_t *)&nic->pkind;
+
+	/* Get HW capability info */
+	nic_get_hw_info(nic);
+
+	/* Enable NIC HW block */
+	nic_reg_write(nic, NIC_PF_CFG, 0x3);
+
+	/* Enable backpressure */
+	nic_reg_write(nic, NIC_PF_BP_CFG, (1ULL << 6) | 0x03);
+	nic_reg_write(nic, NIC_PF_INTF_0_1_BP_CFG, (1ULL << 63) | 0x08);
+	nic_reg_write(nic, NIC_PF_INTF_0_1_BP_CFG + (1 << 8), (1ULL << 63) | 0x09);
+
+	for (i = 0; i < NIC_MAX_CHANS; i++)
+		nic_reg_write(nic, NIC_PF_CHAN_0_255_TX_CFG | (i << 3), 1);
+
+	if (nic->flags & NIC_TNS_ENABLED) {
+		reg = NIC_TNS_MODE << 7;
+		reg |= 0x06;
+		nic_reg_write(nic, NIC_PF_INTF_0_1_SEND_CFG, reg);
+		reg &= ~0xFull;
+		reg |= 0x07;
+		nic_reg_write(nic, NIC_PF_INTF_0_1_SEND_CFG | (1 << 8), reg);
+	} else {
+		/* Disable TNS mode on both interfaces */
+		reg = NIC_TNS_BYPASS_MODE << 7;
+		reg |= 0x08; /* Block identifier */
+		nic_reg_write(nic, NIC_PF_INTF_0_1_SEND_CFG, reg);
+		reg &= ~0xFull;
+		reg |= 0x09;
+		nic_reg_write(nic, NIC_PF_INTF_0_1_SEND_CFG | (1 << 8), reg);
+	}
+
+	/* PKIND configuration */
+	nic->pkind.minlen = 0;
+	nic->pkind.maxlen = NIC_HW_MAX_FRS + ETH_HLEN;
+	nic->pkind.lenerr_en = 1;
+	nic->pkind.rx_hdr = 0;
+	nic->pkind.hdr_sl = 0;
+
+	for (i = 0; i < NIC_MAX_PKIND; i++)
+		nic_reg_write(nic, NIC_PF_PKIND_0_15_CFG | (i << 3), *pkind);
+
+	nic_set_tx_pkt_pad(nic, NIC_HW_MIN_FRS);
+
+	/* Timer config */
+	nic_reg_write(nic, NIC_PF_INTR_TIMER_CFG, NICPF_CLK_PER_INT_TICK);
+}
+
+/* Channel parse index configuration */
+static void nic_config_cpi(struct nicpf *nic, struct cpi_cfg_msg *cfg)
+{
+	struct hw_info *hw = nic->hw;
+	u32 vnic, bgx, lmac, chan;
+	u32 padd, cpi_count = 0;
+	u64 cpi_base, cpi, rssi_base, rssi;
+	u8  qset, rq_idx = 0;
+
+	vnic = cfg->vf_id;
+	bgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vnic]);
+	lmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[vnic]);
+
+	chan = (lmac * hw->chans_per_lmac) + (bgx * hw->chans_per_bgx);
+	cpi_base = vnic * NIC_MAX_CPI_PER_LMAC;
+	rssi_base = vnic * hw->rss_ind_tbl_size;
+
+	/* Rx channel configuration */
+	nic_reg_write(nic, NIC_PF_CHAN_0_255_RX_BP_CFG | (chan << 3),
+		      (1ull << 63) | (vnic << 0));
+	nic_reg_write(nic, NIC_PF_CHAN_0_255_RX_CFG | (chan << 3),
+		      ((u64)cfg->cpi_alg << 62) | (cpi_base << 48));
+
+	if (cfg->cpi_alg == CPI_ALG_NONE)
+		cpi_count = 1;
+	else if (cfg->cpi_alg == CPI_ALG_VLAN) /* 3 bits of PCP */
+		cpi_count = 8;
+	else if (cfg->cpi_alg == CPI_ALG_VLAN16) /* 3 bits PCP + DEI */
+		cpi_count = 16;
+	else if (cfg->cpi_alg == CPI_ALG_DIFF) /* 6bits DSCP */
+		cpi_count = NIC_MAX_CPI_PER_LMAC;
+
+	/* RSS Qset, Qidx mapping */
+	qset = cfg->vf_id;
+	rssi = rssi_base;
+	for (; rssi < (rssi_base + cfg->rq_cnt); rssi++) {
+		nic_reg_write(nic, NIC_PF_RSSI_0_4097_RQ | (rssi << 3),
+			      (qset << 3) | rq_idx);
+		rq_idx++;
+	}
+
+	rssi = 0;
+	cpi = cpi_base;
+	for (; cpi < (cpi_base + cpi_count); cpi++) {
+		/* Determine port to channel adder */
+		if (cfg->cpi_alg != CPI_ALG_DIFF)
+			padd = cpi % cpi_count;
+		else
+			padd = cpi % 8; /* 3 bits CS out of 6bits DSCP */
+
+		/* Leave RSS_SIZE as '0' to disable RSS */
+		if (pass1_silicon(nic->rev_id, nic->hw->model_id)) {
+			nic_reg_write(nic, NIC_PF_CPI_0_2047_CFG | (cpi << 3),
+				      (vnic << 24) | (padd << 16) |
+				      (rssi_base + rssi));
+		} else {
+			/* Set MPI_ALG to '0' to disable MCAM parsing */
+			nic_reg_write(nic, NIC_PF_CPI_0_2047_CFG | (cpi << 3),
+				      (padd << 16));
+			/* MPI index is same as CPI if MPI_ALG is not enabled */
+			nic_reg_write(nic, NIC_PF_MPI_0_2047_CFG | (cpi << 3),
+				      (vnic << 24) | (rssi_base + rssi));
+		}
+
+		if ((rssi + 1) >= cfg->rq_cnt)
+			continue;
+
+		if (cfg->cpi_alg == CPI_ALG_VLAN)
+			rssi++;
+		else if (cfg->cpi_alg == CPI_ALG_VLAN16)
+			rssi = ((cpi - cpi_base) & 0xe) >> 1;
+		else if (cfg->cpi_alg == CPI_ALG_DIFF)
+			rssi = ((cpi - cpi_base) & 0x38) >> 3;
+	}
+	nic->cpi_base[cfg->vf_id] = cpi_base;
+	nic->rssi_base[cfg->vf_id] = rssi_base;
+}
+
+
+/* Transmit channel configuration (TL4 -> TL3 -> Chan)
+ * VNIC0-SQ0 -> TL4(0)  -> TL4A(0) -> TL3[0] -> BGX0/LMAC0/Chan0
+ * VNIC1-SQ0 -> TL4(8)  -> TL4A(2) -> TL3[2] -> BGX0/LMAC1/Chan0
+ * VNIC2-SQ0 -> TL4(16) -> TL4A(4) -> TL3[4] -> BGX0/LMAC2/Chan0
+ * VNIC3-SQ0 -> TL4(32) -> TL4A(6) -> TL3[6] -> BGX0/LMAC3/Chan0
+ * VNIC4-SQ0 -> TL4(512)  -> TL4A(128) -> TL3[128] -> BGX1/LMAC0/Chan0
+ * VNIC5-SQ0 -> TL4(520)  -> TL4A(130) -> TL3[130] -> BGX1/LMAC1/Chan0
+ * VNIC6-SQ0 -> TL4(528)  -> TL4A(132) -> TL3[132] -> BGX1/LMAC2/Chan0
+ * VNIC7-SQ0 -> TL4(536)  -> TL4A(134) -> TL3[134] -> BGX1/LMAC3/Chan0
+ */
+static void nic_tx_channel_cfg(struct nicpf *nic, u8 vnic,
+			       struct sq_cfg_msg *sq)
+{
+	struct hw_info *hw = nic->hw;
+	u32 bgx, lmac, chan;
+	u32 tl2, tl3, tl4;
+	u32 rr_quantum;
+	u8 sq_idx = sq->sq_num;
+	u8 pqs_vnic = vnic;
+	int svf;
+	u16 sdevid;
+
+	dm_pci_read_config16(nic->udev, PCI_SUBSYSTEM_ID, &sdevid);
+
+	bgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(nic->vf_lmac_map[pqs_vnic]);
+	lmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(nic->vf_lmac_map[pqs_vnic]);
+
+	/* 24 bytes for FCS, IPG and preamble */
+	rr_quantum = ((NIC_HW_MAX_FRS + 24) / 4);
+
+	/* For 88xx 0-511 TL4 transmits via BGX0 and
+	 * 512-1023 TL4s transmit via BGX1.
+	 */
+	if (hw->tl1_per_bgx) {
+		tl4 = bgx * (hw->tl4_cnt / hw->bgx_cnt);
+		if (!sq->sqs_mode) {
+			tl4 += (lmac * MAX_QUEUES_PER_QSET);
+		} else {
+			for (svf = 0; svf < MAX_SQS_PER_VF_SINGLE_NODE; svf++) {
+				if (nic->vf_sqs[pqs_vnic][svf] == vnic)
+					break;
+			}
+			tl4 += (MAX_LMAC_PER_BGX * MAX_QUEUES_PER_QSET);
+			tl4 += (lmac * MAX_QUEUES_PER_QSET * MAX_SQS_PER_VF_SINGLE_NODE);
+			tl4 += (svf * MAX_QUEUES_PER_QSET);
+		}
+	} else {
+		tl4 = (vnic * MAX_QUEUES_PER_QSET);
+	}
+
+	tl4 += sq_idx;
+
+	tl3 = tl4 / (hw->tl4_cnt / hw->tl3_cnt);
+	nic_reg_write(nic, NIC_PF_QSET_0_127_SQ_0_7_CFG2 |
+		      ((u64)vnic << NIC_QS_ID_SHIFT) |
+		      ((u32)sq_idx << NIC_Q_NUM_SHIFT), tl4);
+	nic_reg_write(nic, NIC_PF_TL4_0_1023_CFG | (tl4 << 3),
+		      ((u64)vnic << 27) | ((u32)sq_idx << 24) | rr_quantum);
+
+	nic_reg_write(nic, NIC_PF_TL3_0_255_CFG | (tl3 << 3), rr_quantum);
+
+	/* On 88xx 0-127 channels are for BGX0 and
+	 * 127-255 channels for BGX1.
+	 *
+	 * On 81xx/83xx TL3_CHAN reg should be configured with channel
+	 * within LMAC i.e 0-7 and not the actual channel number like on 88xx
+	 */
+	chan = (lmac * hw->chans_per_lmac) + (bgx * hw->chans_per_bgx);
+	if (hw->tl1_per_bgx)
+		nic_reg_write(nic, NIC_PF_TL3_0_255_CHAN | (tl3 << 3), chan);
+	else
+		nic_reg_write(nic, NIC_PF_TL3_0_255_CHAN | (tl3 << 3), 0);
+
+	/* Enable backpressure on the channel */
+	nic_reg_write(nic, NIC_PF_CHAN_0_255_TX_CFG | (chan << 3), 1);
+
+	tl2 = tl3 >> 2;
+	nic_reg_write(nic, NIC_PF_TL3A_0_63_CFG | (tl2 << 3), tl2);
+	nic_reg_write(nic, NIC_PF_TL2_0_63_CFG | (tl2 << 3), rr_quantum);
+	/* No priorities as of now */
+	nic_reg_write(nic, NIC_PF_TL2_0_63_PRI | (tl2 << 3), 0x00);
+
+	/* Unlike 88xx where TL2s 0-31 transmits to TL1 '0' and rest to TL1 '1'
+	 * on 81xx/83xx TL2 needs to be configured to transmit to one of the
+	 * possible LMACs.
+	 *
+	 * This register doesn't exist on 88xx.
+	 */
+	if (!hw->tl1_per_bgx)
+		nic_reg_write(nic, NIC_PF_TL2_LMAC | (tl2 << 3),
+			      lmac + (bgx * MAX_LMAC_PER_BGX));
+}
+
+int nic_initialize(struct udevice *dev)
+{
+	struct nicpf *nic = dev_get_priv(dev);
+	size_t size;
+
+	nic->udev = dev;
+	nic->hw = calloc(1, sizeof(struct hw_info));
+	if (!nic->hw) {
+		return -ENOMEM;
+	}
+
+	/* MAP PF's configuration registers */
+	nic->reg_base = dm_pci_map_bar(dev, 0, &size, PCI_REGION_MEM);
+	if (!nic->reg_base) {
+		printf("Cannot map config register space, aborting\n");
+		goto exit;
+	}
+
+	nic->node = node_id(nic->reg_base);
+	dm_pci_read_config8(dev, PCI_REVISION_ID, &nic->rev_id);
+
+	/* By default set NIC in TNS bypass mode */
+	nic->flags &= ~NIC_TNS_ENABLED;
+
+	/* Initialize hardware */
+	nic_init_hw(nic);
+
+	nic_set_lmac_vf_mapping(nic);
+
+	/* Set RSS TBL size for each VF */
+	nic->rss_ind_tbl_size = NIC_MAX_RSS_IDR_TBL_SIZE;
+
+	nic->rss_ind_tbl_size = rounddown_pow_of_two(nic->rss_ind_tbl_size);
+
+	return 0;
+exit:
+	free(nic->hw);
+	return -ENODEV;
+}
+
+int octeontx_nic_probe(struct udevice *dev)
+{
+	int ret = 0;
+	struct nicpf *nicpf = dev_get_priv(dev);
+
+	ret = nic_initialize(dev);
+	if (ret < 0) {
+		printf("couldn't initialize NIC PF");
+		return ret;
+	}
+	ret = pci_sriov_init(dev, nicpf->num_vf_en);
+	if (ret < 0) {
+		printf("enabling SRIOV failed for num VFs %d",nicpf->num_vf_en);
+	}
+#if 0
+	for (int vf = 0; vf < nicpf->num_vf_en; vf++) {
+		 nicvf_initialize(dev, vf);
+	}
+#endif
+	return ret;
+}
+
+static const struct misc_ops octeontx_nic_ops = {
+};
+
+static const struct udevice_id octeontx_nic_ids[] = {
+	{ .compatible = "cavium,nic" },
+	{}
+};
+
+U_BOOT_DRIVER(octeontx_nic) = {
+	.name	= "octeontx_nic",
+	.id	= UCLASS_MISC,
+	.probe	= octeontx_nic_probe,
+	.of_match = octeontx_nic_ids,
+	.ops	= &octeontx_nic_ops,
+	.priv_auto_alloc_size = sizeof(struct nicpf),
+};
+
+static struct pci_device_id octeontx_nic_supported[] = {
+	{ PCI_VDEVICE(CAVIUM, PCI_DEVICE_ID_OCTEONTX_NIC_PF) },
+	{}
+};
+
+U_BOOT_PCI_DEVICE(octeontx_nic, octeontx_nic_supported);
+
diff --git a/drivers/net/octeontx/nic_reg.h b/drivers/net/octeontx/nic_reg.h
new file mode 100644
index 0000000..a4e7df2
--- /dev/null
+++ b/drivers/net/octeontx/nic_reg.h
@@ -0,0 +1,251 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#ifndef NIC_REG_H
+#define NIC_REG_H
+
+
+#define   NIC_PF_REG_COUNT			29573
+#define   NIC_VF_REG_COUNT			249
+
+/* Physical function register offsets */
+#define   NIC_PF_CFG				(0x0000)
+#define   NIC_PF_STATUS				(0x0010)
+
+#define   NIC_PF_INTR_TIMER_CFG			(0x0030)
+#define   NIC_PF_BIST_STATUS			(0x0040)
+#define   NIC_PF_SOFT_RESET			(0x0050)
+
+#define   NIC_PF_TCP_TIMER			(0x0060)
+#define   NIC_PF_BP_CFG				(0x0080)
+#define   NIC_PF_RRM_CFG			(0x0088)
+#define   NIC_PF_CQM_CF				(0x00A0)
+#define   NIC_PF_CNM_CF				(0x00A8)
+#define   NIC_PF_CNM_STATUS			(0x00B0)
+#define   NIC_PF_CQ_AVG_CFG			(0x00C0)
+#define   NIC_PF_RRM_AVG_CFG			(0x00C8)
+
+#define   NIC_PF_INTF_0_1_SEND_CFG		(0x0200)
+#define   NIC_PF_INTF_0_1_BP_CFG		(0x0208)
+#define   NIC_PF_INTF_0_1_BP_DIS_0_1		(0x0210)
+#define   NIC_PF_INTF_0_1_BP_SW_0_1		(0x0220)
+#define   NIC_PF_RBDR_BP_STATE_0_3		(0x0240)
+
+#define   NIC_PF_MAILBOX_INT			(0x0410)
+#define   NIC_PF_MAILBOX_INT_W1S		(0x0430)
+#define   NIC_PF_MAILBOX_ENA_W1C		(0x0450)
+#define   NIC_PF_MAILBOX_ENA_W1S		(0x0470)
+
+#define   NIC_PF_RX_ETYPE_0_7			(0x0500)
+#define   NIC_PF_RX_CFG				(0x05D0)
+#define   NIC_PF_PKIND_0_15_CFG			(0x0600)
+
+#define   NIC_PF_ECC0_FLIP0			(0x1000)
+#define   NIC_PF_ECC1_FLIP0			(0x1008)
+#define   NIC_PF_ECC2_FLIP0			(0x1010)
+#define   NIC_PF_ECC3_FLIP0			(0x1018)
+#define   NIC_PF_ECC0_FLIP1			(0x1080)
+#define   NIC_PF_ECC1_FLIP1			(0x1088)
+#define   NIC_PF_ECC2_FLIP1			(0x1090)
+#define   NIC_PF_ECC3_FLIP1			(0x1098)
+#define   NIC_PF_ECC0_CDIS			(0x1100)
+#define   NIC_PF_ECC1_CDIS			(0x1108)
+#define   NIC_PF_ECC2_CDIS			(0x1110)
+#define   NIC_PF_ECC3_CDIS			(0x1118)
+#define   NIC_PF_BIST0_STATUS			(0x1280)
+#define   NIC_PF_BIST1_STATUS			(0x1288)
+#define   NIC_PF_BIST2_STATUS			(0x1290)
+#define   NIC_PF_BIST3_STATUS			(0x1298)
+
+#define   NIC_PF_ECC0_SBE_INT			(0x2000)
+#define   NIC_PF_ECC0_SBE_INT_W1S		(0x2008)
+#define   NIC_PF_ECC0_SBE_ENA_W1C		(0x2010)
+#define   NIC_PF_ECC0_SBE_ENA_W1S		(0x2018)
+#define   NIC_PF_ECC0_DBE_INT			(0x2100)
+#define   NIC_PF_ECC0_DBE_INT_W1S		(0x2108)
+#define   NIC_PF_ECC0_DBE_ENA_W1C		(0x2110)
+#define   NIC_PF_ECC0_DBE_ENA_W1S		(0x2118)
+
+#define   NIC_PF_ECC1_SBE_INT			(0x2200)
+#define   NIC_PF_ECC1_SBE_INT_W1S		(0x2208)
+#define   NIC_PF_ECC1_SBE_ENA_W1C		(0x2210)
+#define   NIC_PF_ECC1_SBE_ENA_W1S		(0x2218)
+#define   NIC_PF_ECC1_DBE_INT			(0x2300)
+#define   NIC_PF_ECC1_DBE_INT_W1S		(0x2308)
+#define   NIC_PF_ECC1_DBE_ENA_W1C		(0x2310)
+#define   NIC_PF_ECC1_DBE_ENA_W1S		(0x2318)
+
+#define   NIC_PF_ECC2_SBE_INT			(0x2400)
+#define   NIC_PF_ECC2_SBE_INT_W1S		(0x2408)
+#define   NIC_PF_ECC2_SBE_ENA_W1C		(0x2410)
+#define   NIC_PF_ECC2_SBE_ENA_W1S		(0x2418)
+#define   NIC_PF_ECC2_DBE_INT			(0x2500)
+#define   NIC_PF_ECC2_DBE_INT_W1S		(0x2508)
+#define   NIC_PF_ECC2_DBE_ENA_W1C		(0x2510)
+#define   NIC_PF_ECC2_DBE_ENA_W1S		(0x2518)
+
+#define   NIC_PF_ECC3_SBE_INT			(0x2600)
+#define   NIC_PF_ECC3_SBE_INT_W1S		(0x2608)
+#define   NIC_PF_ECC3_SBE_ENA_W1C		(0x2610)
+#define   NIC_PF_ECC3_SBE_ENA_W1S		(0x2618)
+#define   NIC_PF_ECC3_DBE_INT			(0x2700)
+#define   NIC_PF_ECC3_DBE_INT_W1S		(0x2708)
+#define   NIC_PF_ECC3_DBE_ENA_W1C		(0x2710)
+#define   NIC_PF_ECC3_DBE_ENA_W1S		(0x2718)
+
+#define   NIC_PF_CPI_0_2047_CFG			(0x200000)
+#define   NIC_PF_MPI_0_2047_CFG			(0x210000)
+#define   NIC_PF_RSSI_0_4097_RQ			(0x220000)
+#define   NIC_PF_LMAC_0_7_CFG			(0x240000)
+#define   NIC_PF_LMAC_0_7_SW_XOFF		(0x242000)
+#define   NIC_PF_LMAC_0_7_CREDIT		(0x244000)
+#define   NIC_PF_CHAN_0_255_TX_CFG		(0x400000)
+#define   NIC_PF_CHAN_0_255_RX_CFG		(0x420000)
+#define   NIC_PF_CHAN_0_255_SW_XOFF		(0x440000)
+#define   NIC_PF_CHAN_0_255_CREDIT		(0x460000)
+#define   NIC_PF_CHAN_0_255_RX_BP_CFG		(0x480000)
+
+#define   NIC_PF_SW_SYNC_RX			(0x490000)
+
+#define   NIC_PF_SW_SYNC_RX_DONE		(0x490008)
+#define   NIC_PF_TL2_0_63_CFG			(0x500000)
+#define   NIC_PF_TL2_0_63_PRI			(0x520000)
+#define   NIC_PF_TL2_LMAC			(0x540000)
+#define   NIC_PF_TL2_0_63_SH_STATUS		(0x580000)
+#define   NIC_PF_TL3A_0_63_CFG			(0x5F0000)
+#define   NIC_PF_TL3_0_255_CFG			(0x600000)
+#define   NIC_PF_TL3_0_255_CHAN			(0x620000)
+#define   NIC_PF_TL3_0_255_PIR			(0x640000)
+#define   NIC_PF_TL3_0_255_SW_XOFF		(0x660000)
+#define   NIC_PF_TL3_0_255_CNM_RATE		(0x680000)
+#define   NIC_PF_TL3_0_255_SH_STATUS		(0x6A0000)
+#define   NIC_PF_TL4A_0_255_CFG			(0x6F0000)
+#define   NIC_PF_TL4_0_1023_CFG			(0x800000)
+#define   NIC_PF_TL4_0_1023_SW_XOFF		(0x820000)
+#define   NIC_PF_TL4_0_1023_SH_STATUS		(0x840000)
+#define   NIC_PF_TL4A_0_1023_CNM_RATE		(0x880000)
+#define   NIC_PF_TL4A_0_1023_CNM_STATUS		(0x8A0000)
+
+#define   NIC_PF_VF_0_127_MAILBOX_0_1		(0x20002030)
+#define   NIC_PF_VNIC_0_127_TX_STAT_0_4		(0x20004000)
+#define   NIC_PF_VNIC_0_127_RX_STAT_0_13	(0x20004100)
+#define   NIC_PF_QSET_0_127_LOCK_0_15		(0x20006000)
+#define   NIC_PF_QSET_0_127_CFG			(0x20010000)
+#define   NIC_PF_QSET_0_127_RQ_0_7_CFG		(0x20010400)
+#define   NIC_PF_QSET_0_127_RQ_0_7_DROP_CFG	(0x20010420)
+#define   NIC_PF_QSET_0_127_RQ_0_7_BP_CFG	(0x20010500)
+#define   NIC_PF_QSET_0_127_RQ_0_7_STAT_0_1	(0x20010600)
+#define   NIC_PF_QSET_0_127_SQ_0_7_CFG		(0x20010C00)
+#define   NIC_PF_QSET_0_127_SQ_0_7_CFG2		(0x20010C08)
+#define   NIC_PF_QSET_0_127_SQ_0_7_STAT_0_1	(0x20010D00)
+
+#define   NIC_PF_MSIX_VEC_0_18_ADDR		(0x000000)
+#define   NIC_PF_MSIX_VEC_0_CTL			(0x000008)
+#define   NIC_PF_MSIX_PBA_0			(0x0F0000)
+
+/* Virtual function register offsets */
+#define   NIC_VNIC_CFG				(0x000020)
+#define   NIC_VF_PF_MAILBOX_0_1			(0x000130)
+#define   NIC_VF_INT				(0x000200)
+#define   NIC_VF_INT_W1S			(0x000220)
+#define   NIC_VF_ENA_W1C			(0x000240)
+#define   NIC_VF_ENA_W1S			(0x000260)
+
+#define   NIC_VNIC_RSS_CFG			(0x0020E0)
+#define   NIC_VNIC_RSS_KEY_0_4			(0x002200)
+#define   NIC_VNIC_TX_STAT_0_4			(0x004000)
+#define   NIC_VNIC_RX_STAT_0_13			(0x004100)
+#define   NIC_QSET_RQ_GEN_CFG			(0x010010)
+
+#define   NIC_QSET_CQ_0_7_CFG			(0x010400)
+#define   NIC_QSET_CQ_0_7_CFG2			(0x010408)
+#define   NIC_QSET_CQ_0_7_THRESH		(0x010410)
+#define   NIC_QSET_CQ_0_7_BASE			(0x010420)
+#define   NIC_QSET_CQ_0_7_HEAD			(0x010428)
+#define   NIC_QSET_CQ_0_7_TAIL			(0x010430)
+#define   NIC_QSET_CQ_0_7_DOOR			(0x010438)
+#define   NIC_QSET_CQ_0_7_STATUS		(0x010440)
+#define   NIC_QSET_CQ_0_7_STATUS2		(0x010448)
+#define   NIC_QSET_CQ_0_7_DEBUG			(0x010450)
+
+#define   NIC_QSET_RQ_0_7_CFG			(0x010600)
+#define   NIC_QSET_RQ_0_7_STAT_0_1		(0x010700)
+
+#define   NIC_QSET_SQ_0_7_CFG			(0x010800)
+#define   NIC_QSET_SQ_0_7_THRESH		(0x010810)
+#define   NIC_QSET_SQ_0_7_BASE			(0x010820)
+#define   NIC_QSET_SQ_0_7_HEAD			(0x010828)
+#define   NIC_QSET_SQ_0_7_TAIL			(0x010830)
+#define   NIC_QSET_SQ_0_7_DOOR			(0x010838)
+#define   NIC_QSET_SQ_0_7_STATUS		(0x010840)
+#define   NIC_QSET_SQ_0_7_DEBUG			(0x010848)
+#define   NIC_QSET_SQ_0_7_CNM_CHG		(0x010860)
+#define   NIC_QSET_SQ_0_7_STAT_0_1		(0x010900)
+
+#define   NIC_QSET_RBDR_0_1_CFG			(0x010C00)
+#define   NIC_QSET_RBDR_0_1_THRESH		(0x010C10)
+#define   NIC_QSET_RBDR_0_1_BASE		(0x010C20)
+#define   NIC_QSET_RBDR_0_1_HEAD		(0x010C28)
+#define   NIC_QSET_RBDR_0_1_TAIL		(0x010C30)
+#define   NIC_QSET_RBDR_0_1_DOOR		(0x010C38)
+#define   NIC_QSET_RBDR_0_1_STATUS0		(0x010C40)
+#define   NIC_QSET_RBDR_0_1_STATUS1		(0x010C48)
+#define   NIC_QSET_RBDR_0_1_PREFETCH_STATUS	(0x010C50)
+
+#define   NIC_VF_MSIX_VECTOR_0_19_ADDR		(0x000000)
+#define   NIC_VF_MSIX_VECTOR_0_19_CTL		(0x000008)
+#define   NIC_VF_MSIX_PBA			(0x0F0000)
+
+/* Offsets within registers */
+#define   NIC_MSIX_VEC_SHIFT			4
+#define   NIC_Q_NUM_SHIFT			18
+#define   NIC_QS_ID_SHIFT			21
+#define   NIC_VF_NUM_SHIFT			21
+
+/* Port kind configuration register */
+struct pkind_cfg {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	uint64_t reserved_42_63:22;
+	uint64_t hdr_sl:5;	/* Header skip length */
+	uint64_t rx_hdr:3;	/* TNS Receive header present */
+	uint64_t lenerr_en:1;	/* L2 length error check enable */
+	uint64_t reserved_32_32:1;
+	uint64_t maxlen:16;	/* Max frame size */
+	uint64_t minlen:16;	/* Min frame size */
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	uint64_t minlen:16;
+	uint64_t maxlen:16;
+	uint64_t reserved_32_32:1;
+	uint64_t lenerr_en:1;
+	uint64_t rx_hdr:3;
+	uint64_t hdr_sl:5;
+	uint64_t reserved_42_63:22;
+#endif
+};
+
+static inline uint64_t BGXX_PF_BAR0(unsigned long param1) __attribute__ ((pure, always_inline));
+static inline uint64_t BGXX_PF_BAR0(unsigned long param1)
+{
+	assert(param1 <= 1);
+	return 0x87E0E0000000 + (param1 << 24);
+}
+#define BGXX_PF_BAR0_SIZE 0x400000
+
+#define NIC_PF_BAR0 0x843000000000
+#define NIC_PF_BAR0_SIZE 0x40000000
+
+static inline uint64_t NIC_VFX_BAR0(unsigned long param1) __attribute__ ((pure, always_inline));
+static inline uint64_t NIC_VFX_BAR0(unsigned long param1)
+{
+	assert(param1 <= 127);
+
+	return 0x8430A0000000 + (param1 << 21);
+}
+#define NIC_VFX_BAR0_SIZE 0x200000
+
+#endif /* NIC_REG_H */
diff --git a/drivers/net/octeontx/nicvf_main.c b/drivers/net/octeontx/nicvf_main.c
new file mode 100644
index 0000000..06a0208
--- /dev/null
+++ b/drivers/net/octeontx/nicvf_main.c
@@ -0,0 +1,582 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#include <config.h>
+#include <common.h>
+#include <dm.h>
+#include <pci.h>
+#include <net.h>
+#include <misc.h>
+#include <malloc.h>
+#include <asm/io.h>
+
+#include <asm/arch/octeontx_vnic.h>
+#include <asm/arch/octeontx.h>
+
+#include "nic_reg.h"
+#include "nic.h"
+#include "nicvf_queues.h"
+#include "octeontx_bgx.h"
+
+#define ETH_ALEN 6
+
+
+/* Register read/write APIs */
+void nicvf_reg_write(struct nicvf *nic, uint64_t offset, uint64_t val)
+{
+	writeq(val, nic->reg_base + offset);
+}
+
+uint64_t nicvf_reg_read(struct nicvf *nic, uint64_t offset)
+{
+	return readq(nic->reg_base + offset);
+}
+
+void nicvf_queue_reg_write(struct nicvf *nic, uint64_t offset,
+			   uint64_t qidx, uint64_t val)
+{
+	void *addr = nic->reg_base + offset;
+
+	writeq(val, (void *)(addr + (qidx << NIC_Q_NUM_SHIFT)));
+}
+
+uint64_t nicvf_queue_reg_read(struct nicvf *nic, uint64_t offset, uint64_t qidx)
+{
+	void *addr = nic->reg_base + offset;
+
+	return readq((void *)(addr + (qidx << NIC_Q_NUM_SHIFT)));
+}
+
+static void  nicvf_handle_mbx_intr(struct nicvf *nic);
+
+/* VF -> PF mailbox communication */
+static void nicvf_write_to_mbx(struct nicvf *nic, union nic_mbx *mbx)
+{
+	u64 *msg = (u64 *)mbx;
+
+	nicvf_reg_write(nic, NIC_VF_PF_MAILBOX_0_1 + 0, msg[0]);
+	nicvf_reg_write(nic, NIC_VF_PF_MAILBOX_0_1 + 8, msg[1]);
+}
+
+int nicvf_send_msg_to_pf(struct nicvf *nic, union nic_mbx *mbx)
+{
+	int timeout = NIC_PF_VF_MBX_TIMEOUT;
+	int sleep = 10;
+
+	nic->pf_acked = false;
+	nic->pf_nacked = false;
+
+	nicvf_write_to_mbx(nic, mbx);
+
+	nic_handle_mbx_intr(nic->nicpf, nic->vf_id);
+
+	/* Wait for previous message to be acked, timeout 2sec */
+	while (!nic->pf_acked) {
+		if (nic->pf_nacked)
+			return -1;
+		mdelay(sleep);
+		nicvf_handle_mbx_intr(nic);
+
+		if (nic->pf_acked)
+			break;
+		timeout -= sleep;
+		if (!timeout) {
+			printf("PF didn't ack to mbox msg %d from VF%d\n",
+			       (mbx->msg.msg & 0xFF), nic->vf_id);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+
+/* Checks if VF is able to comminicate with PF
+* and also gets the VNIC number this VF is associated to.
+*/
+static int nicvf_check_pf_ready(struct nicvf *nic)
+{
+	union nic_mbx mbx = {};
+
+	mbx.msg.msg = NIC_MBOX_MSG_READY;
+	if (nicvf_send_msg_to_pf(nic, &mbx)) {
+		printf("PF didn't respond to READY msg\n");
+		return 0;
+	}
+
+	return 1;
+}
+
+static void  nicvf_handle_mbx_intr(struct nicvf *nic)
+{
+	union nic_mbx mbx = {};
+	struct eth_pdata *pdata = dev_get_platdata(nic->dev);
+	u64 *mbx_data;
+	u64 mbx_addr;
+	int i;
+
+	mbx_addr = NIC_VF_PF_MAILBOX_0_1;
+	mbx_data = (u64 *)&mbx;
+
+	for (i = 0; i < NIC_PF_VF_MAILBOX_SIZE; i++) {
+		*mbx_data = nicvf_reg_read(nic, mbx_addr);
+		mbx_data++;
+		mbx_addr += sizeof(u64);
+	}
+
+	debug("Mbox message: msg: 0x%x\n", mbx.msg.msg);
+	switch (mbx.msg.msg) {
+	case NIC_MBOX_MSG_READY:
+		nic->pf_acked = true;
+		nic->vf_id = mbx.nic_cfg.vf_id & 0x7F;
+		nic->tns_mode = mbx.nic_cfg.tns_mode & 0x7F;
+		nic->node = mbx.nic_cfg.node_id;
+		if (!nic->set_mac_pending)
+			memcpy(pdata->enetaddr,
+					mbx.nic_cfg.mac_addr, 6);
+		nic->loopback_supported = mbx.nic_cfg.loopback_supported;
+		nic->link_up = false;
+		nic->duplex = 0;
+		nic->speed = 0;
+		break;
+	case NIC_MBOX_MSG_ACK:
+		nic->pf_acked = true;
+		break;
+	case NIC_MBOX_MSG_NACK:
+		nic->pf_nacked = true;
+		break;
+	case NIC_MBOX_MSG_BGX_LINK_CHANGE:
+		nic->pf_acked = true;
+		nic->link_up = mbx.link_status.link_up;
+		nic->duplex = mbx.link_status.duplex;
+		nic->speed = mbx.link_status.speed;
+		if (nic->link_up) {
+			printf("%s: Link is Up %d Mbps %s\n",
+				    nic->dev->name, nic->speed,
+				    nic->duplex == 1 ?
+				"Full duplex" : "Half duplex");
+		} else {
+			printf("%s: Link is Down\n",
+				    nic->dev->name);
+		}
+		break;
+	default:
+		printf("Invalid message from PF, msg 0x%x\n", mbx.msg.msg);
+		break;
+	}
+
+	nicvf_clear_intr(nic, NICVF_INTR_MBOX, 0);
+}
+
+static int nicvf_hw_set_mac_addr(struct nicvf *nic, struct udevice *dev)
+{
+	union nic_mbx mbx = {};
+	struct eth_pdata *pdata = dev_get_platdata(dev);
+
+	mbx.mac.msg = NIC_MBOX_MSG_SET_MAC;
+	mbx.mac.vf_id = nic->vf_id;
+	memcpy(mbx.mac.mac_addr, pdata->enetaddr, 6);
+
+	return nicvf_send_msg_to_pf(nic, &mbx);
+}
+
+static void nicvf_config_cpi(struct nicvf *nic)
+{
+	union nic_mbx mbx = {};
+
+	mbx.cpi_cfg.msg = NIC_MBOX_MSG_CPI_CFG;
+	mbx.cpi_cfg.vf_id = nic->vf_id;
+	mbx.cpi_cfg.cpi_alg = nic->cpi_alg;
+	mbx.cpi_cfg.rq_cnt = nic->qs->rq_cnt;
+
+	nicvf_send_msg_to_pf(nic, &mbx);
+}
+
+
+static int nicvf_init_resources(struct nicvf *nic)
+{
+	int err;
+
+	nic->num_qs = 1;
+
+	/* Enable Qset */
+	nicvf_qset_config(nic, true);
+
+	/* Initialize queues and HW for data transfer */
+	err = nicvf_config_data_transfer(nic, true);
+
+	if (err) {
+		printf("Failed to alloc/config VF's QSet resources\n");
+		return err;
+	}
+	return 0;
+}
+#if 0
+void nicvf_free_pkt(struct nicvf *nic, void *pkt)
+{
+	free(pkt);
+}
+#endif
+static void nicvf_snd_pkt_handler(struct nicvf *nic,
+				  struct cmp_queue *cq,
+				  void *cq_desc, int cqe_type)
+{
+	struct cqe_send_t *cqe_tx;
+	struct snd_queue *sq;
+	struct sq_hdr_subdesc *hdr;
+
+	cqe_tx = (struct cqe_send_t *)cq_desc;
+	sq = &nic->qs->sq[cqe_tx->sq_idx];
+
+	hdr = (struct sq_hdr_subdesc *)GET_SQ_DESC(sq, cqe_tx->sqe_ptr);
+	if (hdr->subdesc_type != SQ_DESC_TYPE_HEADER)
+		return;
+
+	nicvf_check_cqe_tx_errs(nic, cq, cq_desc);
+	nicvf_put_sq_desc(sq, hdr->subdesc_cnt + 1);
+}
+
+static int nicvf_rcv_pkt_handler(struct nicvf *nic,
+				 struct cmp_queue *cq, void *cq_desc,
+				 void **ppkt, int cqe_type)
+{
+	void *pkt;
+
+	size_t pkt_len;
+	struct cqe_rx_t *cqe_rx = (struct cqe_rx_t *)cq_desc;
+	int err = 0;
+
+	/* Check for errors */
+	err = nicvf_check_cqe_rx_errs(nic, cq, cq_desc);
+	if (err && !cqe_rx->rb_cnt)
+		return -1;
+
+	pkt = nicvf_get_rcv_pkt(nic, cq_desc, &pkt_len);
+	if (!pkt) {
+		debug("Packet not received\n");
+		return -1;
+	}
+
+	if (pkt)
+		*ppkt = pkt;
+
+	return pkt_len;
+}
+
+int nicvf_cq_handler(struct nicvf *nic, void **ppkt, int *pkt_len)
+{
+	int cq_qnum = 0;
+	int processed_sq_cqe = 0;
+	int processed_rq_cqe = 0;
+	int processed_cqe = 0;
+
+	unsigned long cqe_count, cqe_head;
+	struct queue_set *qs = nic->qs;
+	struct cmp_queue *cq = &qs->cq[cq_qnum];
+	struct cqe_rx_t *cq_desc;
+
+	/* Get num of valid CQ entries expect next one to be SQ completion */
+	cqe_count = nicvf_queue_reg_read(nic, NIC_QSET_CQ_0_7_STATUS, cq_qnum);
+	cqe_count &= 0xFFFF;
+	if (!cqe_count)
+		return 0;
+
+	/* Get head of the valid CQ entries */
+	cqe_head = nicvf_queue_reg_read(nic, NIC_QSET_CQ_0_7_HEAD, cq_qnum) >> 9;
+	cqe_head &= 0xFFFF;
+
+	if (cqe_count) {
+		/* Get the CQ descriptor */
+		cq_desc = (struct cqe_rx_t *)GET_CQ_DESC(cq, cqe_head);
+		cqe_head++;
+		cqe_head &= (cq->dmem.q_len - 1);
+		/* Initiate prefetch for next descriptor */
+		prefetch((struct cqe_rx_t *)GET_CQ_DESC(cq, cqe_head));
+
+		switch (cq_desc->cqe_type) {
+		case CQE_TYPE_RX:
+			debug("%s: Got Rx CQE\n", nic->dev->name);
+			*pkt_len = nicvf_rcv_pkt_handler(nic, cq, cq_desc, ppkt, CQE_TYPE_RX);
+			processed_rq_cqe++;
+			break;
+		case CQE_TYPE_SEND:
+			debug("%s: Got Tx CQE\n", nic->dev->name);
+			nicvf_snd_pkt_handler(nic, cq, cq_desc, CQE_TYPE_SEND);
+			processed_sq_cqe++;
+			break;
+		default:
+			debug("%s: Got CQ type %u\n", nic->dev->name, cq_desc->cqe_type);
+			break;
+		}
+		processed_cqe++;
+	}
+
+
+	/* Dequeue CQE */
+	nicvf_queue_reg_write(nic, NIC_QSET_CQ_0_7_DOOR,
+			      cq_qnum, processed_cqe);
+
+	asm volatile ("dsb sy");
+
+	return (processed_sq_cqe | processed_rq_cqe)  ;
+}
+
+/* Qset error interrupt handler
+ *
+ * As of now only CQ errors are handled
+ */
+void nicvf_handle_qs_err(struct nicvf *nic)
+{
+	struct queue_set *qs = nic->qs;
+	int qidx;
+	uint64_t status;
+
+	/* Check if it is CQ err */
+	for (qidx = 0; qidx < qs->cq_cnt; qidx++) {
+		status = nicvf_queue_reg_read(nic, NIC_QSET_CQ_0_7_STATUS,
+					      qidx);
+		if (!(status & CQ_ERR_MASK))
+			continue;
+		/* Process already queued CQEs and reconfig CQ */
+		nicvf_sq_disable(nic, qidx);
+		nicvf_cmp_queue_config(nic, qs, qidx, true);
+		nicvf_sq_free_used_descs(nic->dev, &qs->sq[qidx], qidx);
+		nicvf_sq_enable(nic, &qs->sq[qidx], qidx);
+	}
+}
+
+static int nicvf_free_pkt(struct udevice *dev, uchar *pkt, int pkt_len)
+{
+	struct nicvf *nic = dev_get_priv(dev);
+
+	if (pkt && pkt_len)
+		free(pkt);
+	nicvf_refill_rbdr(nic);
+	return 0;
+}
+
+static int nicvf_xmit(struct udevice *dev, void *pkt, int pkt_len)
+{
+	struct nicvf *nic = dev_get_priv(dev);
+	int ret = 0;
+	int rcv_len = 0;
+	unsigned int timeout = 5000;
+	void *rpkt = NULL;
+
+	if (!nicvf_sq_append_pkt(nic, pkt, pkt_len)) {
+		printf("VF%d: TX ring full\n", nic->vf_id);
+		return -1;
+	}
+
+	/* check and update CQ for pkt sent */
+	while (!ret && timeout--) {
+		ret = nicvf_cq_handler(nic, &rpkt, &rcv_len);
+		if (!ret)
+		{
+			debug("%s: %d, Not sent\n", __FUNCTION__, __LINE__);
+			udelay(10);
+		}
+	}
+
+	return 0;
+}
+
+static int nicvf_recv(struct udevice *dev, int flags, uchar **packetp)
+{
+	struct nicvf *nic = dev_get_priv(dev);
+	void *pkt;
+	int pkt_len = 0;
+#ifdef DEBUG
+	u8 *dpkt;
+	int i, j;
+#endif
+
+	nicvf_cq_handler(nic, &pkt, &pkt_len);
+
+	if (pkt_len) {
+#ifdef DEBUG
+		dpkt = pkt;
+		printf("RX packet contents:\n");
+		for (i = 0; i < 8; i++) {
+			puts("\t");
+			for (j = 0; j < 10; j++) {
+				printf("%02x ", dpkt[i * 10 + j]);
+			}
+			puts("\n");
+		}
+#endif
+		//net_process_received_packet(pkt, pkt_len);
+		//nicvf_refill_rbdr(nic);
+		*packetp = pkt;
+	}
+
+	return pkt_len;
+}
+
+void nicvf_stop(struct udevice *dev)
+{
+	struct nicvf *nic = dev_get_priv(dev);
+
+	if (!nic->open)
+		return;
+
+	/* Free resources */
+	nicvf_config_data_transfer(nic, false);
+
+	/* Disable HW Qset */
+	nicvf_qset_config(nic, false);
+
+	nic->open = false;
+}
+
+int nicvf_open(struct udevice *dev)
+{
+	int err;
+	struct nicvf *nic = dev_get_priv(dev);
+
+	nicvf_hw_set_mac_addr(nic, dev);
+
+	/* Configure CPI alorithm */
+	nic->cpi_alg = CPI_ALG_NONE;
+	nicvf_config_cpi(nic);
+
+	/* Initialize the queues */
+	err = nicvf_init_resources(nic);
+	if (err)
+		return -1;
+
+	if (!nicvf_check_pf_ready(nic)) {
+		return -1;
+	}
+
+	nic->open = true;
+
+	/* Make sure queue initialization is written */
+	asm volatile("dsb sy");
+
+	return 0;
+}
+
+struct nicpf *nicvf_get_nicpf(void)
+{
+	struct udevice *pdev;
+	int err;
+
+	err = dm_pci_find_device(PCI_VENDOR_ID_CAVIUM,
+				 PCI_DEVICE_ID_OCTEONTX_NIC_PF,
+				 0, &pdev);
+	if (err)
+		printf("%s couldn't find NIC PF device..VF probe failed\n",
+			__func__);
+
+	return (err ? NULL : dev_get_priv(pdev));
+}
+
+static int vfid = 0;
+int nicvf_initialize(struct udevice *dev)
+{
+	struct nicvf *nicvf = dev_get_priv(dev);
+	struct eth_pdata *pdata = dev_get_platdata(dev);
+	int    ret = 0, bgx, lmac;
+	size_t size;
+	char   name[16];
+	unsigned char ethaddr[ARP_HLEN];
+
+	nicvf->nicpf = nicvf_get_nicpf();
+	if (!nicvf->nicpf) {
+		printf("%s couldn't get pf device\n", __func__);
+		return -1;
+	}
+	nicvf->vf_id = vfid++;
+	nicvf->dev = dev;
+
+	/* Enable TSO support */
+	nicvf->hw_tso = true;
+
+	nicvf->reg_base = dm_pci_map_bar(dev, 9, &size, PCI_REGION_MEM);
+
+	debug("nicvf->reg_base: %p\n", nicvf->reg_base);
+
+	if (!nicvf->reg_base) {
+		printf("Cannot map config register space, aborting\n");
+		ret = -1;
+		goto fail;
+	}
+
+	ret = nicvf_set_qset_resources(nicvf);
+	if (ret)
+		return -1;
+
+	sprintf(name, "vnic%u", nicvf->vf_id);
+	debug("%s name %s\n", __func__, name);
+	device_set_name(dev, name);
+
+	bgx = NIC_GET_BGX_FROM_VF_LMAC_MAP(
+				nicvf->nicpf->vf_lmac_map[nicvf->vf_id]);
+	lmac = NIC_GET_LMAC_FROM_VF_LMAC_MAP(
+				nicvf->nicpf->vf_lmac_map[nicvf->vf_id]);
+	debug("%s VF %d BGX %d LMAC %d \n",
+		__func__, nicvf->vf_id, bgx, lmac);
+	debug("%s PF %p pfdev %p VF %p vfdev %p vf->pdata %p \n",
+		__func__, nicvf->nicpf, nicvf->nicpf->udev, nicvf, nicvf->dev, pdata);
+
+	octeontx_board_get_ethaddr(bgx, lmac, ethaddr);
+
+	debug("%s bgx %d lmac %d ethaddr %pM\n",
+		__func__, bgx, lmac, ethaddr);
+
+	memcpy(pdata->enetaddr, ethaddr, ARP_HLEN);
+	debug("%s enetaddr %pM ethaddr %pM\n",
+		__func__, pdata->enetaddr, ethaddr);
+	eth_env_set_enetaddr_by_index("eth", dev->seq, ethaddr);
+#if 0
+	if (!eth_env_get_enetaddr_by_index("eth", nicvf->vf_id, netdev->enetaddr)) {
+		eth_env_get_enetaddr("ethaddr", netdev->enetaddr);
+		netdev->enetaddr[5] += nicvf->vf_id;
+	}
+#endif
+
+fail:
+	return ret;
+}
+
+int octeontx_vnic_probe(struct udevice *dev)
+{
+	return nicvf_initialize(dev);
+}
+
+static const struct eth_ops octeontx_vnic_ops = {
+	.start = nicvf_open,
+	.stop  = nicvf_stop,
+	.send  = nicvf_xmit,
+	.recv  = nicvf_recv,
+	.free_pkt = nicvf_free_pkt,
+};
+
+static const struct udevice_id octeontx_vnic_ids[] = {
+	{ .compatible = "cavium,vnic" },
+	{}
+};
+
+U_BOOT_DRIVER(octeontx_vnic) = {
+	.name	= "vnic",
+	.id	= UCLASS_ETH,
+	.probe	= octeontx_vnic_probe,
+	.of_match = octeontx_vnic_ids,
+	.ops	= &octeontx_vnic_ops,
+	.priv_auto_alloc_size = sizeof(struct nicvf),
+	.platdata_auto_alloc_size = sizeof(struct eth_pdata),
+};
+
+static struct pci_device_id octeontx_vnic_supported[] = {
+	{ PCI_VDEVICE(CAVIUM, PCI_DEVICE_ID_OCTEONTX_NIC_VF_1) },
+	{ PCI_VDEVICE(CAVIUM, PCI_DEVICE_ID_OCTEONTX_NIC_VF_2) },
+	{}
+};
+
+U_BOOT_PCI_DEVICE(octeontx_vnic, octeontx_vnic_supported);
diff --git a/drivers/net/octeontx/nicvf_queues.c b/drivers/net/octeontx/nicvf_queues.c
new file mode 100644
index 0000000..c8cb693
--- /dev/null
+++ b/drivers/net/octeontx/nicvf_queues.c
@@ -0,0 +1,1144 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#include <config.h>
+#include <common.h>
+#include <net.h>
+#include <dm/device.h>
+#include <malloc.h>
+
+#include "nic_reg.h"
+#include "nic.h"
+#include "q_struct.h"
+#include "nicvf_queues.h"
+
+static int nicvf_poll_reg(struct nicvf *nic, int qidx,
+			  uint64_t reg, int bit_pos, int bits, int val)
+{
+	uint64_t bit_mask;
+	uint64_t reg_val;
+	int timeout = 10;
+
+	bit_mask = (1ULL << bits) - 1;
+	bit_mask = (bit_mask << bit_pos);
+
+	while (timeout) {
+		reg_val = nicvf_queue_reg_read(nic, reg, qidx);
+		if (((reg_val & bit_mask) >> bit_pos) == val)
+			return 0;
+		udelay(2000);
+		timeout--;
+	}
+	printf("Poll on reg 0x%llx failed\n", reg);
+	return 1;
+}
+
+static int nicvf_alloc_q_desc_mem(struct nicvf *nic, struct q_desc_mem *dmem,
+				  int q_len, int desc_size, int align_bytes)
+{
+	dmem->q_len = q_len;
+	dmem->size = (desc_size * q_len) + align_bytes;
+	/* Save address, need it while freeing */
+	dmem->unalign_base = calloc(1, dmem->size);
+	dmem->dma = (uintptr_t)dmem->unalign_base;
+
+	if (!dmem->unalign_base)
+		return -1;
+
+	/* Align memory address for 'align_bytes' */
+	dmem->phys_base = NICVF_ALIGNED_ADDR((u64)dmem->dma, align_bytes);
+	dmem->base = dmem->unalign_base + (dmem->phys_base - dmem->dma);
+
+	return 0;
+}
+
+static void nicvf_free_q_desc_mem(struct nicvf *nic, struct q_desc_mem *dmem)
+{
+	if (!dmem)
+		return;
+
+	free(dmem->unalign_base);
+
+	dmem->unalign_base = NULL;
+	dmem->base = NULL;
+}
+
+
+static void *nicvf_rb_ptr_to_pkt(struct nicvf *nic, uintptr_t rb_ptr)
+{
+	return (void *)rb_ptr;
+}
+
+static int nicvf_init_rbdr(struct nicvf *nic, struct rbdr *rbdr,
+			    int ring_len, int buf_size)
+{
+	int idx;
+	uintptr_t rbuf;
+	struct rbdr_entry_t *desc;
+
+	if (nicvf_alloc_q_desc_mem(nic, &rbdr->dmem, ring_len,
+				   sizeof(struct rbdr_entry_t),
+				   NICVF_RCV_BUF_ALIGN_BYTES)) {
+		printf("Unable to allocate memory for rcv buffer ring\n");
+		return -1;
+	}
+
+	rbdr->desc = rbdr->dmem.base;
+	/* Buffer size has to be in multiples of 128 bytes */
+	rbdr->dma_size = buf_size;
+	rbdr->enable = true;
+	rbdr->thresh = RBDR_THRESH;
+
+	debug("%s: %d: allocating %lld bytes for rcv buffers\n",
+	      __FUNCTION__, __LINE__,
+	      ring_len * buf_size + NICVF_RCV_BUF_ALIGN_BYTES);
+	rbdr->buf_mem = (uintptr_t)calloc(1, ring_len * buf_size
+						+ NICVF_RCV_BUF_ALIGN_BYTES);
+
+	if (!rbdr->buf_mem) {
+		printf("Unable to allocate memory for rcv buffers\n");
+		return -1;
+	}
+
+	rbdr->buffers = NICVF_ALIGNED_ADDR(rbdr->buf_mem, NICVF_RCV_BUF_ALIGN_BYTES);
+
+	debug("%s: %d: rbdr->buf_mem: %lx, rbdr->buffers: %lx\n",
+		__FUNCTION__, __LINE__, rbdr->buf_mem, rbdr->buffers);
+
+	for (idx = 0; idx < ring_len; idx++) {
+		rbuf = rbdr->buffers + DMA_BUFFER_LEN * idx;
+		desc = GET_RBDR_DESC(rbdr, idx);
+		desc->buf_addr = rbuf >> NICVF_RCV_BUF_ALIGN;
+		flush_dcache_range((uintptr_t)desc, (uintptr_t)desc + sizeof(desc));
+	}
+	return 0;
+}
+
+static void nicvf_free_rbdr(struct nicvf *nic, struct rbdr *rbdr)
+{
+	if (!rbdr)
+		return;
+
+	rbdr->enable = false;
+	if (!rbdr->dmem.base)
+		return;
+
+	debug("%s: %d: rbdr->buf_mem: %p\n", __FUNCTION__,
+	      __LINE__, (void *)rbdr->buf_mem);
+	free((void *)rbdr->buf_mem);
+
+	/* Free RBDR ring */
+	nicvf_free_q_desc_mem(nic, &rbdr->dmem);
+}
+
+/* Refill receive buffer descriptors with new buffers.
+ * This runs in softirq context .
+ */
+void nicvf_refill_rbdr(struct nicvf *nic)
+{
+	struct queue_set *qs = nic->qs;
+	int rbdr_idx = qs->rbdr_cnt;
+	unsigned long qcount, head, tail, rb_cnt;
+	struct rbdr *rbdr;
+
+	if (!rbdr_idx)
+		return;
+	rbdr_idx--;
+	rbdr = &qs->rbdr[rbdr_idx];
+	/* Check if it's enabled */
+	if (!rbdr->enable) {
+		printf("Receive queue %d is disabled\n", rbdr_idx);
+		return;
+	}
+
+	/* check if valid descs reached or crossed threshold level */
+	qcount = nicvf_queue_reg_read(nic, NIC_QSET_RBDR_0_1_STATUS0, rbdr_idx);
+	head = nicvf_queue_reg_read(nic, NIC_QSET_RBDR_0_1_HEAD, rbdr_idx);
+	tail = nicvf_queue_reg_read(nic, NIC_QSET_RBDR_0_1_TAIL, rbdr_idx);
+
+	qcount &= 0x7FFFF;
+
+	rb_cnt = qs->rbdr_len - qcount - 1;
+
+	debug("%s: %d: qcount: %lu, head: %lx, tail: %lx, rb_cnt: %lu\n",
+	      __FUNCTION__, __LINE__, qcount, head, tail, rb_cnt);
+
+
+	/* Notify HW */
+	nicvf_queue_reg_write(nic, NIC_QSET_RBDR_0_1_DOOR, rbdr_idx, rb_cnt);
+
+	asm volatile ("dsb sy");
+}
+
+
+/* TBD: how to handle full packets received in CQ
+ * i.e conversion of buffers into SKBs
+ */
+static int nicvf_init_cmp_queue(struct nicvf *nic,
+				struct cmp_queue *cq, int q_len)
+{
+	if (nicvf_alloc_q_desc_mem(nic, &cq->dmem, q_len,
+				   CMP_QUEUE_DESC_SIZE,
+				   NICVF_CQ_BASE_ALIGN_BYTES)) {
+		printf("Unable to allocate memory for completion queue\n");
+		return -1;
+	}
+	cq->desc = cq->dmem.base;
+	if (!pass1_silicon(nic->rev_id, nic->nicpf->hw->model_id))
+		cq->thresh = CMP_QUEUE_CQE_THRESH;
+	else
+		cq->thresh = 0;
+	cq->intr_timer_thresh = CMP_QUEUE_TIMER_THRESH;
+
+	return 0;
+}
+
+static void nicvf_free_cmp_queue(struct nicvf *nic, struct cmp_queue *cq)
+{
+	if (!cq)
+		return;
+	if (!cq->dmem.base)
+		return;
+
+	nicvf_free_q_desc_mem(nic, &cq->dmem);
+}
+
+static int nicvf_init_snd_queue(struct nicvf *nic,
+				struct snd_queue *sq, int q_len)
+{
+	if (nicvf_alloc_q_desc_mem(nic, &sq->dmem, q_len,
+				   SND_QUEUE_DESC_SIZE,
+				   NICVF_SQ_BASE_ALIGN_BYTES)) {
+		printf("Unable to allocate memory for send queue\n");
+		return -1;
+	}
+
+	sq->desc = sq->dmem.base;
+	sq->skbuff = calloc(q_len, sizeof(uint64_t));
+	sq->head = 0;
+	sq->tail = 0;
+	sq->free_cnt = q_len - 1;
+	sq->thresh = SND_QUEUE_THRESH;
+
+	return 0;
+}
+
+static void nicvf_free_snd_queue(struct nicvf *nic, struct snd_queue *sq)
+{
+	if (!sq)
+		return;
+	if (!sq->dmem.base)
+		return;
+
+	debug("%s: %d\n", __FUNCTION__, __LINE__);
+	free(sq->skbuff);
+
+	nicvf_free_q_desc_mem(nic, &sq->dmem);
+}
+
+static void nicvf_reclaim_snd_queue(struct nicvf *nic,
+				    struct queue_set *qs, int qidx)
+{
+	/* Disable send queue */
+	nicvf_queue_reg_write(nic, NIC_QSET_SQ_0_7_CFG, qidx, 0);
+	/* Check if SQ is stopped */
+	if (nicvf_poll_reg(nic, qidx, NIC_QSET_SQ_0_7_STATUS, 21, 1, 0x01))
+		return;
+	/* Reset send queue */
+	nicvf_queue_reg_write(nic, NIC_QSET_SQ_0_7_CFG, qidx, NICVF_SQ_RESET);
+}
+
+static void nicvf_reclaim_rcv_queue(struct nicvf *nic,
+				    struct queue_set *qs, int qidx)
+{
+	union nic_mbx mbx = {};
+
+	/* Make sure all packets in the pipeline are written back into mem */
+	mbx.msg.msg = NIC_MBOX_MSG_RQ_SW_SYNC;
+	nicvf_send_msg_to_pf(nic, &mbx);
+}
+
+static void nicvf_reclaim_cmp_queue(struct nicvf *nic,
+				    struct queue_set *qs, int qidx)
+{
+	/* Disable timer threshold (doesn't get reset upon CQ reset */
+	nicvf_queue_reg_write(nic, NIC_QSET_CQ_0_7_CFG2, qidx, 0);
+	/* Disable completion queue */
+	nicvf_queue_reg_write(nic, NIC_QSET_CQ_0_7_CFG, qidx, 0);
+	/* Reset completion queue */
+	nicvf_queue_reg_write(nic, NIC_QSET_CQ_0_7_CFG, qidx, NICVF_CQ_RESET);
+}
+
+static void nicvf_reclaim_rbdr(struct nicvf *nic,
+			       struct rbdr *rbdr, int qidx)
+{
+	u64 tmp, fifo_state;
+	int timeout = 10;
+
+	/* Save head and tail pointers for feeing up buffers */
+	rbdr->head = nicvf_queue_reg_read(nic,
+					  NIC_QSET_RBDR_0_1_HEAD,
+					  qidx) >> 3;
+	rbdr->tail = nicvf_queue_reg_read(nic,
+					  NIC_QSET_RBDR_0_1_TAIL,
+					  qidx) >> 3;
+
+	/* If RBDR FIFO is in 'FAIL' state then do a reset first
+	 * before relaiming.
+	 */
+	fifo_state = nicvf_queue_reg_read(nic, NIC_QSET_RBDR_0_1_STATUS0, qidx);
+	if (((fifo_state >> 62) & 0x03) == 0x3)
+		nicvf_queue_reg_write(nic, NIC_QSET_RBDR_0_1_CFG,
+				      qidx, NICVF_RBDR_RESET);
+
+	/* Disable RBDR */
+	nicvf_queue_reg_write(nic, NIC_QSET_RBDR_0_1_CFG, qidx, 0);
+	if (nicvf_poll_reg(nic, qidx, NIC_QSET_RBDR_0_1_STATUS0, 62, 2, 0x00))
+		return;
+	while (1) {
+		tmp = nicvf_queue_reg_read(nic,
+					   NIC_QSET_RBDR_0_1_PREFETCH_STATUS,
+					   qidx);
+		if ((tmp & 0xFFFFFFFF) == ((tmp >> 32) & 0xFFFFFFFF))
+			break;
+		mdelay(2000);
+		timeout--;
+		if (!timeout) {
+			printf("Failed polling on prefetch status\n");
+			return;
+		}
+	}
+	nicvf_queue_reg_write(nic, NIC_QSET_RBDR_0_1_CFG,
+			      qidx, NICVF_RBDR_RESET);
+
+	if (nicvf_poll_reg(nic, qidx, NIC_QSET_RBDR_0_1_STATUS0, 62, 2, 0x02))
+		return;
+	nicvf_queue_reg_write(nic, NIC_QSET_RBDR_0_1_CFG, qidx, 0x00);
+	if (nicvf_poll_reg(nic, qidx, NIC_QSET_RBDR_0_1_STATUS0, 62, 2, 0x00))
+		return;
+}
+
+
+/* Configures receive queue */
+static void nicvf_rcv_queue_config(struct nicvf *nic, struct queue_set *qs,
+				   int qidx, bool enable)
+{
+	union nic_mbx mbx = {};
+	struct rcv_queue *rq;
+	union {
+		struct rq_cfg s;
+		u64    u;
+	} rq_cfg;
+
+	rq = &qs->rq[qidx];
+	rq->enable = enable;
+
+	/* Disable receive queue */
+	nicvf_queue_reg_write(nic, NIC_QSET_RQ_0_7_CFG, qidx, 0);
+
+	if (!rq->enable) {
+		nicvf_reclaim_rcv_queue(nic, qs, qidx);
+		return;
+	}
+
+	rq->cq_qs = qs->vnic_id;
+	rq->cq_idx = qidx;
+	rq->start_rbdr_qs = qs->vnic_id;
+	rq->start_qs_rbdr_idx = qs->rbdr_cnt - 1;
+	rq->cont_rbdr_qs = qs->vnic_id;
+	rq->cont_qs_rbdr_idx = qs->rbdr_cnt - 1;
+	/* all writes of RBDR data to be loaded into L2 Cache as well*/
+	rq->caching = 1;
+
+	/* Send a mailbox msg to PF to config RQ */
+	mbx.rq.msg = NIC_MBOX_MSG_RQ_CFG;
+	mbx.rq.qs_num = qs->vnic_id;
+	mbx.rq.rq_num = qidx;
+	mbx.rq.cfg = (rq->caching << 26) | (rq->cq_qs << 19) |
+			  (rq->cq_idx << 16) | (rq->cont_rbdr_qs << 9) |
+			  (rq->cont_qs_rbdr_idx << 8) |
+			  (rq->start_rbdr_qs << 1) | (rq->start_qs_rbdr_idx);
+	nicvf_send_msg_to_pf(nic, &mbx);
+
+	mbx.rq.msg = NIC_MBOX_MSG_RQ_BP_CFG;
+	mbx.rq.cfg = (1ULL << 63) | (1ULL << 62) | (qs->vnic_id << 0);
+	nicvf_send_msg_to_pf(nic, &mbx);
+
+	/* RQ drop config
+	 * Enable CQ drop to reserve sufficient CQEs for all tx packets
+	 */
+	mbx.rq.msg = NIC_MBOX_MSG_RQ_DROP_CFG;
+	mbx.rq.cfg = (1ULL << 62) | (RQ_CQ_DROP << 8);
+	nicvf_send_msg_to_pf(nic, &mbx);
+	nicvf_queue_reg_write(nic, NIC_QSET_RQ_GEN_CFG, 0, 0x00);
+
+	/* Enable Receive queue */
+	rq_cfg.s.ena = 1;
+	rq_cfg.s.tcp_ena = 0;
+	nicvf_queue_reg_write(nic, NIC_QSET_RQ_0_7_CFG, qidx, rq_cfg.u);
+}
+
+void nicvf_cmp_queue_config(struct nicvf *nic, struct queue_set *qs,
+			    int qidx, bool enable)
+{
+	struct cmp_queue *cq;
+	union {
+		uint64_t u;
+		struct cq_cfg s;
+	} cq_cfg;
+
+	cq = &qs->cq[qidx];
+	cq->enable = enable;
+
+	if (!cq->enable) {
+		nicvf_reclaim_cmp_queue(nic, qs, qidx);
+		return;
+	}
+
+	/* Reset completion queue */
+	nicvf_queue_reg_write(nic, NIC_QSET_CQ_0_7_CFG, qidx, NICVF_CQ_RESET);
+
+	if (!cq->enable)
+		return;
+
+	/* Set completion queue base address */
+	nicvf_queue_reg_write(nic, NIC_QSET_CQ_0_7_BASE,
+			      qidx, (uint64_t)(cq->dmem.phys_base));
+
+	/* Enable Completion queue */
+	cq_cfg.s.ena = 1;
+	cq_cfg.s.reset = 0;
+	cq_cfg.s.caching = 0;
+	cq_cfg.s.qsize = CMP_QSIZE;
+	cq_cfg.s.avg_con = 0;
+	nicvf_queue_reg_write(nic, NIC_QSET_CQ_0_7_CFG, qidx, cq_cfg.u);
+
+	/* Set threshold value for interrupt generation */
+	nicvf_queue_reg_write(nic, NIC_QSET_CQ_0_7_THRESH, qidx, cq->thresh);
+	nicvf_queue_reg_write(nic, NIC_QSET_CQ_0_7_CFG2, qidx, cq->intr_timer_thresh);
+}
+
+/* Configures transmit queue */
+static void nicvf_snd_queue_config(struct nicvf *nic, struct queue_set *qs,
+				   int qidx, bool enable)
+{
+	union nic_mbx mbx = {};
+	struct snd_queue *sq;
+
+	union {
+		struct sq_cfg s;
+		u64 u;
+	} sq_cfg;
+
+	sq = &qs->sq[qidx];
+	sq->enable = enable;
+
+	if (!sq->enable) {
+		nicvf_reclaim_snd_queue(nic, qs, qidx);
+		return;
+	}
+
+	/* Reset send queue */
+	nicvf_queue_reg_write(nic, NIC_QSET_SQ_0_7_CFG, qidx, NICVF_SQ_RESET);
+
+	sq->cq_qs = qs->vnic_id;
+	sq->cq_idx = qidx;
+
+	/* Send a mailbox msg to PF to config SQ */
+	mbx.sq.msg = NIC_MBOX_MSG_SQ_CFG;
+	mbx.sq.qs_num = qs->vnic_id;
+	mbx.sq.sq_num = qidx;
+	mbx.sq.sqs_mode = nic->sqs_mode;
+	mbx.sq.cfg = (sq->cq_qs << 3) | sq->cq_idx;
+	nicvf_send_msg_to_pf(nic, &mbx);
+
+	/* Set queue base address */
+	nicvf_queue_reg_write(nic, NIC_QSET_SQ_0_7_BASE,
+			      qidx, (u64)(sq->dmem.phys_base));
+
+	/* Enable send queue  & set queue size */
+	sq_cfg.s.ena = 1;
+	sq_cfg.s.reset = 0;
+	sq_cfg.s.ldwb = 0;
+	sq_cfg.s.qsize = SND_QSIZE;
+	sq_cfg.s.tstmp_bgx_intf = 0;
+	nicvf_queue_reg_write(nic, NIC_QSET_SQ_0_7_CFG, qidx, sq_cfg.u);
+
+	/* Set threshold value for interrupt generation */
+	nicvf_queue_reg_write(nic, NIC_QSET_SQ_0_7_THRESH, qidx, sq->thresh);
+}
+
+/* Configures receive buffer descriptor ring */
+static void nicvf_rbdr_config(struct nicvf *nic, struct queue_set *qs,
+			      int qidx, bool enable)
+{
+	struct rbdr *rbdr;
+	union {
+		struct rbdr_cfg s;
+		u64 u;
+	} rbdr_cfg;
+
+	rbdr = &qs->rbdr[qidx];
+	nicvf_reclaim_rbdr(nic, rbdr, qidx);
+	if (!enable)
+		return;
+
+	/* Set descriptor base address */
+	nicvf_queue_reg_write(nic, NIC_QSET_RBDR_0_1_BASE,
+			      qidx, (u64)(rbdr->dmem.phys_base));
+
+	/* Enable RBDR  & set queue size */
+	/* Buffer size should be in multiples of 128 bytes */
+	rbdr_cfg.s.ena = 1;
+	rbdr_cfg.s.reset = 0;
+	rbdr_cfg.s.ldwb = 0;
+	rbdr_cfg.s.qsize = RBDR_SIZE;
+	rbdr_cfg.s.avg_con = 0;
+	rbdr_cfg.s.lines = rbdr->dma_size / 128;
+	nicvf_queue_reg_write(nic, NIC_QSET_RBDR_0_1_CFG,
+			      qidx, rbdr_cfg.u);
+
+	/* Notify HW */
+	nicvf_queue_reg_write(nic, NIC_QSET_RBDR_0_1_DOOR,
+			      qidx, qs->rbdr_len - 1);
+
+	/* Set threshold value for interrupt generation */
+	nicvf_queue_reg_write(nic, NIC_QSET_RBDR_0_1_THRESH,
+			      qidx, rbdr->thresh - 1);
+}
+
+/* Requests PF to assign and enable Qset */
+void nicvf_qset_config(struct nicvf *nic, bool enable)
+{
+	union nic_mbx mbx = {};
+	struct queue_set *qs = nic->qs;
+	struct qs_cfg *qs_cfg;
+
+	if (!qs) {
+		printf("Qset is still not allocated, don't init queues\n");
+		return;
+	}
+
+	qs->enable = enable;
+	qs->vnic_id = nic->vf_id;
+
+	/* Send a mailbox msg to PF to config Qset */
+	mbx.qs.msg = NIC_MBOX_MSG_QS_CFG;
+	mbx.qs.num = qs->vnic_id;
+#ifdef VNIC_MULTI_QSET_SUPPORT
+	mbx.qs.sqs_count = nic->sqs_count;
+#endif
+
+	mbx.qs.cfg = 0;
+	qs_cfg = (struct qs_cfg *)&mbx.qs.cfg;
+	if (qs->enable) {
+		qs_cfg->ena = 1;
+#ifdef __BIG_ENDIAN
+		qs_cfg->be = 1;
+#endif
+		qs_cfg->vnic = qs->vnic_id;
+	}
+	nicvf_send_msg_to_pf(nic, &mbx);
+}
+
+static void nicvf_free_resources(struct nicvf *nic)
+{
+	int qidx;
+	struct queue_set *qs = nic->qs;
+
+	/* Free receive buffer descriptor ring */
+	for (qidx = 0; qidx < qs->rbdr_cnt; qidx++)
+		nicvf_free_rbdr(nic, &qs->rbdr[qidx]);
+
+	/* Free completion queue */
+	for (qidx = 0; qidx < qs->cq_cnt; qidx++)
+		nicvf_free_cmp_queue(nic, &qs->cq[qidx]);
+
+	/* Free send queue */
+	for (qidx = 0; qidx < qs->sq_cnt; qidx++)
+		nicvf_free_snd_queue(nic, &qs->sq[qidx]);
+}
+
+static int nicvf_alloc_resources(struct nicvf *nic)
+{
+	int qidx;
+	struct queue_set *qs = nic->qs;
+
+	/* Alloc receive buffer descriptor ring */
+	for (qidx = 0; qidx < qs->rbdr_cnt; qidx++) {
+		if (nicvf_init_rbdr(nic, &qs->rbdr[qidx], qs->rbdr_len,
+				    DMA_BUFFER_LEN))
+			goto alloc_fail;
+	}
+
+	/* Alloc send queue */
+	for (qidx = 0; qidx < qs->sq_cnt; qidx++) {
+		if (nicvf_init_snd_queue(nic, &qs->sq[qidx], qs->sq_len))
+			goto alloc_fail;
+	}
+
+	/* Alloc completion queue */
+	for (qidx = 0; qidx < qs->cq_cnt; qidx++) {
+		if (nicvf_init_cmp_queue(nic, &qs->cq[qidx], qs->cq_len))
+			goto alloc_fail;
+	}
+
+	return 0;
+alloc_fail:
+	nicvf_free_resources(nic);
+	return -1;
+}
+
+int nicvf_set_qset_resources(struct nicvf *nic)
+{
+	struct queue_set *qs;
+
+	qs = calloc(1, sizeof(struct queue_set));
+	if (!qs)
+		return -1;
+	nic->qs = qs;
+
+	/* Set count of each queue */
+	qs->rbdr_cnt = RBDR_CNT;
+	qs->rq_cnt = 1;
+	qs->sq_cnt = SND_QUEUE_CNT;
+	qs->cq_cnt = CMP_QUEUE_CNT;
+
+	/* Set queue lengths */
+	qs->rbdr_len = RCV_BUF_COUNT;
+	qs->sq_len = SND_QUEUE_LEN;
+	qs->cq_len = CMP_QUEUE_LEN;
+
+	nic->rx_queues = qs->rq_cnt;
+	nic->tx_queues = qs->sq_cnt;
+
+	return 0;
+}
+
+int nicvf_config_data_transfer(struct nicvf *nic, bool enable)
+{
+	bool disable = false;
+	struct queue_set *qs = nic->qs;
+	int qidx;
+
+	if (!qs)
+		return 0;
+
+	if (enable) {
+		if (nicvf_alloc_resources(nic))
+			return -1;
+
+		for (qidx = 0; qidx < qs->sq_cnt; qidx++)
+			nicvf_snd_queue_config(nic, qs, qidx, enable);
+		for (qidx = 0; qidx < qs->cq_cnt; qidx++)
+			nicvf_cmp_queue_config(nic, qs, qidx, enable);
+		for (qidx = 0; qidx < qs->rbdr_cnt; qidx++)
+			nicvf_rbdr_config(nic, qs, qidx, enable);
+		for (qidx = 0; qidx < qs->rq_cnt; qidx++)
+			nicvf_rcv_queue_config(nic, qs, qidx, enable);
+	} else {
+		for (qidx = 0; qidx < qs->rq_cnt; qidx++)
+			nicvf_rcv_queue_config(nic, qs, qidx, disable);
+		for (qidx = 0; qidx < qs->rbdr_cnt; qidx++)
+			nicvf_rbdr_config(nic, qs, qidx, disable);
+		for (qidx = 0; qidx < qs->sq_cnt; qidx++)
+			nicvf_snd_queue_config(nic, qs, qidx, disable);
+		for (qidx = 0; qidx < qs->cq_cnt; qidx++)
+			nicvf_cmp_queue_config(nic, qs, qidx, disable);
+
+		nicvf_free_resources(nic);
+	}
+
+	return 0;
+}
+
+/* Get a free desc from SQ
+ * returns descriptor ponter & descriptor number
+ */
+static int nicvf_get_sq_desc(struct snd_queue *sq, int desc_cnt)
+{
+	int qentry;
+
+	qentry = sq->tail;
+	sq->free_cnt -= desc_cnt;
+	sq->tail += desc_cnt;
+	sq->tail &= (sq->dmem.q_len - 1);
+
+	return qentry;
+}
+
+/* Free descriptor back to SQ for future use */
+void nicvf_put_sq_desc(struct snd_queue *sq, int desc_cnt)
+{
+	sq->free_cnt += desc_cnt;
+	sq->head += desc_cnt;
+	sq->head &= (sq->dmem.q_len - 1);
+}
+
+static int nicvf_get_nxt_sqentry(struct snd_queue *sq, int qentry)
+{
+	qentry++;
+	qentry &= (sq->dmem.q_len - 1);
+	return qentry;
+}
+
+void nicvf_sq_enable(struct nicvf *nic, struct snd_queue *sq, int qidx)
+{
+	uint64_t sq_cfg;
+
+	sq_cfg = nicvf_queue_reg_read(nic, NIC_QSET_SQ_0_7_CFG, qidx);
+	sq_cfg |= NICVF_SQ_EN;
+	nicvf_queue_reg_write(nic, NIC_QSET_SQ_0_7_CFG, qidx, sq_cfg);
+	/* Ring doorbell so that H/W restarts processing SQEs */
+	nicvf_queue_reg_write(nic, NIC_QSET_SQ_0_7_DOOR, qidx, 0);
+}
+
+void nicvf_sq_disable(struct nicvf *nic, int qidx)
+{
+	uint64_t sq_cfg;
+
+	sq_cfg = nicvf_queue_reg_read(nic, NIC_QSET_SQ_0_7_CFG, qidx);
+	sq_cfg &= ~NICVF_SQ_EN;
+	nicvf_queue_reg_write(nic, NIC_QSET_SQ_0_7_CFG, qidx, sq_cfg);
+}
+
+void nicvf_sq_free_used_descs(struct udevice *dev, struct snd_queue *sq,
+								int qidx)
+{
+	uint64_t head;
+	struct nicvf *nic = dev_get_priv(dev);
+	struct sq_hdr_subdesc *hdr;
+
+	head = nicvf_queue_reg_read(nic, NIC_QSET_SQ_0_7_HEAD, qidx) >> 4;
+
+	while (sq->head != head) {
+		hdr = (struct sq_hdr_subdesc *)GET_SQ_DESC(sq, sq->head);
+		if (hdr->subdesc_type != SQ_DESC_TYPE_HEADER) {
+			nicvf_put_sq_desc(sq, 1);
+			continue;
+		}
+		nicvf_put_sq_desc(sq, hdr->subdesc_cnt + 1);
+	}
+}
+
+/* Get the number of SQ descriptors needed to xmit this skb */
+static int nicvf_sq_subdesc_required(struct nicvf *nic)
+{
+	int subdesc_cnt = MIN_SQ_DESC_PER_PKT_XMIT;
+
+	return subdesc_cnt;
+}
+
+/* Add SQ HEADER subdescriptor.
+ * First subdescriptor for every send descriptor.
+ */
+static inline void
+nicvf_sq_add_hdr_subdesc(struct nicvf *nic, struct snd_queue *sq, int qentry,
+			 int subdesc_cnt, void *pkt, size_t pkt_len)
+{
+	struct sq_hdr_subdesc *hdr;
+
+	hdr = (struct sq_hdr_subdesc *)GET_SQ_DESC(sq, qentry);
+	sq->skbuff[qentry] = (uintptr_t)pkt;
+
+	memset(hdr, 0, SND_QUEUE_DESC_SIZE);
+	hdr->subdesc_type = SQ_DESC_TYPE_HEADER;
+	/* Enable notification via CQE after processing SQE */
+	hdr->post_cqe = 1;
+	/* No of subdescriptors following this */
+	hdr->subdesc_cnt = subdesc_cnt;
+	hdr->tot_len = pkt_len;
+
+	flush_dcache_range((uintptr_t)hdr,
+			   (uintptr_t)hdr + sizeof(struct sq_hdr_subdesc));
+}
+
+/* SQ GATHER subdescriptor
+ * Must follow HDR descriptor
+ */
+static inline void nicvf_sq_add_gather_subdesc(struct snd_queue *sq, int qentry,
+					       size_t size, uintptr_t data)
+{
+	struct sq_gather_subdesc *gather;
+
+	qentry &= (sq->dmem.q_len - 1);
+	gather = (struct sq_gather_subdesc *)GET_SQ_DESC(sq, qentry);
+
+	memset(gather, 0, SND_QUEUE_DESC_SIZE);
+	gather->subdesc_type = SQ_DESC_TYPE_GATHER;
+	gather->ld_type = NIC_SEND_LD_TYPE_E_LDD;
+	gather->size = size;
+	gather->addr = data;
+
+	flush_dcache_range((uintptr_t)gather,
+			   (uintptr_t)gather + sizeof(struct sq_hdr_subdesc));
+}
+
+/* Append an skb to a SQ for packet transfer. */
+int nicvf_sq_append_pkt(struct nicvf *nic, void *pkt, size_t pkt_size)
+{
+	int subdesc_cnt;
+	int sq_num = 0, qentry;
+	struct queue_set *qs;
+	struct snd_queue *sq;
+
+	qs = nic->qs;
+	sq = &qs->sq[sq_num];
+
+	subdesc_cnt = nicvf_sq_subdesc_required(nic);
+	if (subdesc_cnt > sq->free_cnt)
+		goto append_fail;
+
+	qentry = nicvf_get_sq_desc(sq, subdesc_cnt);
+
+	/* Add SQ header subdesc */
+	nicvf_sq_add_hdr_subdesc(nic, sq, qentry, subdesc_cnt - 1,
+				 pkt, pkt_size);
+
+	/* Add SQ gather subdescs */
+	qentry = nicvf_get_nxt_sqentry(sq, qentry);
+	nicvf_sq_add_gather_subdesc(sq, qentry, pkt_size, (uintptr_t)(pkt));
+
+	flush_dcache_range((uintptr_t)pkt,
+			   (uintptr_t)pkt + pkt_size);
+
+	/* make sure all memory stores are done before ringing doorbell */
+	asm volatile ("dsb sy");
+
+	/* Inform HW to xmit new packet */
+	nicvf_queue_reg_write(nic, NIC_QSET_SQ_0_7_DOOR,
+			      sq_num, subdesc_cnt);
+	return 1;
+
+append_fail:
+	printf("Not enough SQ descriptors to xmit pkt\n");
+	return 0;
+}
+
+static unsigned frag_num(unsigned i)
+{
+#ifdef __BIG_ENDIAN
+	return (i & ~3) + 3 - (i & 3);
+#else
+	return i;
+#endif
+}
+
+void *nicvf_get_rcv_pkt(struct nicvf *nic, void *cq_desc, size_t *pkt_len)
+{
+	int frag;
+	int payload_len = 0, tot_len;
+	void *pkt = NULL, *pkt_buf = NULL, *buffer;
+	struct cqe_rx_t *cqe_rx;
+	struct rbdr *rbdr;
+	struct rcv_queue *rq;
+	struct queue_set *qs = nic->qs;
+	uint16_t *rb_lens = NULL;
+	uint64_t *rb_ptrs = NULL;
+
+	cqe_rx = (struct cqe_rx_t *)cq_desc;
+
+	rq = &qs->rq[cqe_rx->rq_idx];
+	rbdr = &qs->rbdr[rq->start_qs_rbdr_idx];
+	rb_lens = cq_desc + (3 * sizeof(uint64_t)); /* Use offsetof */
+	/* Except 88xx pass1 on all other chips CQE_RX2_S is added to
+	 * CQE_RX at word6, hence buffer pointers move by word
+	 *
+	 * Use existing 'hw_tso' flag which will be set for all chips
+	 * except 88xx pass1 instead of a additional cache line
+	 * access (or miss) by using pci dev's revision.
+	 */
+	if (!nic->hw_tso)
+		rb_ptrs = (void *)cqe_rx + (6 * sizeof(u64));
+	else
+		rb_ptrs = (void *)cqe_rx + (7 * sizeof(u64));
+
+	/*
+	 * Figure out packet length to create packet buffer
+	 */
+	for (frag = 0; frag < cqe_rx->rb_cnt; frag++)
+		payload_len += rb_lens[frag_num(frag)];
+	*pkt_len = payload_len;
+	/* round up size to 8 byte multiple */
+	tot_len = (payload_len & (~0x7)) + 8;
+	buffer = calloc(1, tot_len);
+	if (!buffer) {
+		printf("%s - Failed to allocate packet buffer\n", __func__);
+		return NULL;
+	}
+	pkt_buf = buffer;
+	debug("total pkt buf %p len %ld tot_len %d\n", pkt_buf, *pkt_len,
+	      tot_len);
+	for (frag = 0; frag < cqe_rx->rb_cnt; frag++) {
+		payload_len = rb_lens[frag_num(frag)];
+
+		invalidate_dcache_range((uintptr_t)(*rb_ptrs),
+					(uintptr_t)(*rb_ptrs) + rbdr->dma_size);
+
+		/* First fragment */
+		*rb_ptrs = *rb_ptrs - cqe_rx->align_pad;
+
+		pkt = nicvf_rb_ptr_to_pkt(nic, *rb_ptrs);
+
+		invalidate_dcache_range((uintptr_t)pkt,
+					(uintptr_t)pkt + payload_len);
+
+		if (cqe_rx->align_pad) {
+			pkt += cqe_rx->align_pad;
+		}
+		debug("pkt_buf %p, pkt %p payload_len %d\n", pkt_buf, pkt,
+		      payload_len);
+		memcpy(buffer, pkt, payload_len);
+		buffer += payload_len;
+		/* Next buffer pointer */
+		rb_ptrs++;
+	}
+	return pkt_buf;
+}
+
+/* Clear interrupt */
+void nicvf_clear_intr(struct nicvf *nic, int int_type, int q_idx)
+{
+	uint64_t reg_val = 0;
+
+	switch (int_type) {
+	case NICVF_INTR_CQ:
+		reg_val = ((1ULL << q_idx) << NICVF_INTR_CQ_SHIFT);
+	break;
+	case NICVF_INTR_SQ:
+		reg_val = ((1ULL << q_idx) << NICVF_INTR_SQ_SHIFT);
+	break;
+	case NICVF_INTR_RBDR:
+		reg_val = ((1ULL << q_idx) << NICVF_INTR_RBDR_SHIFT);
+	break;
+	case NICVF_INTR_PKT_DROP:
+		reg_val = (1ULL << NICVF_INTR_PKT_DROP_SHIFT);
+	break;
+	case NICVF_INTR_TCP_TIMER:
+		reg_val = (1ULL << NICVF_INTR_TCP_TIMER_SHIFT);
+	break;
+	case NICVF_INTR_MBOX:
+		reg_val = (1ULL << NICVF_INTR_MBOX_SHIFT);
+	break;
+	case NICVF_INTR_QS_ERR:
+		reg_val |= (1ULL << NICVF_INTR_QS_ERR_SHIFT);
+	break;
+	default:
+		printf("Failed to clear interrupt: unknown type\n");
+	break;
+	}
+
+	nicvf_reg_write(nic, NIC_VF_INT, reg_val);
+}
+
+void nicvf_update_rq_stats(struct nicvf *nic, int rq_idx)
+{
+	struct rcv_queue *rq;
+
+#define GET_RQ_STATS(reg) \
+	nicvf_reg_read(nic, NIC_QSET_RQ_0_7_STAT_0_1 |\
+			    (rq_idx << NIC_Q_NUM_SHIFT) | (reg << 3))
+
+	rq = &nic->qs->rq[rq_idx];
+	rq->stats.bytes = GET_RQ_STATS(RQ_SQ_STATS_OCTS);
+	rq->stats.pkts = GET_RQ_STATS(RQ_SQ_STATS_PKTS);
+}
+
+void nicvf_update_sq_stats(struct nicvf *nic, int sq_idx)
+{
+	struct snd_queue *sq;
+
+#define GET_SQ_STATS(reg) \
+	nicvf_reg_read(nic, NIC_QSET_SQ_0_7_STAT_0_1 |\
+			    (sq_idx << NIC_Q_NUM_SHIFT) | (reg << 3))
+
+	sq = &nic->qs->sq[sq_idx];
+	sq->stats.bytes = GET_SQ_STATS(RQ_SQ_STATS_OCTS);
+	sq->stats.pkts = GET_SQ_STATS(RQ_SQ_STATS_PKTS);
+}
+
+/* Check for errors in the receive cmp.queue entry */
+int nicvf_check_cqe_rx_errs(struct nicvf *nic,
+			    struct cmp_queue *cq, void *cq_desc)
+{
+	struct cqe_rx_t *cqe_rx;
+	struct cmp_queue_stats *stats = &cq->stats;
+
+	cqe_rx = (struct cqe_rx_t *)cq_desc;
+	if (!cqe_rx->err_level && !cqe_rx->err_opcode) {
+		stats->rx.errop.good++;
+		return 0;
+	}
+
+	switch (cqe_rx->err_level) {
+	case CQ_ERRLVL_MAC:
+		stats->rx.errlvl.mac_errs++;
+	break;
+	case CQ_ERRLVL_L2:
+		stats->rx.errlvl.l2_errs++;
+	break;
+	case CQ_ERRLVL_L3:
+		stats->rx.errlvl.l3_errs++;
+	break;
+	case CQ_ERRLVL_L4:
+		stats->rx.errlvl.l4_errs++;
+	break;
+	}
+
+	switch (cqe_rx->err_opcode) {
+	case CQ_RX_ERROP_RE_PARTIAL:
+		stats->rx.errop.partial_pkts++;
+	break;
+	case CQ_RX_ERROP_RE_JABBER:
+		stats->rx.errop.jabber_errs++;
+	break;
+	case CQ_RX_ERROP_RE_FCS:
+		stats->rx.errop.fcs_errs++;
+	break;
+	case CQ_RX_ERROP_RE_TERMINATE:
+		stats->rx.errop.terminate_errs++;
+	break;
+	case CQ_RX_ERROP_RE_RX_CTL:
+		stats->rx.errop.bgx_rx_errs++;
+	break;
+	case CQ_RX_ERROP_PREL2_ERR:
+		stats->rx.errop.prel2_errs++;
+	break;
+	case CQ_RX_ERROP_L2_FRAGMENT:
+		stats->rx.errop.l2_frags++;
+	break;
+	case CQ_RX_ERROP_L2_OVERRUN:
+		stats->rx.errop.l2_overruns++;
+	break;
+	case CQ_RX_ERROP_L2_PFCS:
+		stats->rx.errop.l2_pfcs++;
+	break;
+	case CQ_RX_ERROP_L2_PUNY:
+		stats->rx.errop.l2_puny++;
+	break;
+	case CQ_RX_ERROP_L2_MAL:
+		stats->rx.errop.l2_hdr_malformed++;
+	break;
+	case CQ_RX_ERROP_L2_OVERSIZE:
+		stats->rx.errop.l2_oversize++;
+	break;
+	case CQ_RX_ERROP_L2_UNDERSIZE:
+		stats->rx.errop.l2_undersize++;
+	break;
+	case CQ_RX_ERROP_L2_LENMISM:
+		stats->rx.errop.l2_len_mismatch++;
+	break;
+	case CQ_RX_ERROP_L2_PCLP:
+		stats->rx.errop.l2_pclp++;
+	break;
+	case CQ_RX_ERROP_IP_NOT:
+		stats->rx.errop.non_ip++;
+	break;
+	case CQ_RX_ERROP_IP_CSUM_ERR:
+		stats->rx.errop.ip_csum_err++;
+	break;
+	case CQ_RX_ERROP_IP_MAL:
+		stats->rx.errop.ip_hdr_malformed++;
+	break;
+	case CQ_RX_ERROP_IP_MALD:
+		stats->rx.errop.ip_payload_malformed++;
+	break;
+	case CQ_RX_ERROP_IP_HOP:
+		stats->rx.errop.ip_hop_errs++;
+	break;
+	case CQ_RX_ERROP_L3_ICRC:
+		stats->rx.errop.l3_icrc_errs++;
+	break;
+	case CQ_RX_ERROP_L3_PCLP:
+		stats->rx.errop.l3_pclp++;
+	break;
+	case CQ_RX_ERROP_L4_MAL:
+		stats->rx.errop.l4_malformed++;
+	break;
+	case CQ_RX_ERROP_L4_CHK:
+		stats->rx.errop.l4_csum_errs++;
+	break;
+	case CQ_RX_ERROP_UDP_LEN:
+		stats->rx.errop.udp_len_err++;
+	break;
+	case CQ_RX_ERROP_L4_PORT:
+		stats->rx.errop.bad_l4_port++;
+	break;
+	case CQ_RX_ERROP_TCP_FLAG:
+		stats->rx.errop.bad_tcp_flag++;
+	break;
+	case CQ_RX_ERROP_TCP_OFFSET:
+		stats->rx.errop.tcp_offset_errs++;
+	break;
+	case CQ_RX_ERROP_L4_PCLP:
+		stats->rx.errop.l4_pclp++;
+	break;
+	case CQ_RX_ERROP_RBDR_TRUNC:
+		stats->rx.errop.pkt_truncated++;
+	break;
+	}
+
+	return 1;
+}
+
+/* Check for errors in the send cmp.queue entry */
+int nicvf_check_cqe_tx_errs(struct nicvf *nic,
+			    struct cmp_queue *cq, void *cq_desc)
+{
+	struct cqe_send_t *cqe_tx;
+	struct cmp_queue_stats *stats = &cq->stats;
+
+	cqe_tx = (struct cqe_send_t *)cq_desc;
+	switch (cqe_tx->send_status) {
+	case CQ_TX_ERROP_GOOD:
+		stats->tx.good++;
+		return 0;
+	break;
+	case CQ_TX_ERROP_DESC_FAULT:
+		stats->tx.desc_fault++;
+	break;
+	case CQ_TX_ERROP_HDR_CONS_ERR:
+		stats->tx.hdr_cons_err++;
+	break;
+	case CQ_TX_ERROP_SUBDC_ERR:
+		stats->tx.subdesc_err++;
+	break;
+	case CQ_TX_ERROP_IMM_SIZE_OFLOW:
+		stats->tx.imm_size_oflow++;
+	break;
+	case CQ_TX_ERROP_DATA_SEQUENCE_ERR:
+		stats->tx.data_seq_err++;
+	break;
+	case CQ_TX_ERROP_MEM_SEQUENCE_ERR:
+		stats->tx.mem_seq_err++;
+	break;
+	case CQ_TX_ERROP_LOCK_VIOL:
+		stats->tx.lock_viol++;
+	break;
+	case CQ_TX_ERROP_DATA_FAULT:
+		stats->tx.data_fault++;
+	break;
+	case CQ_TX_ERROP_TSTMP_CONFLICT:
+		stats->tx.tstmp_conflict++;
+	break;
+	case CQ_TX_ERROP_TSTMP_TIMEOUT:
+		stats->tx.tstmp_timeout++;
+	break;
+	case CQ_TX_ERROP_MEM_FAULT:
+		stats->tx.mem_fault++;
+	break;
+	case CQ_TX_ERROP_CK_OVERLAP:
+		stats->tx.csum_overlap++;
+	break;
+	case CQ_TX_ERROP_CK_OFLOW:
+		stats->tx.csum_overflow++;
+	break;
+	}
+
+	return 1;
+}
diff --git a/drivers/net/octeontx/nicvf_queues.h b/drivers/net/octeontx/nicvf_queues.h
new file mode 100644
index 0000000..e0c64a5
--- /dev/null
+++ b/drivers/net/octeontx/nicvf_queues.h
@@ -0,0 +1,368 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#ifndef NICVF_QUEUES_H
+#define NICVF_QUEUES_H
+
+#include "q_struct.h"
+
+#define MAX_QUEUE_SET			128
+#define MAX_RCV_QUEUES_PER_QS		8
+#define MAX_RCV_BUF_DESC_RINGS_PER_QS	2
+#define MAX_SND_QUEUES_PER_QS		8
+#define MAX_CMP_QUEUES_PER_QS		8
+
+/* VF's queue interrupt ranges */
+#define	NICVF_INTR_ID_CQ		0
+#define	NICVF_INTR_ID_SQ		8
+#define	NICVF_INTR_ID_RBDR		16
+#define	NICVF_INTR_ID_MISC		18
+#define	NICVF_INTR_ID_QS_ERR		19
+
+#define	for_each_cq_irq(irq)	\
+	for (irq = NICVF_INTR_ID_CQ; irq < NICVF_INTR_ID_SQ; irq++)
+#define	for_each_sq_irq(irq)	\
+	for (irq = NICVF_INTR_ID_SQ; irq < NICVF_INTR_ID_RBDR; irq++)
+#define	for_each_rbdr_irq(irq)	\
+	for (irq = NICVF_INTR_ID_RBDR; irq < NICVF_INTR_ID_MISC; irq++)
+
+#define RBDR_SIZE0		0ULL /* 8K entries */
+#define RBDR_SIZE1		1ULL /* 16K entries */
+#define RBDR_SIZE2		2ULL /* 32K entries */
+#define RBDR_SIZE3		3ULL /* 64K entries */
+#define RBDR_SIZE4		4ULL /* 126K entries */
+#define RBDR_SIZE5		5ULL /* 256K entries */
+#define RBDR_SIZE6		6ULL /* 512K entries */
+
+#define SND_QUEUE_SIZE0		0ULL /* 1K entries */
+#define SND_QUEUE_SIZE1		1ULL /* 2K entries */
+#define SND_QUEUE_SIZE2		2ULL /* 4K entries */
+#define SND_QUEUE_SIZE3		3ULL /* 8K entries */
+#define SND_QUEUE_SIZE4		4ULL /* 16K entries */
+#define SND_QUEUE_SIZE5		5ULL /* 32K entries */
+#define SND_QUEUE_SIZE6		6ULL /* 64K entries */
+
+#define CMP_QUEUE_SIZE0		0ULL /* 1K entries */
+#define CMP_QUEUE_SIZE1		1ULL /* 2K entries */
+#define CMP_QUEUE_SIZE2		2ULL /* 4K entries */
+#define CMP_QUEUE_SIZE3		3ULL /* 8K entries */
+#define CMP_QUEUE_SIZE4		4ULL /* 16K entries */
+#define CMP_QUEUE_SIZE5		5ULL /* 32K entries */
+#define CMP_QUEUE_SIZE6		6ULL /* 64K entries */
+
+/* Default queue count per QS, its lengths and threshold values */
+#define RBDR_CNT			1
+#define RCV_QUEUE_CNT		1
+#define SND_QUEUE_CNT		1
+#define CMP_QUEUE_CNT		1 /* Max of RCV and SND qcount */
+
+#define SND_QSIZE		SND_QUEUE_SIZE0
+#define SND_QUEUE_LEN		(1ULL << (SND_QSIZE + 10))
+#define SND_QUEUE_THRESH	2ULL
+#define MIN_SQ_DESC_PER_PKT_XMIT	2
+#define MAX_CQE_PER_PKT_XMIT		2
+
+#define CMP_QSIZE		CMP_QUEUE_SIZE0
+#define CMP_QUEUE_LEN		(1ULL << (CMP_QSIZE + 10))
+#define CMP_QUEUE_CQE_THRESH	0
+#define CMP_QUEUE_TIMER_THRESH	1 /* 1 ms */
+
+#define RBDR_SIZE		RBDR_SIZE0
+#define RCV_BUF_COUNT		(1ULL << (RBDR_SIZE + 13))
+#define RBDR_THRESH		(RCV_BUF_COUNT / 2)
+#define DMA_BUFFER_LEN		2048 /* In multiples of 128bytes */
+#define RCV_FRAG_LEN	 	DMA_BUFFER_LEN
+
+#define MAX_CQES_FOR_TX		((SND_QUEUE_LEN / MIN_SQ_DESC_PER_PKT_XMIT) *\
+				 MAX_CQE_PER_PKT_XMIT)
+#define RQ_CQ_DROP		((CMP_QUEUE_LEN - MAX_CQES_FOR_TX) / 256)
+
+/* Descriptor size */
+#define SND_QUEUE_DESC_SIZE	16   /* 128 bits */
+#define CMP_QUEUE_DESC_SIZE	512
+
+/* Buffer / descriptor alignments */
+#define NICVF_RCV_BUF_ALIGN		7
+#define NICVF_RCV_BUF_ALIGN_BYTES	(1ULL << NICVF_RCV_BUF_ALIGN)
+#define NICVF_CQ_BASE_ALIGN_BYTES	512  /* 9 bits */
+#define NICVF_SQ_BASE_ALIGN_BYTES	128  /* 7 bits */
+
+#define NICVF_ALIGNED_ADDR(ADDR, ALIGN_BYTES)	ALIGN(ADDR, ALIGN_BYTES)
+#define NICVF_ADDR_ALIGN_LEN(ADDR, BYTES)\
+	(NICVF_ALIGNED_ADDR(ADDR, BYTES) - BYTES)
+#define NICVF_RCV_BUF_ALIGN_LEN(X)\
+	(NICVF_ALIGNED_ADDR(X, NICVF_RCV_BUF_ALIGN_BYTES) - X)
+
+/* Queue enable/disable */
+#define NICVF_SQ_EN            (1ULL << 19)
+
+/* Queue reset */
+#define NICVF_CQ_RESET		(1ULL << 41)
+#define NICVF_SQ_RESET		(1ULL << 17)
+#define NICVF_RBDR_RESET	(1ULL << 43)
+
+enum CQ_RX_ERRLVL_E {
+	CQ_ERRLVL_MAC,
+	CQ_ERRLVL_L2,
+	CQ_ERRLVL_L3,
+	CQ_ERRLVL_L4,
+};
+
+enum CQ_RX_ERROP_E {
+	CQ_RX_ERROP_RE_NONE = 0x0,
+	CQ_RX_ERROP_RE_PARTIAL = 0x1,
+	CQ_RX_ERROP_RE_JABBER = 0x2,
+	CQ_RX_ERROP_RE_FCS = 0x7,
+	CQ_RX_ERROP_RE_TERMINATE = 0x9,
+	CQ_RX_ERROP_RE_RX_CTL = 0xb,
+	CQ_RX_ERROP_PREL2_ERR = 0x1f,
+	CQ_RX_ERROP_L2_FRAGMENT = 0x20,
+	CQ_RX_ERROP_L2_OVERRUN = 0x21,
+	CQ_RX_ERROP_L2_PFCS = 0x22,
+	CQ_RX_ERROP_L2_PUNY = 0x23,
+	CQ_RX_ERROP_L2_MAL = 0x24,
+	CQ_RX_ERROP_L2_OVERSIZE = 0x25,
+	CQ_RX_ERROP_L2_UNDERSIZE = 0x26,
+	CQ_RX_ERROP_L2_LENMISM = 0x27,
+	CQ_RX_ERROP_L2_PCLP = 0x28,
+	CQ_RX_ERROP_IP_NOT = 0x41,
+	CQ_RX_ERROP_IP_CSUM_ERR = 0x42,
+	CQ_RX_ERROP_IP_MAL = 0x43,
+	CQ_RX_ERROP_IP_MALD = 0x44,
+	CQ_RX_ERROP_IP_HOP = 0x45,
+	CQ_RX_ERROP_L3_ICRC = 0x46,
+	CQ_RX_ERROP_L3_PCLP = 0x47,
+	CQ_RX_ERROP_L4_MAL = 0x61,
+	CQ_RX_ERROP_L4_CHK = 0x62,
+	CQ_RX_ERROP_UDP_LEN = 0x63,
+	CQ_RX_ERROP_L4_PORT = 0x64,
+	CQ_RX_ERROP_TCP_FLAG = 0x65,
+	CQ_RX_ERROP_TCP_OFFSET = 0x66,
+	CQ_RX_ERROP_L4_PCLP = 0x67,
+	CQ_RX_ERROP_RBDR_TRUNC = 0x70,
+};
+
+enum CQ_TX_ERROP_E {
+	CQ_TX_ERROP_GOOD = 0x0,
+	CQ_TX_ERROP_DESC_FAULT = 0x10,
+	CQ_TX_ERROP_HDR_CONS_ERR = 0x11,
+	CQ_TX_ERROP_SUBDC_ERR = 0x12,
+	CQ_TX_ERROP_IMM_SIZE_OFLOW = 0x80,
+	CQ_TX_ERROP_DATA_SEQUENCE_ERR = 0x81,
+	CQ_TX_ERROP_MEM_SEQUENCE_ERR = 0x82,
+	CQ_TX_ERROP_LOCK_VIOL = 0x83,
+	CQ_TX_ERROP_DATA_FAULT = 0x84,
+	CQ_TX_ERROP_TSTMP_CONFLICT = 0x85,
+	CQ_TX_ERROP_TSTMP_TIMEOUT = 0x86,
+	CQ_TX_ERROP_MEM_FAULT = 0x87,
+	CQ_TX_ERROP_CK_OVERLAP = 0x88,
+	CQ_TX_ERROP_CK_OFLOW = 0x89,
+	CQ_TX_ERROP_ENUM_LAST = 0x8a,
+};
+
+struct cmp_queue_stats {
+	struct rx_stats {
+		struct {
+			u64 mac_errs;
+			u64 l2_errs;
+			u64 l3_errs;
+			u64 l4_errs;
+		} errlvl;
+		struct {
+			u64 good;
+			u64 partial_pkts;
+			u64 jabber_errs;
+			u64 fcs_errs;
+			u64 terminate_errs;
+			u64 bgx_rx_errs;
+			u64 prel2_errs;
+			u64 l2_frags;
+			u64 l2_overruns;
+			u64 l2_pfcs;
+			u64 l2_puny;
+			u64 l2_hdr_malformed;
+			u64 l2_oversize;
+			u64 l2_undersize;
+			u64 l2_len_mismatch;
+			u64 l2_pclp;
+			u64 non_ip;
+			u64 ip_csum_err;
+			u64 ip_hdr_malformed;
+			u64 ip_payload_malformed;
+			u64 ip_hop_errs;
+			u64 l3_icrc_errs;
+			u64 l3_pclp;
+			u64 l4_malformed;
+			u64 l4_csum_errs;
+			u64 udp_len_err;
+			u64 bad_l4_port;
+			u64 bad_tcp_flag;
+			u64 tcp_offset_errs;
+			u64 l4_pclp;
+			u64 pkt_truncated;
+		} errop;
+	} rx;
+	struct tx_stats {
+		u64 good;
+		u64 desc_fault;
+		u64 hdr_cons_err;
+		u64 subdesc_err;
+		u64 imm_size_oflow;
+		u64 data_seq_err;
+		u64 mem_seq_err;
+		u64 lock_viol;
+		u64 data_fault;
+		u64 tstmp_conflict;
+		u64 tstmp_timeout;
+		u64 mem_fault;
+		u64 csum_overlap;
+		u64 csum_overflow;
+	} tx;
+};
+
+enum RQ_SQ_STATS {
+	RQ_SQ_STATS_OCTS,
+	RQ_SQ_STATS_PKTS,
+};
+
+struct rx_tx_queue_stats {
+	u64	bytes;
+	u64	pkts;
+};
+
+struct q_desc_mem {
+	uintptr_t	dma;
+	uint64_t	size;
+	uint16_t	q_len;
+	uintptr_t	phys_base;
+	void		*base;
+	void		*unalign_base;
+	bool		allocated;
+};
+
+struct rbdr {
+	bool		enable;
+	uint32_t	dma_size;
+	uint32_t	thresh;      /* Threshold level for interrupt */
+	void		*desc;
+	uint32_t	head;
+	uint32_t	tail;
+	struct		q_desc_mem   dmem;
+	uintptr_t	buf_mem;
+	uintptr_t	buffers;
+};
+
+struct rcv_queue {
+	bool		enable;
+	struct	rbdr	*rbdr_start;
+	struct	rbdr	*rbdr_cont;
+	bool		en_tcp_reassembly;
+	uint8_t		cq_qs;  /* CQ's QS to which this RQ is assigned */
+	uint8_t		cq_idx; /* CQ index (0 to 7) in the QS */
+	uint8_t		cont_rbdr_qs;      /* Continue buffer ptrs - QS num */
+	uint8_t		cont_qs_rbdr_idx;  /* RBDR idx in the cont QS */
+	uint8_t		start_rbdr_qs;     /* First buffer ptrs - QS num */
+	uint8_t		start_qs_rbdr_idx; /* RBDR idx in the above QS */
+	uint8_t         caching;
+	struct		rx_tx_queue_stats stats;
+};
+
+struct cmp_queue {
+	bool		enable;
+	uint16_t	intr_timer_thresh;
+	uint16_t	thresh;
+	void		*desc;
+	struct q_desc_mem   dmem;
+	struct cmp_queue_stats	stats;
+};
+
+struct snd_queue {
+	bool		enable;
+	uint8_t		cq_qs;  /* CQ's QS to which this SQ is pointing */
+	uint8_t		cq_idx; /* CQ index (0 to 7) in the above QS */
+	uint16_t	thresh;
+	uint32_t	free_cnt;
+	uint32_t	head;
+	uint32_t	tail;
+	uint64_t	*skbuff;
+	void		*desc;
+	struct q_desc_mem   dmem;
+	struct rx_tx_queue_stats stats;
+};
+
+struct queue_set {
+	bool		enable;
+	bool		be_en;
+	uint8_t		vnic_id;
+	uint8_t		rq_cnt;
+	uint8_t		cq_cnt;
+	uint64_t	cq_len;
+	uint8_t		sq_cnt;
+	uint64_t	sq_len;
+	uint8_t		rbdr_cnt;
+	uint64_t	rbdr_len;
+	struct	rcv_queue	rq[MAX_RCV_QUEUES_PER_QS];
+	struct	cmp_queue	cq[MAX_CMP_QUEUES_PER_QS];
+	struct	snd_queue	sq[MAX_SND_QUEUES_PER_QS];
+	struct	rbdr		rbdr[MAX_RCV_BUF_DESC_RINGS_PER_QS];
+};
+
+#define GET_RBDR_DESC(RING, idx)\
+		(&(((struct rbdr_entry_t *)((RING)->desc))[idx]))
+#define GET_SQ_DESC(RING, idx)\
+		(&(((struct sq_hdr_subdesc *)((RING)->desc))[idx]))
+#define GET_CQ_DESC(RING, idx)\
+		(&(((union cq_desc_t *)((RING)->desc))[idx]))
+
+/* CQ status bits */
+#define	CQ_WR_FULL	(1 << 26)
+#define	CQ_WR_DISABLE	(1 << 25)
+#define	CQ_WR_FAULT	(1 << 24)
+#define	CQ_CQE_COUNT	(0xFFFF << 0)
+
+#define	CQ_ERR_MASK	(CQ_WR_FULL | CQ_WR_DISABLE | CQ_WR_FAULT)
+
+int nicvf_set_qset_resources(struct nicvf *nic);
+int nicvf_config_data_transfer(struct nicvf *nic, bool enable);
+void nicvf_qset_config(struct nicvf *nic, bool enable);
+void nicvf_cmp_queue_config(struct nicvf *nic, struct queue_set *qs,
+			    int qidx, bool enable);
+
+void nicvf_sq_enable(struct nicvf *nic, struct snd_queue *sq, int qidx);
+void nicvf_sq_disable(struct nicvf *nic, int qidx);
+void nicvf_put_sq_desc(struct snd_queue *sq, int desc_cnt);
+void nicvf_sq_free_used_descs(struct udevice *dev,
+					struct snd_queue *sq, int qidx);
+int nicvf_sq_append_pkt(struct nicvf *nic, void *pkt, size_t pkt_len);
+
+void *nicvf_get_rcv_pkt(struct nicvf *nic, void *cq_desc, size_t *pkt_len);
+void nicvf_refill_rbdr(struct nicvf *nic);
+
+void nicvf_enable_intr(struct nicvf *nic, int int_type, int q_idx);
+void nicvf_disable_intr(struct nicvf *nic, int int_type, int q_idx);
+void nicvf_clear_intr(struct nicvf *nic, int int_type, int q_idx);
+int nicvf_is_intr_enabled(struct nicvf *nic, int int_type, int q_idx);
+
+/* Register access APIs */
+void nicvf_reg_write(struct nicvf *nic, uint64_t offset, uint64_t val);
+uint64_t nicvf_reg_read(struct nicvf *nic, uint64_t offset);
+void nicvf_qset_reg_write(struct nicvf *nic, uint64_t offset, uint64_t val);
+uint64_t nicvf_qset_reg_read(struct nicvf *nic, uint64_t offset);
+void nicvf_queue_reg_write(struct nicvf *nic, uint64_t offset,
+			   uint64_t qidx, uint64_t val);
+uint64_t nicvf_queue_reg_read(struct nicvf *nic,
+			      uint64_t offset, uint64_t qidx);
+
+/* Stats */
+void nicvf_update_rq_stats(struct nicvf *nic, int rq_idx);
+void nicvf_update_sq_stats(struct nicvf *nic, int sq_idx);
+int nicvf_check_cqe_rx_errs(struct nicvf *nic,
+			    struct cmp_queue *cq, void *cq_desc);
+int nicvf_check_cqe_tx_errs(struct nicvf *nic,
+			    struct cmp_queue *cq, void *cq_desc);
+#endif /* NICVF_QUEUES_H */
diff --git a/drivers/net/octeontx/octeontx_bgx.c b/drivers/net/octeontx/octeontx_bgx.c
new file mode 100644
index 0000000..a2f9c2b
--- /dev/null
+++ b/drivers/net/octeontx/octeontx_bgx.c
@@ -0,0 +1,1497 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#include <config.h>
+#include <common.h>
+#include <errno.h>
+#include <net.h>
+#include <dm.h>
+#include <pci.h>
+#include <misc.h>
+#include <netdev.h>
+#include <malloc.h>
+#include <miiphy.h>
+#include <asm/io.h>
+
+#ifdef CONFIG_OF_LIBFDT
+ #include <linux/libfdt.h>
+ #include <fdt_support.h>
+#endif
+
+#include <asm/arch/octeontx.h>
+#include <asm/arch/octeontx_vnic.h>
+
+#include "nic_reg.h"
+#include "nic.h"
+#include "octeontx_bgx.h"
+
+static const phy_interface_t if_mode[] = {
+	[QLM_MODE_SGMII]  = PHY_INTERFACE_MODE_SGMII,
+	[QLM_MODE_RGMII]  = PHY_INTERFACE_MODE_RGMII,
+	[QLM_MODE_QSGMII] = PHY_INTERFACE_MODE_QSGMII,
+	[QLM_MODE_XAUI]   = PHY_INTERFACE_MODE_XAUI,
+	[QLM_MODE_RXAUI]  = PHY_INTERFACE_MODE_RXAUI,
+};
+
+struct lmac {
+	struct bgx		*bgx;
+	int			dmac;
+	u8			mac[6];
+	bool			link_up;
+	int			lmacid; /* ID within BGX */
+	int			phy_addr; /* ID on board */
+	struct udevice		*dev;
+	struct mii_dev		*mii_bus;
+	struct phy_device	*phydev;
+	unsigned int		last_duplex;
+	unsigned int		last_link;
+	unsigned int		last_speed;
+	int			lane_to_sds;
+	int			use_training;
+	int			lmac_type;
+	u8			qlm_mode;
+	int			qlm;
+	bool			is_1gx;
+};
+
+struct bgx {
+	u8			bgx_id;
+	int			node;
+	struct	lmac		lmac[MAX_LMAC_PER_BGX];
+	int			lmac_count;
+	u8			max_lmac;
+	void __iomem		*reg_base;
+	struct pci_dev		*pdev;
+	bool			is_rgx;
+};
+
+struct bgx_board_info bgx_board_info[CONFIG_MAX_BGX];
+
+struct bgx *bgx_vnic[CONFIG_MAX_BGX];
+bool is_altpkg = 0;
+extern int __cavm_if_phy_xs_init(struct mii_dev *bus, int phy_addr);
+
+/* APIs to read/write BGXX CSRs */
+static uint64_t bgx_reg_read(struct bgx *bgx, uint8_t lmac, uint64_t offset)
+{
+	uint64_t addr = (uintptr_t)bgx->reg_base +
+				((uint32_t)lmac << 20) + offset;
+
+	return readq((void *)addr);
+}
+
+static void bgx_reg_write(struct bgx *bgx, uint8_t lmac,
+			  uint64_t offset, uint64_t val)
+{
+	uint64_t addr = (uintptr_t)bgx->reg_base +
+				((uint32_t)lmac << 20) + offset;
+
+	writeq(val, (void *)addr);
+}
+
+static void bgx_reg_modify(struct bgx *bgx, uint8_t lmac,
+			   uint64_t offset, uint64_t val)
+{
+	uint64_t addr = (uintptr_t)bgx->reg_base +
+				((uint32_t)lmac << 20) + offset;
+
+	writeq(val | bgx_reg_read(bgx, lmac, offset), (void *)addr);
+}
+
+static int bgx_poll_reg(struct bgx *bgx, uint8_t lmac,
+			uint64_t reg, uint64_t mask, bool zero)
+{
+	int timeout = 200;
+	uint64_t reg_val;
+
+	while (timeout) {
+		reg_val = bgx_reg_read(bgx, lmac, reg);
+		if (zero && !(reg_val & mask))
+			return 0;
+		if (!zero && (reg_val & mask))
+			return 0;
+		mdelay(1);
+		timeout--;
+	}
+	return 1;
+}
+
+static int gser_poll_reg(uint64_t reg, int bit, uint64_t mask, uint64_t expected_val, int timeout)
+{
+	uint64_t reg_val;
+	debug("gser_poll_reg: reg = %#llx, mask = %#llx, expected_val = %#llx, bit = %d\n",
+		reg, mask, expected_val, bit);
+	while (timeout) {
+		reg_val = readq(CSR_PA(0, reg)) >> bit;
+		if ((reg_val & mask) == (expected_val))
+			return 0;
+		mdelay(1);
+		timeout--;
+	}
+	return 1;
+}
+
+static bool is_bgx_port_valid(int bgx, int lmac)
+{
+	debug("is_bgx_port_valid bgx %d lmac %d valid %d\n",
+	      bgx, lmac, bgx_board_info[bgx].lmac_reg[lmac]);
+
+	if (bgx_board_info[bgx].lmac_reg[lmac])
+		return 1;
+	else
+		return 0;
+}
+
+struct lmac *bgx_get_lmac(int node, int bgx_idx, int lmacid)
+{
+	struct bgx *bgx = bgx_vnic[(node * CONFIG_MAX_BGX_PER_NODE) + bgx_idx];
+
+	if (bgx)
+		return &bgx->lmac[lmacid];
+
+	return NULL;
+}
+
+const u8 *bgx_get_lmac_mac(int node, int bgx_idx, int lmacid)
+{
+	struct bgx *bgx = bgx_vnic[(node * CONFIG_MAX_BGX_PER_NODE) + bgx_idx];
+
+	if (bgx)
+		return bgx->lmac[lmacid].mac;
+
+	return NULL;
+}
+
+void bgx_set_lmac_mac(int node, int bgx_idx, int lmacid, const u8 *mac)
+{
+	struct bgx *bgx = bgx_vnic[(node * CONFIG_MAX_BGX_PER_NODE) + bgx_idx];
+
+	if (!bgx)
+		return;
+
+	memcpy(bgx->lmac[lmacid].mac, mac, 6);
+}
+
+/* Return number of BGX present in HW */
+void bgx_get_count(int node, int *bgx_count)
+{
+	int i;
+	struct bgx *bgx;
+
+	*bgx_count = 0;
+	for (i = 0; i < CONFIG_MAX_BGX_PER_NODE; i++) {
+		bgx = bgx_vnic[node * CONFIG_MAX_BGX_PER_NODE + i];
+		debug("bgx_vnic[%u]: %p\n", node * CONFIG_MAX_BGX_PER_NODE + i, bgx);
+		if (bgx)
+			*bgx_count |= (1 << i);
+	}
+}
+
+/* Return number of LMAC configured for this BGX */
+int bgx_get_lmac_count(int node, int bgx_idx)
+{
+	struct bgx *bgx;
+
+	bgx = bgx_vnic[(node * CONFIG_MAX_BGX_PER_NODE) + bgx_idx];
+	if (bgx)
+		return bgx->lmac_count;
+
+	return 0;
+}
+
+void bgx_lmac_rx_tx_enable(int node, int bgx_idx, int lmacid, bool enable)
+{
+	struct bgx *bgx = bgx_vnic[(node * CONFIG_MAX_BGX_PER_NODE) + bgx_idx];
+	u64 cfg;
+
+	if (!bgx)
+		return;
+
+	cfg = bgx_reg_read(bgx, lmacid, BGX_CMRX_CFG);
+	if (enable)
+		cfg |= CMR_PKT_RX_EN | CMR_PKT_TX_EN;
+	else
+		cfg &= ~(CMR_PKT_RX_EN | CMR_PKT_TX_EN);
+	bgx_reg_write(bgx, lmacid, BGX_CMRX_CFG, cfg);
+}
+
+static void bgx_flush_dmac_addrs(struct bgx *bgx, uint64_t lmac)
+{
+	uint64_t dmac = 0x00;
+	uint64_t offset, addr;
+
+	while (bgx->lmac[lmac].dmac > 0) {
+		offset = ((bgx->lmac[lmac].dmac - 1) * sizeof(dmac)) +
+			(lmac * MAX_DMAC_PER_LMAC * sizeof(dmac));
+		addr = (uintptr_t)bgx->reg_base +
+				BGX_CMR_RX_DMACX_CAM + offset;
+		writeq(dmac, (void *)addr);
+		bgx->lmac[lmac].dmac--;
+	}
+}
+
+/* Configure BGX LMAC in internal loopback mode */
+void bgx_lmac_internal_loopback(int node, int bgx_idx,
+				int lmac_idx, bool enable)
+{
+	struct bgx *bgx;
+	struct lmac *lmac;
+	u64    cfg;
+
+	bgx = bgx_vnic[(node * CONFIG_MAX_BGX_PER_NODE) + bgx_idx];
+	if (!bgx)
+		return;
+
+	lmac = &bgx->lmac[lmac_idx];
+	if (lmac->qlm_mode == QLM_MODE_SGMII) {
+		cfg = bgx_reg_read(bgx, lmac_idx, BGX_GMP_PCS_MRX_CTL);
+		if (enable)
+			cfg |= PCS_MRX_CTL_LOOPBACK1;
+		else
+			cfg &= ~PCS_MRX_CTL_LOOPBACK1;
+		bgx_reg_write(bgx, lmac_idx, BGX_GMP_PCS_MRX_CTL, cfg);
+	} else {
+		cfg = bgx_reg_read(bgx, lmac_idx, BGX_SPUX_CONTROL1);
+		if (enable)
+			cfg |= SPU_CTL_LOOPBACK;
+		else
+			cfg &= ~SPU_CTL_LOOPBACK;
+		bgx_reg_write(bgx, lmac_idx, BGX_SPUX_CONTROL1, cfg);
+	}
+}
+
+/* Return the DLM used for the BGX */
+static int get_qlm_for_bgx(int node, int bgx_id, int index)
+{
+	int qlm = 0;
+	uint64_t cfg;
+
+	if (is_board_model(CN81XX)) {
+		qlm = (bgx_id) ? 2 : 0;
+		qlm += (index >= 2) ? 1 : 0;
+	} else if (is_board_model(CN83XX)) {
+		switch (bgx_id) {
+		case 0:
+			qlm = 2;
+			break;
+		case 1:
+			qlm = 3;
+			break;
+		case 2:
+			if (index >= 2)
+				qlm = 6;
+			else
+				qlm = 5;
+			break;
+		case 3:
+			qlm = 4;
+			break;
+		}
+	}
+
+	cfg = readq(CSR_PA(node, GSERX_CFG(qlm))) & GSERX_CFG_BGX;
+	debug("get_qlm_for_bgx:qlm%d: cfg = %lld\n", qlm, cfg);
+
+	/* Check if DLM is configured as BGX# */
+	if (cfg) {
+		if (readq(CSR_PA(node, GSERX_PHY_CTL(qlm))))
+			return -1;
+		return qlm;
+	}
+	return -1;
+}
+
+static int bgx_lmac_sgmii_init(struct bgx *bgx, int lmacid)
+{
+	u64 cfg;
+	struct lmac *lmac;
+
+	lmac = &bgx->lmac[lmacid];
+
+	debug("bgx_lmac_sgmii_init: bgx_id = %d, lmacid = %d\n", bgx->bgx_id, lmacid);
+
+	bgx_reg_modify(bgx, lmacid, BGX_GMP_GMI_TXX_THRESH, 0x30);
+	/* max packet size */
+	bgx_reg_modify(bgx, lmacid, BGX_GMP_GMI_RXX_JABBER, MAX_FRAME_SIZE);
+
+	/* Disable frame alignment if using preamble */
+	cfg = bgx_reg_read(bgx, lmacid, BGX_GMP_GMI_TXX_APPEND);
+	if (cfg & 1)
+		bgx_reg_write(bgx, lmacid, BGX_GMP_GMI_TXX_SGMII_CTL, 0);
+
+	/* Enable lmac */
+	bgx_reg_modify(bgx, lmacid, BGX_CMRX_CFG, CMR_EN);
+
+	/* PCS reset */
+	bgx_reg_modify(bgx, lmacid, BGX_GMP_PCS_MRX_CTL, PCS_MRX_CTL_RESET);
+	if (bgx_poll_reg(bgx, lmacid, BGX_GMP_PCS_MRX_CTL,
+			 PCS_MRX_CTL_RESET, true)) {
+		printf("BGX PCS reset not completed\n");
+		return -1;
+	}
+
+	/* power down, reset autoneg, autoneg enable */
+	cfg = bgx_reg_read(bgx, lmacid, BGX_GMP_PCS_MRX_CTL);
+	cfg &= ~PCS_MRX_CTL_PWR_DN;
+
+	if (bgx_board_info[bgx->bgx_id].phy_info[lmacid].autoneg_dis)
+		cfg |= (PCS_MRX_CTL_RST_AN);
+	else
+		cfg |= (PCS_MRX_CTL_RST_AN | PCS_MRX_CTL_AN_EN);
+	bgx_reg_write(bgx, lmacid, BGX_GMP_PCS_MRX_CTL, cfg);
+
+	/* Disable disparity for QSGMII mode, to prevent propogation across
+	   ports. */
+
+	if (lmac->qlm_mode == QLM_MODE_QSGMII) {
+		cfg = bgx_reg_read(bgx, lmacid, BGX_GMP_PCS_MISCX_CTL);
+		cfg &= ~PCS_MISCX_CTL_DISP_EN;
+		bgx_reg_write(bgx, lmacid, BGX_GMP_PCS_MISCX_CTL, cfg);
+		return 0; /* Skip checking AN_CPT */
+	}
+
+	if (lmac->is_1gx) {
+		cfg = bgx_reg_read(bgx, lmacid, BGX_GMP_PCS_MISCX_CTL);
+		cfg |= PCS_MISC_CTL_MODE;
+		bgx_reg_write(bgx, lmacid, BGX_GMP_PCS_MISCX_CTL, cfg);
+	}
+
+	if (lmac->qlm_mode == QLM_MODE_SGMII) {
+		if (bgx_poll_reg(bgx, lmacid, BGX_GMP_PCS_MRX_STATUS,
+			 PCS_MRX_STATUS_AN_CPT, false)) {
+			printf("BGX AN_CPT not completed\n");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static int bgx_lmac_sgmii_set_link_speed(struct lmac *lmac)
+{
+	u64 prtx_cfg;
+	u64 pcs_miscx_ctl;
+	u64 cfg;
+	struct bgx *bgx = lmac->bgx;
+	unsigned int lmacid = lmac->lmacid;
+		
+	debug("bgx_lmac_sgmii_set_link_speed(): lmacid %d\n", lmac->lmacid);
+
+	/* Disable LMAC before setting up speed */
+	cfg = bgx_reg_read(bgx, lmacid, BGX_CMRX_CFG);
+	cfg &= ~CMR_EN;
+        bgx_reg_write(bgx, lmacid, BGX_CMRX_CFG, cfg);
+
+	/* Read GMX CFG */
+	prtx_cfg = bgx_reg_read(bgx, lmacid,
+				BGX_GMP_GMI_PRTX_CFG);
+ 	/* Read PCS MISCS CTL */
+	pcs_miscx_ctl = bgx_reg_read(bgx, lmacid,
+				BGX_GMP_PCS_MISCX_CTL);
+
+	/* Use GMXENO to force the link down*/
+	if (lmac->link_up) {
+		pcs_miscx_ctl &= ~PCS_MISC_CTL_GMX_ENO;
+		/* change the duplex setting if the link is up */
+		prtx_cfg |= GMI_PORT_CFG_DUPLEX;
+	} else 
+		pcs_miscx_ctl |= PCS_MISC_CTL_GMX_ENO;
+
+	/* speed based setting for GMX */
+	switch( lmac->last_speed) {
+	case 10:
+		prtx_cfg &= ~GMI_PORT_CFG_SPEED;
+		prtx_cfg |= GMI_PORT_CFG_SPEED_MSB;
+		prtx_cfg &= ~GMI_PORT_CFG_SLOT_TIME;
+		pcs_miscx_ctl |= 50; /* sampling point */
+		bgx_reg_write(bgx, lmacid, BGX_GMP_GMI_TXX_SLOT, 0x40);
+		bgx_reg_write(bgx, lmacid, BGX_GMP_GMI_TXX_BURST, 0);
+		break;
+	case 100:
+		prtx_cfg &= ~GMI_PORT_CFG_SPEED;
+		prtx_cfg &= ~GMI_PORT_CFG_SPEED_MSB;
+		prtx_cfg &= ~GMI_PORT_CFG_SLOT_TIME;
+		pcs_miscx_ctl |= 0x5; /* sampling point */
+		bgx_reg_write(bgx, lmacid, BGX_GMP_GMI_TXX_SLOT, 0x40);
+		bgx_reg_write(bgx, lmacid, BGX_GMP_GMI_TXX_BURST, 0);
+		break;
+	case 1000:
+		prtx_cfg |= GMI_PORT_CFG_SPEED;
+		prtx_cfg &= ~GMI_PORT_CFG_SPEED_MSB;
+		prtx_cfg |= GMI_PORT_CFG_SLOT_TIME;
+		pcs_miscx_ctl |= 0x1; /* sampling point */
+		bgx_reg_write(bgx, lmacid, BGX_GMP_GMI_TXX_SLOT, 0x200);
+		if (lmac->last_duplex)
+			bgx_reg_write(bgx, lmacid, BGX_GMP_GMI_TXX_BURST, 0);
+		else /* half duplex */
+			bgx_reg_write(bgx, lmacid, BGX_GMP_GMI_TXX_BURST, 0x2000);
+		break;
+	default:
+		break;
+	}
+	
+	/* write back the new PCS misc and GMX settings */
+	bgx_reg_write(bgx, lmacid, BGX_GMP_PCS_MISCX_CTL, pcs_miscx_ctl);
+	bgx_reg_write(bgx, lmacid, BGX_GMP_GMI_PRTX_CFG, prtx_cfg);
+
+	/* read back GMX CFG again to check config completion */
+	bgx_reg_read(bgx, lmacid, BGX_GMP_GMI_PRTX_CFG);
+		
+	/* enable BGX back */
+	cfg = bgx_reg_read(bgx, lmacid, BGX_CMRX_CFG);
+	cfg |= CMR_EN;
+       	bgx_reg_write(bgx, lmacid, BGX_CMRX_CFG, cfg);
+
+	return 0;
+}
+
+static int bgx_lmac_xaui_init(struct bgx *bgx, int lmacid, int lmac_type)
+{
+	u64 cfg;
+	struct lmac *lmac;
+
+	lmac = &bgx->lmac[lmacid];
+
+	/* Reset SPU */
+	bgx_reg_modify(bgx, lmacid, BGX_SPUX_CONTROL1, SPU_CTL_RESET);
+	if (bgx_poll_reg(bgx, lmacid, BGX_SPUX_CONTROL1, SPU_CTL_RESET, true)) {
+		printf("BGX SPU reset not completed\n");
+		return -1;
+	}
+
+	/* Disable LMAC */
+	cfg = bgx_reg_read(bgx, lmacid, BGX_CMRX_CFG);
+	cfg &= ~CMR_EN;
+	bgx_reg_write(bgx, lmacid, BGX_CMRX_CFG, cfg);
+
+	bgx_reg_modify(bgx, lmacid, BGX_SPUX_CONTROL1, SPU_CTL_LOW_POWER);
+	/* Set interleaved running disparity for RXAUI */
+	if (lmac->qlm_mode != QLM_MODE_RXAUI)
+		bgx_reg_modify(bgx, lmacid,
+			       BGX_SPUX_MISC_CONTROL, SPU_MISC_CTL_RX_DIS);
+	else
+		bgx_reg_modify(bgx, lmacid, BGX_SPUX_MISC_CONTROL,
+			       SPU_MISC_CTL_RX_DIS | SPU_MISC_CTL_INTLV_RDISP);
+
+	/* clear all interrupts */
+	cfg = bgx_reg_read(bgx, lmacid, BGX_SMUX_RX_INT);
+	bgx_reg_write(bgx, lmacid, BGX_SMUX_RX_INT, cfg);
+	cfg = bgx_reg_read(bgx, lmacid, BGX_SMUX_TX_INT);
+	bgx_reg_write(bgx, lmacid, BGX_SMUX_TX_INT, cfg);
+	cfg = bgx_reg_read(bgx, lmacid, BGX_SPUX_INT);
+	bgx_reg_write(bgx, lmacid, BGX_SPUX_INT, cfg);
+
+	if (lmac->use_training) {
+		bgx_reg_write(bgx, lmacid, BGX_SPUX_BR_PMD_LP_CUP, 0x00);
+		bgx_reg_write(bgx, lmacid, BGX_SPUX_BR_PMD_LD_CUP, 0x00);
+		bgx_reg_write(bgx, lmacid, BGX_SPUX_BR_PMD_LD_REP, 0x00);
+		/* training enable */
+		bgx_reg_modify(bgx, lmacid,
+			       BGX_SPUX_BR_PMD_CRTL, SPU_PMD_CRTL_TRAIN_EN);
+	}
+
+	/* Append FCS to each packet */
+	bgx_reg_modify(bgx, lmacid, BGX_SMUX_TX_APPEND, SMU_TX_APPEND_FCS_D);
+
+	/* Disable forward error correction */
+	cfg = bgx_reg_read(bgx, lmacid, BGX_SPUX_FEC_CONTROL);
+	cfg &= ~SPU_FEC_CTL_FEC_EN;
+	bgx_reg_write(bgx, lmacid, BGX_SPUX_FEC_CONTROL, cfg);
+
+	/* Disable autoneg */
+	cfg = bgx_reg_read(bgx, lmacid, BGX_SPUX_AN_CONTROL);
+	cfg = cfg & ~(SPU_AN_CTL_XNP_EN);
+	if (lmac->use_training)
+		cfg = cfg | (SPU_AN_CTL_AN_EN);
+	else
+		cfg = cfg & ~(SPU_AN_CTL_AN_EN);
+	bgx_reg_write(bgx, lmacid, BGX_SPUX_AN_CONTROL, cfg);
+
+	cfg = bgx_reg_read(bgx, lmacid, BGX_SPUX_AN_ADV);
+	/* Clear all KR bits, configure according to the mode */
+	cfg &= ~((0xfULL << 22) | (1ULL << 12));
+	if (lmac->qlm_mode == QLM_MODE_10G_KR)
+		cfg |= (1 << 23);
+	else if (lmac->qlm_mode == QLM_MODE_40G_KR4)
+		cfg |= (1 << 24);
+	bgx_reg_write(bgx, lmacid, BGX_SPUX_AN_ADV, cfg);
+
+	cfg = bgx_reg_read(bgx, 0, BGX_SPU_DBG_CONTROL);
+	if (lmac->use_training)
+		cfg |= SPU_DBG_CTL_AN_ARB_LINK_CHK_EN;
+	else
+		cfg &= ~SPU_DBG_CTL_AN_ARB_LINK_CHK_EN;
+	bgx_reg_write(bgx, 0, BGX_SPU_DBG_CONTROL, cfg);
+
+	/* Enable lmac */
+	bgx_reg_modify(bgx, lmacid, BGX_CMRX_CFG, CMR_EN);
+
+	cfg = bgx_reg_read(bgx, lmacid, BGX_SPUX_CONTROL1);
+	cfg &= ~SPU_CTL_LOW_POWER;
+	bgx_reg_write(bgx, lmacid, BGX_SPUX_CONTROL1, cfg);
+
+	cfg = bgx_reg_read(bgx, lmacid, BGX_SMUX_TX_CTL);
+	cfg &= ~SMU_TX_CTL_UNI_EN;
+	cfg |= SMU_TX_CTL_DIC_EN;
+	bgx_reg_write(bgx, lmacid, BGX_SMUX_TX_CTL, cfg);
+
+	/* take lmac_count into account */
+	bgx_reg_modify(bgx, lmacid, BGX_SMUX_TX_THRESH, (0x100 - 1));
+	/* max packet size */
+	bgx_reg_modify(bgx, lmacid, BGX_SMUX_RX_JABBER, MAX_FRAME_SIZE);
+
+	debug("xaui_init: lmacid = %d, qlm = %d, qlm_mode = %d\n",
+		lmacid, lmac->qlm, lmac->qlm_mode);
+	/* RXAUI with Marvell PHY requires some tweaking */
+	if (lmac->qlm_mode == QLM_MODE_RXAUI) {
+		char mii_name[20];
+		snprintf(mii_name, sizeof(mii_name), "smi%d",
+			 bgx_board_info[bgx->bgx_id].phy_info[lmacid].mdio_bus);
+
+		debug("mii_name: %s\n", mii_name);
+		lmac->mii_bus = miiphy_get_dev_by_name(mii_name);
+		lmac->phy_addr = bgx_board_info[bgx->bgx_id].
+				 phy_info[lmacid].phy_addr;
+		__cavm_if_phy_xs_init(lmac->mii_bus, lmac->phy_addr);
+	}
+
+	return 0;
+}
+
+/* Get max number of lanes present in a given QLM/DLM */
+static int get_qlm_lanes(int qlm)
+{
+	if (is_board_model(CN81XX))
+		return 2;
+	else if (is_board_model(CN83XX))
+		return (qlm >= 5) ? 2 : 4;
+	else
+		return -1;
+}
+
+int __rx_equalization(int qlm, int lane)
+{
+	int max_lanes = get_qlm_lanes(qlm);
+	int l;
+	int fail = 0;
+
+	/* Before completing Rx equalization wait for GSERx_RX_EIE_DETSTS[CDRLOCK] to be set
+	   This ensures the rx data is valid */
+	if (lane == -1) {
+		if (gser_poll_reg(GSER_RX_EIE_DETSTS(qlm), GSER_CDRLOCK, 0xf, (1 << max_lanes) - 1, 100)) {
+			debug("ERROR: DLM%d: CDR Lock not detected for 2 lanes\n", qlm);
+			return -1;
+		}
+	} else {
+		if (gser_poll_reg(GSER_RX_EIE_DETSTS(qlm), GSER_CDRLOCK, (0xf & (1 << lane)), (1 << lane), 100)) {
+			debug("ERROR: DLM%d: CDR Lock not detected on %d lane\n", qlm, lane);
+			return -1;
+		}
+	}
+
+	for (l = 0; l < max_lanes; l++) {
+		uint64_t rctl, reer;
+
+		if ((lane != -1) && (lane != l))
+			continue;
+
+		/* Enable software control */
+		rctl = readq(CSR_PA(0, GSER_BR_RXX_CTL(qlm, l)));
+		rctl |= GSER_BR_RXX_CTL_RXT_SWM;
+		writeq(rctl, CSR_PA(0, GSER_BR_RXX_CTL(qlm, l)));
+
+		/* Clear the completion flag and initiate a new request */
+		reer = readq(CSR_PA(0, GSER_BR_RXX_EER(qlm, l)));
+		reer &= ~GSER_BR_RXX_EER_RXT_ESV;
+		reer |= GSER_BR_RXX_EER_RXT_EER;
+		writeq(reer, CSR_PA(0, GSER_BR_RXX_EER(qlm, l)));
+	}
+
+	/* Wait for RX equalization to complete */
+	for (l = 0; l < max_lanes; l++) {
+		uint64_t rctl, reer;
+
+		if ((lane != -1) && (lane != l))
+			continue;
+
+		gser_poll_reg(GSER_BR_RXX_EER(qlm, l), EER_RXT_ESV, 1, 1, 200);
+		reer = readq(CSR_PA(0, GSER_BR_RXX_EER(qlm, l)));
+
+		/* Switch back to hardware control */
+		rctl = readq(CSR_PA(0, GSER_BR_RXX_CTL(qlm, l)));
+		rctl &= ~GSER_BR_RXX_CTL_RXT_SWM;
+		writeq(rctl, CSR_PA(0, GSER_BR_RXX_CTL(qlm, l)));
+
+		if (reer & GSER_BR_RXX_EER_RXT_ESV) {
+			debug("Rx equalization completed on DLM%d lane%d, rxt_esm = 0x%llx\n",
+				qlm, l, (reer & 0x3fff));
+		} else {
+			debug("Rx equalization timedout on DLM%d lane%d\n", qlm, l);
+			fail = 1;
+		}
+	}
+
+	return (fail) ? -1 : 0;
+}
+
+static int bgx_xaui_check_link(struct lmac *lmac)
+{
+	struct bgx *bgx = lmac->bgx;
+	int lmacid = lmac->lmacid;
+	int lmac_type = lmac->lmac_type;
+	u64 cfg;
+
+	bgx_reg_modify(bgx, lmacid, BGX_SPUX_MISC_CONTROL, SPU_MISC_CTL_RX_DIS);
+
+	/* check if auto negotiation is complete */
+	cfg = bgx_reg_read(bgx, lmacid, BGX_SPUX_AN_CONTROL);
+	if (cfg & SPU_AN_CTL_AN_EN) {
+		cfg = bgx_reg_read(bgx, lmacid, BGX_SPUX_AN_STATUS);
+		if (!(cfg & SPU_AN_STS_AN_COMPLETE)) {
+			/* Restart autonegotiation */
+			debug("restarting auto-neg\n");
+			bgx_reg_modify(bgx, lmacid, BGX_SPUX_AN_CONTROL, SPU_AN_CTL_AN_RESTART);
+			return -1;
+		}
+	}
+
+	debug("%s link use_training %d\n",__func__, lmac->use_training);
+	if (lmac->use_training) {
+		cfg = bgx_reg_read(bgx, lmacid, BGX_SPUX_INT);
+		if (!(cfg & (1ull << 13))) {
+			debug("waiting for link training\n");
+			/* Clear the training interrupts (W1C) */
+			cfg = (1ull << 13) | (1ull << 14);
+			bgx_reg_write(bgx, lmacid, BGX_SPUX_INT, cfg);
+
+			udelay(2000);
+			/* Restart training */
+			cfg = bgx_reg_read(bgx, lmacid, BGX_SPUX_BR_PMD_CRTL);
+			cfg |= (1ull << 0);
+			bgx_reg_write(bgx, lmacid, BGX_SPUX_BR_PMD_CRTL, cfg);
+			return -1;
+		}
+	}
+
+	/* Perform RX Equalization. Applies to non-KR interfaces for speeds
+	   >= 6.25Gbps. */
+	if (!lmac->use_training) {
+		int qlm;
+		bool use_dlm = 0;
+		if (is_board_model(CN81XX)
+		    || (is_board_model(CN83XX) && (bgx->bgx_id == 2)))
+			use_dlm = 1;
+		switch (lmac->lmac_type) {
+		default:
+		case BGX_MODE_SGMII:
+		case BGX_MODE_RGMII:
+		case BGX_MODE_XAUI:
+			/* Nothing to do */
+			break;
+		case BGX_MODE_XLAUI:
+			if (use_dlm) {
+				if (__rx_equalization(lmac->qlm, -1) ||
+					__rx_equalization(lmac->qlm+1, -1)) {
+					printf("BGX%d:%d: Waiting for RX Equalization on DLM%d/DLM%d\n",
+						bgx->bgx_id, lmacid, lmac->qlm, lmac->qlm+1);
+					return -1;
+				}
+			} else {
+				if (__rx_equalization(lmac->qlm, -1)) {
+					printf("BGX%d:%d: Waiting for RX Equalization on QLM%d:\n",
+						bgx->bgx_id, lmacid, lmac->qlm);
+					return -1;
+				}
+			}
+			break;
+		case BGX_MODE_RXAUI:
+			/* RXAUI0 uses LMAC0:QLM0/QLM2 and RXAUI1 uses LMAC1:QLM1/QLM3
+			   RXAUI requires 2 lanes for each interface */
+			qlm = lmac->qlm;
+			if (__rx_equalization(qlm, 0)) {
+				printf("BGX%d:%d: Waiting for RX Equalization on QLM%d, Lane0\n",
+					bgx->bgx_id, lmacid, qlm);
+				return -1;
+			}
+			if (__rx_equalization(qlm, 1)) {
+				printf("BGX%d:%d: Waiting for RX Equalization on QLM%d, Lane1\n",
+					bgx->bgx_id, lmacid, qlm);
+				return -1;
+			}
+			break;
+		case BGX_MODE_XFI:
+			{
+				int lid;
+				if ((bgx->bgx_id == 0) && is_altpkg && lmacid)
+					lid = 0;
+				else if ((lmacid >= 2) && use_dlm)
+					lid = lmacid - 2;
+				else
+					lid = lmacid;
+
+				if (__rx_equalization(lmac->qlm, lid))
+					printf("BGX%d:%d: Waiting for RX Equalization on QLM%d\n",
+						bgx->bgx_id, lid, lmac->qlm);
+			}
+			break;
+		}
+	}
+
+	/* wait for PCS to come out of reset */
+	if (bgx_poll_reg(bgx, lmacid, BGX_SPUX_CONTROL1, SPU_CTL_RESET, true)) {
+		printf("BGX SPU reset not completed\n");
+		return -1;
+	}
+
+	if ((lmac_type == 3) || (lmac_type == 4)) {
+		if (bgx_poll_reg(bgx, lmacid, BGX_SPUX_BR_STATUS1,
+				 SPU_BR_STATUS_BLK_LOCK, false)) {
+			printf("SPU_BR_STATUS_BLK_LOCK not completed\n");
+			return -1;
+		}
+	} else {
+		if (bgx_poll_reg(bgx, lmacid, BGX_SPUX_BX_STATUS,
+				 SPU_BX_STATUS_RX_ALIGN, false)) {
+			printf("SPU_BX_STATUS_RX_ALIGN not completed\n");
+			return -1;
+		}
+	}
+
+	/* Clear rcvflt bit (latching high) and read it back */
+	bgx_reg_modify(bgx, lmacid, BGX_SPUX_STATUS2, SPU_STATUS2_RCVFLT);
+	if (bgx_reg_read(bgx, lmacid, BGX_SPUX_STATUS2) & SPU_STATUS2_RCVFLT) {
+		printf("Receive fault, retry training\n");
+		if (lmac->use_training) {
+			cfg = bgx_reg_read(bgx, lmacid, BGX_SPUX_INT);
+			if (!(cfg & (1ull << 13))) {
+				cfg = (1ull << 13) | (1ull << 14);
+				bgx_reg_write(bgx, lmacid, BGX_SPUX_INT, cfg);
+				cfg = bgx_reg_read(bgx, lmacid,
+						   BGX_SPUX_BR_PMD_CRTL);
+				cfg |= (1ull << 0);
+				bgx_reg_write(bgx, lmacid,
+					      BGX_SPUX_BR_PMD_CRTL, cfg);
+				return -1;
+			}
+		}
+		return -1;
+	}
+
+	/* Wait for MAC RX to be ready */
+	if (bgx_poll_reg(bgx, lmacid, BGX_SMUX_RX_CTL,
+			 SMU_RX_CTL_STATUS, true)) {
+		printf( "SMU RX link not okay\n");
+		return -1;
+	}
+
+	/* Wait for BGX RX to be idle */
+	if (bgx_poll_reg(bgx, lmacid, BGX_SMUX_CTL, SMU_CTL_RX_IDLE, false)) {
+		printf("SMU RX not idle\n");
+		return -1;
+	}
+
+	/* Wait for BGX TX to be idle */
+	if (bgx_poll_reg(bgx, lmacid, BGX_SMUX_CTL, SMU_CTL_TX_IDLE, false)) {
+		printf("SMU TX not idle\n");
+		return -1;
+	}
+
+	if (bgx_reg_read(bgx, lmacid, BGX_SPUX_STATUS2) & SPU_STATUS2_RCVFLT) {
+		printf("Receive fault\n");
+		return -1;
+	}
+
+	/* Receive link is latching low. Force it high and verify it */
+	if (!(bgx_reg_read(bgx, lmacid, BGX_SPUX_STATUS1) & SPU_STATUS1_RCV_LNK))
+		bgx_reg_modify(bgx, lmacid, BGX_SPUX_STATUS1, SPU_STATUS1_RCV_LNK);
+	if (bgx_poll_reg(bgx, lmacid, BGX_SPUX_STATUS1,
+			 SPU_STATUS1_RCV_LNK, false)) {
+		printf("SPU receive link down\n");
+		return -1;
+	}
+
+	cfg = bgx_reg_read(bgx, lmacid, BGX_SPUX_MISC_CONTROL);
+	cfg &= ~SPU_MISC_CTL_RX_DIS;
+	bgx_reg_write(bgx, lmacid, BGX_SPUX_MISC_CONTROL, cfg);
+	return 0;
+}
+
+int bgx_poll_for_link(int node, int bgx_idx, int lmacid)
+{
+	int ret;
+	struct lmac *lmac = bgx_get_lmac(node, bgx_idx, lmacid);
+	char mii_name[10];
+
+	if (lmac == NULL) {
+		printf("LMAC %d/%d/%d is disabled or doesn't exist\n",
+		       node, bgx_idx, lmacid);
+		return 0;
+	}
+
+	debug("%s: %d, lmac: %d/%d/%d %p\n",
+	      __FILE__, __LINE__,
+	      node, bgx_idx, lmacid, lmac);
+
+	if ((lmac->qlm_mode == QLM_MODE_SGMII) ||
+	    (lmac->qlm_mode == QLM_MODE_RGMII) ||
+	    (lmac->qlm_mode == QLM_MODE_QSGMII)) {
+
+		if (bgx_board_info[bgx_idx].phy_info[lmacid].phy_addr == -1) {
+			lmac->link_up = 1;
+			lmac->last_speed = 1000;
+			lmac->last_duplex = 1;
+			printf("BGX%d:LMAC %u link up\n", bgx_idx, lmacid);
+			return lmac->link_up;
+		}
+		snprintf(mii_name, sizeof(mii_name), "smi%d",
+			 bgx_board_info[bgx_idx].phy_info[lmacid].mdio_bus);
+
+		debug("mii_name: %s\n", mii_name);
+
+		lmac->mii_bus = miiphy_get_dev_by_name(mii_name);
+		lmac->phy_addr = bgx_board_info[bgx_idx].
+				 phy_info[lmacid].phy_addr;
+
+		debug("lmac->mii_bus: %p\n",lmac->mii_bus);
+		if (!lmac->mii_bus) {
+			printf("MDIO device %s not found\n", mii_name);
+			ret = -ENODEV;
+			return ret;
+		}
+
+		lmac->phydev = phy_connect(lmac->mii_bus, lmac->phy_addr,
+					   lmac->dev,
+					   if_mode[lmac->qlm_mode]);
+
+		if (!lmac->phydev) {
+			printf("%s: No PHY device\n",
+				__func__);
+			return -1;
+		}
+
+		ret = phy_config(lmac->phydev);
+		if (ret) {
+			printf("%s: Could not initialize PHY %s\n",
+				__func__, lmac->phydev->dev->name);
+			return ret;
+		}
+
+		ret = phy_startup(lmac->phydev);
+		debug("%s: %d\n", __FILE__, __LINE__);
+		if (ret) {
+			printf("%s: Could not initialize PHY %s\n",
+				__func__, lmac->phydev->dev->name);
+		}
+
+#ifdef CONFIG_OCTEONTX_XCV
+		if (lmac->qlm_mode == QLM_MODE_RGMII)
+			xcv_setup_link(lmac->phydev->link, lmac->phydev->speed);
+#endif
+
+		lmac->link_up = lmac->phydev->link;
+		lmac->last_speed = lmac->phydev->speed;
+		lmac->last_duplex = lmac->phydev->duplex;
+
+		debug("bgx_poll_for_link(), qlm_mode %d phy link status 0x%x,"
+			"last speed 0x%x, duplex 0x%x\n",
+			lmac->qlm_mode, lmac->link_up, lmac->last_speed, lmac->last_duplex);
+
+		if (lmac->qlm_mode != QLM_MODE_RGMII)
+			bgx_lmac_sgmii_set_link_speed(lmac);
+
+	} else {
+		u64 status1;
+		u64 tx_ctl;
+		u64 rx_ctl;
+		status1 = bgx_reg_read(lmac->bgx, lmac->lmacid, BGX_SPUX_STATUS1);
+		tx_ctl = bgx_reg_read(lmac->bgx, lmac->lmacid, BGX_SMUX_TX_CTL);
+		rx_ctl = bgx_reg_read(lmac->bgx, lmac->lmacid, BGX_SMUX_RX_CTL);
+
+		debug("BGX%d LMAC%d BGX_SPUX_STATUS2: %lx\n",
+		      bgx_idx, lmacid,
+		      (unsigned long)bgx_reg_read(lmac->bgx, lmac->lmacid, BGX_SPUX_STATUS2));
+		debug("BGX%d LMAC%d BGX_SPUX_STATUS1: %lx\n",
+		      bgx_idx, lmacid,
+		      (unsigned long)bgx_reg_read(lmac->bgx, lmac->lmacid, BGX_SPUX_STATUS1));
+		debug("BGX%d LMAC%d BGX_SMUX_RX_CTL: %lx\n",
+		      bgx_idx, lmacid,
+		      (unsigned long)bgx_reg_read(lmac->bgx, lmac->lmacid, BGX_SMUX_RX_CTL));
+		debug("BGX%d LMAC%d BGX_SMUX_TX_CTL: %lx\n",
+		      bgx_idx, lmacid,
+		      (unsigned long)bgx_reg_read(lmac->bgx, lmac->lmacid, BGX_SMUX_TX_CTL));
+
+		if ((status1 & SPU_STATUS1_RCV_LNK) &&
+		    ((tx_ctl & SMU_TX_CTL_LNK_STATUS) == 0) &&
+		    ((rx_ctl & SMU_RX_CTL_STATUS) == 0)) {
+			lmac->link_up = 1;
+			if (lmac->lmac_type == 4)
+				lmac->last_speed = 40000;
+			else
+				lmac->last_speed = 10000;
+			lmac->last_duplex = 1;
+		} else {
+			lmac->link_up = 0;
+			lmac->last_speed = 0;
+			lmac->last_duplex = 0;
+			return bgx_xaui_check_link(lmac);
+		}
+
+		lmac->last_link = lmac->link_up;
+	}
+
+	printf("BGX%d:LMAC %u link %s\n", bgx_idx, lmacid,  (lmac->link_up) ? "up" : "down");
+
+	return lmac->link_up;
+}
+
+
+static int bgx_lmac_enable(struct bgx *bgx, int8_t lmacid)
+{
+	struct lmac *lmac;
+	uint64_t cfg;
+
+	lmac = &bgx->lmac[lmacid];
+	lmac->bgx = bgx;
+
+	debug("bgx_lmac_enable: lmac: %p, lmacid = %d\n", lmac, lmacid);
+
+	if ((lmac->qlm_mode == QLM_MODE_SGMII) ||
+	    (lmac->qlm_mode == QLM_MODE_RGMII) ||
+	    (lmac->qlm_mode == QLM_MODE_QSGMII)) {
+		if (bgx_lmac_sgmii_init(bgx, lmacid)) {
+			debug("bgx_lmac_sgmii_init failed\n");
+			return -1;
+		}
+		cfg = bgx_reg_read(bgx, lmacid, BGX_GMP_GMI_TXX_APPEND);
+		cfg |= ((1ull << 2) | (1ull << 1)); /* FCS and PAD */
+		bgx_reg_modify(bgx, lmacid, BGX_GMP_GMI_TXX_APPEND, cfg);
+		bgx_reg_write(bgx, lmacid, BGX_GMP_GMI_TXX_MIN_PKT, 60 - 1);
+	} else {
+		if (bgx_lmac_xaui_init(bgx, lmacid, lmac->lmac_type))
+			return -1;
+		cfg = bgx_reg_read(bgx, lmacid, BGX_SMUX_TX_APPEND);
+		cfg |= ((1ull << 2) | (1ull << 1)); /* FCS and PAD */
+		bgx_reg_modify(bgx, lmacid, BGX_SMUX_TX_APPEND, cfg);
+		bgx_reg_write(bgx, lmacid, BGX_SMUX_TX_MIN_PKT, 60 + 4);
+	}
+
+	/* Enable lmac */
+	bgx_reg_modify(bgx, lmacid, BGX_CMRX_CFG,
+		       CMR_EN | CMR_PKT_RX_EN | CMR_PKT_TX_EN);
+
+	return 0;
+}
+
+void bgx_lmac_disable(struct bgx *bgx, uint8_t lmacid)
+{
+	struct lmac *lmac;
+	uint64_t cmrx_cfg;
+
+	lmac = &bgx->lmac[lmacid];
+
+	cmrx_cfg = bgx_reg_read(bgx, lmacid, BGX_CMRX_CFG);
+	cmrx_cfg &= ~(1 << 15);
+	bgx_reg_write(bgx, lmacid, BGX_CMRX_CFG, cmrx_cfg);
+	bgx_flush_dmac_addrs(bgx, lmacid);
+
+	if (lmac->phydev)
+		phy_shutdown(lmac->phydev);
+
+	lmac->phydev = NULL;
+}
+
+/* Program BGXX_CMRX_CONFIG.{lmac_type,lane_to_sds} for each interface.
+ * And the number of LMACs used by this interface. Each lmac can be in
+ * programmed in a different mode, so parse each lmac one at a time. */
+static void bgx_init_hw(struct bgx *bgx)
+{
+	struct lmac *lmac;
+	int i, lmacid, count = 0, inc = 0;
+	char buf[40];
+	static int qsgmii_configured = 0;
+
+	for (lmacid = 0; lmacid < MAX_LMAC_PER_BGX; lmacid++) {
+		struct lmac *tlmac;
+
+		lmac = &bgx->lmac[lmacid];
+		debug("bgx_init_hw: lmacid = %d, qlm = %d, mode = %d\n", lmacid, lmac->qlm, lmac->qlm_mode);
+		/* If QLM is not programmed, skip */
+		if (lmac->qlm == -1)
+			continue;
+
+		switch (lmac->qlm_mode) {
+		case QLM_MODE_SGMII:
+		{
+			/* EBB8000 (alternative pkg) has only lane0 present on
+			   DLM0 and DLM1, skip configuring other lanes */
+			if ((bgx->bgx_id == 0) && is_altpkg) {
+				if (lmacid % 2)
+					continue;
+			}
+			lmac->lane_to_sds = lmacid;
+			lmac->lmac_type = 0;
+			snprintf(buf, sizeof(buf),
+				 "BGX%d QLM%d LMAC%d mode: %s\n",
+				 bgx->bgx_id, lmac->qlm, lmacid,
+				 lmac->is_1gx ? "1000Base-X" : "SGMII");
+			break;
+		}
+		case QLM_MODE_XAUI:
+			if (lmacid != 0)
+				continue;
+			lmac->lmac_type = 1;
+			lmac->lane_to_sds = 0xE4;
+			snprintf(buf, sizeof(buf),
+				 "BGX%d QLM%d LMAC%d mode: XAUI\n",
+				 bgx->bgx_id, lmac->qlm, lmacid);
+			break;
+		case QLM_MODE_RXAUI:
+			if (lmacid == 0) {
+				lmac->lmac_type = 2;
+				lmac->lane_to_sds = 0x4;
+			} else if (lmacid == 1) {
+				struct lmac *tlmac;
+				tlmac = &bgx->lmac[2];
+				if (tlmac->qlm_mode == QLM_MODE_RXAUI) {
+					lmac->lmac_type = 2;
+					lmac->lane_to_sds = 0xe;
+					lmac->qlm = tlmac->qlm;
+				}
+			} else
+				continue;
+			snprintf(buf, sizeof(buf),
+				 "BGX%d QLM%d LMAC%d mode: RXAUI\n",
+				 bgx->bgx_id, lmac->qlm, lmacid);
+			break;
+		case QLM_MODE_XFI:
+			/* EBB8000 (alternative pkg) has only lane0 present on
+			   DLM0 and DLM1, skip configuring other lanes */
+			if ((bgx->bgx_id == 0) && is_altpkg) {
+				if (lmacid % 2)
+					continue;
+			}
+			lmac->lane_to_sds = lmacid;
+			lmac->lmac_type = 3;
+			snprintf(buf, sizeof(buf),
+				 "BGX%d QLM%d LMAC%d mode: XFI\n",
+				 bgx->bgx_id, lmac->qlm, lmacid);
+			break;
+		case QLM_MODE_XLAUI:
+			if (lmacid != 0)
+				continue;
+			lmac->lmac_type = 4;
+			lmac->lane_to_sds = 0xE4;
+			snprintf(buf, sizeof(buf),
+				 "BGX%d QLM%d LMAC%d mode: XLAUI\n",
+				 bgx->bgx_id, lmac->qlm, lmacid);
+			break;
+		case QLM_MODE_10G_KR:
+			/* EBB8000 (alternative pkg) has only lane0 present on
+			   DLM0 and DLM1, skip configuring other lanes */
+			if ((bgx->bgx_id == 0) && is_altpkg) {
+				if (lmacid % 2)
+					continue;
+			}
+			lmac->lane_to_sds = lmacid;
+			lmac->lmac_type = 3;
+			lmac->use_training = 1;
+			snprintf(buf, sizeof(buf),
+				 "BGX%d QLM%d LMAC%d mode: 10G-KR\n",
+				 bgx->bgx_id, lmac->qlm, lmacid);
+			break;
+		case QLM_MODE_40G_KR4:
+			if (lmacid != 0)
+				continue;
+			lmac->lmac_type = 4;
+			lmac->lane_to_sds = 0xE4;
+			lmac->use_training = 1;
+			snprintf(buf, sizeof(buf),
+				 "BGX%d QLM%d LMAC%d mode: 40G-KR4\n",
+				 bgx->bgx_id, lmac->qlm, lmacid);
+			break;
+		case QLM_MODE_RGMII:
+			if (lmacid != 0)
+				continue;
+			lmac->lmac_type = 5;
+			lmac->lane_to_sds = 0xE4;
+			snprintf(buf, sizeof(buf),
+				 "BGX%d LMAC%d mode: RGMII\n",
+				 bgx->bgx_id, lmacid);
+			break;
+		case QLM_MODE_QSGMII:
+			if (qsgmii_configured)
+				continue;
+			if ((lmacid == 0) || (lmacid == 2)) {
+				count = 4;
+				printf("BGX%d QLM%d LMAC%d mode: QSGMII\n",
+					bgx->bgx_id, lmac->qlm, lmacid);
+				for (i = 0; i < count; i++) {
+					struct lmac *l;
+					l = &bgx->lmac[i];
+					l->lmac_type = 6;
+					l->qlm_mode = QLM_MODE_QSGMII;
+					l->lane_to_sds = lmacid + i;
+					if (is_bgx_port_valid(bgx->bgx_id, i))
+						bgx_reg_write(bgx, i, BGX_CMRX_CFG,
+							      (l->lmac_type << 8) |
+							      l->lane_to_sds);
+				}
+				qsgmii_configured = 1;
+			}
+			continue;
+		default:
+			continue;
+		}
+
+		/* Reset lmac to the unused slot */
+		if (is_bgx_port_valid(bgx->bgx_id, count) &&
+		    (lmac->qlm_mode != QLM_MODE_QSGMII)) {
+			int lmac_enable = 0;
+			tlmac = &bgx->lmac[count];
+			tlmac->lmac_type = lmac->lmac_type;
+			/* Adjust lane_to_sds based on BGX-ENABLE */
+			for (; (inc + count) < MAX_LMAC_PER_BGX; inc++) {
+				lmac_enable = bgx_board_info[bgx->bgx_id].lmac_enable[count + inc];
+				if (lmac_enable)
+					break;
+			}
+
+			if ((inc != 0) && (inc < MAX_LMAC_PER_BGX) && lmac_enable && (inc != count))
+				tlmac->lane_to_sds = lmac->lane_to_sds + abs(inc - count);
+			else
+				tlmac->lane_to_sds = lmac->lane_to_sds;
+			tlmac->qlm = lmac->qlm;
+			tlmac->qlm_mode = lmac->qlm_mode;
+
+			printf("%s", buf);
+			/* Initialize lmac_type and lane_to_sds */
+			bgx_reg_write(bgx, count, BGX_CMRX_CFG,
+				      (tlmac->lmac_type << 8) |
+				      tlmac->lane_to_sds);
+			count += 1;
+		}
+	}
+
+	/* Done probing all 4 lmacs, now clear qsgmii_configured */
+	qsgmii_configured = 0;
+
+	printf("BGX%d LMACs: %d\n", bgx->bgx_id, count);
+	bgx->lmac_count = count;
+	bgx_reg_write(bgx, 0, BGX_CMR_RX_LMACS, count);
+	bgx_reg_write(bgx, 0, BGX_CMR_TX_LMACS, count);
+
+	bgx_reg_modify(bgx, 0, BGX_CMR_GLOBAL_CFG, CMR_GLOBAL_CFG_FCS_STRIP);
+	if (bgx_reg_read(bgx, 0, BGX_CMR_BIST_STATUS))
+		printf("BGX%d BIST failed\n", bgx->bgx_id);
+
+	/* Set the backpressure AND mask */
+	for (i = 0; i < bgx->lmac_count; i++)
+		bgx_reg_modify(bgx, 0, BGX_CMR_CHAN_MSK_AND,
+			       ((1ULL << MAX_BGX_CHANS_PER_LMAC) - 1) <<
+				(i * MAX_BGX_CHANS_PER_LMAC));
+
+	/* Disable all MAC filtering */
+	for (i = 0; i < RX_DMAC_COUNT; i++)
+		bgx_reg_write(bgx, 0, BGX_CMR_RX_DMACX_CAM + (i * 8), 0x00);
+
+	/* Disable MAC steering (NCSI traffic) */
+	for (i = 0; i < RX_TRAFFIC_STEER_RULE_COUNT; i++)
+		bgx_reg_write(bgx, 0, BGX_CMR_RX_STREERING + (i * 8), 0x00);
+}
+
+static void bgx_get_qlm_mode(struct bgx *bgx)
+{
+	struct lmac *lmac;
+	int lmacid;
+
+	/* Read LMACx type to figure out QLM mode
+	 * This is configured by low level firmware
+	 */
+	for (lmacid = 0; lmacid < MAX_LMAC_PER_BGX; lmacid++) {
+		int lmac_type;
+		int train_en;
+		int index = 0;
+
+		if (is_board_model(CN81XX)
+		    || (is_board_model(CN83XX) && (bgx->bgx_id == 2)))
+			index = (lmacid < 2) ? 0 : 2;
+
+		lmac = &bgx->lmac[lmacid];
+
+		/* check if QLM is programmed, if not, skip */
+		if (lmac->qlm == -1)
+			continue;
+
+		lmac_type = bgx_reg_read(bgx, index, BGX_CMRX_CFG);
+		lmac->lmac_type = (lmac_type >> 8) & 0x07;
+		debug("bgx_get_qlm_mode:%d:%d: lmac_type = %d, altpkg = %d\n", bgx->bgx_id,
+				lmacid, lmac->lmac_type, is_altpkg);
+
+		train_en = (readq(CSR_PA(0, GSERX_SCRATCH(lmac->qlm))) & 0xf);
+		lmac->is_1gx = bgx_reg_read(bgx, index, BGX_GMP_PCS_MISCX_CTL)
+				& (PCS_MISC_CTL_MODE) ? true : false;
+
+		switch(lmac->lmac_type) {
+		case BGX_MODE_SGMII:
+			if (bgx->is_rgx) {
+				if (lmacid == 0) {
+					lmac->qlm_mode = QLM_MODE_RGMII;
+					debug("BGX%d LMAC%d mode: RGMII\n",
+							bgx->bgx_id, lmacid);
+				}
+				continue;
+			} else {
+				if ((bgx->bgx_id == 0) && is_altpkg) {
+					if (lmacid % 2)
+						continue;
+				}
+				lmac->qlm_mode = QLM_MODE_SGMII;
+				debug("BGX%d QLM%d LMAC%d mode: %s\n",
+				      bgx->bgx_id, lmac->qlm, lmacid,
+				      lmac->is_1gx ? "1000Base-X" : "SGMII");
+			}
+			break;
+		case BGX_MODE_XAUI:
+			if ((bgx->bgx_id == 0) && is_altpkg)
+				continue;
+			lmac->qlm_mode = QLM_MODE_XAUI;
+			if (lmacid != 0)
+				continue;
+			debug("BGX%d QLM%d LMAC%d mode: XAUI\n",
+					bgx->bgx_id, lmac->qlm, lmacid);
+			break;
+		case BGX_MODE_RXAUI:
+			if ((bgx->bgx_id == 0) && is_altpkg)
+				continue;
+			lmac->qlm_mode = QLM_MODE_RXAUI;
+			if (index == lmacid) {
+				debug("BGX%d QLM%d LMAC%d mode: RXAUI\n",
+					bgx->bgx_id, lmac->qlm, (index ? 1 : 0));
+			}
+			break;
+		case BGX_MODE_XFI:
+			if ((bgx->bgx_id == 0) && is_altpkg) {
+				if (lmacid % 2)
+					continue;
+			}
+			if (((lmacid < 2) && (train_en & (1 << lmacid)))
+			    || (train_en & (1 << (lmacid - 2)))) {
+				lmac->qlm_mode = QLM_MODE_10G_KR;
+				debug("BGX%d QLM%d LMAC%d mode: 10G_KR\n",
+					bgx->bgx_id, lmac->qlm, lmacid);
+			} else {
+				lmac->qlm_mode = QLM_MODE_XFI;
+				debug("BGX%d QLM%d LMAC%d mode: XFI\n",
+					bgx->bgx_id, lmac->qlm, lmacid);
+			}
+			break;
+		case BGX_MODE_XLAUI:
+			if ((bgx->bgx_id == 0) && is_altpkg)
+				continue;
+			if (train_en) {
+				lmac->qlm_mode = QLM_MODE_40G_KR4;
+				if (lmacid != 0)
+					break;
+				debug("BGX%d QLM%d LMAC%d mode: 40G_KR4\n",
+					bgx->bgx_id, lmac->qlm, lmacid);
+			} else {
+				lmac->qlm_mode = QLM_MODE_XLAUI;
+				if (lmacid != 0)
+					break;
+				debug("BGX%d QLM%d LMAC%d mode: XLAUI\n",
+					bgx->bgx_id, lmac->qlm, lmacid);
+			}
+		break;
+		case BGX_MODE_QSGMII:
+			/* If QLM is configured as QSGMII, use lmac0 */
+			if (is_board_model(CN83XX)
+			    && (lmacid == 2)
+			    && (bgx->bgx_id != 2)) {
+				//lmac->qlm_mode = QLM_MODE_DISABLED;
+				continue;
+			}
+
+			if ((lmacid == 0) || (lmacid == 2)) {
+				lmac->qlm_mode = QLM_MODE_QSGMII;
+				debug("BGX%d QLM%d LMAC%d mode: QSGMII\n",
+					bgx->bgx_id, lmac->qlm, lmacid);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+}
+
+void bgx_set_board_info(int bgx_id, int *mdio_bus,
+			int *phy_addr, bool *autoneg_dis, bool *lmac_reg,
+			bool *lmac_enable)
+{
+	unsigned int i;
+
+	for (i = 0; i < MAX_LMAC_PER_BGX; i++) {
+		bgx_board_info[bgx_id].phy_info[i].phy_addr = phy_addr[i];
+		bgx_board_info[bgx_id].phy_info[i].mdio_bus = mdio_bus[i];
+		bgx_board_info[bgx_id].phy_info[i].autoneg_dis = autoneg_dis[i];
+		bgx_board_info[bgx_id].lmac_reg[i] = lmac_reg[i];
+		bgx_board_info[bgx_id].lmac_enable[i] = lmac_enable[i];
+		debug("bgx_set_board_info bgx_id %d lmac %d phy_addr 0x%x mdio bus %d\n"
+		      "autoneg_dis %d lmac_reg %d, lmac_enable = %d\n", bgx_id, i,
+			bgx_board_info[bgx_id].phy_info[i].phy_addr,
+			bgx_board_info[bgx_id].phy_info[i].mdio_bus,
+			bgx_board_info[bgx_id].phy_info[i].autoneg_dis,
+			bgx_board_info[bgx_id].lmac_reg[i],
+			bgx_board_info[bgx_id].lmac_enable[i]);
+	}
+}
+
+
+int octeontx_bgx_remove(struct udevice *dev)
+{
+	int lmacid;
+	u64 cfg;
+	int count = MAX_LMAC_PER_BGX;
+	struct bgx *bgx = dev_get_priv(dev);
+
+	if (bgx->reg_base == NULL)
+		return 0;
+
+	if (bgx->is_rgx)
+		count = 1;
+
+	for (lmacid = 0; lmacid < count; lmacid++) {
+		struct lmac *lmac;	
+		lmac = &bgx->lmac[lmacid];
+		cfg = bgx_reg_read(bgx, lmacid, BGX_CMRX_CFG);
+		cfg &= ~(CMR_PKT_RX_EN | CMR_PKT_TX_EN);
+		bgx_reg_write(bgx, lmacid, BGX_CMRX_CFG, cfg);
+
+		/* Disable PCS for 1G interface */
+		if ((lmac->lmac_type == BGX_MODE_SGMII)
+		    || (lmac->lmac_type == BGX_MODE_QSGMII)) {
+			cfg = bgx_reg_read(bgx, lmacid, BGX_GMP_PCS_MRX_CTL);
+			cfg |= PCS_MRX_CTL_PWR_DN;
+			bgx_reg_write(bgx, lmacid, BGX_GMP_PCS_MRX_CTL, cfg);
+		}
+
+		debug("%s disabling bgx%d lmacid%d\n", __func__, bgx->bgx_id, lmacid);
+		bgx_lmac_disable(bgx, lmacid);
+	}
+	return 0;
+}
+
+int octeontx_bgx_probe(struct udevice *dev)
+{
+	int err;
+	struct bgx *bgx = dev_get_priv(dev);
+	uint8_t lmac = 0;
+	int qlm[4] = {-1, -1, -1, -1};
+	int bgx_idx, node;
+	size_t size;
+	int inc = 1;
+
+	bgx->reg_base = dm_pci_map_bar(dev, 0, &size, PCI_REGION_MEM);
+	if (bgx->reg_base == NULL) {
+		debug("No PCI region found\n");
+		return 0;
+	}
+	is_altpkg = g_cavm_bdt.alt_pkg;
+
+#ifdef CONFIG_OCTEONTX_XCV
+	/* Use FAKE BGX2 for RGX interface */
+	if ((((uintptr_t)bgx->reg_base >> 24) & 0xf) == 0x8) {
+		bgx->bgx_id = 2;
+		bgx->is_rgx = true;
+		for (lmac = 0; lmac < MAX_LMAC_PER_BGX; lmac++) {
+			if (lmac == 0) {
+				bgx->lmac[lmac].lmacid = 0;
+				bgx->lmac[lmac].qlm = 0;
+			} else {
+				bgx->lmac[lmac].qlm = -1;
+			}
+		}
+		xcv_init_hw();
+		goto skip_qlm_config;
+	}
+#endif
+
+	node = node_id(bgx->reg_base);
+	bgx_idx = ((uintptr_t)bgx->reg_base >> 24) & 3;
+	bgx->bgx_id = (node * CONFIG_MAX_BGX_PER_NODE) + bgx_idx;
+
+	if (is_board_model(CN81XX))
+		inc = 2;
+	else if (is_board_model(CN83XX) && (bgx_idx == 2))
+		inc = 2;
+
+	for (lmac = 0; lmac < MAX_LMAC_PER_BGX; lmac += inc) {
+		/* BGX3 (DLM4), has only 2 lanes */
+		if (is_board_model(CN83XX) && (bgx_idx == 3) && lmac >= 2)
+			continue;
+		qlm[lmac + 0] = get_qlm_for_bgx(node, bgx_idx, lmac);
+		/* Each DLM has 2 lanes, configure both lanes with
+		   same qlm configuration */
+		if (inc == 2)
+			qlm[lmac + 1] = qlm[lmac];
+		debug("qlm[%d] = %d\n", lmac, qlm[lmac]);
+	}
+
+	/* A BGX can take 1 or 2 DLMs, if both the DLMs are not configured
+	   as BGX, then return, nothing to initialize */
+	if (is_board_model(CN81XX))
+		if ((qlm[0] == -1) && (qlm[2] == -1))
+			return -ENODEV;
+
+	/* MAP configuration registers */
+	for (lmac = 0; lmac < MAX_LMAC_PER_BGX; lmac++) {
+		bgx->lmac[lmac].qlm = qlm[lmac];
+		bgx->lmac[lmac].lmacid = lmac;
+	}
+
+#ifdef CONFIG_OCTEONTX_XCV
+skip_qlm_config:
+#endif
+	bgx_vnic[bgx->bgx_id] = bgx;
+	bgx_get_qlm_mode(bgx);
+	debug("bgx_vnic[%u]: %p\n", bgx->bgx_id, bgx);
+
+	bgx_init_hw(bgx);
+
+	/* Enable all LMACs */
+	for (lmac = 0; lmac < bgx->lmac_count; lmac++) {
+		struct lmac *tlmac = &bgx->lmac[lmac];
+		tlmac->dev = dev;
+		err = bgx_lmac_enable(bgx, lmac);
+		if (err) {
+			printf("BGX%d failed to enable lmac%d\n",
+				bgx->bgx_id, lmac);
+		}
+	}
+
+	return 0;
+}
+
+static const struct misc_ops octeontx_bgx_ops = {
+};
+
+static const struct udevice_id octeontx_bgx_ids[] = {
+	{ .compatible = "cavium,thunder-8890-bgx" },
+	{}
+};
+
+U_BOOT_DRIVER(octeontx_bgx) = {
+	.name	= "octeontx_bgx",
+	.id	= UCLASS_MISC,
+	.probe	= octeontx_bgx_probe,
+	.remove	= octeontx_bgx_remove,
+	.of_match = octeontx_bgx_ids,
+	.ops	= &octeontx_bgx_ops,
+	.priv_auto_alloc_size = sizeof(struct bgx),
+	.flags  = DM_FLAG_OS_PREPARE,
+};
+
diff --git a/drivers/net/octeontx/octeontx_bgx.h b/drivers/net/octeontx/octeontx_bgx.h
new file mode 100644
index 0000000..d64fad1
--- /dev/null
+++ b/drivers/net/octeontx/octeontx_bgx.h
@@ -0,0 +1,252 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#ifndef OCTEONT_BGX_H
+#define OCTEONT_BGX_H
+
+#define    MAX_LMAC_PER_BGX			4
+#define    MAX_BGX_CHANS_PER_LMAC		16
+#define    MAX_DMAC_PER_LMAC			8
+#define    MAX_FRAME_SIZE			9216
+
+#define    MAX_DMAC_PER_LMAC_TNS_BYPASS_MODE	2
+
+#define    MAX_LMAC	(CONFIG_MAX_BGX_PER_NODE * MAX_LMAC_PER_BGX)
+
+#define    NODE_ID_MASK				0x300000000000
+#define    NODE_ID(x)				((x & NODE_ID_MASK) >> 44)
+
+/* Registers */
+#define GSERX_CFG(x)		(0x000087E090000080ull + (x) * 0x1000000ull)
+#define GSERX_SCRATCH(x)	(0x000087E090000020ull + (x) * 0x1000000ull)
+#define GSERX_PHY_CTL(x)	(0x000087E090000000ull + (x) * 0x1000000ull)
+#define GSERX_CFG_BGX		(1 << 2)
+#define GSER_RX_EIE_DETSTS(x)	(0x000087e090000150ull + (x) * 0x1000000ull)
+#define GSER_CDRLOCK		(8)
+#define GSER_BR_RXX_CTL(x,y)	(0x000087e090000400ull + (x) * 0x1000000ull + (y) * 0x80) 
+#define GSER_BR_RXX_CTL_RXT_SWM	(1 << 2)
+#define GSER_BR_RXX_EER(x,y)	(0x000087e090000418ull + (x) * 0x1000000ull + (y) * 0x80)
+#define GSER_BR_RXX_EER_RXT_ESV (1 << 14)
+#define GSER_BR_RXX_EER_RXT_EER (1 << 15)
+#define EER_RXT_ESV		(14)
+
+#define BGX_CMRX_CFG			0x00
+#define CMR_PKT_TX_EN				(1ull << 13)
+#define CMR_PKT_RX_EN				(1ull << 14)
+#define CMR_EN					(1ull << 15)
+#define BGX_CMR_GLOBAL_CFG		0x08
+#define CMR_GLOBAL_CFG_FCS_STRIP		(1ull << 6)
+#define BGX_CMRX_RX_ID_MAP		0x60
+#define BGX_CMRX_RX_STAT0		0x70
+#define BGX_CMRX_RX_STAT1		0x78
+#define BGX_CMRX_RX_STAT2		0x80
+#define BGX_CMRX_RX_STAT3		0x88
+#define BGX_CMRX_RX_STAT4		0x90
+#define BGX_CMRX_RX_STAT5		0x98
+#define BGX_CMRX_RX_STAT6		0xA0
+#define BGX_CMRX_RX_STAT7		0xA8
+#define BGX_CMRX_RX_STAT8		0xB0
+#define BGX_CMRX_RX_STAT9		0xB8
+#define BGX_CMRX_RX_STAT10		0xC0
+#define BGX_CMRX_RX_BP_DROP		0xC8
+#define BGX_CMRX_RX_DMAC_CTL		0x0E8
+#define BGX_CMR_RX_DMACX_CAM		0x200
+#define RX_DMACX_CAM_EN				(1ull << 48)
+#define RX_DMACX_CAM_LMACID(x)			(x << 49)
+#define RX_DMAC_COUNT				32
+#define BGX_CMR_RX_STREERING		0x300
+#define RX_TRAFFIC_STEER_RULE_COUNT		8
+#define BGX_CMR_CHAN_MSK_AND		0x450
+#define BGX_CMR_BIST_STATUS		0x460
+#define BGX_CMR_RX_LMACS		0x468
+#define BGX_CMRX_TX_STAT0		0x600
+#define BGX_CMRX_TX_STAT1		0x608
+#define BGX_CMRX_TX_STAT2		0x610
+#define BGX_CMRX_TX_STAT3		0x618
+#define BGX_CMRX_TX_STAT4		0x620
+#define BGX_CMRX_TX_STAT5		0x628
+#define BGX_CMRX_TX_STAT6		0x630
+#define BGX_CMRX_TX_STAT7		0x638
+#define BGX_CMRX_TX_STAT8		0x640
+#define BGX_CMRX_TX_STAT9		0x648
+#define BGX_CMRX_TX_STAT10		0x650
+#define BGX_CMRX_TX_STAT11		0x658
+#define BGX_CMRX_TX_STAT12		0x660
+#define BGX_CMRX_TX_STAT13		0x668
+#define BGX_CMRX_TX_STAT14		0x670
+#define BGX_CMRX_TX_STAT15		0x678
+#define BGX_CMRX_TX_STAT16		0x680
+#define BGX_CMRX_TX_STAT17		0x688
+#define BGX_CMR_TX_LMACS		0x1000
+
+#define BGX_SPUX_CONTROL1		0x10000
+#define SPU_CTL_LOW_POWER			(1ull << 11)
+#define SPU_CTL_LOOPBACK                        (1ull << 14)
+#define SPU_CTL_RESET				(1ull << 15)
+#define BGX_SPUX_STATUS1		0x10008
+#define SPU_STATUS1_RCV_LNK			(1ull << 2)
+#define BGX_SPUX_STATUS2		0x10020
+#define SPU_STATUS2_RCVFLT			(1ull << 10)
+#define BGX_SPUX_BX_STATUS		0x10028
+#define SPU_BX_STATUS_RX_ALIGN                  (1ull << 12)
+#define BGX_SPUX_BR_STATUS1		0x10030
+#define SPU_BR_STATUS_BLK_LOCK			(1ull << 0)
+#define SPU_BR_STATUS_RCV_LNK			(1ull << 12)
+#define BGX_SPUX_BR_PMD_CRTL		0x10068
+#define SPU_PMD_CRTL_TRAIN_EN			(1ull << 1)
+#define BGX_SPUX_BR_PMD_LP_CUP		0x10078
+#define BGX_SPUX_BR_PMD_LD_CUP		0x10088
+#define BGX_SPUX_BR_PMD_LD_REP		0x10090
+#define BGX_SPUX_FEC_CONTROL		0x100A0
+#define SPU_FEC_CTL_FEC_EN			(1ull << 0)
+#define SPU_FEC_CTL_ERR_EN			(1ull << 1)
+#define BGX_SPUX_AN_CONTROL		0x100C8
+#define SPU_AN_CTL_AN_EN			(1ull << 12)
+#define SPU_AN_CTL_XNP_EN			(1ull << 13)
+#define SPU_AN_CTL_AN_RESTART			(1ull << 15)
+#define BGX_SPUX_AN_STATUS		0x100D0
+#define SPU_AN_STS_AN_COMPLETE			(1ull << 5)
+#define BGX_SPUX_AN_ADV			0x100D8
+#define BGX_SPUX_MISC_CONTROL		0x10218
+#define SPU_MISC_CTL_INTLV_RDISP		(1ull << 10)
+#define SPU_MISC_CTL_RX_DIS			(1ull << 12)
+#define BGX_SPUX_INT			0x10220	/* +(0..3) << 20 */
+#define BGX_SPUX_INT_W1S		0x10228
+#define BGX_SPUX_INT_ENA_W1C		0x10230
+#define BGX_SPUX_INT_ENA_W1S		0x10238
+#define BGX_SPU_DBG_CONTROL		0x10300
+#define SPU_DBG_CTL_AN_ARB_LINK_CHK_EN		(1ull << 18)
+#define SPU_DBG_CTL_AN_NONCE_MCT_DIS		(1ull << 29)
+
+#define BGX_SMUX_RX_INT			0x20000
+#define BGX_SMUX_RX_JABBER		0x20030
+#define BGX_SMUX_RX_CTL			0x20048
+#define SMU_RX_CTL_STATUS			(3ull << 0)
+#define BGX_SMUX_TX_APPEND		0x20100
+#define SMU_TX_APPEND_FCS_D			(1ull << 2)
+#define BGX_SMUX_TX_MIN_PKT		0x20118
+#define BGX_SMUX_TX_INT			0x20140
+#define BGX_SMUX_TX_CTL			0x20178
+#define SMU_TX_CTL_DIC_EN			(1ull << 0)
+#define SMU_TX_CTL_UNI_EN			(1ull << 1)
+#define SMU_TX_CTL_LNK_STATUS			(3ull << 4)
+#define BGX_SMUX_TX_THRESH		0x20180
+#define BGX_SMUX_CTL			0x20200
+#define SMU_CTL_RX_IDLE				(1ull << 0)
+#define SMU_CTL_TX_IDLE				(1ull << 1)
+
+#define BGX_GMP_PCS_MRX_CTL		0x30000
+#define	PCS_MRX_CTL_RST_AN			(1ull << 9)
+#define	PCS_MRX_CTL_PWR_DN			(1ull << 11)
+#define	PCS_MRX_CTL_AN_EN			(1ull << 12)
+#define PCS_MRX_CTL_LOOPBACK1                   (1ull << 14)
+#define	PCS_MRX_CTL_RESET			(1ull << 15)
+#define BGX_GMP_PCS_MRX_STATUS		0x30008
+#define	PCS_MRX_STATUS_AN_CPT			(1ull << 5)
+#define BGX_GMP_PCS_ANX_AN_RESULTS	0x30020
+#define BGX_GMP_PCS_SGM_AN_ADV		0x30068
+#define BGX_GMP_PCS_MISCX_CTL		0x30078
+#define PCS_MISCX_CTL_DISP_EN			(1ull << 13)
+#define PCS_MISC_CTL_GMX_ENO			(1ull << 11)
+#define PCS_MISC_CTL_SAMP_PT_MASK		0x7Full
+#define PCS_MISC_CTL_MODE			(1ull << 8)
+#define BGX_GMP_GMI_PRTX_CFG		0x38020
+#define GMI_PORT_CFG_SPEED			(1ull << 1)
+#define GMI_PORT_CFG_DUPLEX			(1ull << 2)
+#define GMI_PORT_CFG_SLOT_TIME			(1ull << 3)
+#define GMI_PORT_CFG_SPEED_MSB			(1ull << 8)
+#define BGX_GMP_GMI_RXX_JABBER		0x38038
+#define BGX_GMP_GMI_TXX_THRESH		0x38210
+#define BGX_GMP_GMI_TXX_APPEND		0x38218
+#define BGX_GMP_GMI_TXX_SLOT		0x38220
+#define BGX_GMP_GMI_TXX_BURST		0x38228
+#define BGX_GMP_GMI_TXX_MIN_PKT		0x38240
+#define BGX_GMP_GMI_TXX_SGMII_CTL	0x38300
+
+#define BGX_MSIX_VEC_0_29_ADDR		0x400000 /* +(0..29) << 4 */
+#define BGX_MSIX_VEC_0_29_CTL		0x400008
+#define BGX_MSIX_PBA_0			0x4F0000
+
+/* MSI-X interrupts */
+#define BGX_MSIX_VECTORS	30
+#define BGX_LMAC_VEC_OFFSET	7
+#define BGX_MSIX_VEC_SHIFT	4
+
+#define CMRX_INT		0
+#define SPUX_INT		1
+#define SMUX_RX_INT		2
+#define SMUX_TX_INT		3
+#define GMPX_PCS_INT		4
+#define GMPX_GMI_RX_INT		5
+#define GMPX_GMI_TX_INT		6
+#define CMR_MEM_INT		28
+#define SPU_MEM_INT		29
+
+#define LMAC_INTR_LINK_UP	(1 << 0)
+#define LMAC_INTR_LINK_DOWN	(1 << 1)
+
+/*  RX_DMAC_CTL configuration*/
+enum MCAST_MODE {
+		MCAST_MODE_REJECT,
+		MCAST_MODE_ACCEPT,
+		MCAST_MODE_CAM_FILTER,
+		RSVD
+};
+
+#define BCAST_ACCEPT	1
+#define CAM_ACCEPT	1
+
+int octeontx_bgx_initialize(unsigned int bgx_idx, unsigned int node);
+void bgx_add_dmac_addr(uint64_t dmac, int node, int bgx_idx, int lmac);
+void bgx_get_count(int node, int *bgx_count);
+int bgx_get_lmac_count(int node, int bgx);
+void bgx_print_stats(int bgx_idx, int lmac);
+void xcv_init_hw(void);
+void xcv_setup_link(bool link_up, int link_speed);
+
+#undef LINK_INTR_ENABLE
+
+enum qlm_mode {
+	QLM_MODE_SGMII,         /* SGMII, each lane independent */
+	QLM_MODE_XAUI,      /* 1 XAUI or DXAUI, 4 lanes */
+	QLM_MODE_RXAUI,     /* 2 RXAUI, 2 lanes each */
+	QLM_MODE_XFI,       /* 4 XFI, 1 lane each */
+	QLM_MODE_XLAUI,     /* 1 XLAUI, 4 lanes each */
+	QLM_MODE_10G_KR,    /* 4 10GBASE-KR, 1 lane each */
+	QLM_MODE_40G_KR4,   /* 1 40GBASE-KR4, 4 lanes each */
+	QLM_MODE_QSGMII,    /* 4 QSGMII, each lane independent */
+	QLM_MODE_RGMII,     /* 1 RGX */
+};
+
+struct phy_info {
+	int mdio_bus;
+	int phy_addr;
+	bool autoneg_dis;
+};
+
+struct bgx_board_info {
+	struct phy_info phy_info[MAX_LMAC_PER_BGX];
+	bool lmac_reg[MAX_LMAC_PER_BGX];
+	bool lmac_enable[MAX_LMAC_PER_BGX];
+};
+
+enum LMAC_TYPE {
+	BGX_MODE_SGMII = 0, /* 1 lane, 1.250 Gbaud */
+	BGX_MODE_XAUI = 1,  /* 4 lanes, 3.125 Gbaud */
+	BGX_MODE_DXAUI = 1, /* 4 lanes, 6.250 Gbaud */
+	BGX_MODE_RXAUI = 2, /* 2 lanes, 6.250 Gbaud */
+	BGX_MODE_XFI = 3,   /* 1 lane, 10.3125 Gbaud */
+	BGX_MODE_XLAUI = 4, /* 4 lanes, 10.3125 Gbaud */
+	BGX_MODE_10G_KR = 3,/* 1 lane, 10.3125 Gbaud */
+	BGX_MODE_40G_KR = 4,/* 4 lanes, 10.3125 Gbaud */
+	BGX_MODE_RGMII = 5,
+	BGX_MODE_QSGMII = 6,
+	BGX_MODE_INVALID = 7,
+};
+
+#endif /* OCTEONT_BGX_H */
diff --git a/drivers/net/octeontx/octeontx_smi.c b/drivers/net/octeontx/octeontx_smi.c
new file mode 100644
index 0000000..2b21170
--- /dev/null
+++ b/drivers/net/octeontx/octeontx_smi.c
@@ -0,0 +1,382 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#include <common.h>
+#include <dm.h>
+#include <pci.h>
+#include <phy.h>
+#include <miiphy.h>
+#include <misc.h>
+#include <malloc.h>
+#include <asm/io.h>
+#include <environment.h>
+#include <linux/ctype.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+enum octeontx_smi_mode {
+	CLAUSE22 = 0,
+	CLAUSE45 = 1,
+};
+
+enum {
+	SMI_OP_C22_WRITE = 0,
+	SMI_OP_C22_READ = 1,
+
+	SMI_OP_C45_ADDR = 0,
+	SMI_OP_C45_WRITE = 1,
+	SMI_OP_C45_PRIA = 2,
+	SMI_OP_C45_READ = 3,
+};
+
+union smi_x_clk {
+	u64 u;
+	struct smi_x_clk_s {
+		int phase:8;
+		int sample:4;
+		int preamble:1;
+		int clk_idle:1;
+		int reserved_14_14:1;
+		int sample_mode:1;
+		int sample_hi:5;
+		int reserved_21_23:3;
+		int mode:1;
+	} s;
+};
+
+union smi_x_cmd {
+	u64 u;
+	struct smi_x_cmd_s {
+		int reg_adr:5;
+		int reserved_5_7:3;
+		int phy_adr:5;
+		int reserved_13_15:3;
+		int phy_op:2;
+	} s;
+};
+
+union smi_x_wr_dat {
+	u64 u;
+	struct smi_x_wr_dat_s {
+		unsigned int dat:16;
+		int val:1;
+		int pending:1;
+	} s;
+};
+
+union smi_x_rd_dat {
+	u64 u;
+	struct smi_x_rd_dat_s {
+		unsigned int dat:16;
+		int val:1;
+		int pending:1;
+	} s;
+};
+
+union smi_x_en {
+	u64 u;
+	struct smi_x_en_s {
+		int en:1;
+	} s;
+};
+
+#define SMI_X_RD_DAT	0x10ull
+#define SMI_X_WR_DAT	0x08ull
+#define SMI_X_CMD	0x00ull
+#define SMI_X_CLK	0x18ull
+#define SMI_X_EN	0x20ull
+
+struct octeontx_smi_priv {
+	void __iomem *baseaddr;
+	enum octeontx_smi_mode mode;
+};
+
+#define MDIO_TIMEOUT 10000
+
+void octeontx_smi_setmode(struct mii_dev *bus, enum octeontx_smi_mode mode)
+{
+	struct octeontx_smi_priv *priv = bus->priv;
+	union smi_x_clk smix_clk;
+
+	smix_clk.u = readq(priv->baseaddr + SMI_X_CLK);
+	smix_clk.s.mode = mode;
+	smix_clk.s.preamble = mode == CLAUSE45;
+	writeq(smix_clk.u, priv->baseaddr + SMI_X_CLK);
+
+	priv->mode = mode;
+}
+
+int octeontx_c45_addr(struct mii_dev *bus, int addr, int devad, int regnum)
+{
+	struct octeontx_smi_priv *priv = bus->priv;
+
+	union smi_x_cmd smix_cmd;
+	union smi_x_wr_dat smix_wr_dat;
+	unsigned long timeout = MDIO_TIMEOUT;
+
+	smix_wr_dat.u = 0;
+	smix_wr_dat.s.dat = regnum;
+
+	writeq(smix_wr_dat.u, priv->baseaddr + SMI_X_WR_DAT);
+
+	smix_cmd.u = 0;
+	smix_cmd.s.phy_op = SMI_OP_C45_ADDR;
+	smix_cmd.s.phy_adr = addr;
+	smix_cmd.s.reg_adr = devad;
+
+	writeq(smix_cmd.u, priv->baseaddr + SMI_X_CMD);
+
+	do {
+		smix_wr_dat.u = readq(priv->baseaddr + SMI_X_WR_DAT);
+		udelay(100);
+		timeout--;
+	} while (smix_wr_dat.s.pending && timeout);
+
+	return timeout == 0;
+}
+
+int octeontx_phy_read(struct mii_dev *bus, int addr, int devad, int regnum)
+{
+	struct octeontx_smi_priv *priv = bus->priv;
+	union smi_x_cmd smix_cmd;
+	union smi_x_rd_dat smix_rd_dat;
+	unsigned long timeout = MDIO_TIMEOUT;
+	int ret;
+
+	enum octeontx_smi_mode mode = (devad < 0) ? CLAUSE22 : CLAUSE45;
+
+	debug("RD: Mode: %u, baseaddr: %p, addr: %d, devad: %d, reg: %d\n",
+	      mode, priv->baseaddr, addr, devad, regnum);
+
+	octeontx_smi_setmode(bus, mode);
+
+	if (mode == CLAUSE45) {
+		ret = octeontx_c45_addr(bus, addr, devad, regnum);
+
+		debug("RD: ret: %u\n", ret);
+
+		if (ret)
+			return 0;
+	}
+
+	smix_cmd.u = 0;
+	smix_cmd.s.phy_adr = addr;
+
+
+	if (mode == CLAUSE45) {
+		smix_cmd.s.reg_adr = devad;
+		smix_cmd.s.phy_op = SMI_OP_C45_READ;
+	} else {
+		smix_cmd.s.reg_adr = regnum;
+		smix_cmd.s.phy_op = SMI_OP_C22_READ;
+	}
+
+	writeq(smix_cmd.u, priv->baseaddr + SMI_X_CMD);
+
+	do {
+		smix_rd_dat.u = readq(priv->baseaddr + SMI_X_RD_DAT);
+		udelay(10);
+		timeout--;
+	} while (smix_rd_dat.s.pending && timeout);
+
+	debug("SMIX_RD_DAT: %lx\n", (unsigned long)smix_rd_dat.u);
+
+	return smix_rd_dat.s.dat;
+}
+
+int octeontx_phy_write(struct mii_dev *bus, int addr, int devad, int regnum,
+		       u16 value)
+{
+	struct octeontx_smi_priv *priv = bus->priv;
+	union smi_x_cmd smix_cmd;
+	union smi_x_wr_dat smix_wr_dat;
+	unsigned long timeout = MDIO_TIMEOUT;
+	int ret;
+
+	enum octeontx_smi_mode mode = (devad < 0) ? CLAUSE22 : CLAUSE45;
+
+	debug("WR: Mode: %u, baseaddr: %p, addr: %d, devad: %d, reg: %d\n",
+	      mode, priv->baseaddr, addr, devad, regnum);
+
+	if (mode == CLAUSE45) {
+		ret = octeontx_c45_addr(bus, addr, devad, regnum);
+
+		debug("WR: ret: %u\n", ret);
+
+		if (ret)
+			return ret;
+	}
+
+	smix_wr_dat.u = 0;
+	smix_wr_dat.s.dat = value;
+
+	writeq(smix_wr_dat.u, priv->baseaddr + SMI_X_WR_DAT);
+
+	smix_cmd.u = 0;
+	smix_cmd.s.phy_adr = addr;
+
+	if (mode == CLAUSE45) {
+		smix_cmd.s.reg_adr = devad;
+		smix_cmd.s.phy_op = SMI_OP_C45_WRITE;
+	} else {
+		smix_cmd.s.reg_adr = regnum;
+		smix_cmd.s.phy_op = SMI_OP_C22_WRITE;
+	}
+
+	writeq(smix_cmd.u, priv->baseaddr + SMI_X_CMD);
+
+	do {
+		smix_wr_dat.u = readq(priv->baseaddr + SMI_X_WR_DAT);
+		udelay(10);
+		timeout--;
+	} while (smix_wr_dat.s.pending && timeout);
+
+	debug("SMIX_WR_DAT: %lx\n", (unsigned long)smix_wr_dat.u);
+
+	return timeout == 0;
+}
+
+int octeontx_smi_reset(struct mii_dev *bus)
+{
+	struct octeontx_smi_priv *priv = bus->priv;
+
+	union smi_x_en smi_en;
+
+	smi_en.s.en = 0;
+	writeq(smi_en.u, priv->baseaddr + SMI_X_EN);
+
+	smi_en.s.en = 1;
+	writeq(smi_en.u, priv->baseaddr + SMI_X_EN);
+
+	octeontx_smi_setmode(bus, CLAUSE22);
+
+	return 0;
+}
+
+/* PHY XS initialization, primarily for RXAUI
+ *
+ */
+int __cavm_if_phy_xs_init(struct mii_dev *bus, int phy_addr)
+{
+	int reg;
+	ulong start_time;
+	int phy_id1, phy_id2;
+	int oui, model_number;
+
+	phy_id1 = octeontx_phy_read(bus, phy_addr, 1, 0x2);
+	phy_id2 = octeontx_phy_read(bus, phy_addr, 1, 0x3);
+	model_number = (phy_id2 >> 4) & 0x3F;
+	debug("%s model %x\n", __func__,model_number);
+	oui = phy_id1;
+	oui <<= 6;
+	oui |= (phy_id2 >> 10) & 0x3F;
+	debug("%s oui %x\n", __func__,oui);
+	switch (oui)
+	{
+		case 0x5016:
+			if (model_number == 9)
+			{
+				debug("%s +\n", __func__);
+				/* Perform hardware reset in XGXS control */
+				reg = octeontx_phy_read(bus, phy_addr, 4, 0x0);
+				if ((reg & 0xffff) < 0)
+				       goto read_error;
+				reg |= 0x8000;
+				octeontx_phy_write(bus, phy_addr, 4, 0x0, reg);
+
+				start_time = get_timer(0);
+				do {
+				       reg = octeontx_phy_read(bus, phy_addr, 4, 0x0);
+				       if ((reg & 0xffff) < 0)
+					       goto read_error;
+				} while ((reg & 0x8000) && get_timer(start_time) < 500);
+				if (reg & 0x8000) {
+				       printf("Hardware reset for M88X3120 PHY failed, MII_BMCR: 0x%x\n", reg);
+				       return -1;
+				}
+				/* program 4.49155 with 0x5 */
+				octeontx_phy_write(bus, phy_addr, 4, 0xc003, 0x5);
+			}
+			break;
+			default:
+				break;
+	}
+
+	return 0;
+
+read_error:
+	debug("M88X3120 PHY config read failed\n");
+	return -1;
+}
+
+int octeontx_smi_probe(struct udevice *dev)
+{
+	size_t size;
+	int ret, subnode, cnt = 0, node = dev->node.of_offset;
+	struct mii_dev *bus;
+	struct octeontx_smi_priv *priv;
+	pci_dev_t bdf = dm_pci_get_bdf(dev);
+
+        debug("SMI PCI device: %x\n", bdf);
+        dev->req_seq = PCI_FUNC(bdf);
+        if ( !dm_pci_map_bar(dev, 0, &size, PCI_REGION_MEM)) {
+		printf("Failed to map PCI region for bdf %x\n", bdf);
+		return -1;
+	}
+
+	fdt_for_each_subnode(subnode, gd->fdt_blob, node) {
+		ret = fdt_node_check_compatible(gd->fdt_blob, subnode,
+						"cavium,thunder-8890-mdio");
+		if (ret)
+			continue;
+
+		bus = mdio_alloc();
+		priv = malloc(sizeof(*priv));
+		if (!bus || !priv) {
+			printf("Failed to allocate OcteonTX MDIO bus # %u\n",
+				dev->seq);
+			return -1;
+		}
+
+		bus->read = octeontx_phy_read;
+		bus->write = octeontx_phy_write;
+		bus->reset = octeontx_smi_reset;
+		bus->priv = priv;
+
+		priv->mode = CLAUSE22;
+		priv->baseaddr = (void __iomem *)fdtdec_get_addr(gd->fdt_blob,
+							 subnode, "reg");
+		debug("mdio base addr %p\n", priv->baseaddr);
+
+		/* use given name or generate its own unique name */
+		snprintf(bus->name, MDIO_NAME_LEN, "smi%d", cnt++);
+
+		ret = mdio_register(bus);
+		if (ret) {
+			return ret;
+		}
+	}
+	return 0;
+}
+
+static const struct misc_ops octeontx_smi_ops = {
+};
+
+static const struct udevice_id octeontx_smi_ids[] = {
+	{ .compatible = "cavium,thunder-8890-mdio-nexus" },
+	{}
+};
+
+U_BOOT_DRIVER(octeontx_smi) = {
+	.name	= "octeontx_smi",
+	.id	= UCLASS_MISC,
+	.probe	= octeontx_smi_probe,
+	.of_match = octeontx_smi_ids,
+	.ops	= &octeontx_smi_ops,
+};
+
diff --git a/drivers/net/octeontx/octeontx_xcv.c b/drivers/net/octeontx/octeontx_xcv.c
new file mode 100644
index 0000000..ca2951a
--- /dev/null
+++ b/drivers/net/octeontx/octeontx_xcv.c
@@ -0,0 +1,171 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#include <config.h>
+#include <common.h>
+#include <errno.h>
+#include <net.h>
+#include <dm.h>
+#include <pci.h>
+#include <misc.h>
+#include <netdev.h>
+#include <malloc.h>
+#include <miiphy.h>
+#include <asm/io.h>
+
+#ifdef CONFIG_OF_LIBFDT
+ #include <linux/libfdt.h>
+ #include <fdt_support.h>
+#endif
+
+#include <asm/arch/octeontx_xcv.h>
+#include <asm/arch/octeontx_smi.h>
+#include <asm/arch/octeontx_vnic.h>
+
+struct lxcv {
+	void __iomem		*reg_base;
+	struct pci_dev		*pdev;
+};
+
+struct lxcv *xcv;
+
+/* Initialize XCV block */
+void xcv_init_hw(void)
+{
+	//union cavm_xcvx_ctl xcv_ctl;
+	union cavm_xcvx_reset reset;
+	union cavm_xcvx_dll_ctl xcv_dll_ctl;
+	//union cavm_xcvx_comp_ctl xcv_comp_ctl;
+
+	/* Take the DLL out of reset */
+	reset.u = readq(CAVM_XCVX_RESET);
+	reset.s.dllrst = 0;
+	writeq(reset.u, CAVM_XCVX_RESET);
+
+	/* Take the clock tree out of reset */
+	reset.u = readq(CAVM_XCVX_RESET);
+	reset.s.clkrst = 0;
+	writeq(reset.u, CAVM_XCVX_RESET);
+
+	/* Once the 125MHz ref clock is stable, wait 10us for DLL to lock *.
+ */
+	udelay(10);
+
+	/* Optionally, bypass the DLL setting */
+	xcv_dll_ctl.u = readq(CAVM_XCVX_DLL_CTL);
+	xcv_dll_ctl.s.clkrx_set = 0;
+	xcv_dll_ctl.s.clkrx_byp = 1;
+	xcv_dll_ctl.s.clktx_byp = 0;
+	writeq(xcv_dll_ctl.u, CAVM_XCVX_DLL_CTL);
+
+	/* Enable the compensation controller */
+	reset.u = readq(CAVM_XCVX_RESET);
+	reset.s.comp = 1;
+	writeq(reset.u, CAVM_XCVX_RESET);
+	reset.u = readq(CAVM_XCVX_RESET);
+
+	/* Wait for 1040 reference clock cycles for the compensation state 
+	   machine lock. */
+	udelay(100); 
+
+	/* Enable the XCV block */
+	reset.u = readq(CAVM_XCVX_RESET);
+	reset.s.enable = 1;
+	writeq(reset.u, CAVM_XCVX_RESET);
+
+	/* set XCV(0)_RESET[CLKRST] to 1 */
+	reset.u = readq(CAVM_XCVX_RESET);
+	reset.s.clkrst = 1;
+	writeq(reset.u, CAVM_XCVX_RESET);
+}
+
+/* 
+ * Configure XCV link based on the speed
+ * link_up   : Set to 1 when link is up otherwise 0
+ * link_speed: The speed of the link.
+ */ 
+void xcv_setup_link(bool link_up, int link_speed)
+{
+	union cavm_xcvx_ctl xcv_ctl;
+	union cavm_xcvx_reset reset;
+	//union cavm_xcvx_comp_ctl xcv_comp_ctl;
+	union cavm_xcvx_batch_crd_ret xcv_crd_ret;
+	int speed = 2;
+
+	/* Check RGMII link */
+	if (link_speed == 100)
+		speed = 1;
+	else if (link_speed == 10)
+		speed = 0;
+
+	if (link_up) {
+		/* Set operating speed */
+		xcv_ctl.u = readq(CAVM_XCVX_CTL);
+		xcv_ctl.s.speed = speed;
+		writeq(xcv_ctl.u, CAVM_XCVX_CTL);
+
+		/* Datapaths come out of reset
+		   - The datapath resets will disengage BGX from the
+		     RGMII interface
+		   - XCV will continue to return TX credits for each tick
+		     that is sent on the TX data path */
+		reset.u = readq(CAVM_XCVX_RESET);
+		reset.s.tx_dat_rst_n = 1;
+		reset.s.rx_dat_rst_n = 1;
+		writeq(reset.u, CAVM_XCVX_RESET);
+
+		/* Enable packet flow */
+		reset.u = readq(CAVM_XCVX_RESET);
+		reset.s.tx_pkt_rst_n = 1;
+		reset.s.rx_pkt_rst_n = 1;
+		writeq(reset.u, CAVM_XCVX_RESET);
+
+		xcv_crd_ret.u = readq(CAVM_XCVX_BATCH_CRD_RET);
+		xcv_crd_ret.s.crd_ret = 1;
+		writeq(xcv_crd_ret.u, CAVM_XCVX_BATCH_CRD_RET);
+	} else {
+		/* Enable packet flow */
+		reset.u = readq(CAVM_XCVX_RESET);
+		reset.s.tx_pkt_rst_n = 0;
+		reset.s.rx_pkt_rst_n = 0;
+		writeq(reset.u, CAVM_XCVX_RESET);
+		reset.u = readq(CAVM_XCVX_RESET);
+	}
+}
+
+int octeontx_xcv_probe(struct udevice *dev)
+{
+	size_t size;
+
+	xcv = dev_get_priv(dev);
+	if (xcv == NULL) {
+		return -ENOMEM;
+	}
+
+	xcv->reg_base = dm_pci_map_bar(dev, 0, &size, PCI_REGION_MEM);
+
+	return 0;
+}
+
+static const struct misc_ops octeontx_xcv_ops = {
+};
+
+static const struct udevice_id octeontx_xcv_ids[] = {
+	{ .compatible = "cavium,xcv" },
+	{}
+};
+
+U_BOOT_DRIVER(octeontx_xcv) = {
+        .name   = "octeontx_xcv",
+        .id     = UCLASS_MISC,
+        .probe  = octeontx_xcv_probe,
+        .of_match = octeontx_xcv_ids,
+        .ops    = &octeontx_xcv_ops,
+        .priv_auto_alloc_size = sizeof(struct lxcv),
+};
+
diff --git a/drivers/net/octeontx/q_struct.h b/drivers/net/octeontx/q_struct.h
new file mode 100644
index 0000000..723d730
--- /dev/null
+++ b/drivers/net/octeontx/q_struct.h
@@ -0,0 +1,698 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#ifndef Q_STRUCT_H
+#define Q_STRUCT_H
+
+/* Load transaction types for reading segment bytes specified by
+ * NIC_SEND_GATHER_S[LD_TYPE].
+ */
+enum nic_send_ld_type_e {
+	NIC_SEND_LD_TYPE_E_LDD = 0x0,
+	NIC_SEND_LD_TYPE_E_LDT = 0x1,
+	NIC_SEND_LD_TYPE_E_LDWB = 0x2,
+	NIC_SEND_LD_TYPE_E_ENUM_LAST = 0x3,
+};
+
+enum ether_type_algorithm {
+	ETYPE_ALG_NONE = 0x0,
+	ETYPE_ALG_SKIP = 0x1,
+	ETYPE_ALG_ENDPARSE = 0x2,
+	ETYPE_ALG_VLAN = 0x3,
+	ETYPE_ALG_VLAN_STRIP = 0x4,
+};
+
+enum layer3_type {
+	L3TYPE_NONE = 0x00,
+	L3TYPE_GRH = 0x01,
+	L3TYPE_IPV4 = 0x04,
+	L3TYPE_IPV4_OPTIONS = 0x05,
+	L3TYPE_IPV6 = 0x06,
+	L3TYPE_IPV6_OPTIONS = 0x07,
+	L3TYPE_ET_STOP = 0x0D,
+	L3TYPE_OTHER = 0x0E,
+};
+
+enum layer4_type {
+	L4TYPE_NONE = 0x00,
+	L4TYPE_IPSEC_ESP = 0x01,
+	L4TYPE_IPFRAG = 0x02,
+	L4TYPE_IPCOMP = 0x03,
+	L4TYPE_TCP = 0x04,
+	L4TYPE_UDP = 0x05,
+	L4TYPE_SCTP = 0x06,
+	L4TYPE_GRE = 0x07,
+	L4TYPE_ROCE_BTH = 0x08,
+	L4TYPE_OTHER = 0x0E,
+};
+
+/* CPI and RSSI configuration */
+enum cpi_algorithm_type {
+	CPI_ALG_NONE = 0x0,
+	CPI_ALG_VLAN = 0x1,
+	CPI_ALG_VLAN16 = 0x2,
+	CPI_ALG_DIFF = 0x3,
+};
+
+enum rss_algorithm_type {
+	RSS_ALG_NONE = 0x00,
+	RSS_ALG_PORT = 0x01,
+	RSS_ALG_IP = 0x02,
+	RSS_ALG_TCP_IP = 0x03,
+	RSS_ALG_UDP_IP = 0x04,
+	RSS_ALG_SCTP_IP = 0x05,
+	RSS_ALG_GRE_IP = 0x06,
+	RSS_ALG_ROCE = 0x07,
+};
+
+enum rss_hash_cfg {
+	RSS_HASH_L2ETC = 0x00,
+	RSS_HASH_IP = 0x01,
+	RSS_HASH_TCP = 0x02,
+	RSS_TCP_SYN_DIS = 0x03,
+	RSS_HASH_UDP = 0x04,
+	RSS_HASH_L4ETC = 0x05,
+	RSS_HASH_ROCE = 0x06,
+	RSS_L3_BIDI = 0x07,
+	RSS_L4_BIDI = 0x08,
+};
+
+/* Completion queue entry types */
+enum cqe_type {
+	CQE_TYPE_INVALID = 0x0,
+	CQE_TYPE_RX = 0x2,
+	CQE_TYPE_RX_SPLIT = 0x3,
+	CQE_TYPE_RX_TCP = 0x4,
+	CQE_TYPE_SEND = 0x8,
+	CQE_TYPE_SEND_PTP = 0x9,
+};
+
+enum cqe_rx_tcp_status {
+	CQE_RX_STATUS_VALID_TCP_CNXT = 0x00,
+	CQE_RX_STATUS_INVALID_TCP_CNXT = 0x0F,
+};
+
+enum cqe_send_status {
+	CQE_SEND_STATUS_GOOD = 0x00,
+	CQE_SEND_STATUS_DESC_FAULT = 0x01,
+	CQE_SEND_STATUS_HDR_CONS_ERR = 0x11,
+	CQE_SEND_STATUS_SUBDESC_ERR = 0x12,
+	CQE_SEND_STATUS_IMM_SIZE_OFLOW = 0x80,
+	CQE_SEND_STATUS_CRC_SEQ_ERR = 0x81,
+	CQE_SEND_STATUS_DATA_SEQ_ERR = 0x82,
+	CQE_SEND_STATUS_MEM_SEQ_ERR = 0x83,
+	CQE_SEND_STATUS_LOCK_VIOL = 0x84,
+	CQE_SEND_STATUS_LOCK_UFLOW = 0x85,
+	CQE_SEND_STATUS_DATA_FAULT = 0x86,
+	CQE_SEND_STATUS_TSTMP_CONFLICT = 0x87,
+	CQE_SEND_STATUS_TSTMP_TIMEOUT = 0x88,
+	CQE_SEND_STATUS_MEM_FAULT = 0x89,
+	CQE_SEND_STATUS_CSUM_OVERLAP = 0x8A,
+	CQE_SEND_STATUS_CSUM_OVERFLOW = 0x8B,
+};
+
+enum cqe_rx_tcp_end_reason {
+	CQE_RX_TCP_END_FIN_FLAG_DET = 0,
+	CQE_RX_TCP_END_INVALID_FLAG = 1,
+	CQE_RX_TCP_END_TIMEOUT = 2,
+	CQE_RX_TCP_END_OUT_OF_SEQ = 3,
+	CQE_RX_TCP_END_PKT_ERR = 4,
+	CQE_RX_TCP_END_QS_DISABLED = 0x0F,
+};
+
+/* Packet protocol level error enumeration */
+enum cqe_rx_err_level {
+	CQE_RX_ERRLVL_RE = 0x0,
+	CQE_RX_ERRLVL_L2 = 0x1,
+	CQE_RX_ERRLVL_L3 = 0x2,
+	CQE_RX_ERRLVL_L4 = 0x3,
+};
+
+/* Packet protocol level error type enumeration */
+enum cqe_rx_err_opcode {
+	CQE_RX_ERR_RE_NONE = 0x0,
+	CQE_RX_ERR_RE_PARTIAL = 0x1,
+	CQE_RX_ERR_RE_JABBER = 0x2,
+	CQE_RX_ERR_RE_FCS = 0x7,
+	CQE_RX_ERR_RE_TERMINATE = 0x9,
+	CQE_RX_ERR_RE_RX_CTL = 0xb,
+	CQE_RX_ERR_PREL2_ERR = 0x1f,
+	CQE_RX_ERR_L2_FRAGMENT = 0x20,
+	CQE_RX_ERR_L2_OVERRUN = 0x21,
+	CQE_RX_ERR_L2_PFCS = 0x22,
+	CQE_RX_ERR_L2_PUNY = 0x23,
+	CQE_RX_ERR_L2_MAL = 0x24,
+	CQE_RX_ERR_L2_OVERSIZE = 0x25,
+	CQE_RX_ERR_L2_UNDERSIZE = 0x26,
+	CQE_RX_ERR_L2_LENMISM = 0x27,
+	CQE_RX_ERR_L2_PCLP = 0x28,
+	CQE_RX_ERR_IP_NOT = 0x41,
+	CQE_RX_ERR_IP_CHK = 0x42,
+	CQE_RX_ERR_IP_MAL = 0x43,
+	CQE_RX_ERR_IP_MALD = 0x44,
+	CQE_RX_ERR_IP_HOP = 0x45,
+	CQE_RX_ERR_L3_ICRC = 0x46,
+	CQE_RX_ERR_L3_PCLP = 0x47,
+	CQE_RX_ERR_L4_MAL = 0x61,
+	CQE_RX_ERR_L4_CHK = 0x62,
+	CQE_RX_ERR_UDP_LEN = 0x63,
+	CQE_RX_ERR_L4_PORT = 0x64,
+	CQE_RX_ERR_TCP_FLAG = 0x65,
+	CQE_RX_ERR_TCP_OFFSET = 0x66,
+	CQE_RX_ERR_L4_PCLP = 0x67,
+	CQE_RX_ERR_RBDR_TRUNC = 0x70,
+};
+
+struct cqe_rx_t {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	uint64_t   cqe_type:4; /* W0 */
+	uint64_t   stdn_fault:1;
+	uint64_t   rsvd0:1;
+	uint64_t   rq_qs:7;
+	uint64_t   rq_idx:3;
+	uint64_t   rsvd1:12;
+	uint64_t   rss_alg:4;
+	uint64_t   rsvd2:4;
+	uint64_t   rb_cnt:4;
+	uint64_t   vlan_found:1;
+	uint64_t   vlan_stripped:1;
+	uint64_t   vlan2_found:1;
+	uint64_t   vlan2_stripped:1;
+	uint64_t   l4_type:4;
+	uint64_t   l3_type:4;
+	uint64_t   l2_present:1;
+	uint64_t   err_level:3;
+	uint64_t   err_opcode:8;
+
+	uint64_t   pkt_len:16; /* W1 */
+	uint64_t   l2_ptr:8;
+	uint64_t   l3_ptr:8;
+	uint64_t   l4_ptr:8;
+	uint64_t   cq_pkt_len:8;
+	uint64_t   align_pad:3;
+	uint64_t   rsvd3:1;
+	uint64_t   chan:12;
+
+	uint64_t   rss_tag:32; /* W2 */
+	uint64_t   vlan_tci:16;
+	uint64_t   vlan_ptr:8;
+	uint64_t   vlan2_ptr:8;
+
+	uint64_t   rb3_sz:16; /* W3 */
+	uint64_t   rb2_sz:16;
+	uint64_t   rb1_sz:16;
+	uint64_t   rb0_sz:16;
+
+	uint64_t   rb7_sz:16; /* W4 */
+	uint64_t   rb6_sz:16;
+	uint64_t   rb5_sz:16;
+	uint64_t   rb4_sz:16;
+
+	uint64_t   rb11_sz:16; /* W5 */
+	uint64_t   rb10_sz:16;
+	uint64_t   rb9_sz:16;
+	uint64_t   rb8_sz:16;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	uint64_t   err_opcode:8;
+	uint64_t   err_level:3;
+	uint64_t   l2_present:1;
+	uint64_t   l3_type:4;
+	uint64_t   l4_type:4;
+	uint64_t   vlan2_stripped:1;
+	uint64_t   vlan2_found:1;
+	uint64_t   vlan_stripped:1;
+	uint64_t   vlan_found:1;
+	uint64_t   rb_cnt:4;
+	uint64_t   rsvd2:4;
+	uint64_t   rss_alg:4;
+	uint64_t   rsvd1:12;
+	uint64_t   rq_idx:3;
+	uint64_t   rq_qs:7;
+	uint64_t   rsvd0:1;
+	uint64_t   stdn_fault:1;
+	uint64_t   cqe_type:4; /* W0 */
+	uint64_t   chan:12;
+	uint64_t   rsvd3:1;
+	uint64_t   align_pad:3;
+	uint64_t   cq_pkt_len:8;
+	uint64_t   l4_ptr:8;
+	uint64_t   l3_ptr:8;
+	uint64_t   l2_ptr:8;
+	uint64_t   pkt_len:16; /* W1 */
+	uint64_t   vlan2_ptr:8;
+	uint64_t   vlan_ptr:8;
+	uint64_t   vlan_tci:16;
+	uint64_t   rss_tag:32; /* W2 */
+	uint64_t   rb0_sz:16;
+	uint64_t   rb1_sz:16;
+	uint64_t   rb2_sz:16;
+	uint64_t   rb3_sz:16; /* W3 */
+	uint64_t   rb4_sz:16;
+	uint64_t   rb5_sz:16;
+	uint64_t   rb6_sz:16;
+	uint64_t   rb7_sz:16; /* W4 */
+	uint64_t   rb8_sz:16;
+	uint64_t   rb9_sz:16;
+	uint64_t   rb10_sz:16;
+	uint64_t   rb11_sz:16; /* W5 */
+#endif
+	uint64_t   rb0_ptr:64;
+	uint64_t   rb1_ptr:64;
+	uint64_t   rb2_ptr:64;
+	uint64_t   rb3_ptr:64;
+	uint64_t   rb4_ptr:64;
+	uint64_t   rb5_ptr:64;
+	uint64_t   rb6_ptr:64;
+	uint64_t   rb7_ptr:64;
+	uint64_t   rb8_ptr:64;
+	uint64_t   rb9_ptr:64;
+	uint64_t   rb10_ptr:64;
+	uint64_t   rb11_ptr:64;
+};
+
+struct cqe_rx_tcp_err_t {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	uint64_t   cqe_type:4; /* W0 */
+	uint64_t   rsvd0:60;
+
+	uint64_t   rsvd1:4; /* W1 */
+	uint64_t   partial_first:1;
+	uint64_t   rsvd2:27;
+	uint64_t   rbdr_bytes:8;
+	uint64_t   rsvd3:24;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	uint64_t   rsvd0:60;
+	uint64_t   cqe_type:4;
+
+	uint64_t   rsvd3:24;
+	uint64_t   rbdr_bytes:8;
+	uint64_t   rsvd2:27;
+	uint64_t   partial_first:1;
+	uint64_t   rsvd1:4;
+#endif
+};
+
+struct cqe_rx_tcp_t {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	uint64_t   cqe_type:4; /* W0 */
+	uint64_t   rsvd0:52;
+	uint64_t   cq_tcp_status:8;
+
+	uint64_t   rsvd1:32; /* W1 */
+	uint64_t   tcp_cntx_bytes:8;
+	uint64_t   rsvd2:8;
+	uint64_t   tcp_err_bytes:16;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	uint64_t   cq_tcp_status:8;
+	uint64_t   rsvd0:52;
+	uint64_t   cqe_type:4; /* W0 */
+
+	uint64_t   tcp_err_bytes:16;
+	uint64_t   rsvd2:8;
+	uint64_t   tcp_cntx_bytes:8;
+	uint64_t   rsvd1:32; /* W1 */
+#endif
+};
+
+struct cqe_send_t {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	uint64_t   cqe_type:4; /* W0 */
+	uint64_t   rsvd0:4;
+	uint64_t   sqe_ptr:16;
+	uint64_t   rsvd1:4;
+	uint64_t   rsvd2:10;
+	uint64_t   sq_qs:7;
+	uint64_t   sq_idx:3;
+	uint64_t   rsvd3:8;
+	uint64_t   send_status:8;
+
+	uint64_t   ptp_timestamp:64; /* W1 */
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	uint64_t   send_status:8;
+	uint64_t   rsvd3:8;
+	uint64_t   sq_idx:3;
+	uint64_t   sq_qs:7;
+	uint64_t   rsvd2:10;
+	uint64_t   rsvd1:4;
+	uint64_t   sqe_ptr:16;
+	uint64_t   rsvd0:4;
+	uint64_t   cqe_type:4; /* W0 */
+
+	uint64_t   ptp_timestamp:64; /* W1 */
+#endif
+};
+
+union cq_desc_t {
+	uint64_t u[64];
+	struct cqe_send_t snd_hdr;
+	struct cqe_rx_t rx_hdr;
+	struct cqe_rx_tcp_t rx_tcp_hdr;
+	struct cqe_rx_tcp_err_t rx_tcp_err_hdr;
+};
+
+struct rbdr_entry_t {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	uint64_t   rsvd0:15;
+	uint64_t   buf_addr:42;
+	uint64_t   cache_align:7;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	uint64_t   cache_align:7;
+	uint64_t   buf_addr:42;
+	uint64_t   rsvd0:15;
+#endif
+};
+
+/* TCP reassembly context */
+struct rbe_tcp_cnxt_t {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	uint64_t   tcp_pkt_cnt:12;
+	uint64_t   rsvd1:4;
+	uint64_t   align_hdr_bytes:4;
+	uint64_t   align_ptr_bytes:4;
+	uint64_t   ptr_bytes:16;
+	uint64_t   rsvd2:24;
+	uint64_t   cqe_type:4;
+	uint64_t   rsvd0:54;
+	uint64_t   tcp_end_reason:2;
+	uint64_t   tcp_status:4;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	uint64_t   tcp_status:4;
+	uint64_t   tcp_end_reason:2;
+	uint64_t   rsvd0:54;
+	uint64_t   cqe_type:4;
+	uint64_t   rsvd2:24;
+	uint64_t   ptr_bytes:16;
+	uint64_t   align_ptr_bytes:4;
+	uint64_t   align_hdr_bytes:4;
+	uint64_t   rsvd1:4;
+	uint64_t   tcp_pkt_cnt:12;
+#endif
+};
+
+/* Always Big endian */
+struct rx_hdr_t {
+	uint64_t   opaque:32;
+	uint64_t   rss_flow:8;
+	uint64_t   skip_length:6;
+	uint64_t   disable_rss:1;
+	uint64_t   disable_tcp_reassembly:1;
+	uint64_t   nodrop:1;
+	uint64_t   dest_alg:2;
+	uint64_t   rsvd0:2;
+	uint64_t   dest_rq:11;
+};
+
+enum send_l4_csum_type {
+	SEND_L4_CSUM_DISABLE = 0x00,
+	SEND_L4_CSUM_UDP = 0x01,
+	SEND_L4_CSUM_TCP = 0x02,
+	SEND_L4_CSUM_SCTP = 0x03,
+};
+
+enum send_crc_alg {
+	SEND_CRCALG_CRC32 = 0x00,
+	SEND_CRCALG_CRC32C = 0x01,
+	SEND_CRCALG_ICRC = 0x02,
+};
+
+enum send_load_type {
+	SEND_LD_TYPE_LDD = 0x00,
+	SEND_LD_TYPE_LDT = 0x01,
+	SEND_LD_TYPE_LDWB = 0x02,
+};
+
+enum send_mem_alg_type {
+	SEND_MEMALG_SET = 0x00,
+	SEND_MEMALG_ADD = 0x08,
+	SEND_MEMALG_SUB = 0x09,
+	SEND_MEMALG_ADDLEN = 0x0A,
+	SEND_MEMALG_SUBLEN = 0x0B,
+};
+
+enum send_mem_dsz_type {
+	SEND_MEMDSZ_B64 = 0x00,
+	SEND_MEMDSZ_B32 = 0x01,
+	SEND_MEMDSZ_B8 = 0x03,
+};
+
+enum sq_subdesc_type {
+	SQ_DESC_TYPE_INVALID = 0x00,
+	SQ_DESC_TYPE_HEADER = 0x01,
+	SQ_DESC_TYPE_CRC = 0x02,
+	SQ_DESC_TYPE_IMMEDIATE = 0x03,
+	SQ_DESC_TYPE_GATHER = 0x04,
+	SQ_DESC_TYPE_MEMORY = 0x05,
+};
+
+struct sq_crc_subdesc {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	uint64_t    rsvd1:32;
+	uint64_t    crc_ival:32;
+	uint64_t    subdesc_type:4;
+	uint64_t    crc_alg:2;
+	uint64_t    rsvd0:10;
+	uint64_t    crc_insert_pos:16;
+	uint64_t    hdr_start:16;
+	uint64_t    crc_len:16;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	uint64_t    crc_len:16;
+	uint64_t    hdr_start:16;
+	uint64_t    crc_insert_pos:16;
+	uint64_t    rsvd0:10;
+	uint64_t    crc_alg:2;
+	uint64_t    subdesc_type:4;
+	uint64_t    crc_ival:32;
+	uint64_t    rsvd1:32;
+#endif
+};
+
+struct sq_gather_subdesc {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	uint64_t    subdesc_type:4; /* W0 */
+	uint64_t    ld_type:2;
+	uint64_t    rsvd0:42;
+	uint64_t    size:16;
+
+	uint64_t    rsvd1:15; /* W1 */
+	uint64_t    addr:49;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	uint64_t    size:16;
+	uint64_t    rsvd0:42;
+	uint64_t    ld_type:2;
+	uint64_t    subdesc_type:4; /* W0 */
+
+	uint64_t    addr:49;
+	uint64_t    rsvd1:15; /* W1 */
+#endif
+};
+
+/* SQ immediate subdescriptor */
+struct sq_imm_subdesc {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	uint64_t    subdesc_type:4; /* W0 */
+	uint64_t    rsvd0:46;
+	uint64_t    len:14;
+
+	uint64_t    data:64; /* W1 */
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	uint64_t    len:14;
+	uint64_t    rsvd0:46;
+	uint64_t    subdesc_type:4; /* W0 */
+
+	uint64_t    data:64; /* W1 */
+#endif
+};
+
+struct sq_mem_subdesc {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	uint64_t    subdesc_type:4; /* W0 */
+	uint64_t    mem_alg:4;
+	uint64_t    mem_dsz:2;
+	uint64_t    wmem:1;
+	uint64_t    rsvd0:21;
+	uint64_t    offset:32;
+
+	uint64_t    rsvd1:15; /* W1 */
+	uint64_t    addr:49;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	uint64_t    offset:32;
+	uint64_t    rsvd0:21;
+	uint64_t    wmem:1;
+	uint64_t    mem_dsz:2;
+	uint64_t    mem_alg:4;
+	uint64_t    subdesc_type:4; /* W0 */
+
+	uint64_t    addr:49;
+	uint64_t    rsvd1:15; /* W1 */
+#endif
+};
+
+struct sq_hdr_subdesc {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	uint64_t    subdesc_type:4;
+	uint64_t    tso:1;
+	uint64_t    post_cqe:1; /* Post CQE on no error also */
+	uint64_t    dont_send:1;
+	uint64_t    tstmp:1;
+	uint64_t    subdesc_cnt:8;
+	uint64_t    csum_l4:2;
+	uint64_t    csum_l3:1;
+	uint64_t    rsvd0:5;
+	uint64_t    l4_offset:8;
+	uint64_t    l3_offset:8;
+	uint64_t    rsvd1:4;
+	uint64_t    tot_len:20; /* W0 */
+
+	uint64_t    tso_sdc_cont:8;
+	uint64_t    tso_sdc_first:8;
+	uint64_t    tso_l4_offset:8;
+	uint64_t    tso_flags_last:12;
+	uint64_t    tso_flags_first:12;
+	uint64_t    rsvd2:2;
+	uint64_t    tso_max_paysize:14; /* W1 */
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	uint64_t    tot_len:20;
+	uint64_t    rsvd1:4;
+	uint64_t    l3_offset:8;
+	uint64_t    l4_offset:8;
+	uint64_t    rsvd0:5;
+	uint64_t    csum_l3:1;
+	uint64_t    csum_l4:2;
+	uint64_t    subdesc_cnt:8;
+	uint64_t    tstmp:1;
+	uint64_t    dont_send:1;
+	uint64_t    post_cqe:1; /* Post CQE on no error also */
+	uint64_t    tso:1;
+	uint64_t    subdesc_type:4; /* W0 */
+
+	uint64_t    tso_max_paysize:14;
+	uint64_t    rsvd2:2;
+	uint64_t    tso_flags_first:12;
+	uint64_t    tso_flags_last:12;
+	uint64_t    tso_l4_offset:8;
+	uint64_t    tso_sdc_first:8;
+	uint64_t    tso_sdc_cont:8; /* W1 */
+#endif
+};
+
+/* Queue config register formats */
+struct rq_cfg {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	uint64_t reserved_2_63:62;
+	uint64_t ena:1;
+	uint64_t tcp_ena:1;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	uint64_t tcp_ena:1;
+	uint64_t ena:1;
+	uint64_t reserved_2_63:62;
+#endif
+};
+
+struct cq_cfg {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	uint64_t reserved_43_63:21;
+	uint64_t ena:1;
+	uint64_t reset:1;
+	uint64_t caching:1;
+	uint64_t reserved_35_39:5;
+	uint64_t qsize:3;
+	uint64_t reserved_25_31:7;
+	uint64_t avg_con:9;
+	uint64_t reserved_0_15:16;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	uint64_t reserved_0_15:16;
+	uint64_t avg_con:9;
+	uint64_t reserved_25_31:7;
+	uint64_t qsize:3;
+	uint64_t reserved_35_39:5;
+	uint64_t caching:1;
+	uint64_t reset:1;
+	uint64_t ena:1;
+	uint64_t reserved_43_63:21;
+#endif
+};
+
+struct sq_cfg {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	uint64_t reserved_20_63:44;
+	uint64_t ena:1;
+	uint64_t reserved_18_18:1;
+	uint64_t reset:1;
+	uint64_t ldwb:1;
+	uint64_t reserved_11_15:5;
+	uint64_t qsize:3;
+	uint64_t reserved_3_7:5;
+	uint64_t tstmp_bgx_intf:3;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	uint64_t tstmp_bgx_intf:3;
+	uint64_t reserved_3_7:5;
+	uint64_t qsize:3;
+	uint64_t reserved_11_15:5;
+	uint64_t ldwb:1;
+	uint64_t reset:1;
+	uint64_t reserved_18_18:1;
+	uint64_t ena:1;
+	uint64_t reserved_20_63:44;
+#endif
+};
+
+struct rbdr_cfg {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	uint64_t reserved_45_63:19;
+	uint64_t ena:1;
+	uint64_t reset:1;
+	uint64_t ldwb:1;
+	uint64_t reserved_36_41:6;
+	uint64_t qsize:4;
+	uint64_t reserved_25_31:7;
+	uint64_t avg_con:9;
+	uint64_t reserved_12_15:4;
+	uint64_t lines:12;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	uint64_t lines:12;
+	uint64_t reserved_12_15:4;
+	uint64_t avg_con:9;
+	uint64_t reserved_25_31:7;
+	uint64_t qsize:4;
+	uint64_t reserved_36_41:6;
+	uint64_t ldwb:1;
+	uint64_t reset:1;
+	uint64_t ena: 1;
+	uint64_t reserved_45_63:19;
+#endif
+};
+
+struct qs_cfg {
+#if defined(__BIG_ENDIAN_BITFIELD)
+	uint64_t reserved_32_63:32;
+	uint64_t ena:1;
+	uint64_t reserved_27_30:4;
+	uint64_t sq_ins_ena:1;
+	uint64_t sq_ins_pos:6;
+	uint64_t lock_ena:1;
+	uint64_t lock_viol_cqe_ena:1;
+	uint64_t send_tstmp_ena:1;
+	uint64_t be:1;
+	uint64_t reserved_7_15:9;
+	uint64_t vnic:7;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	uint64_t vnic:7;
+	uint64_t reserved_7_15:9;
+	uint64_t be:1;
+	uint64_t send_tstmp_ena:1;
+	uint64_t lock_viol_cqe_ena:1;
+	uint64_t lock_ena:1;
+	uint64_t sq_ins_pos:6;
+	uint64_t sq_ins_ena:1;
+	uint64_t reserved_27_30:4;
+	uint64_t ena:1;
+	uint64_t reserved_32_63:32;
+#endif
+};
+
+#endif /* Q_STRUCT_H */
diff --git a/drivers/net/octeontx2/Makefile b/drivers/net/octeontx2/Makefile
new file mode 100644
index 0000000..92183ff
--- /dev/null
+++ b/drivers/net/octeontx2/Makefile
@@ -0,0 +1,11 @@
+#/*
+# * Copyright (C) 2018 Marvell International Ltd.
+# *
+# * SPDX-License-Identifier:    GPL-2.0
+# * https://spdx.org/licenses
+# */
+
+
+obj-$(CONFIG_NET_OCTEONTX2) += cgx.o nix_af.o nix.o rvu_pf.o \
+				rvu_af.o rvu_common.o
+
diff --git a/drivers/net/octeontx2/cavm-csrs-cgx.h b/drivers/net/octeontx2/cavm-csrs-cgx.h
new file mode 100644
index 0000000..1374327
--- /dev/null
+++ b/drivers/net/octeontx2/cavm-csrs-cgx.h
@@ -0,0 +1,7715 @@
+#ifndef __CAVM_CSRS_CGX_H__
+#define __CAVM_CSRS_CGX_H__
+/* This file is auto-generated.  Do not edit */
+
+/***********************license start***********************************
+* Copyright (C) 2019 Marvell International Ltd.
+* SPDX-License-Identifier: BSD-3-Clause
+* https://spdx.org/licenses
+***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * Configuration and status register (CSR) address and type definitions for
+ * Cavium CGX.
+ *
+ * This file is auto generated.  Do not edit.
+ *
+ */
+
+/**
+ * Enumeration cgx_bar_e
+ *
+ * CGX Base Address Register Enumeration Enumerates the base address
+ * registers.
+ */
+#define CAVM_CGX_BAR_E_CGXX_PF_BAR0(a) (0x87e0e0000000ll + 0x1000000ll * (a))
+#define CAVM_CGX_BAR_E_CGXX_PF_BAR0_SIZE 0x100000ull
+#define CAVM_CGX_BAR_E_CGXX_PF_BAR4(a) (0x87e0e0400000ll + 0x1000000ll * (a))
+#define CAVM_CGX_BAR_E_CGXX_PF_BAR4_SIZE 0x100000ull
+
+/**
+ * Enumeration cgx_int_vec_e
+ *
+ * CGX MSI-X Vector Enumeration Enumeration the MSI-X interrupt vectors.
+ */
+#define CAVM_CGX_INT_VEC_E_CMRX_INT(a) (0 + 9 * (a))
+#define CAVM_CGX_INT_VEC_E_CMR_MEM_INT (0x24)
+#define CAVM_CGX_INT_VEC_E_GMPX_GMI_RX_INT(a) (5 + 9 * (a))
+#define CAVM_CGX_INT_VEC_E_GMPX_GMI_TX_INT(a) (6 + 9 * (a))
+#define CAVM_CGX_INT_VEC_E_GMPX_GMI_WOL_INT(a) (7 + 9 * (a))
+#define CAVM_CGX_INT_VEC_E_GMPX_PCS_INT(a) (4 + 9 * (a))
+#define CAVM_CGX_INT_VEC_E_SMUX_RX_INT(a) (2 + 9 * (a))
+#define CAVM_CGX_INT_VEC_E_SMUX_RX_WOL_INT(a) (8 + 9 * (a))
+#define CAVM_CGX_INT_VEC_E_SMUX_TX_INT(a) (3 + 9 * (a))
+#define CAVM_CGX_INT_VEC_E_SPUX_INT(a) (1 + 9 * (a))
+#define CAVM_CGX_INT_VEC_E_SW (0x25)
+
+/**
+ * Enumeration cgx_lmac_types_e
+ *
+ * CGX LMAC Type Enumeration Enumerates the LMAC Types that CGX supports.
+ */
+#define CAVM_CGX_LMAC_TYPES_E_FIFTYG_R (8)
+#define CAVM_CGX_LMAC_TYPES_E_FORTYG_R (4)
+#define CAVM_CGX_LMAC_TYPES_E_HUNDREDG_R (9)
+#define CAVM_CGX_LMAC_TYPES_E_QSGMII (6)
+#define CAVM_CGX_LMAC_TYPES_E_RGMII (5)
+#define CAVM_CGX_LMAC_TYPES_E_RXAUI (2)
+#define CAVM_CGX_LMAC_TYPES_E_SGMII (0)
+#define CAVM_CGX_LMAC_TYPES_E_TENG_R (3)
+#define CAVM_CGX_LMAC_TYPES_E_TWENTYFIVEG_R (7)
+#define CAVM_CGX_LMAC_TYPES_E_USXGMII (0xa)
+#define CAVM_CGX_LMAC_TYPES_E_XAUI (1)
+
+/**
+ * Enumeration cgx_opcode_e
+ *
+ * INTERNAL: CGX Error Opcode Enumeration  Enumerates the error opcodes
+ * created by CGX and presented to NCSI/NIX.
+ */
+#define CAVM_CGX_OPCODE_E_RE_FCS (7)
+#define CAVM_CGX_OPCODE_E_RE_FCS_RCV (8)
+#define CAVM_CGX_OPCODE_E_RE_JABBER (2)
+#define CAVM_CGX_OPCODE_E_RE_NONE (0)
+#define CAVM_CGX_OPCODE_E_RE_PARTIAL (1)
+#define CAVM_CGX_OPCODE_E_RE_RX_CTL (0xb)
+#define CAVM_CGX_OPCODE_E_RE_SKIP (0xc)
+#define CAVM_CGX_OPCODE_E_RE_TERMINATE (9)
+
+/**
+ * Enumeration cgx_spu_br_train_cst_e
+ *
+ * CGX Training Coefficient Status Enumeration 2-bit status for each
+ * coefficient as defined in IEEE 802.3, Table 72-5.
+ */
+#define CAVM_CGX_SPU_BR_TRAIN_CST_E_MAXIMUM (3)
+#define CAVM_CGX_SPU_BR_TRAIN_CST_E_MINIMUM (2)
+#define CAVM_CGX_SPU_BR_TRAIN_CST_E_NOT_UPDATED (0)
+#define CAVM_CGX_SPU_BR_TRAIN_CST_E_UPDATED (1)
+
+/**
+ * Enumeration cgx_spu_br_train_cup_e
+ *
+ * CGX Training Coefficient Enumeration 2-bit command for each
+ * coefficient as defined in IEEE 802.3, Table 72-4.
+ */
+#define CAVM_CGX_SPU_BR_TRAIN_CUP_E_DECREMENT (1)
+#define CAVM_CGX_SPU_BR_TRAIN_CUP_E_HOLD (0)
+#define CAVM_CGX_SPU_BR_TRAIN_CUP_E_INCREMENT (2)
+#define CAVM_CGX_SPU_BR_TRAIN_CUP_E_RSV_CMD (3)
+
+/**
+ * Enumeration cgx_usxgmii_rate_e
+ *
+ * CGX USXGMII Rate Enumeration Enumerates the USXGMII sub-port type
+ * rate, CGX()_SPU()_CONTROL1[USXGMII_RATE].  Selecting a rate higher
+ * than the maximum allowed for a given port sub-type (specified by
+ * CGX()_SPU()_CONTROL1[USXGMII_TYPE]), e.g., selecting ::RATE_2HG (2.5
+ * Gbps) for CGX_USXGMII_TYPE_E::SXGMII_2G, will cause unpredictable
+ * behavior. USXGMII hardware-based autonegotiation may change this
+ * setting.
+ */
+#define CAVM_CGX_USXGMII_RATE_E_RATE_100M (1)
+#define CAVM_CGX_USXGMII_RATE_E_RATE_10G (5)
+#define CAVM_CGX_USXGMII_RATE_E_RATE_10M (0)
+#define CAVM_CGX_USXGMII_RATE_E_RATE_1G (2)
+#define CAVM_CGX_USXGMII_RATE_E_RATE_20G (6)
+#define CAVM_CGX_USXGMII_RATE_E_RATE_2HG (3)
+#define CAVM_CGX_USXGMII_RATE_E_RATE_5G (4)
+#define CAVM_CGX_USXGMII_RATE_E_RSV_RATE (7)
+
+/**
+ * Enumeration cgx_usxgmii_type_e
+ *
+ * CGX USXGMII Port Sub-Type Enumeration Enumerates the USXGMII sub-port
+ * type, CGX()_SPU()_CONTROL1[USXGMII_TYPE].  The description indicates
+ * the maximum rate and the maximum number of ports (LMACs) for each sub-
+ * type. The minimum rate for any port is 10M. The rate selection for
+ * each LMAC is made using CGX()_SPU()_CONTROL1[USXGMII_RATE] and the
+ * number of active ports/LMACs is implicitly determined by the value
+ * given to CGX()_CMR()_CONFIG[ENABLE] for each LMAC.  Selecting a rate
+ * higher than the maximum allowed for a given port sub-type or enabling
+ * more LMACs than the maximum allowed for a given port sub-type will
+ * cause unpredictable behavior.
+ */
+#define CAVM_CGX_USXGMII_TYPE_E_DXGMII_10G (3)
+#define CAVM_CGX_USXGMII_TYPE_E_DXGMII_20G (5)
+#define CAVM_CGX_USXGMII_TYPE_E_DXGMII_5G (4)
+#define CAVM_CGX_USXGMII_TYPE_E_QXGMII_10G (7)
+#define CAVM_CGX_USXGMII_TYPE_E_QXGMII_20G (6)
+#define CAVM_CGX_USXGMII_TYPE_E_SXGMII_10G (0)
+#define CAVM_CGX_USXGMII_TYPE_E_SXGMII_2G (2)
+#define CAVM_CGX_USXGMII_TYPE_E_SXGMII_5G (1)
+
+/**
+ * Structure cgx_spu_br_lane_train_status_s
+ *
+ * CGX Lane Training Status Structure This is the group of lane status
+ * bits for a single lane in the BASE-R PMD status register (MDIO address
+ * 1.151) as defined in IEEE 802.3ba-2010, Table 45-55.
+ */
+union cavm_cgx_spu_br_lane_train_status_s {
+	u32 u;
+	struct cavm_cgx_spu_br_lane_train_status_s_s {
+		u32 rx_trained                       : 1;
+		u32 frame_lock                       : 1;
+		u32 training                         : 1;
+		u32 training_failure                 : 1;
+		u32 reserved_4_31                    : 28;
+	} s;
+	/* struct cavm_cgx_spu_br_lane_train_status_s_s cn; */
+};
+
+/**
+ * Structure cgx_spu_br_train_cup_s
+ *
+ * CGX Lane Training Coeffiecient Structure This is the coefficient
+ * update field of the BASE-R link training packet as defined in IEEE
+ * 802.3, Table 72-4.
+ */
+union cavm_cgx_spu_br_train_cup_s {
+	u32 u;
+	struct cavm_cgx_spu_br_train_cup_s_s {
+		u32 pre_cup                          : 2;
+		u32 main_cup                         : 2;
+		u32 post_cup                         : 2;
+		u32 reserved_6_11                    : 6;
+		u32 init                             : 1;
+		u32 preset                           : 1;
+		u32 reserved_14_31                   : 18;
+	} s;
+	struct cavm_cgx_spu_br_train_cup_s_cn {
+		u32 pre_cup                          : 2;
+		u32 main_cup                         : 2;
+		u32 post_cup                         : 2;
+		u32 reserved_6_11                    : 6;
+		u32 init                             : 1;
+		u32 preset                           : 1;
+		u32 reserved_14_15                   : 2;
+		u32 reserved_16_31                   : 16;
+	} cn;
+};
+
+/**
+ * Structure cgx_spu_br_train_rep_s
+ *
+ * CGX Training Report Structure This is the status report field of the
+ * BASE-R link training packet as defined in IEEE 802.3, Table 72-5.
+ */
+union cavm_cgx_spu_br_train_rep_s {
+	u32 u;
+	struct cavm_cgx_spu_br_train_rep_s_s {
+		u32 pre_cst                          : 2;
+		u32 main_cst                         : 2;
+		u32 post_cst                         : 2;
+		u32 reserved_6_14                    : 9;
+		u32 rx_ready                         : 1;
+		u32 reserved_16_31                   : 16;
+	} s;
+	/* struct cavm_cgx_spu_br_train_rep_s_s cn; */
+};
+
+/**
+ * Structure cgx_spu_sds_cu_s
+ *
+ * INTERNAL: CGX Training Coeffiecient Structure  This structure is
+ * similar to CGX_SPU_BR_TRAIN_CUP_S format, but with reserved fields
+ * removed and [RCVR_READY] field added.
+ */
+union cavm_cgx_spu_sds_cu_s {
+	u32 u;
+	struct cavm_cgx_spu_sds_cu_s_s {
+		u32 pre_cu                           : 2;
+		u32 main_cu                          : 2;
+		u32 post_cu                          : 2;
+		u32 initialize                       : 1;
+		u32 preset                           : 1;
+		u32 rcvr_ready                       : 1;
+		u32 reserved_9_31                    : 23;
+	} s;
+	/* struct cavm_cgx_spu_sds_cu_s_s cn; */
+};
+
+/**
+ * Structure cgx_spu_sds_skew_status_s
+ *
+ * CGX Skew Status Structure Provides receive skew information detected
+ * for a physical SerDes lane when it is assigned to a multilane
+ * LMAC/LPCS. Contents are valid when RX deskew is done for the
+ * associated LMAC/LPCS.
+ */
+union cavm_cgx_spu_sds_skew_status_s {
+	u32 u;
+	struct cavm_cgx_spu_sds_skew_status_s_s {
+		u32 am_timestamp                     : 12;
+		u32 reserved_12_15                   : 4;
+		u32 am_lane_id                       : 5;
+		u32 reserved_21_22                   : 2;
+		u32 lane_skew                        : 7;
+		u32 reserved_30_31                   : 2;
+	} s;
+	/* struct cavm_cgx_spu_sds_skew_status_s_s cn; */
+};
+
+/**
+ * Structure cgx_spu_sds_sr_s
+ *
+ * INTERNAL: CGX Lane Training Coefficient Structure  Similar to
+ * CGX_SPU_BR_TRAIN_REP_S format, but with reserved and RX ready fields
+ * removed.
+ */
+union cavm_cgx_spu_sds_sr_s {
+	u32 u;
+	struct cavm_cgx_spu_sds_sr_s_s {
+		u32 pre_status                       : 2;
+		u32 main_status                      : 2;
+		u32 post_status                      : 2;
+		u32 reserved_6_31                    : 26;
+	} s;
+	/* struct cavm_cgx_spu_sds_sr_s_s cn; */
+};
+
+/**
+ * Register (RSL) cgx#_active_pc
+ *
+ * CGX ACTIVE PC Register This register counts the conditional clocks for
+ * power management.
+ */
+union cavm_cgxx_active_pc {
+	u64 u;
+	struct cavm_cgxx_active_pc_s {
+		u64 cnt                              : 64;
+	} s;
+	/* struct cavm_cgxx_active_pc_s cn; */
+};
+
+static inline u64 CAVM_CGXX_ACTIVE_PC(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_ACTIVE_PC(void)
+{
+	return 0x2010;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_activity
+ *
+ * CGX CMR Activity Registers
+ */
+union cavm_cgxx_cmrx_activity {
+	u64 u;
+	struct cavm_cgxx_cmrx_activity_s {
+		u64 act_tx_lo                        : 1;
+		u64 act_tx_hi                        : 1;
+		u64 pause_tx                         : 1;
+		u64 act_rx_lo                        : 1;
+		u64 act_rx_hi                        : 1;
+		u64 pause_rx                         : 1;
+		u64 reserved_6_63                    : 58;
+	} s;
+	/* struct cavm_cgxx_cmrx_activity_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_ACTIVITY(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_ACTIVITY(u64 a)
+{
+	return 0x5f8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_config
+ *
+ * CGX CMR Configuration Registers Logical MAC/PCS configuration
+ * registers; one per LMAC. The maximum number of LMACs (and maximum LMAC
+ * ID) that can be enabled by these registers is limited by
+ * CGX()_CMR_RX_LMACS[LMACS] and CGX()_CMR_TX_LMACS[LMACS].  Internal:
+ * \<pre\> Example configurations:   ------------------------------------
+ * ---------------------------------------   Configuration
+ * LMACS  Register             [ENABLE]    [LMAC_TYPE]   ----------------
+ * -----------------------------------------------------------
+ * 1x50G+1x25G+1xSGMII     4      CGXn_CMR0_CONFIG     1           8
+ * CGXn_CMR1_CONFIG     0           --
+ * CGXn_CMR2_CONFIG     1           7
+ * CGXn_CMR3_CONFIG     1           0   ---------------------------------
+ * ------------------------------------------   USXGMII
+ * 1-4    CGXn_CMR0_CONFIG     1           a
+ * CGXn_CMR1_CONFIG     1           a
+ * CGXn_CMR2_CONFIG     1           a
+ * CGXn_CMR3_CONFIG     1           a   ---------------------------------
+ * ------------------------------------------   1x100GBASE-R4           1
+ * CGXn_CMR0_CONFIG     1           9
+ * CGXn_CMR1_CONFIG     0           --
+ * CGXn_CMR2_CONFIG     0           --
+ * CGXn_CMR3_CONFIG     0           --   --------------------------------
+ * -------------------------------------------   2x50GBASE-R2
+ * 2      CGXn_CMR0_CONFIG     1           8
+ * CGXn_CMR1_CONFIG     1           8
+ * CGXn_CMR2_CONFIG     0           --
+ * CGXn_CMR3_CONFIG     0           --   --------------------------------
+ * -------------------------------------------   4x25GBASE-R
+ * 4      CGXn_CMR0_CONFIG     1           7
+ * CGXn_CMR1_CONFIG     1           7
+ * CGXn_CMR2_CONFIG     1           7
+ * CGXn_CMR3_CONFIG     1           7   ---------------------------------
+ * ------------------------------------------   QSGMII                  4
+ * CGXn_CMR0_CONFIG     1           6
+ * CGXn_CMR1_CONFIG     1           6
+ * CGXn_CMR2_CONFIG     1           6
+ * CGXn_CMR3_CONFIG     1           6   ---------------------------------
+ * ------------------------------------------   1x40GBASE-R4            1
+ * CGXn_CMR0_CONFIG     1           4
+ * CGXn_CMR1_CONFIG     0           --
+ * CGXn_CMR2_CONFIG     0           --
+ * CGXn_CMR3_CONFIG     0           --   --------------------------------
+ * -------------------------------------------   4x10GBASE-R
+ * 4      CGXn_CMR0_CONFIG     1           3
+ * CGXn_CMR1_CONFIG     1           3
+ * CGXn_CMR2_CONFIG     1           3
+ * CGXn_CMR3_CONFIG     1           3   ---------------------------------
+ * ------------------------------------------   2xRXAUI                 2
+ * CGXn_CMR0_CONFIG     1           2
+ * CGXn_CMR1_CONFIG     1           2
+ * CGXn_CMR2_CONFIG     0           --
+ * CGXn_CMR3_CONFIG     0           --   --------------------------------
+ * -------------------------------------------   1x10GBASE-X/XAUI/DXAUI
+ * 1      CGXn_CMR0_CONFIG     1           1
+ * CGXn_CMR1_CONFIG     0           --
+ * CGXn_CMR2_CONFIG     0           --
+ * CGXn_CMR3_CONFIG     0           --   --------------------------------
+ * -------------------------------------------   4xSGMII/1000BASE-X
+ * 4      CGXn_CMR0_CONFIG     1           0
+ * CGXn_CMR1_CONFIG     1           0
+ * CGXn_CMR2_CONFIG     1           0
+ * CGXn_CMR3_CONFIG     1           0   ---------------------------------
+ * ------------------------------------------ \</pre\>
+ */
+union cavm_cgxx_cmrx_config {
+	u64 u;
+	struct cavm_cgxx_cmrx_config_s {
+		u64 lane_to_sds                      : 8;
+		u64 reserved_8_39                    : 32;
+		u64 lmac_type                        : 4;
+		u64 unused                           : 8;
+		u64 int_beat_gen                     : 1;
+		u64 data_pkt_tx_en                   : 1;
+		u64 data_pkt_rx_en                   : 1;
+		u64 enable                           : 1;
+		u64 x2p_select                       : 3;
+		u64 p2x_select                       : 3;
+		u64 reserved_62_63                   : 2;
+	} s;
+	/* struct cavm_cgxx_cmrx_config_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_CONFIG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_CONFIG(u64 a)
+{
+	return 0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_int
+ *
+ * CGX CMR Interrupt Register
+ */
+union cavm_cgxx_cmrx_int {
+	u64 u;
+	struct cavm_cgxx_cmrx_int_s {
+		u64 pause_drp                        : 1;
+		u64 overflw                          : 1;
+		u64 nic_nxc                          : 1;
+		u64 nix0_nxc                         : 1;
+		u64 nix1_nxc                         : 1;
+		u64 nix0_e_nxc                       : 1;
+		u64 nix1_e_nxc                       : 1;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct cavm_cgxx_cmrx_int_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_INT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_INT(u64 a)
+{
+	return 0x40 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_int_ena_w1c
+ *
+ * CGX CMR Interrupt Enable Clear Register This register clears interrupt
+ * enable bits.
+ */
+union cavm_cgxx_cmrx_int_ena_w1c {
+	u64 u;
+	struct cavm_cgxx_cmrx_int_ena_w1c_s {
+		u64 pause_drp                        : 1;
+		u64 overflw                          : 1;
+		u64 nic_nxc                          : 1;
+		u64 nix0_nxc                         : 1;
+		u64 nix1_nxc                         : 1;
+		u64 nix0_e_nxc                       : 1;
+		u64 nix1_e_nxc                       : 1;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct cavm_cgxx_cmrx_int_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_INT_ENA_W1C(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_INT_ENA_W1C(u64 a)
+{
+	return 0x50 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_int_ena_w1s
+ *
+ * CGX CMR Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
+ */
+union cavm_cgxx_cmrx_int_ena_w1s {
+	u64 u;
+	struct cavm_cgxx_cmrx_int_ena_w1s_s {
+		u64 pause_drp                        : 1;
+		u64 overflw                          : 1;
+		u64 nic_nxc                          : 1;
+		u64 nix0_nxc                         : 1;
+		u64 nix1_nxc                         : 1;
+		u64 nix0_e_nxc                       : 1;
+		u64 nix1_e_nxc                       : 1;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct cavm_cgxx_cmrx_int_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_INT_ENA_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_INT_ENA_W1S(u64 a)
+{
+	return 0x58 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_int_w1s
+ *
+ * CGX CMR Interrupt Set Register This register sets interrupt bits.
+ */
+union cavm_cgxx_cmrx_int_w1s {
+	u64 u;
+	struct cavm_cgxx_cmrx_int_w1s_s {
+		u64 pause_drp                        : 1;
+		u64 overflw                          : 1;
+		u64 nic_nxc                          : 1;
+		u64 nix0_nxc                         : 1;
+		u64 nix1_nxc                         : 1;
+		u64 nix0_e_nxc                       : 1;
+		u64 nix1_e_nxc                       : 1;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct cavm_cgxx_cmrx_int_w1s_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_INT_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_INT_W1S(u64 a)
+{
+	return 0x48 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_led_timing
+ *
+ * CGX MAC LED Activity Timing Registers
+ */
+union cavm_cgxx_cmrx_led_timing {
+	u64 u;
+	struct cavm_cgxx_cmrx_led_timing_s {
+		u64 extension                        : 8;
+		u64 reserved_8_63                    : 56;
+	} s;
+	/* struct cavm_cgxx_cmrx_led_timing_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_LED_TIMING(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_LED_TIMING(u64 a)
+{
+	return 0x5f0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_prt_cbfc_ctl
+ *
+ * CGX CMR LMAC PFC Control Registers See CGX()_CMR()_RX_LOGL_XOFF[XOFF].
+ */
+union cavm_cgxx_cmrx_prt_cbfc_ctl {
+	u64 u;
+	struct cavm_cgxx_cmrx_prt_cbfc_ctl_s {
+		u64 reserved_0_15                    : 16;
+		u64 phys_bp                          : 16;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cavm_cgxx_cmrx_prt_cbfc_ctl_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_PRT_CBFC_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_PRT_CBFC_CTL(u64 a)
+{
+	return 0x608 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_bp_drop
+ *
+ * CGX Receive Backpressure Drop Register
+ */
+union cavm_cgxx_cmrx_rx_bp_drop {
+	u64 u;
+	struct cavm_cgxx_cmrx_rx_bp_drop_s {
+		u64 mark                             : 7;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct cavm_cgxx_cmrx_rx_bp_drop_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_RX_BP_DROP(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_RX_BP_DROP(u64 a)
+{
+	return 0xd8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_bp_off
+ *
+ * CGX Receive Backpressure Off Register
+ */
+union cavm_cgxx_cmrx_rx_bp_off {
+	u64 u;
+	struct cavm_cgxx_cmrx_rx_bp_off_s {
+		u64 mark                             : 7;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct cavm_cgxx_cmrx_rx_bp_off_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_RX_BP_OFF(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_RX_BP_OFF(u64 a)
+{
+	return 0xe8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_bp_on
+ *
+ * CGX Receive Backpressure On Register
+ */
+union cavm_cgxx_cmrx_rx_bp_on {
+	u64 u;
+	struct cavm_cgxx_cmrx_rx_bp_on_s {
+		u64 mark                             : 13;
+		u64 reserved_13_63                   : 51;
+	} s;
+	/* struct cavm_cgxx_cmrx_rx_bp_on_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_RX_BP_ON(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_RX_BP_ON(u64 a)
+{
+	return 0xe0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_bp_status
+ *
+ * CGX CMR Receive Backpressure Status Registers
+ */
+union cavm_cgxx_cmrx_rx_bp_status {
+	u64 u;
+	struct cavm_cgxx_cmrx_rx_bp_status_s {
+		u64 bp                               : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_cgxx_cmrx_rx_bp_status_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_RX_BP_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_RX_BP_STATUS(u64 a)
+{
+	return 0xf0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_dmac_ctl0
+ *
+ * CGX CMR Receive DMAC Address-Control0 Register DMAC CAM control
+ * register for use by X2P/NIX bound traffic. Received packets are only
+ * passed to X2P/NIX when the DMAC0 filter result is ACCEPT and STEERING0
+ * filter result is PASS. See also CGX()_CMR_RX_DMAC()_CAM0 and
+ * CGX()_CMR_RX_STEERING0().  Internal: "* ALGORITHM Here is some pseudo
+ * code that represents the address filter behavior. \<pre\>
+ * dmac_addr_filter(uint8 prt, uint48 dmac) { for (lmac=0, lmac\<4,
+ * lmac++) {   if (is_bcst(dmac))                               //
+ * broadcast accept     return (CGX()_CMR(lmac)_RX_DMAC_CTL0[BCST_ACCEPT]
+ * ? ACCEPT : REJECT);   if (is_mcst(dmac) &&
+ * CGX()_CMR(lmac)_RX_DMAC_CTL0[MCST_MODE] == 0)   // multicast reject
+ * return REJECT;   if (is_mcst(dmac) &&
+ * CGX()_CMR(lmac)_RX_DMAC_CTL0[MCST_MODE] == 1)   // multicast accept
+ * return ACCEPT;   else        // DMAC CAM filter     cam_hit = 0;   for
+ * (i=0; i\<32; i++) {     cam = CGX()_CMR_RX_DMAC(i)_CAM0;     if
+ * (cam[EN] && cam[ID] == lmac && cam[ADR] == dmac) {       cam_hit = 1;
+ * break;     }   }   if (cam_hit) {     return
+ * (CGX()_CMR(lmac)_RX_DMAC_CTL0[CAM_ACCEPT] ? ACCEPT : REJECT);   else
+ * return (CGX()_CMR(lmac)_RX_DMAC_CTL0[CAM_ACCEPT] ? REJECT : ACCEPT);
+ * } } \</pre\>"
+ */
+union cavm_cgxx_cmrx_rx_dmac_ctl0 {
+	u64 u;
+	struct cavm_cgxx_cmrx_rx_dmac_ctl0_s {
+		u64 bcst_accept                      : 1;
+		u64 mcst_mode                        : 2;
+		u64 cam_accept                       : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cavm_cgxx_cmrx_rx_dmac_ctl0_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_RX_DMAC_CTL0(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_RX_DMAC_CTL0(u64 a)
+{
+	return 0x1f8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_dmac_ctl1
+ *
+ * CGX CMR Receive DMAC Address-Control1 Register DMAC CAM control
+ * register for use by NCSI bound traffic. Received packets are only
+ * passed to NCSI when the DMAC1 filter result is ACCEPT and STEERING1
+ * filter result is PASS. See also CGX()_CMR_RX_DMAC()_CAM1 and
+ * CGX()_CMR_RX_STEERING1(). For use with the LMAC associated with NCSI;
+ * see CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID].  Internal: ALGORITHM: See
+ * CGX()_CMR()_RX_DMAC_CTL0.
+ */
+union cavm_cgxx_cmrx_rx_dmac_ctl1 {
+	u64 u;
+	struct cavm_cgxx_cmrx_rx_dmac_ctl1_s {
+		u64 bcst_accept                      : 1;
+		u64 mcst_mode                        : 2;
+		u64 cam_accept                       : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cavm_cgxx_cmrx_rx_dmac_ctl1_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_RX_DMAC_CTL1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_RX_DMAC_CTL1(u64 a)
+{
+	return 0x3f8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_fifo_len
+ *
+ * CGX CMR Receive Fifo Length Registers
+ */
+union cavm_cgxx_cmrx_rx_fifo_len {
+	u64 u;
+	struct cavm_cgxx_cmrx_rx_fifo_len_s {
+		u64 fifo_len                         : 14;
+		u64 busy                             : 1;
+		u64 fifo_len_e                       : 14;
+		u64 busy_e                           : 1;
+		u64 reserved_30_63                   : 34;
+	} s;
+	/* struct cavm_cgxx_cmrx_rx_fifo_len_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_RX_FIFO_LEN(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_RX_FIFO_LEN(u64 a)
+{
+	return 0x108 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_id_map
+ *
+ * CGX CMR Receive ID Map Register These registers set the RX LMAC ID
+ * mapping for X2P/NIX.
+ */
+union cavm_cgxx_cmrx_rx_id_map {
+	u64 u;
+	struct cavm_cgxx_cmrx_rx_id_map_s {
+		u64 pknd                             : 6;
+		u64 unused                           : 2;
+		u64 rid                              : 7;
+		u64 reserved_15_63                   : 49;
+	} s;
+	/* struct cavm_cgxx_cmrx_rx_id_map_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_RX_ID_MAP(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_RX_ID_MAP(u64 a)
+{
+	return 0x60 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_logl_xoff
+ *
+ * CGX CMR Receive Logical XOFF Registers
+ */
+union cavm_cgxx_cmrx_rx_logl_xoff {
+	u64 u;
+	struct cavm_cgxx_cmrx_rx_logl_xoff_s {
+		u64 xoff                             : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_cmrx_rx_logl_xoff_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_RX_LOGL_XOFF(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_RX_LOGL_XOFF(u64 a)
+{
+	return 0xf8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_logl_xon
+ *
+ * CGX CMR Receive Logical XON Registers
+ */
+union cavm_cgxx_cmrx_rx_logl_xon {
+	u64 u;
+	struct cavm_cgxx_cmrx_rx_logl_xon_s {
+		u64 xon                              : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_cmrx_rx_logl_xon_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_RX_LOGL_XON(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_RX_LOGL_XON(u64 a)
+{
+	return 0x100 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_merge_stat0
+ *
+ * CGX RX Preemption Status Register 0
+ */
+union cavm_cgxx_cmrx_rx_merge_stat0 {
+	u64 u;
+	struct cavm_cgxx_cmrx_rx_merge_stat0_s {
+		u64 fa_err_cnt                       : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_rx_merge_stat0_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_RX_MERGE_STAT0(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_RX_MERGE_STAT0(u64 a)
+{
+	return 0x138 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_merge_stat1
+ *
+ * CGX RX Preemption Status Register 1
+ */
+union cavm_cgxx_cmrx_rx_merge_stat1 {
+	u64 u;
+	struct cavm_cgxx_cmrx_rx_merge_stat1_s {
+		u64 fs_err_cnt                       : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_rx_merge_stat1_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_RX_MERGE_STAT1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_RX_MERGE_STAT1(u64 a)
+{
+	return 0x140 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_merge_stat2
+ *
+ * CGX RX Preemption Status Register 2
+ */
+union cavm_cgxx_cmrx_rx_merge_stat2 {
+	u64 u;
+	struct cavm_cgxx_cmrx_rx_merge_stat2_s {
+		u64 fa_ok_cnt                        : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_rx_merge_stat2_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_RX_MERGE_STAT2(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_RX_MERGE_STAT2(u64 a)
+{
+	return 0x148 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_merge_stat3
+ *
+ * CGX RX Preemption Status Register 3
+ */
+union cavm_cgxx_cmrx_rx_merge_stat3 {
+	u64 u;
+	struct cavm_cgxx_cmrx_rx_merge_stat3_s {
+		u64 ff_cnt                           : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_rx_merge_stat3_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_RX_MERGE_STAT3(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_RX_MERGE_STAT3(u64 a)
+{
+	return 0x150 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_merge_stat4
+ *
+ * CGX RX Preemption Status Register 4
+ */
+union cavm_cgxx_cmrx_rx_merge_stat4 {
+	u64 u;
+	struct cavm_cgxx_cmrx_rx_merge_stat4_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_rx_merge_stat4_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_RX_MERGE_STAT4(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_RX_MERGE_STAT4(u64 a)
+{
+	return 0x158 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_pause_drop_time
+ *
+ * CGX CMR Receive Pause Drop-Time Register
+ */
+union cavm_cgxx_cmrx_rx_pause_drop_time {
+	u64 u;
+	struct cavm_cgxx_cmrx_rx_pause_drop_time_s {
+		u64 pause_time                       : 16;
+		u64 pause_time_e                     : 16;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cavm_cgxx_cmrx_rx_pause_drop_time_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_RX_PAUSE_DROP_TIME(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_RX_PAUSE_DROP_TIME(u64 a)
+{
+	return 0x68 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_stat0
+ *
+ * CGX Receive Status Register 0 These registers provide a count of
+ * received packets that meet the following conditions: * are not
+ * recognized as ERROR packets(any OPCODE). * are not recognized as PAUSE
+ * packets. * are not dropped due FIFO full status. * are not dropped due
+ * DMAC0 or STEERING0 filtering.  Internal: "This pseudo code represents
+ * the RX STAT0 through STAT8 accounting: \<pre\> If (errored)   incr
+ * RX_STAT8 else if (ctrl packet, i.e. Pause/PFC)   incr RX_STAT2,3 else
+ * if (fifo full drop)   incr RX_STAT6,7 else if (DMAC0/VLAN0 filter
+ * drop)   incr RX_STAT4,5 if not a filter+decision else   incr
+ * RX_STAT0,1 end \</pre\>"
+ */
+union cavm_cgxx_cmrx_rx_stat0 {
+	u64 u;
+	struct cavm_cgxx_cmrx_rx_stat0_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_rx_stat0_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_RX_STAT0(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_RX_STAT0(u64 a)
+{
+	return 0x70 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_stat1
+ *
+ * CGX Receive Status Register 1 These registers provide a count of
+ * octets of received packets.
+ */
+union cavm_cgxx_cmrx_rx_stat1 {
+	u64 u;
+	struct cavm_cgxx_cmrx_rx_stat1_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_rx_stat1_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_RX_STAT1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_RX_STAT1(u64 a)
+{
+	return 0x78 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_stat2
+ *
+ * CGX Receive Status Register 2 These registers provide a count of
+ * received packets that meet the following conditions: * are not
+ * recognized as ERROR packets(any OPCODE). * are recognized as PAUSE
+ * packets.  Pause packets can be optionally dropped or forwarded based
+ * on
+ * CGX()_SMU()_RX_FRM_CTL[CTL_DRP]/CGX()_GMP_GMI_RX()_FRM_CTL[CTL_DRP].
+ * This count increments regardless of whether the packet is dropped.
+ */
+union cavm_cgxx_cmrx_rx_stat2 {
+	u64 u;
+	struct cavm_cgxx_cmrx_rx_stat2_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_rx_stat2_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_RX_STAT2(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_RX_STAT2(u64 a)
+{
+	return 0x80 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_stat3
+ *
+ * CGX Receive Status Register 3 These registers provide a count of
+ * octets of received PAUSE and control packets.
+ */
+union cavm_cgxx_cmrx_rx_stat3 {
+	u64 u;
+	struct cavm_cgxx_cmrx_rx_stat3_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_rx_stat3_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_RX_STAT3(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_RX_STAT3(u64 a)
+{
+	return 0x88 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_stat4
+ *
+ * CGX Receive Status Register 4 These registers provide a count of
+ * received packets that meet the following conditions: * are not
+ * recognized as ERROR packets(any OPCODE). * are not recognized as PAUSE
+ * packets. * are not dropped due FIFO full status. * are dropped due
+ * DMAC0 or STEERING0 filtering.  16B packets or smaller (20B in case of
+ * FCS strip) as the result of truncation or other means are not dropped
+ * by CGX (unless filter and decision is also asserted) and will never
+ * appear in this count. Should the MAC signal to the CMR that the packet
+ * be filtered upon decision before the end of packet, then STAT4 and
+ * STAT5 will not be updated.
+ */
+union cavm_cgxx_cmrx_rx_stat4 {
+	u64 u;
+	struct cavm_cgxx_cmrx_rx_stat4_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_rx_stat4_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_RX_STAT4(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_RX_STAT4(u64 a)
+{
+	return 0x90 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_stat5
+ *
+ * CGX Receive Status Register 5 These registers provide a count of
+ * octets of filtered DMAC0 or VLAN STEERING0 packets.
+ */
+union cavm_cgxx_cmrx_rx_stat5 {
+	u64 u;
+	struct cavm_cgxx_cmrx_rx_stat5_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_rx_stat5_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_RX_STAT5(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_RX_STAT5(u64 a)
+{
+	return 0x98 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_stat6
+ *
+ * CGX Receive Status Register 6 These registers provide a count of
+ * received packets that meet the following conditions: * are not
+ * recognized as ERROR packets(any OPCODE). * are not recognized as PAUSE
+ * packets. * are dropped due FIFO full status.  They do not count any
+ * packet that is truncated at the point of overflow and sent on to the
+ * NIX. The truncated packet will be marked with error and increment
+ * STAT8. These registers count all entire packets dropped by the FIFO
+ * for a given LMAC.
+ */
+union cavm_cgxx_cmrx_rx_stat6 {
+	u64 u;
+	struct cavm_cgxx_cmrx_rx_stat6_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_rx_stat6_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_RX_STAT6(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_RX_STAT6(u64 a)
+{
+	return 0xa0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_stat7
+ *
+ * CGX Receive Status Register 7 These registers provide a count of
+ * octets of received packets that were dropped due to a full receive
+ * FIFO.
+ */
+union cavm_cgxx_cmrx_rx_stat7 {
+	u64 u;
+	struct cavm_cgxx_cmrx_rx_stat7_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_rx_stat7_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_RX_STAT7(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_RX_STAT7(u64 a)
+{
+	return 0xa8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_stat8
+ *
+ * CGX Receive Status Register 8 These registers provide a count of
+ * received packets that meet the following conditions:  * are recognized
+ * as ERROR packets(any OPCODE).
+ */
+union cavm_cgxx_cmrx_rx_stat8 {
+	u64 u;
+	struct cavm_cgxx_cmrx_rx_stat8_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_rx_stat8_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_RX_STAT8(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_RX_STAT8(u64 a)
+{
+	return 0xb0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_rx_stat_pri#_xoff
+ *
+ * CGX CMR RX XON to XOFF transition Registers
+ */
+union cavm_cgxx_cmrx_rx_stat_prix_xoff {
+	u64 u;
+	struct cavm_cgxx_cmrx_rx_stat_prix_xoff_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_rx_stat_prix_xoff_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_RX_STAT_PRIX_XOFF(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_RX_STAT_PRIX_XOFF(u64 a, u64 b)
+{
+	return 0x7c0 + 0x40000 * a + 8 * b;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_scratch#
+ *
+ * CGX CMR Scratch Registers
+ */
+union cavm_cgxx_cmrx_scratchx {
+	u64 u;
+	struct cavm_cgxx_cmrx_scratchx_s {
+		u64 scratch                          : 64;
+	} s;
+	/* struct cavm_cgxx_cmrx_scratchx_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_SCRATCHX(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_SCRATCHX(u64 a, u64 b)
+{
+	return 0x1050 + 0x40000 * a + 8 * b;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_channel
+ *
+ * CGX CMR Transmit-Channels Registers
+ */
+union cavm_cgxx_cmrx_tx_channel {
+	u64 u;
+	struct cavm_cgxx_cmrx_tx_channel_s {
+		u64 msk                              : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_cmrx_tx_channel_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_TX_CHANNEL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_TX_CHANNEL(u64 a)
+{
+	return 0x600 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_fifo_len
+ *
+ * CGX CMR Transmit Fifo Length Registers
+ */
+union cavm_cgxx_cmrx_tx_fifo_len {
+	u64 u;
+	struct cavm_cgxx_cmrx_tx_fifo_len_s {
+		u64 fifo_len                         : 14;
+		u64 lmac_idle                        : 1;
+		u64 fifo_e_len                       : 14;
+		u64 lmac_e_idle                      : 1;
+		u64 reserved_30_63                   : 34;
+	} s;
+	/* struct cavm_cgxx_cmrx_tx_fifo_len_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_TX_FIFO_LEN(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_TX_FIFO_LEN(u64 a)
+{
+	return 0x618 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_hg2_status
+ *
+ * CGX CMR Transmit HiGig2 Status Registers
+ */
+union cavm_cgxx_cmrx_tx_hg2_status {
+	u64 u;
+	struct cavm_cgxx_cmrx_tx_hg2_status_s {
+		u64 lgtim2go                         : 16;
+		u64 xof                              : 16;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cavm_cgxx_cmrx_tx_hg2_status_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_TX_HG2_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_TX_HG2_STATUS(u64 a)
+{
+	return 0x610 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_merge_stat0
+ *
+ * CGX TX Preemption Status Register 0
+ */
+union cavm_cgxx_cmrx_tx_merge_stat0 {
+	u64 u;
+	struct cavm_cgxx_cmrx_tx_merge_stat0_s {
+		u64 ff_cnt                           : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_tx_merge_stat0_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_TX_MERGE_STAT0(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_TX_MERGE_STAT0(u64 a)
+{
+	return 0x160 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_ovr_bp
+ *
+ * CGX CMR Transmit-Channels Backpressure Override Registers
+ */
+union cavm_cgxx_cmrx_tx_ovr_bp {
+	u64 u;
+	struct cavm_cgxx_cmrx_tx_ovr_bp_s {
+		u64 tx_chan_bp                       : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_cmrx_tx_ovr_bp_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_TX_OVR_BP(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_TX_OVR_BP(u64 a)
+{
+	return 0x620 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat0
+ *
+ * CGX CMR Transmit Statistics Registers 0
+ */
+union cavm_cgxx_cmrx_tx_stat0 {
+	u64 u;
+	struct cavm_cgxx_cmrx_tx_stat0_s {
+		u64 xscol                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_tx_stat0_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_TX_STAT0(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_TX_STAT0(u64 a)
+{
+	return 0x700 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat1
+ *
+ * CGX CMR Transmit Statistics Registers 1
+ */
+union cavm_cgxx_cmrx_tx_stat1 {
+	u64 u;
+	struct cavm_cgxx_cmrx_tx_stat1_s {
+		u64 xsdef                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_tx_stat1_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_TX_STAT1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_TX_STAT1(u64 a)
+{
+	return 0x708 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat10
+ *
+ * CGX CMR Transmit Statistics Registers 10
+ */
+union cavm_cgxx_cmrx_tx_stat10 {
+	u64 u;
+	struct cavm_cgxx_cmrx_tx_stat10_s {
+		u64 hist4                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_tx_stat10_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_TX_STAT10(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_TX_STAT10(u64 a)
+{
+	return 0x750 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat11
+ *
+ * CGX CMR Transmit Statistics Registers 11
+ */
+union cavm_cgxx_cmrx_tx_stat11 {
+	u64 u;
+	struct cavm_cgxx_cmrx_tx_stat11_s {
+		u64 hist5                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_tx_stat11_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_TX_STAT11(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_TX_STAT11(u64 a)
+{
+	return 0x758 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat12
+ *
+ * CGX CMR Transmit Statistics Registers 12
+ */
+union cavm_cgxx_cmrx_tx_stat12 {
+	u64 u;
+	struct cavm_cgxx_cmrx_tx_stat12_s {
+		u64 hist6                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_tx_stat12_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_TX_STAT12(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_TX_STAT12(u64 a)
+{
+	return 0x760 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat13
+ *
+ * CGX CMR Transmit Statistics Registers 13
+ */
+union cavm_cgxx_cmrx_tx_stat13 {
+	u64 u;
+	struct cavm_cgxx_cmrx_tx_stat13_s {
+		u64 hist7                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_tx_stat13_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_TX_STAT13(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_TX_STAT13(u64 a)
+{
+	return 0x768 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat14
+ *
+ * CGX CMR Transmit Statistics Registers 14
+ */
+union cavm_cgxx_cmrx_tx_stat14 {
+	u64 u;
+	struct cavm_cgxx_cmrx_tx_stat14_s {
+		u64 bcst                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_tx_stat14_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_TX_STAT14(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_TX_STAT14(u64 a)
+{
+	return 0x770 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat15
+ *
+ * CGX CMR Transmit Statistics Registers 15
+ */
+union cavm_cgxx_cmrx_tx_stat15 {
+	u64 u;
+	struct cavm_cgxx_cmrx_tx_stat15_s {
+		u64 mcst                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_tx_stat15_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_TX_STAT15(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_TX_STAT15(u64 a)
+{
+	return 0x778 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat16
+ *
+ * CGX CMR Transmit Statistics Registers 16
+ */
+union cavm_cgxx_cmrx_tx_stat16 {
+	u64 u;
+	struct cavm_cgxx_cmrx_tx_stat16_s {
+		u64 undflw                           : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_tx_stat16_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_TX_STAT16(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_TX_STAT16(u64 a)
+{
+	return 0x780 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat17
+ *
+ * CGX CMR Transmit Statistics Registers 17
+ */
+union cavm_cgxx_cmrx_tx_stat17 {
+	u64 u;
+	struct cavm_cgxx_cmrx_tx_stat17_s {
+		u64 ctl                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_tx_stat17_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_TX_STAT17(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_TX_STAT17(u64 a)
+{
+	return 0x788 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat2
+ *
+ * CGX CMR Transmit Statistics Registers 2
+ */
+union cavm_cgxx_cmrx_tx_stat2 {
+	u64 u;
+	struct cavm_cgxx_cmrx_tx_stat2_s {
+		u64 mcol                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_tx_stat2_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_TX_STAT2(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_TX_STAT2(u64 a)
+{
+	return 0x710 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat3
+ *
+ * CGX CMR Transmit Statistics Registers 3
+ */
+union cavm_cgxx_cmrx_tx_stat3 {
+	u64 u;
+	struct cavm_cgxx_cmrx_tx_stat3_s {
+		u64 scol                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_tx_stat3_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_TX_STAT3(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_TX_STAT3(u64 a)
+{
+	return 0x718 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat4
+ *
+ * CGX CMR Transmit Statistics Registers 4
+ */
+union cavm_cgxx_cmrx_tx_stat4 {
+	u64 u;
+	struct cavm_cgxx_cmrx_tx_stat4_s {
+		u64 octs                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_tx_stat4_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_TX_STAT4(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_TX_STAT4(u64 a)
+{
+	return 0x720 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat5
+ *
+ * CGX CMR Transmit Statistics Registers 5
+ */
+union cavm_cgxx_cmrx_tx_stat5 {
+	u64 u;
+	struct cavm_cgxx_cmrx_tx_stat5_s {
+		u64 pkts                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_tx_stat5_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_TX_STAT5(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_TX_STAT5(u64 a)
+{
+	return 0x728 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat6
+ *
+ * CGX CMR Transmit Statistics Registers 6
+ */
+union cavm_cgxx_cmrx_tx_stat6 {
+	u64 u;
+	struct cavm_cgxx_cmrx_tx_stat6_s {
+		u64 hist0                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_tx_stat6_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_TX_STAT6(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_TX_STAT6(u64 a)
+{
+	return 0x730 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat7
+ *
+ * CGX CMR Transmit Statistics Registers 7
+ */
+union cavm_cgxx_cmrx_tx_stat7 {
+	u64 u;
+	struct cavm_cgxx_cmrx_tx_stat7_s {
+		u64 hist1                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_tx_stat7_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_TX_STAT7(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_TX_STAT7(u64 a)
+{
+	return 0x738 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat8
+ *
+ * CGX CMR Transmit Statistics Registers 8
+ */
+union cavm_cgxx_cmrx_tx_stat8 {
+	u64 u;
+	struct cavm_cgxx_cmrx_tx_stat8_s {
+		u64 hist2                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_tx_stat8_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_TX_STAT8(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_TX_STAT8(u64 a)
+{
+	return 0x740 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat9
+ *
+ * CGX CMR Transmit Statistics Registers 9
+ */
+union cavm_cgxx_cmrx_tx_stat9 {
+	u64 u;
+	struct cavm_cgxx_cmrx_tx_stat9_s {
+		u64 hist3                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_tx_stat9_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_TX_STAT9(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_TX_STAT9(u64 a)
+{
+	return 0x748 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr#_tx_stat_pri#_xoff
+ *
+ * CGX CMR TX XON to XOFF transition Registers
+ */
+union cavm_cgxx_cmrx_tx_stat_prix_xoff {
+	u64 u;
+	struct cavm_cgxx_cmrx_tx_stat_prix_xoff_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmrx_tx_stat_prix_xoff_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMRX_TX_STAT_PRIX_XOFF(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMRX_TX_STAT_PRIX_XOFF(u64 a, u64 b)
+{
+	return 0x800 + 0x40000 * a + 8 * b;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_bad
+ *
+ * CGX CMR Bad Registers
+ */
+union cavm_cgxx_cmr_bad {
+	u64 u;
+	struct cavm_cgxx_cmr_bad_s {
+		u64 rxb_nxl                          : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_cgxx_cmr_bad_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMR_BAD(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMR_BAD(void)
+{
+	return 0x1020;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_chan_msk_and
+ *
+ * CGX CMR Backpressure Channel Mask AND Registers
+ */
+union cavm_cgxx_cmr_chan_msk_and {
+	u64 u;
+	struct cavm_cgxx_cmr_chan_msk_and_s {
+		u64 msk_and                          : 64;
+	} s;
+	/* struct cavm_cgxx_cmr_chan_msk_and_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMR_CHAN_MSK_AND(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMR_CHAN_MSK_AND(void)
+{
+	return 0x110;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_chan_msk_or
+ *
+ * CGX Backpressure Channel Mask OR Registers
+ */
+union cavm_cgxx_cmr_chan_msk_or {
+	u64 u;
+	struct cavm_cgxx_cmr_chan_msk_or_s {
+		u64 msk_or                           : 64;
+	} s;
+	/* struct cavm_cgxx_cmr_chan_msk_or_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMR_CHAN_MSK_OR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMR_CHAN_MSK_OR(void)
+{
+	return 0x118;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_eco
+ *
+ * INTERNAL: CGX ECO Registers
+ */
+union cavm_cgxx_cmr_eco {
+	u64 u;
+	struct cavm_cgxx_cmr_eco_s {
+		u64 eco_rw                           : 32;
+		u64 eco_ro                           : 32;
+	} s;
+	/* struct cavm_cgxx_cmr_eco_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMR_ECO(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMR_ECO(void)
+{
+	return 0x1028;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_global_config
+ *
+ * CGX CMR Global Configuration Register These registers configure the
+ * global CMR, PCS, and MAC.
+ */
+union cavm_cgxx_cmr_global_config {
+	u64 u;
+	struct cavm_cgxx_cmr_global_config_s {
+		u64 pmux_sds_sel                     : 1;
+		u64 cgx_clk_enable                   : 1;
+		u64 cmr_x2p_reset                    : 3;
+		u64 interleave_mode                  : 1;
+		u64 fcs_strip                        : 1;
+		u64 ncsi_lmac_id                     : 2;
+		u64 cmr_ncsi_drop                    : 1;
+		u64 cmr_ncsi_reset                   : 1;
+		u64 cmr_ncsi_tag_cnt                 : 13;
+		u64 cmr_clken_ovrd                   : 1;
+		u64 reserved_25_63                   : 39;
+	} s;
+	/* struct cavm_cgxx_cmr_global_config_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMR_GLOBAL_CONFIG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMR_GLOBAL_CONFIG(void)
+{
+	return 8;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_mem_int
+ *
+ * CGX CMR Memory Interrupt Register
+ */
+union cavm_cgxx_cmr_mem_int {
+	u64 u;
+	struct cavm_cgxx_cmr_mem_int_s {
+		u64 gmp_in_overfl                    : 1;
+		u64 smu_in_overfl                    : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cavm_cgxx_cmr_mem_int_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMR_MEM_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMR_MEM_INT(void)
+{
+	return 0x10;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_mem_int_ena_w1c
+ *
+ * CGX CMR Memory Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union cavm_cgxx_cmr_mem_int_ena_w1c {
+	u64 u;
+	struct cavm_cgxx_cmr_mem_int_ena_w1c_s {
+		u64 gmp_in_overfl                    : 1;
+		u64 smu_in_overfl                    : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cavm_cgxx_cmr_mem_int_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMR_MEM_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMR_MEM_INT_ENA_W1C(void)
+{
+	return 0x20;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_mem_int_ena_w1s
+ *
+ * CGX CMR Memory Interrupt Enable Set Register This register sets
+ * interrupt enable bits.
+ */
+union cavm_cgxx_cmr_mem_int_ena_w1s {
+	u64 u;
+	struct cavm_cgxx_cmr_mem_int_ena_w1s_s {
+		u64 gmp_in_overfl                    : 1;
+		u64 smu_in_overfl                    : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cavm_cgxx_cmr_mem_int_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMR_MEM_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMR_MEM_INT_ENA_W1S(void)
+{
+	return 0x28;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_mem_int_w1s
+ *
+ * CGX CMR Memory Interrupt Set Register This register sets interrupt
+ * bits.
+ */
+union cavm_cgxx_cmr_mem_int_w1s {
+	u64 u;
+	struct cavm_cgxx_cmr_mem_int_w1s_s {
+		u64 gmp_in_overfl                    : 1;
+		u64 smu_in_overfl                    : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cavm_cgxx_cmr_mem_int_w1s_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMR_MEM_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMR_MEM_INT_W1S(void)
+{
+	return 0x18;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_nic_nxc_adr
+ *
+ * CGX CMR NIC NXC Exception Registers
+ */
+union cavm_cgxx_cmr_nic_nxc_adr {
+	u64 u;
+	struct cavm_cgxx_cmr_nic_nxc_adr_s {
+		u64 channel                          : 12;
+		u64 lmac_id                          : 4;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_cmr_nic_nxc_adr_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMR_NIC_NXC_ADR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMR_NIC_NXC_ADR(void)
+{
+	return 0x1030;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_nix0_nxc_adr
+ *
+ * CGX CMR NIX0 NXC Exception Registers
+ */
+union cavm_cgxx_cmr_nix0_nxc_adr {
+	u64 u;
+	struct cavm_cgxx_cmr_nix0_nxc_adr_s {
+		u64 channel                          : 12;
+		u64 lmac_id                          : 4;
+		u64 channel_e                        : 12;
+		u64 lmac_e_id                        : 4;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cavm_cgxx_cmr_nix0_nxc_adr_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMR_NIX0_NXC_ADR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMR_NIX0_NXC_ADR(void)
+{
+	return 0x1038;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_nix1_nxc_adr
+ *
+ * CGX CMR NIX1 NXC Exception Registers
+ */
+union cavm_cgxx_cmr_nix1_nxc_adr {
+	u64 u;
+	struct cavm_cgxx_cmr_nix1_nxc_adr_s {
+		u64 channel                          : 12;
+		u64 lmac_id                          : 4;
+		u64 channel_e                        : 12;
+		u64 lmac_e_id                        : 4;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cavm_cgxx_cmr_nix1_nxc_adr_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMR_NIX1_NXC_ADR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMR_NIX1_NXC_ADR(void)
+{
+	return 0x1040;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_p2x#_count
+ *
+ * CGX P2X Activity Register
+ */
+union cavm_cgxx_cmr_p2xx_count {
+	u64 u;
+	struct cavm_cgxx_cmr_p2xx_count_s {
+		u64 p2x_cnt                          : 64;
+	} s;
+	/* struct cavm_cgxx_cmr_p2xx_count_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMR_P2XX_COUNT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMR_P2XX_COUNT(u64 a)
+{
+	return 0x168 + 0x1000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_rx_dmac#_cam0
+ *
+ * CGX CMR Receive CAM Registers These registers provide access to the 32
+ * DMAC CAM0 entries in CGX, for use by X2P/NIX bound traffic.
+ */
+union cavm_cgxx_cmr_rx_dmacx_cam0 {
+	u64 u;
+	struct cavm_cgxx_cmr_rx_dmacx_cam0_s {
+		u64 adr                              : 48;
+		u64 en                               : 1;
+		u64 id                               : 2;
+		u64 reserved_51_63                   : 13;
+	} s;
+	/* struct cavm_cgxx_cmr_rx_dmacx_cam0_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMR_RX_DMACX_CAM0(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMR_RX_DMACX_CAM0(u64 a)
+{
+	return 0x200 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_rx_dmac#_cam1
+ *
+ * CGX CMR Receive CAM Registers These registers provide access to the 32
+ * DMAC CAM entries in CGX for use by NCSI bound traffic. See
+ * CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID] and CGX()_CMR_RX_STEERING1()
+ * registers.
+ */
+union cavm_cgxx_cmr_rx_dmacx_cam1 {
+	u64 u;
+	struct cavm_cgxx_cmr_rx_dmacx_cam1_s {
+		u64 adr                              : 48;
+		u64 en                               : 1;
+		u64 id                               : 2;
+		u64 reserved_51_63                   : 13;
+	} s;
+	/* struct cavm_cgxx_cmr_rx_dmacx_cam1_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMR_RX_DMACX_CAM1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMR_RX_DMACX_CAM1(u64 a)
+{
+	return 0x400 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_rx_lmacs
+ *
+ * CGX CMR Receive Logical MACs Registers
+ */
+union cavm_cgxx_cmr_rx_lmacs {
+	u64 u;
+	struct cavm_cgxx_cmr_rx_lmacs_s {
+		u64 lmacs                            : 3;
+		u64 reserved_3_63                    : 61;
+	} s;
+	/* struct cavm_cgxx_cmr_rx_lmacs_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMR_RX_LMACS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMR_RX_LMACS(void)
+{
+	return 0x128;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_rx_ovr_bp
+ *
+ * CGX CMR Receive-Ports Backpressure Override Registers Per-LMAC
+ * backpressure override register. For SMU, CGX()_CMR_RX_OVR_BP[EN]\<0\>
+ * must be set to one and CGX()_CMR_RX_OVR_BP[BP]\<0\> must be cleared to
+ * zero (to forcibly disable hardware-automatic 802.3 PAUSE packet
+ * generation) with the HiGig2 Protocol when
+ * CGX()_SMU()_HG2_CONTROL[HG2TX_EN]=0. (The HiGig2 protocol is indicated
+ * by CGX()_SMU()_TX_CTL[HG_EN]=1 and CGX()_SMU()_RX_UDD_SKP[LEN]=16).
+ * Hardware can only auto-generate backpressure through HiGig2 messages
+ * (optionally, when CGX()_SMU()_HG2_CONTROL[HG2TX_EN]=1) with the HiGig2
+ * protocol.
+ */
+union cavm_cgxx_cmr_rx_ovr_bp {
+	u64 u;
+	struct cavm_cgxx_cmr_rx_ovr_bp_s {
+		u64 ign_fifo_bp                      : 4;
+		u64 bp                               : 4;
+		u64 en                               : 4;
+		u64 reserved_12_63                   : 52;
+	} s;
+	/* struct cavm_cgxx_cmr_rx_ovr_bp_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMR_RX_OVR_BP(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMR_RX_OVR_BP(void)
+{
+	return 0x130;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_rx_stat10
+ *
+ * CGX Receive Status Register 10 These registers provide a count of
+ * octets of filtered DMAC1 or VLAN STEERING1 packets.
+ */
+union cavm_cgxx_cmr_rx_stat10 {
+	u64 u;
+	struct cavm_cgxx_cmr_rx_stat10_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmr_rx_stat10_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMR_RX_STAT10(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMR_RX_STAT10(void)
+{
+	return 0xc0;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_rx_stat11
+ *
+ * CGX Receive Status Register 11 This registers provides a count of
+ * packets dropped at the NCSI interface. This includes drops due to
+ * CGX()_CMR_GLOBAL_CONFIG[CMR_NCSI_DROP] or NCSI FIFO full. The count of
+ * dropped NCSI packets is not accounted for in any other stats
+ * registers.
+ */
+union cavm_cgxx_cmr_rx_stat11 {
+	u64 u;
+	struct cavm_cgxx_cmr_rx_stat11_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmr_rx_stat11_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMR_RX_STAT11(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMR_RX_STAT11(void)
+{
+	return 0xc8;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_rx_stat12
+ *
+ * CGX Receive Status Register 12 This register provide a count of octets
+ * of dropped at the NCSI interface.
+ */
+union cavm_cgxx_cmr_rx_stat12 {
+	u64 u;
+	struct cavm_cgxx_cmr_rx_stat12_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmr_rx_stat12_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMR_RX_STAT12(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMR_RX_STAT12(void)
+{
+	return 0xd0;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_rx_stat9
+ *
+ * CGX Receive Status Register 9 These registers provide a count of all
+ * received packets that were dropped by the DMAC1 or VLAN STEERING1
+ * filter. Packets that are dropped by the DMAC1 or VLAN STEERING1
+ * filters are counted here regardless of whether they were ERR packets,
+ * but does not include those reported in CGX()_CMR()_RX_STAT6. 16B
+ * packets or smaller (20B in case of FCS strip) as the result of
+ * truncation or other means are not dropped by CGX (unless filter and
+ * decision is also asserted) and will never appear in this count. Should
+ * the MAC signal to the CMR that the packet be filtered upon decision
+ * before the end of packet, then STAT9 and STAT10 will not be updated.
+ */
+union cavm_cgxx_cmr_rx_stat9 {
+	u64 u;
+	struct cavm_cgxx_cmr_rx_stat9_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_cmr_rx_stat9_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMR_RX_STAT9(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMR_RX_STAT9(void)
+{
+	return 0xb8;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_rx_steering0#
+ *
+ * CGX CMR Receive Steering0 Registers These registers, along with
+ * CGX()_CMR_RX_STEERING_VETYPE0(), provide eight filters for identifying
+ * and steering receive traffic to X2P/NIX. Received packets are only
+ * passed to X2P/NIX when the DMAC0 filter result is ACCEPT and STEERING0
+ * filter result is PASS. See also CGX()_CMR()_RX_DMAC_CTL0.  Internal:
+ * "* ALGORITHM \<pre\> rx_steering(uint48 pkt_dmac, uint16 pkt_etype,
+ * uint16 pkt_vlan_id) {    for (int i = 0; i \< 8; i++) {       steer =
+ * CGX()_CMR_RX_STEERING0(i);       vetype =
+ * CGX()_CMR_RX_STEERING_VETYPE0(i);       if (steer[MCST_EN] ||
+ * steer[DMAC_EN] || vetype[VLAN_EN] || vetype[VLAN_TAG_EN]) {
+ * // Filter is enabled.          if (   (!steer[MCST_EN] ||
+ * is_mcst(pkt_dmac))              && (!steer[DMAC_EN] || pkt_dmac ==
+ * steer[DMAC])              && (!vetype[VLAN_EN] || pkt_vlan_id ==
+ * vetype[VLAN_ID])              && (!vetype[VLAN_TAG_EN] || pkt_etype ==
+ * vetype[VLAN_ETYPE]) )          {             // Filter match (all
+ * enabled matching criteria are met).             return steer[PASS];
+ * }       }    }    return CGX()_CMR_RX_STEERING_DEFAULT0[PASS]; // No
+ * match } \</pre\>"
+ */
+union cavm_cgxx_cmr_rx_steering0x {
+	u64 u;
+	struct cavm_cgxx_cmr_rx_steering0x_s {
+		u64 dmac                             : 48;
+		u64 dmac_en                          : 1;
+		u64 mcst_en                          : 1;
+		u64 pass                             : 1;
+		u64 reserved_51_63                   : 13;
+	} s;
+	/* struct cavm_cgxx_cmr_rx_steering0x_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMR_RX_STEERING0X(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMR_RX_STEERING0X(u64 a)
+{
+	return 0x300 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_rx_steering1#
+ *
+ * CGX CMR Receive Steering1 Registers These registers, along with
+ * CGX()_CMR_RX_STEERING_VETYPE1(), provide eight filters for identifying
+ * and steering NCSI receive traffic. Received packets are only passed to
+ * NCSI when the DMAC1 filter result is ACCEPT and STEERING1 filter
+ * result is PASS. See also CGX()_CMR_RX_DMAC()_CAM1 and
+ * CGX()_CMR_RX_STEERING1(). For use with the LMAC associated with NCSI.
+ * See CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID].  Internal: ALGORITHM: See
+ * CGX()_CMR_RX_STEERING0().
+ */
+union cavm_cgxx_cmr_rx_steering1x {
+	u64 u;
+	struct cavm_cgxx_cmr_rx_steering1x_s {
+		u64 dmac                             : 48;
+		u64 dmac_en                          : 1;
+		u64 mcst_en                          : 1;
+		u64 pass                             : 1;
+		u64 reserved_51_63                   : 13;
+	} s;
+	/* struct cavm_cgxx_cmr_rx_steering1x_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMR_RX_STEERING1X(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMR_RX_STEERING1X(u64 a)
+{
+	return 0x500 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_rx_steering_default0
+ *
+ * CGX CMR Receive Steering Default0 Destination Register For determining
+ * destination of traffic that does not meet matching algorithm described
+ * in registers CGX()_CMR_RX_STEERING0() and
+ * CGX()_CMR_RX_STEERING_VETYPE0(). All 16B packets or smaller (20B in
+ * case of FCS strip) as the result of truncation will steer to default
+ * destination
+ */
+union cavm_cgxx_cmr_rx_steering_default0 {
+	u64 u;
+	struct cavm_cgxx_cmr_rx_steering_default0_s {
+		u64 pass                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_cgxx_cmr_rx_steering_default0_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMR_RX_STEERING_DEFAULT0(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMR_RX_STEERING_DEFAULT0(void)
+{
+	return 0x3f0;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_rx_steering_default1
+ *
+ * CGX CMR Receive Steering Default1 Destination Register For use with
+ * the lmac_id associated with NCSI. See
+ * CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID]. For determining destination of
+ * traffic that does not meet matching algorithm described in registers
+ * CGX()_CMR_RX_STEERING1() and CGX()_CMR_RX_STEERING_VETYPE1(). All 16B
+ * packets or smaller (20B in case of FCS strip) as the result of
+ * truncation will steer to default destination
+ */
+union cavm_cgxx_cmr_rx_steering_default1 {
+	u64 u;
+	struct cavm_cgxx_cmr_rx_steering_default1_s {
+		u64 pass                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_cgxx_cmr_rx_steering_default1_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMR_RX_STEERING_DEFAULT1(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMR_RX_STEERING_DEFAULT1(void)
+{
+	return 0x5e0;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_rx_steering_vetype0#
+ *
+ * CGX CMR Receive VLAN Ethertype1 Register These registers, along with
+ * CGX()_CMR_RX_STEERING0(), provide eight filters for identifying and
+ * steering X2P/NIX receive traffic.
+ */
+union cavm_cgxx_cmr_rx_steering_vetype0x {
+	u64 u;
+	struct cavm_cgxx_cmr_rx_steering_vetype0x_s {
+		u64 vlan_etype                       : 16;
+		u64 vlan_tag_en                      : 1;
+		u64 vlan_id                          : 12;
+		u64 vlan_en                          : 1;
+		u64 reserved_30_63                   : 34;
+	} s;
+	/* struct cavm_cgxx_cmr_rx_steering_vetype0x_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMR_RX_STEERING_VETYPE0X(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMR_RX_STEERING_VETYPE0X(u64 a)
+{
+	return 0x380 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_rx_steering_vetype1#
+ *
+ * CGX CMR Receive VLAN Ethertype1 Register For use with the lmac_id
+ * associated with NCSI. See CGX()_CMR_GLOBAL_CONFIG[NCSI_LMAC_ID]. These
+ * registers, along with CGX()_CMR_RX_STEERING1(), provide eight filters
+ * for identifying and steering NCSI receive traffic.
+ */
+union cavm_cgxx_cmr_rx_steering_vetype1x {
+	u64 u;
+	struct cavm_cgxx_cmr_rx_steering_vetype1x_s {
+		u64 vlan_etype                       : 16;
+		u64 vlan_tag_en                      : 1;
+		u64 vlan_id                          : 12;
+		u64 vlan_en                          : 1;
+		u64 reserved_30_63                   : 34;
+	} s;
+	/* struct cavm_cgxx_cmr_rx_steering_vetype1x_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMR_RX_STEERING_VETYPE1X(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMR_RX_STEERING_VETYPE1X(u64 a)
+{
+	return 0x580 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_tx_lmacs
+ *
+ * CGX CMR Transmit Logical MACs Registers This register sets the number
+ * of LMACs allowed on the TX interface. The value is important for
+ * defining the partitioning of the transmit FIFO.
+ */
+union cavm_cgxx_cmr_tx_lmacs {
+	u64 u;
+	struct cavm_cgxx_cmr_tx_lmacs_s {
+		u64 lmacs                            : 3;
+		u64 reserved_3_63                    : 61;
+	} s;
+	/* struct cavm_cgxx_cmr_tx_lmacs_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMR_TX_LMACS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMR_TX_LMACS(void)
+{
+	return 0x1000;
+}
+
+/**
+ * Register (RSL) cgx#_cmr_x2p#_count
+ *
+ * CGX X2P Activity Register
+ */
+union cavm_cgxx_cmr_x2px_count {
+	u64 u;
+	struct cavm_cgxx_cmr_x2px_count_s {
+		u64 x2p_cnt                          : 64;
+	} s;
+	/* struct cavm_cgxx_cmr_x2px_count_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CMR_X2PX_COUNT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CMR_X2PX_COUNT(u64 a)
+{
+	return 0x170 + 0x1000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_const
+ *
+ * CGX CONST Registers This register contains constants for software
+ * discovery.
+ */
+union cavm_cgxx_const {
+	u64 u;
+	struct cavm_cgxx_const_s {
+		u64 tx_fifosz                        : 24;
+		u64 lmacs                            : 8;
+		u64 rx_fifosz                        : 24;
+		u64 reserved_56_63                   : 8;
+	} s;
+	/* struct cavm_cgxx_const_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CONST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CONST(void)
+{
+	return 0x2000;
+}
+
+/**
+ * Register (RSL) cgx#_const1
+ *
+ * CGX CONST1 Registers This register contains constants for software
+ * discovery.
+ */
+union cavm_cgxx_const1 {
+	u64 u;
+	struct cavm_cgxx_const1_s {
+		u64 types                            : 11;
+		u64 res_types                        : 21;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cavm_cgxx_const1_s cn; */
+};
+
+static inline u64 CAVM_CGXX_CONST1(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_CONST1(void)
+{
+	return 0x2008;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi#_rx_wol_ctrl0
+ *
+ * CGX GMP GMI RX Wake-on-LAN Control 0 Registers
+ */
+union cavm_cgxx_gmp_gmix_rx_wol_ctrl0 {
+	u64 u;
+	struct cavm_cgxx_gmp_gmix_rx_wol_ctrl0_s {
+		u64 dmac                             : 48;
+		u64 pswd_len                         : 4;
+		u64 reserved_52_63                   : 12;
+	} s;
+	/* struct cavm_cgxx_gmp_gmix_rx_wol_ctrl0_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMIX_RX_WOL_CTRL0(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMIX_RX_WOL_CTRL0(u64 a)
+{
+	return 0x38a00 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi#_rx_wol_ctrl1
+ *
+ * CGX GMP GMI RX Wake-on-LAN Control 1 Registers
+ */
+union cavm_cgxx_gmp_gmix_rx_wol_ctrl1 {
+	u64 u;
+	struct cavm_cgxx_gmp_gmix_rx_wol_ctrl1_s {
+		u64 pswd                             : 64;
+	} s;
+	/* struct cavm_cgxx_gmp_gmix_rx_wol_ctrl1_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMIX_RX_WOL_CTRL1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMIX_RX_WOL_CTRL1(u64 a)
+{
+	return 0x38a08 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi#_tx_eee
+ *
+ * INTERNAL: CGX GMP GMI TX EEE Configure Registers  Reserved. Internal:
+ * These registers control when GMP GMI TX requests to enter or exist
+ * LPI. Those registers take effect only when EEE is supported and
+ * enabled for a given LMAC.
+ */
+union cavm_cgxx_gmp_gmix_tx_eee {
+	u64 u;
+	struct cavm_cgxx_gmp_gmix_tx_eee_s {
+		u64 idle_thresh                      : 28;
+		u64 reserved_28                      : 1;
+		u64 force_lpi                        : 1;
+		u64 wakeup                           : 1;
+		u64 auto_lpi                         : 1;
+		u64 idle_cnt                         : 28;
+		u64 tx_lpi                           : 1;
+		u64 tx_lpi_wait                      : 1;
+		u64 sync_status_lpi_enable           : 1;
+		u64 reserved_63                      : 1;
+	} s;
+	/* struct cavm_cgxx_gmp_gmix_tx_eee_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMIX_TX_EEE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMIX_TX_EEE(u64 a)
+{
+	return 0x38800 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi#_tx_eee_cfg1
+ *
+ * INTERNAL: CGX GMP GMI TX EEE Configure More Configuration Registers
+ * Reserved. Internal: Controls the GMP exiting of LPI and starting to
+ * send data.
+ */
+union cavm_cgxx_gmp_gmix_tx_eee_cfg1 {
+	u64 u;
+	struct cavm_cgxx_gmp_gmix_tx_eee_cfg1_s {
+		u64 wake2data_time                   : 24;
+		u64 reserved_24_35                   : 12;
+		u64 tx_eee_enable                    : 1;
+		u64 reserved_37_39                   : 3;
+		u64 sync2lpi_time                    : 21;
+		u64 reserved_61_63                   : 3;
+	} s;
+	struct cavm_cgxx_gmp_gmix_tx_eee_cfg1_cn {
+		u64 wake2data_time                   : 24;
+		u64 reserved_24_31                   : 8;
+		u64 reserved_32_35                   : 4;
+		u64 tx_eee_enable                    : 1;
+		u64 reserved_37_39                   : 3;
+		u64 sync2lpi_time                    : 21;
+		u64 reserved_61_63                   : 3;
+	} cn;
+};
+
+static inline u64 CAVM_CGXX_GMP_GMIX_TX_EEE_CFG1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMIX_TX_EEE_CFG1(u64 a)
+{
+	return 0x38808 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi#_wol_int
+ *
+ * CGX GMP GMI RX WOL Interrupt Registers These registers allow WOL
+ * interrupts to be sent to the control processor.
+ */
+union cavm_cgxx_gmp_gmix_wol_int {
+	u64 u;
+	struct cavm_cgxx_gmp_gmix_wol_int_s {
+		u64 wol_rcvd                         : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_cgxx_gmp_gmix_wol_int_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMIX_WOL_INT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMIX_WOL_INT(u64 a)
+{
+	return 0x38a80 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi#_wol_int_ena_w1c
+ *
+ * CGX GMP GMI RX WOL Interrupt Enable Clear Registers This register
+ * clears interrupt enable bits.
+ */
+union cavm_cgxx_gmp_gmix_wol_int_ena_w1c {
+	u64 u;
+	struct cavm_cgxx_gmp_gmix_wol_int_ena_w1c_s {
+		u64 wol_rcvd                         : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_cgxx_gmp_gmix_wol_int_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMIX_WOL_INT_ENA_W1C(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMIX_WOL_INT_ENA_W1C(u64 a)
+{
+	return 0x38a90 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi#_wol_int_ena_w1s
+ *
+ * CGX GMP GMI RX WOL Interrupt Enable Set Registers This register sets
+ * interrupt enable bits.
+ */
+union cavm_cgxx_gmp_gmix_wol_int_ena_w1s {
+	u64 u;
+	struct cavm_cgxx_gmp_gmix_wol_int_ena_w1s_s {
+		u64 wol_rcvd                         : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_cgxx_gmp_gmix_wol_int_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMIX_WOL_INT_ENA_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMIX_WOL_INT_ENA_W1S(u64 a)
+{
+	return 0x38a98 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi#_wol_int_w1s
+ *
+ * CGX GMP GMI RX WOL Interrupt Set Registers This register sets
+ * interrupt bits.
+ */
+union cavm_cgxx_gmp_gmix_wol_int_w1s {
+	u64 u;
+	struct cavm_cgxx_gmp_gmix_wol_int_w1s_s {
+		u64 wol_rcvd                         : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_cgxx_gmp_gmix_wol_int_w1s_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMIX_WOL_INT_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMIX_WOL_INT_W1S(u64 a)
+{
+	return 0x38a88 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_prt#_cfg
+ *
+ * CGX GMP GMI LMAC Configuration Registers This register controls the
+ * configuration of the LMAC.
+ */
+union cavm_cgxx_gmp_gmi_prtx_cfg {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_prtx_cfg_s {
+		u64 reserved_0                       : 1;
+		u64 speed                            : 1;
+		u64 duplex                           : 1;
+		u64 slottime                         : 1;
+		u64 reserved_4_7                     : 4;
+		u64 speed_msb                        : 1;
+		u64 reserved_9_11                    : 3;
+		u64 rx_idle                          : 1;
+		u64 tx_idle                          : 1;
+		u64 reserved_14_63                   : 50;
+	} s;
+	/* struct cavm_cgxx_gmp_gmi_prtx_cfg_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_PRTX_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_PRTX_CFG(u64 a)
+{
+	return 0x38020 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_rx#_decision
+ *
+ * CGX GMP Packet-Decision Registers This register specifies the byte
+ * count used to determine when to accept or to filter a packet. As each
+ * byte in a packet is received by GMI, the L2 byte count is compared
+ * against [CNT]. In normal operation, the L2 header begins after the
+ * PREAMBLE + SFD (CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK] = 1) and any
+ * optional UDD skip data (CGX()_GMP_GMI_RX()_UDD_SKP[LEN]).  Internal:
+ * Notes: As each byte in a packet is received by GMI, the L2 byte count
+ * is compared against the [CNT].  The L2 byte count is the number of
+ * bytes from the beginning of the L2 header (DMAC).  In normal
+ * operation, the L2 header begins after the PREAMBLE+SFD
+ * (CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK]=1) and any optional UDD skip data
+ * (CGX()_GMP_GMI_RX()_UDD_SKP[LEN]). When
+ * CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK] is clear, PREAMBLE+SFD are
+ * prepended to the packet and would require UDD skip length to account
+ * for them.  Full Duplex: _   L2 Size \<  [CNT] - Accept packet. No
+ * filtering is applied. _   L2 Size \>= [CNT] - Apply filter. Accept
+ * packet based on PAUSE packet filter.  Half Duplex: _   L2 Size \<
+ * [CNT] - Drop packet. Packet is unconditionally dropped. _   L2 Size
+ * \>= [CNT] - Accept packet.  where L2_size = MAX(0, total_packet_size -
+ * CGX()_GMP_GMI_RX()_UDD_SKP[LEN] -
+ * ((CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK]==1)*8)).
+ */
+union cavm_cgxx_gmp_gmi_rxx_decision {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_rxx_decision_s {
+		u64 cnt                              : 5;
+		u64 reserved_5_63                    : 59;
+	} s;
+	/* struct cavm_cgxx_gmp_gmi_rxx_decision_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_RXX_DECISION(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_RXX_DECISION(u64 a)
+{
+	return 0x38040 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_rx#_frm_chk
+ *
+ * CGX GMP Frame Check Registers
+ */
+union cavm_cgxx_gmp_gmi_rxx_frm_chk {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_rxx_frm_chk_s {
+		u64 minerr                           : 1;
+		u64 carext                           : 1;
+		u64 reserved_2                       : 1;
+		u64 jabber                           : 1;
+		u64 fcserr                           : 1;
+		u64 reserved_5_6                     : 2;
+		u64 rcverr                           : 1;
+		u64 skperr                           : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct cavm_cgxx_gmp_gmi_rxx_frm_chk_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_RXX_FRM_CHK(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_RXX_FRM_CHK(u64 a)
+{
+	return 0x38030 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_rx#_frm_ctl
+ *
+ * CGX GMP Frame Control Registers This register controls the handling of
+ * the frames. The [CTL_BCK] and [CTL_DRP] bits control how the hardware
+ * handles incoming PAUSE packets. The most common modes of operation: _
+ * [CTL_BCK] = 1, [CTL_DRP] = 1: hardware handles everything. _ [CTL_BCK]
+ * = 0, [CTL_DRP] = 0: software sees all PAUSE frames. _ [CTL_BCK] = 0,
+ * [CTL_DRP] = 1: all PAUSE frames are completely ignored.  These control
+ * bits should be set to [CTL_BCK] = 0, [CTL_DRP] = 0 in half-duplex
+ * mode. Since PAUSE packets only apply to full duplex operation, any
+ * PAUSE packet would constitute an exception which should be handled by
+ * the processing cores. PAUSE packets should not be forwarded.
+ * Internal: Notes: [PRE_STRP]: When [PRE_CHK] is set (indicating that
+ * the PREAMBLE will be sent), [PRE_STRP] determines if the PREAMBLE+SFD
+ * bytes are thrown away or sent to the Octane core as part of the
+ * packet. In either mode, the PREAMBLE+SFD bytes are not counted toward
+ * the packet size when checking against the MIN and MAX bounds.
+ * Furthermore, the bytes are skipped when locating the start of the L2
+ * header for DMAC and Control frame recognition.
+ */
+union cavm_cgxx_gmp_gmi_rxx_frm_ctl {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_rxx_frm_ctl_s {
+		u64 pre_chk                          : 1;
+		u64 pre_strp                         : 1;
+		u64 ctl_drp                          : 1;
+		u64 ctl_bck                          : 1;
+		u64 ctl_mcst                         : 1;
+		u64 ctl_smac                         : 1;
+		u64 pre_free                         : 1;
+		u64 reserved_7_8                     : 2;
+		u64 pre_align                        : 1;
+		u64 null_dis                         : 1;
+		u64 reserved_11                      : 1;
+		u64 ptp_mode                         : 1;
+		u64 rx_fc_type                       : 1;
+		u64 reserved_14_63                   : 50;
+	} s;
+	struct cavm_cgxx_gmp_gmi_rxx_frm_ctl_cn {
+		u64 pre_chk                          : 1;
+		u64 pre_strp                         : 1;
+		u64 ctl_drp                          : 1;
+		u64 ctl_bck                          : 1;
+		u64 ctl_mcst                         : 1;
+		u64 ctl_smac                         : 1;
+		u64 pre_free                         : 1;
+		u64 reserved_7                       : 1;
+		u64 reserved_8                       : 1;
+		u64 pre_align                        : 1;
+		u64 null_dis                         : 1;
+		u64 reserved_11                      : 1;
+		u64 ptp_mode                         : 1;
+		u64 rx_fc_type                       : 1;
+		u64 reserved_14_63                   : 50;
+	} cn;
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_RXX_FRM_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_RXX_FRM_CTL(u64 a)
+{
+	return 0x38028 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_rx#_ifg
+ *
+ * CGX GMI Minimum Interframe-Gap Cycles Registers This register
+ * specifies the minimum number of interframe-gap (IFG) cycles between
+ * packets.
+ */
+union cavm_cgxx_gmp_gmi_rxx_ifg {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_rxx_ifg_s {
+		u64 ifg                              : 4;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cavm_cgxx_gmp_gmi_rxx_ifg_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_RXX_IFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_RXX_IFG(u64 a)
+{
+	return 0x38058 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_rx#_int
+ *
+ * CGX GMP GMI RX Interrupt Registers These registers allow interrupts to
+ * be sent to the control processor. * Exception conditions \<10:0\> can
+ * also set the rcv/opcode in the received packet's work-queue entry.
+ * CGX()_GMP_GMI_RX()_FRM_CHK provides a bit mask for configuring which
+ * conditions set the error. In half duplex operation, the expectation is
+ * that collisions will appear as either MINERR or CAREXT errors.
+ * Internal: Notes: (1) exception conditions 10:0 can also set the
+ * rcv/opcode in the received packet's workQ entry.  The
+ * CGX()_GMP_GMI_RX()_FRM_CHK register provides a bit mask for
+ * configuring which conditions set the error.  (2) in half duplex
+ * operation, the expectation is that collisions will appear as either
+ * MINERR o r CAREXT errors.  (3) JABBER An RX jabber error indicates
+ * that a packet was received which is longer than the maximum allowed
+ * packet as defined by the system.  GMI will truncate the packet at the
+ * JABBER count. Failure to do so could lead to system instabilty.  (4)
+ * NIBERR This error is illegal at 1000Mbs speeds
+ * (CGX()_GMP_GMI_PRT()_CFG[SPEED]==0) and will never assert.  (5) MINERR
+ * total frame DA+SA+TL+DATA+PAD+FCS \< 64  (6) ALNERR Indicates that the
+ * packet received was not an integer number of bytes.  If FCS checking
+ * is enabled, ALNERR will only assert if the FCS is bad.  If FCS
+ * checking is disabled, ALNERR will assert in all non-integer frame
+ * cases.  (7) Collisions Collisions can only occur in half-duplex mode.
+ * A collision is assumed by the receiver when the slottime
+ * (CGX()_GMP_GMI_PRT()_CFG[SLOTTIME]) is not satisfied.  In 10/100 mode,
+ * this will result in a frame \< SLOTTIME.  In 1000 mode, it could
+ * result either in frame \< SLOTTIME or a carrier extend error with the
+ * SLOTTIME.  These conditions are visible by... . transfer ended before
+ * slottime COLDET . carrier extend error           CAREXT  (A) LENERR
+ * Length errors occur when the received packet does not match the length
+ * field.  LENERR is only checked for packets between 64 and 1500 bytes.
+ * For untagged frames, the length must exact match.  For tagged frames
+ * the length or length+4 must match.  (B) PCTERR checks that the frame
+ * begins with a valid PREAMBLE sequence. Does not check the number of
+ * PREAMBLE cycles.  (C) OVRERR *DON'T PUT IN HRM* OVRERR is an
+ * architectural assertion check internal to GMI to make sure no
+ * assumption was violated.  In a correctly operating system, this
+ * interrupt can never fire. GMI has an internal arbiter which selects
+ * which of four ports to buffer in the main RX FIFO.  If we normally
+ * buffer eight bytes, then each port will typically push a tick every
+ * eight cycles if the packet interface is going as fast as possible.  If
+ * there are four ports, they push every two cycles.  So that's the
+ * assumption.  That the inbound module will always be able to consume
+ * the tick before another is produced.  If that doesn't happen that's
+ * when OVRERR will assert."
+ */
+union cavm_cgxx_gmp_gmi_rxx_int {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_rxx_int_s {
+		u64 minerr                           : 1;
+		u64 carext                           : 1;
+		u64 jabber                           : 1;
+		u64 fcserr                           : 1;
+		u64 rcverr                           : 1;
+		u64 skperr                           : 1;
+		u64 ovrerr                           : 1;
+		u64 pcterr                           : 1;
+		u64 rsverr                           : 1;
+		u64 falerr                           : 1;
+		u64 coldet                           : 1;
+		u64 ifgerr                           : 1;
+		u64 reserved_12_63                   : 52;
+	} s;
+	struct cavm_cgxx_gmp_gmi_rxx_int_cn {
+		u64 minerr                           : 1;
+		u64 carext                           : 1;
+		u64 jabber                           : 1;
+		u64 fcserr                           : 1;
+		u64 rcverr                           : 1;
+		u64 skperr                           : 1;
+		u64 ovrerr                           : 1;
+		u64 pcterr                           : 1;
+		u64 rsverr                           : 1;
+		u64 falerr                           : 1;
+		u64 coldet                           : 1;
+		u64 ifgerr                           : 1;
+		u64 reserved_12_15                   : 4;
+		u64 reserved_16_63                   : 48;
+	} cn;
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_RXX_INT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_RXX_INT(u64 a)
+{
+	return 0x38000 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_rx#_int_ena_w1c
+ *
+ * CGX GMP GMI RX Interrupt Enable Clear Registers This register clears
+ * interrupt enable bits.
+ */
+union cavm_cgxx_gmp_gmi_rxx_int_ena_w1c {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_rxx_int_ena_w1c_s {
+		u64 minerr                           : 1;
+		u64 carext                           : 1;
+		u64 jabber                           : 1;
+		u64 fcserr                           : 1;
+		u64 rcverr                           : 1;
+		u64 skperr                           : 1;
+		u64 ovrerr                           : 1;
+		u64 pcterr                           : 1;
+		u64 rsverr                           : 1;
+		u64 falerr                           : 1;
+		u64 coldet                           : 1;
+		u64 ifgerr                           : 1;
+		u64 reserved_12_63                   : 52;
+	} s;
+	struct cavm_cgxx_gmp_gmi_rxx_int_ena_w1c_cn {
+		u64 minerr                           : 1;
+		u64 carext                           : 1;
+		u64 jabber                           : 1;
+		u64 fcserr                           : 1;
+		u64 rcverr                           : 1;
+		u64 skperr                           : 1;
+		u64 ovrerr                           : 1;
+		u64 pcterr                           : 1;
+		u64 rsverr                           : 1;
+		u64 falerr                           : 1;
+		u64 coldet                           : 1;
+		u64 ifgerr                           : 1;
+		u64 reserved_12_15                   : 4;
+		u64 reserved_16_63                   : 48;
+	} cn;
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_RXX_INT_ENA_W1C(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_RXX_INT_ENA_W1C(u64 a)
+{
+	return 0x38010 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_rx#_int_ena_w1s
+ *
+ * CGX GMP GMI RX Interrupt Enable Set Registers This register sets
+ * interrupt enable bits.
+ */
+union cavm_cgxx_gmp_gmi_rxx_int_ena_w1s {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_rxx_int_ena_w1s_s {
+		u64 minerr                           : 1;
+		u64 carext                           : 1;
+		u64 jabber                           : 1;
+		u64 fcserr                           : 1;
+		u64 rcverr                           : 1;
+		u64 skperr                           : 1;
+		u64 ovrerr                           : 1;
+		u64 pcterr                           : 1;
+		u64 rsverr                           : 1;
+		u64 falerr                           : 1;
+		u64 coldet                           : 1;
+		u64 ifgerr                           : 1;
+		u64 reserved_12_63                   : 52;
+	} s;
+	struct cavm_cgxx_gmp_gmi_rxx_int_ena_w1s_cn {
+		u64 minerr                           : 1;
+		u64 carext                           : 1;
+		u64 jabber                           : 1;
+		u64 fcserr                           : 1;
+		u64 rcverr                           : 1;
+		u64 skperr                           : 1;
+		u64 ovrerr                           : 1;
+		u64 pcterr                           : 1;
+		u64 rsverr                           : 1;
+		u64 falerr                           : 1;
+		u64 coldet                           : 1;
+		u64 ifgerr                           : 1;
+		u64 reserved_12_15                   : 4;
+		u64 reserved_16_63                   : 48;
+	} cn;
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_RXX_INT_ENA_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_RXX_INT_ENA_W1S(u64 a)
+{
+	return 0x38018 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_rx#_int_w1s
+ *
+ * CGX GMP GMI RX Interrupt Set Registers This register sets interrupt
+ * bits.
+ */
+union cavm_cgxx_gmp_gmi_rxx_int_w1s {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_rxx_int_w1s_s {
+		u64 minerr                           : 1;
+		u64 carext                           : 1;
+		u64 jabber                           : 1;
+		u64 fcserr                           : 1;
+		u64 rcverr                           : 1;
+		u64 skperr                           : 1;
+		u64 ovrerr                           : 1;
+		u64 pcterr                           : 1;
+		u64 rsverr                           : 1;
+		u64 falerr                           : 1;
+		u64 coldet                           : 1;
+		u64 ifgerr                           : 1;
+		u64 reserved_12_63                   : 52;
+	} s;
+	struct cavm_cgxx_gmp_gmi_rxx_int_w1s_cn {
+		u64 minerr                           : 1;
+		u64 carext                           : 1;
+		u64 jabber                           : 1;
+		u64 fcserr                           : 1;
+		u64 rcverr                           : 1;
+		u64 skperr                           : 1;
+		u64 ovrerr                           : 1;
+		u64 pcterr                           : 1;
+		u64 rsverr                           : 1;
+		u64 falerr                           : 1;
+		u64 coldet                           : 1;
+		u64 ifgerr                           : 1;
+		u64 reserved_12_15                   : 4;
+		u64 reserved_16_63                   : 48;
+	} cn;
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_RXX_INT_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_RXX_INT_W1S(u64 a)
+{
+	return 0x38008 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_rx#_jabber
+ *
+ * CGX GMP Maximum Packet-Size Registers This register specifies the
+ * maximum size for packets, beyond which the GMI truncates.
+ */
+union cavm_cgxx_gmp_gmi_rxx_jabber {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_rxx_jabber_s {
+		u64 cnt                              : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_gmp_gmi_rxx_jabber_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_RXX_JABBER(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_RXX_JABBER(u64 a)
+{
+	return 0x38038 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_rx#_udd_skp
+ *
+ * CGX GMP GMI User-Defined Data Skip Registers This register specifies
+ * the amount of user-defined data (UDD) added before the start of the
+ * L2C data.  Internal: Notes: (1) The skip bytes are part of the packet
+ * and will be handled by NIX.  (2) The system can determine if the UDD
+ * bytes are included in the FCS check by using the FCSSEL field - if the
+ * FCS check is enabled.  (3) Assume that the preamble/sfd is always at
+ * the start of the frame - even before UDD bytes.  In most cases, there
+ * will be no preamble in these cases since it will be packet interface
+ * in direct communication to another packet interface (MAC to MAC)
+ * without a PHY involved.  (4) We can still do address filtering and
+ * control packet filtering is the user desires.  (5)
+ * CGX()_GMP_GMI_RX()_UDD_SKP[LEN] must be 0 in half-duplex operation
+ * unless CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK] is clear.  If
+ * CGX()_GMP_GMI_RX()_FRM_CTL[PRE_CHK] is clear, then
+ * CGX()_GMP_GMI_RX()_UDD_SKP[LEN] will normally be 8.  (6) In all cases,
+ * the UDD bytes will be sent down the packet interface as part of the
+ * packet.  The UDD bytes are never stripped from the actual packet.
+ */
+union cavm_cgxx_gmp_gmi_rxx_udd_skp {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_rxx_udd_skp_s {
+		u64 len                              : 7;
+		u64 reserved_7                       : 1;
+		u64 fcssel                           : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct cavm_cgxx_gmp_gmi_rxx_udd_skp_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_RXX_UDD_SKP(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_RXX_UDD_SKP(u64 a)
+{
+	return 0x38048 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_smac#
+ *
+ * CGX GMI SMAC Registers
+ */
+union cavm_cgxx_gmp_gmi_smacx {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_smacx_s {
+		u64 smac                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_gmp_gmi_smacx_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_SMACX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_SMACX(u64 a)
+{
+	return 0x38230 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_append
+ *
+ * CGX GMI TX Append Control Registers
+ */
+union cavm_cgxx_gmp_gmi_txx_append {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_txx_append_s {
+		u64 preamble                         : 1;
+		u64 pad                              : 1;
+		u64 fcs                              : 1;
+		u64 force_fcs                        : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cavm_cgxx_gmp_gmi_txx_append_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_APPEND(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_APPEND(u64 a)
+{
+	return 0x38218 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_burst
+ *
+ * CGX GMI TX Burst-Counter Registers
+ */
+union cavm_cgxx_gmp_gmi_txx_burst {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_txx_burst_s {
+		u64 burst                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_gmp_gmi_txx_burst_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_BURST(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_BURST(u64 a)
+{
+	return 0x38228 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_ctl
+ *
+ * CGX GMI Transmit Control Registers
+ */
+union cavm_cgxx_gmp_gmi_txx_ctl {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_txx_ctl_s {
+		u64 xscol_en                         : 1;
+		u64 xsdef_en                         : 1;
+		u64 tx_fc_type                       : 1;
+		u64 link_drain                       : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cavm_cgxx_gmp_gmi_txx_ctl_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_CTL(u64 a)
+{
+	return 0x38270 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_int
+ *
+ * CGX GMI TX Interrupt Registers
+ */
+union cavm_cgxx_gmp_gmi_txx_int {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_txx_int_s {
+		u64 undflw                           : 1;
+		u64 xscol                            : 1;
+		u64 xsdef                            : 1;
+		u64 late_col                         : 1;
+		u64 ptp_lost                         : 1;
+		u64 reserved_5_63                    : 59;
+	} s;
+	struct cavm_cgxx_gmp_gmi_txx_int_cn {
+		u64 undflw                           : 1;
+		u64 xscol                            : 1;
+		u64 xsdef                            : 1;
+		u64 late_col                         : 1;
+		u64 ptp_lost                         : 1;
+		u64 reserved_5_7                     : 3;
+		u64 reserved_8                       : 1;
+		u64 reserved_9_63                    : 55;
+	} cn;
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_INT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_INT(u64 a)
+{
+	return 0x38500 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_int_ena_w1c
+ *
+ * CGX GMI TX Interrupt Enable Clear Registers This register clears
+ * interrupt enable bits.
+ */
+union cavm_cgxx_gmp_gmi_txx_int_ena_w1c {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_txx_int_ena_w1c_s {
+		u64 undflw                           : 1;
+		u64 xscol                            : 1;
+		u64 xsdef                            : 1;
+		u64 late_col                         : 1;
+		u64 ptp_lost                         : 1;
+		u64 reserved_5_63                    : 59;
+	} s;
+	struct cavm_cgxx_gmp_gmi_txx_int_ena_w1c_cn {
+		u64 undflw                           : 1;
+		u64 xscol                            : 1;
+		u64 xsdef                            : 1;
+		u64 late_col                         : 1;
+		u64 ptp_lost                         : 1;
+		u64 reserved_5_7                     : 3;
+		u64 reserved_8                       : 1;
+		u64 reserved_9_63                    : 55;
+	} cn;
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_INT_ENA_W1C(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_INT_ENA_W1C(u64 a)
+{
+	return 0x38510 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_int_ena_w1s
+ *
+ * CGX GMI TX Interrupt Enable Set Registers This register sets interrupt
+ * enable bits.
+ */
+union cavm_cgxx_gmp_gmi_txx_int_ena_w1s {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_txx_int_ena_w1s_s {
+		u64 undflw                           : 1;
+		u64 xscol                            : 1;
+		u64 xsdef                            : 1;
+		u64 late_col                         : 1;
+		u64 ptp_lost                         : 1;
+		u64 reserved_5_63                    : 59;
+	} s;
+	struct cavm_cgxx_gmp_gmi_txx_int_ena_w1s_cn {
+		u64 undflw                           : 1;
+		u64 xscol                            : 1;
+		u64 xsdef                            : 1;
+		u64 late_col                         : 1;
+		u64 ptp_lost                         : 1;
+		u64 reserved_5_7                     : 3;
+		u64 reserved_8                       : 1;
+		u64 reserved_9_63                    : 55;
+	} cn;
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_INT_ENA_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_INT_ENA_W1S(u64 a)
+{
+	return 0x38518 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_int_w1s
+ *
+ * CGX GMI TX Interrupt Set Registers This register sets interrupt bits.
+ */
+union cavm_cgxx_gmp_gmi_txx_int_w1s {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_txx_int_w1s_s {
+		u64 undflw                           : 1;
+		u64 xscol                            : 1;
+		u64 xsdef                            : 1;
+		u64 late_col                         : 1;
+		u64 ptp_lost                         : 1;
+		u64 reserved_5_63                    : 59;
+	} s;
+	struct cavm_cgxx_gmp_gmi_txx_int_w1s_cn {
+		u64 undflw                           : 1;
+		u64 xscol                            : 1;
+		u64 xsdef                            : 1;
+		u64 late_col                         : 1;
+		u64 ptp_lost                         : 1;
+		u64 reserved_5_7                     : 3;
+		u64 reserved_8                       : 1;
+		u64 reserved_9_63                    : 55;
+	} cn;
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_INT_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_INT_W1S(u64 a)
+{
+	return 0x38508 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_min_pkt
+ *
+ * CGX GMI TX Minimum-Size-Packet Registers
+ */
+union cavm_cgxx_gmp_gmi_txx_min_pkt {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_txx_min_pkt_s {
+		u64 min_size                         : 8;
+		u64 reserved_8_63                    : 56;
+	} s;
+	/* struct cavm_cgxx_gmp_gmi_txx_min_pkt_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_MIN_PKT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_MIN_PKT(u64 a)
+{
+	return 0x38240 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_pause_pkt_interval
+ *
+ * CGX GMI TX PAUSE-Packet Transmission-Interval Registers This register
+ * specifies how often PAUSE packets are sent. Internal: Notes: Choosing
+ * proper values of CGX()_GMP_GMI_TX()_PAUSE_PKT_TIME[PTIME] and
+ * CGX()_GMP_GMI_TX()_PAUSE_PKT_INTERVAL[INTERVAL] can be challenging to
+ * the system designer.  It is suggested that TIME be much greater than
+ * INTERVAL and CGX()_GMP_GMI_TX()_PAUSE_ZERO[SEND] be set.  This allows
+ * a periodic refresh of the PAUSE count and then when the backpressure
+ * condition is lifted, a PAUSE packet with TIME==0 will be sent
+ * indicating that Octane is ready for additional data.  If the system
+ * chooses to not set CGX()_GMP_GMI_TX()_PAUSE_ZERO[SEND], then it is
+ * suggested that TIME and INTERVAL are programmed such that they
+ * satisify the following rule:  _ INTERVAL \<= TIME - (largest_pkt_size
+ * + IFG + pause_pkt_size)  where largest_pkt_size is that largest packet
+ * that the system can send (normally 1518B), IFG is the interframe gap
+ * and pause_pkt_size is the size of the PAUSE packet (normally 64B).
+ */
+union cavm_cgxx_gmp_gmi_txx_pause_pkt_interval {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_txx_pause_pkt_interval_s {
+		u64 interval                         : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_gmp_gmi_txx_pause_pkt_interval_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_PAUSE_PKT_INTERVAL(u64 a)
+{
+	return 0x38248 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_pause_pkt_time
+ *
+ * CGX GMI TX PAUSE Packet PAUSE-Time Registers
+ */
+union cavm_cgxx_gmp_gmi_txx_pause_pkt_time {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_txx_pause_pkt_time_s {
+		u64 ptime                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_gmp_gmi_txx_pause_pkt_time_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_PAUSE_PKT_TIME(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_PAUSE_PKT_TIME(u64 a)
+{
+	return 0x38238 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_pause_togo
+ *
+ * CGX GMI TX Time-to-Backpressure Registers
+ */
+union cavm_cgxx_gmp_gmi_txx_pause_togo {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_txx_pause_togo_s {
+		u64 ptime                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_gmp_gmi_txx_pause_togo_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_PAUSE_TOGO(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_PAUSE_TOGO(u64 a)
+{
+	return 0x38258 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_pause_zero
+ *
+ * CGX GMI TX PAUSE-Zero-Enable Registers
+ */
+union cavm_cgxx_gmp_gmi_txx_pause_zero {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_txx_pause_zero_s {
+		u64 send                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_cgxx_gmp_gmi_txx_pause_zero_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_PAUSE_ZERO(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_PAUSE_ZERO(u64 a)
+{
+	return 0x38260 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_sgmii_ctl
+ *
+ * CGX SGMII Control Registers
+ */
+union cavm_cgxx_gmp_gmi_txx_sgmii_ctl {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_txx_sgmii_ctl_s {
+		u64 align                            : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_cgxx_gmp_gmi_txx_sgmii_ctl_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_SGMII_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_SGMII_CTL(u64 a)
+{
+	return 0x38300 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_slot
+ *
+ * CGX GMI TX Slottime Counter Registers
+ */
+union cavm_cgxx_gmp_gmi_txx_slot {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_txx_slot_s {
+		u64 slot                             : 10;
+		u64 reserved_10_63                   : 54;
+	} s;
+	/* struct cavm_cgxx_gmp_gmi_txx_slot_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_SLOT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_SLOT(u64 a)
+{
+	return 0x38220 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_soft_pause
+ *
+ * CGX GMI TX Software PAUSE Registers
+ */
+union cavm_cgxx_gmp_gmi_txx_soft_pause {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_txx_soft_pause_s {
+		u64 ptime                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_gmp_gmi_txx_soft_pause_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_SOFT_PAUSE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_SOFT_PAUSE(u64 a)
+{
+	return 0x38250 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx#_thresh
+ *
+ * CGX GMI TX Threshold Registers
+ */
+union cavm_cgxx_gmp_gmi_txx_thresh {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_txx_thresh_s {
+		u64 cnt                              : 11;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct cavm_cgxx_gmp_gmi_txx_thresh_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_THRESH(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_TXX_THRESH(u64 a)
+{
+	return 0x38210 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx_col_attempt
+ *
+ * CGX TX Collision Attempts Before Dropping Frame Registers
+ */
+union cavm_cgxx_gmp_gmi_tx_col_attempt {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_tx_col_attempt_s {
+		u64 limit                            : 5;
+		u64 reserved_5_63                    : 59;
+	} s;
+	/* struct cavm_cgxx_gmp_gmi_tx_col_attempt_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_TX_COL_ATTEMPT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_TX_COL_ATTEMPT(void)
+{
+	return 0x39010;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx_ifg
+ *
+ * CGX GMI TX Interframe-Gap Cycles Registers Consider the following when
+ * programming IFG1 and IFG2: * For 10/100/1000 Mb/s half-duplex systems
+ * that require IEEE 802.3 compatibility, IFG1 must be in the range of
+ * 1-8, [IFG2] must be in the range of 4-12, and the [IFG1] + [IFG2] sum
+ * must be 12. * For 10/100/1000 Mb/s full-duplex systems that require
+ * IEEE 802.3 compatibility, IFG1 must be in the range of 1-11, [IFG2]
+ * must be in the range of 1-11, and the [IFG1] + [IFG2] sum must be 12.
+ * For all other systems, IFG1 and IFG2 can be any value in the range of
+ * 1-15, allowing for a total possible IFG sum of 2-30.
+ */
+union cavm_cgxx_gmp_gmi_tx_ifg {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_tx_ifg_s {
+		u64 ifg1                             : 4;
+		u64 ifg2                             : 4;
+		u64 reserved_8_63                    : 56;
+	} s;
+	/* struct cavm_cgxx_gmp_gmi_tx_ifg_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_TX_IFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_TX_IFG(void)
+{
+	return 0x39000;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx_jam
+ *
+ * CGX GMI TX JAM Pattern Registers This register provides the pattern
+ * used in JAM bytes.
+ */
+union cavm_cgxx_gmp_gmi_tx_jam {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_tx_jam_s {
+		u64 jam                              : 8;
+		u64 reserved_8_63                    : 56;
+	} s;
+	/* struct cavm_cgxx_gmp_gmi_tx_jam_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_TX_JAM(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_TX_JAM(void)
+{
+	return 0x39008;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx_lfsr
+ *
+ * CGX GMI TX LFSR Registers This register shows the contents of the
+ * linear feedback shift register (LFSR), which is used to implement
+ * truncated binary exponential backoff.
+ */
+union cavm_cgxx_gmp_gmi_tx_lfsr {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_tx_lfsr_s {
+		u64 lfsr                             : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_gmp_gmi_tx_lfsr_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_TX_LFSR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_TX_LFSR(void)
+{
+	return 0x39028;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx_pause_pkt_dmac
+ *
+ * CGX TX PAUSE-Packet DMAC-Field Registers
+ */
+union cavm_cgxx_gmp_gmi_tx_pause_pkt_dmac {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_tx_pause_pkt_dmac_s {
+		u64 dmac                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_gmp_gmi_tx_pause_pkt_dmac_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_TX_PAUSE_PKT_DMAC(void)
+{
+	return 0x39018;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_gmi_tx_pause_pkt_type
+ *
+ * CGX GMI TX PAUSE-Packet-PTYPE Field Registers This register provides
+ * the PTYPE field that is placed in outbound PAUSE packets.
+ */
+union cavm_cgxx_gmp_gmi_tx_pause_pkt_type {
+	u64 u;
+	struct cavm_cgxx_gmp_gmi_tx_pause_pkt_type_s {
+		u64 ptype                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_gmp_gmi_tx_pause_pkt_type_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_GMI_TX_PAUSE_PKT_TYPE(void)
+{
+	return 0x39020;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_misc#_cfg
+ *
+ * CGX GMP PCS Miscellaneous Control Registers This register contains
+ * general configuration that should not need to be changed from reset
+ * settings.  Internal: Per lmac diagnostic and chicken bits.
+ */
+union cavm_cgxx_gmp_miscx_cfg {
+	u64 u;
+	struct cavm_cgxx_gmp_miscx_cfg_s {
+		u64 tx_eee_quiet_credit_mode         : 1;
+		u64 tx_eee_wait_gmi_fast_idle        : 1;
+		u64 tx_qsgmii_port0_init             : 1;
+		u64 tx_eee_rx_sync_status_enable     : 1;
+		u64 pcs_alt_an                       : 1;
+		u64 reserved_5_7                     : 3;
+		u64 rx_pcs_sync_signal_detect        : 1;
+		u64 rx_pcs_sync_timeout              : 1;
+		u64 rx_pcs_eee_mode_enable           : 1;
+		u64 rx_pcs_lpi_enable                : 1;
+		u64 rx_pcs_802_rx_k                  : 1;
+		u64 rx_pcs_alt_qlb2i                 : 1;
+		u64 reserved_14_15                   : 2;
+		u64 rx_cgp_gser_throttle             : 1;
+		u64 rx_cgp_edet_filter               : 1;
+		u64 rx_cgp_edet_qlm_val              : 1;
+		u64 reserved_19_63                   : 45;
+	} s;
+	/* struct cavm_cgxx_gmp_miscx_cfg_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_MISCX_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_MISCX_CFG(u64 a)
+{
+	return 0x34000 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs#_an_expansion
+ *
+ * CGX GMP PCS AN Expansion register Register 6 AN status
+ */
+union cavm_cgxx_gmp_pcsx_an_expansion {
+	u64 u;
+	struct cavm_cgxx_gmp_pcsx_an_expansion_s {
+		u64 reserved_0                       : 1;
+		u64 page_received                    : 1;
+		u64 next_page_able                   : 1;
+		u64 reserved_3_63                    : 61;
+	} s;
+	/* struct cavm_cgxx_gmp_pcsx_an_expansion_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_PCSX_AN_EXPANSION(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_PCSX_AN_EXPANSION(u64 a)
+{
+	return 0x30a60 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs#_an_lp_abil_np
+ *
+ * CGX GMP PCS AN Link Partner Ability Next Page Register 8 This register
+ * contains the advertised ability of the link partners Next Page. The
+ * definition for this register is provided in 32.5.4.2 for changes to
+ * 28.2.4.1.4.
+ */
+union cavm_cgxx_gmp_pcsx_an_lp_abil_np {
+	u64 u;
+	struct cavm_cgxx_gmp_pcsx_an_lp_abil_np_s {
+		u64 m_u                              : 11;
+		u64 toggle                           : 1;
+		u64 ack2                             : 1;
+		u64 mp                               : 1;
+		u64 ack                              : 1;
+		u64 np                               : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_gmp_pcsx_an_lp_abil_np_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_PCSX_AN_LP_ABIL_NP(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_PCSX_AN_LP_ABIL_NP(u64 a)
+{
+	return 0x30a80 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs#_an_np_tx
+ *
+ * CGX GMP PCS AN Next Page Transmit Register 7 Software programs this
+ * register with the contents of the AN message next page or unformatted
+ * next page link code word to be transmitted during autonegotiation.
+ * Next page exchange occurs after the base link code words have been
+ * exchanged if either end of the link segment sets the NP bit to 1,
+ * indicating that it has at least one next page to send. Once initiated,
+ * next page exchange continues until both ends of the link segment set
+ * their NP bits to 0. Both sides must be NP capable to use NP exchanges.
+ */
+union cavm_cgxx_gmp_pcsx_an_np_tx {
+	u64 u;
+	struct cavm_cgxx_gmp_pcsx_an_np_tx_s {
+		u64 m_u                              : 11;
+		u64 toggle                           : 1;
+		u64 ack2                             : 1;
+		u64 mp                               : 1;
+		u64 ack                              : 1;
+		u64 np                               : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_gmp_pcsx_an_np_tx_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_PCSX_AN_NP_TX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_PCSX_AN_NP_TX(u64 a)
+{
+	return 0x30a70 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs#_dbg_control
+ *
+ * CGX PCS Debug Control Registers
+ */
+union cavm_cgxx_gmp_pcsx_dbg_control {
+	u64 u;
+	struct cavm_cgxx_gmp_pcsx_dbg_control_s {
+		u64 us_clk_period                    : 7;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct cavm_cgxx_gmp_pcsx_dbg_control_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_PCSX_DBG_CONTROL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_PCSX_DBG_CONTROL(u64 a)
+{
+	return 0x31000 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs#_rx_eee_wake
+ *
+ * INTERNAL: CGX GMP PCS  RX EEE Wake Error Counter  Registers  Reserved.
+ * Internal: This register is used by PHY types that support EEE to count
+ * wake time faults where the PHY fails to complete its normal wake
+ * sequence within the time required for the specific PHY type. The
+ * definition of the fault event to be counted is defined for each PHY
+ * and may occur during a refresh or a wake-up as defined by the PHY.
+ * This 16-bit counter shall be reset to all zeros upon execution of the
+ * PCS reset. This counter shall be held at all ones in the case of
+ * overflow.
+ */
+union cavm_cgxx_gmp_pcsx_rx_eee_wake {
+	u64 u;
+	struct cavm_cgxx_gmp_pcsx_rx_eee_wake_s {
+		u64 error_counter                    : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_gmp_pcsx_rx_eee_wake_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_PCSX_RX_EEE_WAKE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_PCSX_RX_EEE_WAKE(u64 a)
+{
+	return 0x30910 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs#_rx_lpi_timing
+ *
+ * INTERNAL: CGX GMP PCS  RX EEE LPI Timing Parameters Registers
+ * Reserved. Internal: Receiver LPI timing parameters Tqr, Twr and Twtf.
+ */
+union cavm_cgxx_gmp_pcsx_rx_lpi_timing {
+	u64 u;
+	struct cavm_cgxx_gmp_pcsx_rx_lpi_timing_s {
+		u64 twtf                             : 18;
+		u64 reserved_18_19                   : 2;
+		u64 twr                              : 12;
+		u64 tqr                              : 20;
+		u64 reserved_52_63                   : 12;
+	} s;
+	/* struct cavm_cgxx_gmp_pcsx_rx_lpi_timing_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_PCSX_RX_LPI_TIMING(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_PCSX_RX_LPI_TIMING(u64 a)
+{
+	return 0x30900 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs#_status1
+ *
+ * CGX GMP PCS Status 1 Register PCS LPI Status, Link OK.  Register 3.1
+ */
+union cavm_cgxx_gmp_pcsx_status1 {
+	u64 u;
+	struct cavm_cgxx_gmp_pcsx_status1_s {
+		u64 reserved_0_1                     : 2;
+		u64 receive_link_status              : 1;
+		u64 reserved_3_7                     : 5;
+		u64 rx_lpi_indication                : 1;
+		u64 tx_lpi_indication                : 1;
+		u64 rx_lpi_received                  : 1;
+		u64 tx_lpi_received                  : 1;
+		u64 reserved_12_63                   : 52;
+	} s;
+	/* struct cavm_cgxx_gmp_pcsx_status1_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_PCSX_STATUS1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_PCSX_STATUS1(u64 a)
+{
+	return 0x30880 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs#_tx_lpi_timing
+ *
+ * INTERNAL: CGX GMP GMI  TX EEE LPI Timing Parameters Registers
+ * Reserved. Internal: Transmitter LPI timing parameters Tsl, Tql and
+ * Tul.
+ */
+union cavm_cgxx_gmp_pcsx_tx_lpi_timing {
+	u64 u;
+	struct cavm_cgxx_gmp_pcsx_tx_lpi_timing_s {
+		u64 tql                              : 19;
+		u64 reserved_19_31                   : 13;
+		u64 tul                              : 12;
+		u64 reserved_44_47                   : 4;
+		u64 tsl                              : 12;
+		u64 reserved_60_63                   : 4;
+	} s;
+	/* struct cavm_cgxx_gmp_pcsx_tx_lpi_timing_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_PCSX_TX_LPI_TIMING(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_PCSX_TX_LPI_TIMING(u64 a)
+{
+	return 0x30800 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_an#_adv
+ *
+ * CGX GMP PCS Autonegotiation Advertisement Registers
+ */
+union cavm_cgxx_gmp_pcs_anx_adv {
+	u64 u;
+	struct cavm_cgxx_gmp_pcs_anx_adv_s {
+		u64 reserved_0_4                     : 5;
+		u64 fd                               : 1;
+		u64 hfd                              : 1;
+		u64 pause                            : 2;
+		u64 reserved_9_11                    : 3;
+		u64 rem_flt                          : 2;
+		u64 reserved_14                      : 1;
+		u64 np                               : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_gmp_pcs_anx_adv_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_PCS_ANX_ADV(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_PCS_ANX_ADV(u64 a)
+{
+	return 0x30010 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_an#_ext_st
+ *
+ * CGX GMO PCS Autonegotiation Extended Status Registers
+ */
+union cavm_cgxx_gmp_pcs_anx_ext_st {
+	u64 u;
+	struct cavm_cgxx_gmp_pcs_anx_ext_st_s {
+		u64 reserved_0_11                    : 12;
+		u64 thou_thd                         : 1;
+		u64 thou_tfd                         : 1;
+		u64 thou_xhd                         : 1;
+		u64 thou_xfd                         : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_gmp_pcs_anx_ext_st_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_PCS_ANX_EXT_ST(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_PCS_ANX_EXT_ST(u64 a)
+{
+	return 0x30028 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_an#_lp_abil
+ *
+ * CGX GMP PCS Autonegotiation Link Partner Ability Registers This is the
+ * autonegotiation link partner ability register 5 as per IEEE 802.3,
+ * Clause 37.
+ */
+union cavm_cgxx_gmp_pcs_anx_lp_abil {
+	u64 u;
+	struct cavm_cgxx_gmp_pcs_anx_lp_abil_s {
+		u64 reserved_0_4                     : 5;
+		u64 fd                               : 1;
+		u64 hfd                              : 1;
+		u64 pause                            : 2;
+		u64 reserved_9_11                    : 3;
+		u64 rem_flt                          : 2;
+		u64 ack                              : 1;
+		u64 np                               : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_gmp_pcs_anx_lp_abil_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_PCS_ANX_LP_ABIL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_PCS_ANX_LP_ABIL(u64 a)
+{
+	return 0x30018 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_an#_results
+ *
+ * CGX GMP PCS Autonegotiation Results Registers This register is not
+ * valid when CGX()_GMP_PCS_MISC()_CTL[AN_OVRD] is set to 1. If
+ * CGX()_GMP_PCS_MISC()_CTL[AN_OVRD] is set to 0 and
+ * CGX()_GMP_PCS_AN()_RESULTS[AN_CPT] is set to 1, this register is
+ * valid.
+ */
+union cavm_cgxx_gmp_pcs_anx_results {
+	u64 u;
+	struct cavm_cgxx_gmp_pcs_anx_results_s {
+		u64 link_ok                          : 1;
+		u64 dup                              : 1;
+		u64 an_cpt                           : 1;
+		u64 spd                              : 2;
+		u64 pause                            : 2;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct cavm_cgxx_gmp_pcs_anx_results_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_PCS_ANX_RESULTS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_PCS_ANX_RESULTS(u64 a)
+{
+	return 0x30020 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_int#
+ *
+ * CGX GMP PCS Interrupt Registers
+ */
+union cavm_cgxx_gmp_pcs_intx {
+	u64 u;
+	struct cavm_cgxx_gmp_pcs_intx_s {
+		u64 lnkspd                           : 1;
+		u64 xmit                             : 1;
+		u64 an_err                           : 1;
+		u64 txfifu                           : 1;
+		u64 txfifo                           : 1;
+		u64 txbad                            : 1;
+		u64 rxerr                            : 1;
+		u64 rxbad                            : 1;
+		u64 rxlock                           : 1;
+		u64 an_bad                           : 1;
+		u64 sync_bad                         : 1;
+		u64 dup                              : 1;
+		u64 dbg_sync                         : 1;
+		u64 reserved_13_15                   : 3;
+		u64 an_page_received                 : 1;
+		u64 an_complete                      : 1;
+		u64 reserved_18_19                   : 2;
+		u64 eee_tx_change                    : 1;
+		u64 eee_rx_change                    : 1;
+		u64 eee_rx_link_fail                 : 1;
+		u64 reserved_23_63                   : 41;
+	} s;
+	/* struct cavm_cgxx_gmp_pcs_intx_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_PCS_INTX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_PCS_INTX(u64 a)
+{
+	return 0x30080 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_int#_ena_w1c
+ *
+ * CGX GMP PCS Interrupt Enable Clear Registers This register clears
+ * interrupt enable bits.
+ */
+union cavm_cgxx_gmp_pcs_intx_ena_w1c {
+	u64 u;
+	struct cavm_cgxx_gmp_pcs_intx_ena_w1c_s {
+		u64 lnkspd                           : 1;
+		u64 xmit                             : 1;
+		u64 an_err                           : 1;
+		u64 txfifu                           : 1;
+		u64 txfifo                           : 1;
+		u64 txbad                            : 1;
+		u64 rxerr                            : 1;
+		u64 rxbad                            : 1;
+		u64 rxlock                           : 1;
+		u64 an_bad                           : 1;
+		u64 sync_bad                         : 1;
+		u64 dup                              : 1;
+		u64 dbg_sync                         : 1;
+		u64 reserved_13_15                   : 3;
+		u64 an_page_received                 : 1;
+		u64 an_complete                      : 1;
+		u64 reserved_18_19                   : 2;
+		u64 eee_tx_change                    : 1;
+		u64 eee_rx_change                    : 1;
+		u64 eee_rx_link_fail                 : 1;
+		u64 reserved_23_63                   : 41;
+	} s;
+	/* struct cavm_cgxx_gmp_pcs_intx_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_PCS_INTX_ENA_W1C(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_PCS_INTX_ENA_W1C(u64 a)
+{
+	return 0x30090 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_int#_ena_w1s
+ *
+ * CGX GMP PCS Interrupt Enable Set Registers This register sets
+ * interrupt enable bits.
+ */
+union cavm_cgxx_gmp_pcs_intx_ena_w1s {
+	u64 u;
+	struct cavm_cgxx_gmp_pcs_intx_ena_w1s_s {
+		u64 lnkspd                           : 1;
+		u64 xmit                             : 1;
+		u64 an_err                           : 1;
+		u64 txfifu                           : 1;
+		u64 txfifo                           : 1;
+		u64 txbad                            : 1;
+		u64 rxerr                            : 1;
+		u64 rxbad                            : 1;
+		u64 rxlock                           : 1;
+		u64 an_bad                           : 1;
+		u64 sync_bad                         : 1;
+		u64 dup                              : 1;
+		u64 dbg_sync                         : 1;
+		u64 reserved_13_15                   : 3;
+		u64 an_page_received                 : 1;
+		u64 an_complete                      : 1;
+		u64 reserved_18_19                   : 2;
+		u64 eee_tx_change                    : 1;
+		u64 eee_rx_change                    : 1;
+		u64 eee_rx_link_fail                 : 1;
+		u64 reserved_23_63                   : 41;
+	} s;
+	/* struct cavm_cgxx_gmp_pcs_intx_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_PCS_INTX_ENA_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_PCS_INTX_ENA_W1S(u64 a)
+{
+	return 0x30098 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_int#_w1s
+ *
+ * CGX GMP PCS Interrupt Set Registers This register sets interrupt bits.
+ */
+union cavm_cgxx_gmp_pcs_intx_w1s {
+	u64 u;
+	struct cavm_cgxx_gmp_pcs_intx_w1s_s {
+		u64 lnkspd                           : 1;
+		u64 xmit                             : 1;
+		u64 an_err                           : 1;
+		u64 txfifu                           : 1;
+		u64 txfifo                           : 1;
+		u64 txbad                            : 1;
+		u64 rxerr                            : 1;
+		u64 rxbad                            : 1;
+		u64 rxlock                           : 1;
+		u64 an_bad                           : 1;
+		u64 sync_bad                         : 1;
+		u64 dup                              : 1;
+		u64 dbg_sync                         : 1;
+		u64 reserved_13_15                   : 3;
+		u64 an_page_received                 : 1;
+		u64 an_complete                      : 1;
+		u64 reserved_18_19                   : 2;
+		u64 eee_tx_change                    : 1;
+		u64 eee_rx_change                    : 1;
+		u64 eee_rx_link_fail                 : 1;
+		u64 reserved_23_63                   : 41;
+	} s;
+	/* struct cavm_cgxx_gmp_pcs_intx_w1s_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_PCS_INTX_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_PCS_INTX_W1S(u64 a)
+{
+	return 0x30088 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_link#_timer
+ *
+ * CGX GMP PCS Link Timer Registers This is the 1.6 ms nominal link timer
+ * register.
+ */
+union cavm_cgxx_gmp_pcs_linkx_timer {
+	u64 u;
+	struct cavm_cgxx_gmp_pcs_linkx_timer_s {
+		u64 count                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_gmp_pcs_linkx_timer_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_PCS_LINKX_TIMER(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_PCS_LINKX_TIMER(u64 a)
+{
+	return 0x30040 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_misc#_ctl
+ *
+ * CGX GMP SGMII Miscellaneous Control Registers Internal: SGMII bit [12]
+ * is really a misnomer, it is a decode  of pi_qlm_cfg pins to indicate
+ * SGMII or 1000Base-X modes.  Note: The SGMII AN Advertisement Register
+ * above will be sent during Auto Negotiation if [MAC_PHY] is set (1=PHY
+ * mode). If the bit is not set (0=MAC mode), the tx_Config_Reg\<14\>
+ * becomes ACK bit and tx_Config_Reg\<0\> is always 1. All other bits in
+ * tx_Config_Reg sent will be 0. The PHY dictates the Auto Negotiation
+ * results.
+ */
+union cavm_cgxx_gmp_pcs_miscx_ctl {
+	u64 u;
+	struct cavm_cgxx_gmp_pcs_miscx_ctl_s {
+		u64 samp_pt                          : 7;
+		u64 an_ovrd                          : 1;
+		u64 mode                             : 1;
+		u64 mac_phy                          : 1;
+		u64 loopbck2                         : 1;
+		u64 gmxeno                           : 1;
+		u64 reserved_12                      : 1;
+		u64 disp_en                          : 1;
+		u64 reserved_14_15                   : 2;
+		u64 qsgmii_comma_wd                  : 16;
+		u64 qsgmii_comma_wd_en               : 1;
+		u64 reserved_33_63                   : 31;
+	} s;
+	struct cavm_cgxx_gmp_pcs_miscx_ctl_cn {
+		u64 samp_pt                          : 7;
+		u64 an_ovrd                          : 1;
+		u64 mode                             : 1;
+		u64 mac_phy                          : 1;
+		u64 loopbck2                         : 1;
+		u64 gmxeno                           : 1;
+		u64 reserved_12                      : 1;
+		u64 disp_en                          : 1;
+		u64 reserved_14_15                   : 2;
+		u64 qsgmii_comma_wd                  : 16;
+		u64 qsgmii_comma_wd_en               : 1;
+		u64 reserved_33_35                   : 3;
+		u64 reserved_36_63                   : 28;
+	} cn;
+};
+
+static inline u64 CAVM_CGXX_GMP_PCS_MISCX_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_PCS_MISCX_CTL(u64 a)
+{
+	return 0x30078 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_mr#_control
+ *
+ * CGX GMP PCS Control Registers
+ */
+union cavm_cgxx_gmp_pcs_mrx_control {
+	u64 u;
+	struct cavm_cgxx_gmp_pcs_mrx_control_s {
+		u64 reserved_0_4                     : 5;
+		u64 uni                              : 1;
+		u64 spdmsb                           : 1;
+		u64 coltst                           : 1;
+		u64 dup                              : 1;
+		u64 rst_an                           : 1;
+		u64 reserved_10                      : 1;
+		u64 pwr_dn                           : 1;
+		u64 an_en                            : 1;
+		u64 spdlsb                           : 1;
+		u64 loopbck1                         : 1;
+		u64 reset                            : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_gmp_pcs_mrx_control_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_PCS_MRX_CONTROL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_PCS_MRX_CONTROL(u64 a)
+{
+	return 0x30000 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_mr#_status
+ *
+ * CGX GMP PCS Status Registers Bits \<15:9\> in this register indicate
+ * the ability to operate when CGX()_GMP_PCS_MISC()_CTL[MAC_PHY] is set
+ * to MAC mode. Bits \<15:9\> are always read as 0, indicating that the
+ * chip cannot operate in the corresponding modes. The field [RM_FLT] is
+ * a 'don't care' when the selected mode is SGMII/QSGMII.
+ */
+union cavm_cgxx_gmp_pcs_mrx_status {
+	u64 u;
+	struct cavm_cgxx_gmp_pcs_mrx_status_s {
+		u64 extnd                            : 1;
+		u64 reserved_1                       : 1;
+		u64 lnk_st                           : 1;
+		u64 an_abil                          : 1;
+		u64 rm_flt                           : 1;
+		u64 an_cpt                           : 1;
+		u64 prb_sup                          : 1;
+		u64 reserved_7                       : 1;
+		u64 ext_st                           : 1;
+		u64 hun_t2hd                         : 1;
+		u64 hun_t2fd                         : 1;
+		u64 ten_hd                           : 1;
+		u64 ten_fd                           : 1;
+		u64 hun_xhd                          : 1;
+		u64 hun_xfd                          : 1;
+		u64 hun_t4                           : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_gmp_pcs_mrx_status_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_PCS_MRX_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_PCS_MRX_STATUS(u64 a)
+{
+	return 0x30008 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_rx#_states
+ *
+ * CGX GMP PCS RX State-Machines States Registers
+ */
+union cavm_cgxx_gmp_pcs_rxx_states {
+	u64 u;
+	struct cavm_cgxx_gmp_pcs_rxx_states_s {
+		u64 an_st                            : 4;
+		u64 an_bad                           : 1;
+		u64 sync                             : 4;
+		u64 sync_bad                         : 1;
+		u64 rx_st                            : 5;
+		u64 rx_bad                           : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_gmp_pcs_rxx_states_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_PCS_RXX_STATES(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_PCS_RXX_STATES(u64 a)
+{
+	return 0x30058 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_rx#_sync
+ *
+ * CGX GMP PCS Code Group Synchronization Registers
+ */
+union cavm_cgxx_gmp_pcs_rxx_sync {
+	u64 u;
+	struct cavm_cgxx_gmp_pcs_rxx_sync_s {
+		u64 bit_lock                         : 1;
+		u64 sync                             : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cavm_cgxx_gmp_pcs_rxx_sync_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_PCS_RXX_SYNC(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_PCS_RXX_SYNC(u64 a)
+{
+	return 0x30050 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_sgm#_an_adv
+ *
+ * CGX GMP PCS SGMII Autonegotiation Advertisement Registers This is the
+ * SGMII autonegotiation advertisement register (sent out as
+ * tx_Config_Reg\<15:0\> as defined in IEEE 802.3 clause 37). This
+ * register is sent during autonegotiation if
+ * CGX()_GMP_PCS_MISC()_CTL[MAC_PHY] is set (1 = PHY mode). If the bit is
+ * not set (0 = MAC mode), then tx_Config_Reg\<14\> becomes ACK bit and
+ * tx_Config_Reg\<0\> is always 1. All other bits in tx_Config_Reg sent
+ * will be 0. The PHY dictates the autonegotiation results.
+ */
+union cavm_cgxx_gmp_pcs_sgmx_an_adv {
+	u64 u;
+	struct cavm_cgxx_gmp_pcs_sgmx_an_adv_s {
+		u64 one                              : 1;
+		u64 reserved_1_9                     : 9;
+		u64 speed                            : 2;
+		u64 dup                              : 1;
+		u64 reserved_13                      : 1;
+		u64 ack                              : 1;
+		u64 link                             : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_gmp_pcs_sgmx_an_adv_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_PCS_SGMX_AN_ADV(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_PCS_SGMX_AN_ADV(u64 a)
+{
+	return 0x30068 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_sgm#_lp_adv
+ *
+ * CGX GMP PCS SGMII Link-Partner-Advertisement Registers This is the
+ * SGMII link partner advertisement register (received as
+ * rx_Config_Reg\<15:0\> as defined in IEEE 802.3 clause 37).
+ */
+union cavm_cgxx_gmp_pcs_sgmx_lp_adv {
+	u64 u;
+	struct cavm_cgxx_gmp_pcs_sgmx_lp_adv_s {
+		u64 one                              : 1;
+		u64 reserved_1_9                     : 9;
+		u64 speed                            : 2;
+		u64 dup                              : 1;
+		u64 reserved_13_14                   : 2;
+		u64 link                             : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	struct cavm_cgxx_gmp_pcs_sgmx_lp_adv_cn {
+		u64 one                              : 1;
+		u64 reserved_1_9                     : 9;
+		u64 speed                            : 2;
+		u64 dup                              : 1;
+		u64 reserved_13                      : 1;
+		u64 reserved_14                      : 1;
+		u64 link                             : 1;
+		u64 reserved_16_63                   : 48;
+	} cn;
+};
+
+static inline u64 CAVM_CGXX_GMP_PCS_SGMX_LP_ADV(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_PCS_SGMX_LP_ADV(u64 a)
+{
+	return 0x30070 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_tx#_states
+ *
+ * CGX GMP PCS TX State-Machines States Registers
+ */
+union cavm_cgxx_gmp_pcs_txx_states {
+	u64 u;
+	struct cavm_cgxx_gmp_pcs_txx_states_s {
+		u64 ord_st                           : 4;
+		u64 tx_bad                           : 1;
+		u64 xmit                             : 2;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct cavm_cgxx_gmp_pcs_txx_states_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_PCS_TXX_STATES(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_PCS_TXX_STATES(u64 a)
+{
+	return 0x30060 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_gmp_pcs_tx_rx#_polarity
+ *
+ * CGX GMP PCS TX/RX Polarity Registers
+ * CGX()_GMP_PCS_TX_RX()_POLARITY[AUTORXPL] shows correct polarity needed
+ * on the link receive path after code group synchronization is achieved.
+ * When LMAC_TYPE=QSGMII, only lane 0 polarity data and settings are
+ * relevant and settings for lanes 1, 2 and 3 are unused.
+ */
+union cavm_cgxx_gmp_pcs_tx_rxx_polarity {
+	u64 u;
+	struct cavm_cgxx_gmp_pcs_tx_rxx_polarity_s {
+		u64 txplrt                           : 1;
+		u64 rxplrt                           : 1;
+		u64 autorxpl                         : 1;
+		u64 rxovrd                           : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cavm_cgxx_gmp_pcs_tx_rxx_polarity_s cn; */
+};
+
+static inline u64 CAVM_CGXX_GMP_PCS_TX_RXX_POLARITY(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_GMP_PCS_TX_RXX_POLARITY(u64 a)
+{
+	return 0x30048 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_msix_pba#
+ *
+ * CGX MSI-X Pending Bit Array Registers This register is the MSI-X PBA
+ * table, the bit number is indexed by the CGX_INT_VEC_E enumeration.
+ */
+union cavm_cgxx_msix_pbax {
+	u64 u;
+	struct cavm_cgxx_msix_pbax_s {
+		u64 pend                             : 64;
+	} s;
+	/* struct cavm_cgxx_msix_pbax_s cn; */
+};
+
+static inline u64 CAVM_CGXX_MSIX_PBAX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_MSIX_PBAX(u64 a)
+{
+	return 0xf0000 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_msix_vec#_addr
+ *
+ * CGX MSI-X Vector Table Address Registers This register is the MSI-X
+ * vector table, indexed by the CGX_INT_VEC_E enumeration.
+ */
+union cavm_cgxx_msix_vecx_addr {
+	u64 u;
+	struct cavm_cgxx_msix_vecx_addr_s {
+		u64 secvec                           : 1;
+		u64 reserved_1                       : 1;
+		u64 addr                             : 51;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct cavm_cgxx_msix_vecx_addr_s cn; */
+};
+
+static inline u64 CAVM_CGXX_MSIX_VECX_ADDR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_MSIX_VECX_ADDR(u64 a)
+{
+	return 0 + 0x10 * a;
+}
+
+/**
+ * Register (RSL) cgx#_msix_vec#_ctl
+ *
+ * CGX MSI-X Vector Table Control and Data Registers This register is the
+ * MSI-X vector table, indexed by the CGX_INT_VEC_E enumeration.
+ */
+union cavm_cgxx_msix_vecx_ctl {
+	u64 u;
+	struct cavm_cgxx_msix_vecx_ctl_s {
+		u64 data                             : 32;
+		u64 mask                             : 1;
+		u64 reserved_33_63                   : 31;
+	} s;
+	/* struct cavm_cgxx_msix_vecx_ctl_s cn; */
+};
+
+static inline u64 CAVM_CGXX_MSIX_VECX_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_MSIX_VECX_CTL(u64 a)
+{
+	return 8 + 0x10 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_bp_test
+ *
+ * INTERNAL: CGX SMU TX Backpressure Test Registers
+ */
+union cavm_cgxx_smux_bp_test {
+	u64 u;
+	struct cavm_cgxx_smux_bp_test_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 8;
+		u64 reserved_24_47                   : 24;
+		u64 enable                           : 4;
+		u64 reserved_52_63                   : 12;
+	} s;
+	/* struct cavm_cgxx_smux_bp_test_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_BP_TEST(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_BP_TEST(u64 a)
+{
+	return 0x20230 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_cbfc_ctl
+ *
+ * CGX SMU PFC Control Registers Internal: INTERNAL: XOFF for a specific
+ * class/channel \<i\> is XOFF\<i\> = ([PHYS_EN]\<i\> & cmr_rx_phys_bp) |
+ * ([LOGL_EN]\<i\> & cmr_rx_logl_xoff\<i\>).
+ */
+union cavm_cgxx_smux_cbfc_ctl {
+	u64 u;
+	struct cavm_cgxx_smux_cbfc_ctl_s {
+		u64 rx_en                            : 1;
+		u64 tx_en                            : 1;
+		u64 drp_en                           : 1;
+		u64 bck_en                           : 1;
+		u64 reserved_4_31                    : 28;
+		u64 logl_en                          : 16;
+		u64 phys_en                          : 16;
+	} s;
+	/* struct cavm_cgxx_smux_cbfc_ctl_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_CBFC_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_CBFC_CTL(u64 a)
+{
+	return 0x20218 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_ctrl
+ *
+ * CGX SMU Control Registers
+ */
+union cavm_cgxx_smux_ctrl {
+	u64 u;
+	struct cavm_cgxx_smux_ctrl_s {
+		u64 rx_idle                          : 1;
+		u64 tx_idle                          : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cavm_cgxx_smux_ctrl_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_CTRL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_CTRL(u64 a)
+{
+	return 0x20200 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_ext_loopback
+ *
+ * CGX SMU External Loopback Registers In loopback mode, the IFG1+IFG2 of
+ * local and remote parties must match exactly; otherwise loopback FIFO
+ * will overrun: CGX()_SMU()_TX_INT[LB_OVRFLW].
+ */
+union cavm_cgxx_smux_ext_loopback {
+	u64 u;
+	struct cavm_cgxx_smux_ext_loopback_s {
+		u64 thresh                           : 6;
+		u64 reserved_6_7                     : 2;
+		u64 depth                            : 6;
+		u64 reserved_14_15                   : 2;
+		u64 en                               : 1;
+		u64 reserved_17_63                   : 47;
+	} s;
+	/* struct cavm_cgxx_smux_ext_loopback_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_EXT_LOOPBACK(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_EXT_LOOPBACK(u64 a)
+{
+	return 0x20208 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_hg2_control
+ *
+ * CGX SMU HiGig2 Control Registers HiGig2 TX- and RX-enable are normally
+ * set together for HiGig2 messaging. Setting just the TX or RX bit
+ * results in only the HG2 message transmit or receive capability.
+ * Setting [PHYS_EN] and [LOGL_EN] to 1 allows link PAUSE or backpressure
+ * to NIX as per the received HiGig2 message. Setting these fields to 0
+ * disables link PAUSE and backpressure to NIX in response to received
+ * messages.  CGX()_SMU()_TX_CTL[HG_EN] must be set (to enable HiGig)
+ * whenever either [HG2TX_EN] or [HG2RX_EN] are set.
+ * CGX()_SMU()_RX_UDD_SKP[LEN] must be set to 16 (to select HiGig2)
+ * whenever either [HG2TX_EN] or [HG2RX_EN] are set.
+ * CGX()_CMR_RX_OVR_BP[EN]\<0\> must be set and
+ * CGX()_CMR_RX_OVR_BP[BP]\<0\> must be cleared to 0 (to forcibly disable
+ * hardware-automatic 802.3 PAUSE packet generation) with the HiGig2
+ * Protocol when [HG2TX_EN] = 0. (The HiGig2 protocol is indicated by
+ * CGX()_SMU()_TX_CTL[HG_EN] = 1 and CGX()_SMU()_RX_UDD_SKP[LEN]=16.)
+ * Hardware can only autogenerate backpressure via HiGig2 messages
+ * (optionally, when [HG2TX_EN] = 1) with the HiGig2 protocol.
+ */
+union cavm_cgxx_smux_hg2_control {
+	u64 u;
+	struct cavm_cgxx_smux_hg2_control_s {
+		u64 logl_en                          : 16;
+		u64 phys_en                          : 1;
+		u64 hg2rx_en                         : 1;
+		u64 hg2tx_en                         : 1;
+		u64 reserved_19_63                   : 45;
+	} s;
+	/* struct cavm_cgxx_smux_hg2_control_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_HG2_CONTROL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_HG2_CONTROL(u64 a)
+{
+	return 0x20210 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_mmsi_ctl_sta
+ *
+ * CGX SMU MAC Merge Service Interface (MMSI) Control/Status Registers
+ * MMSI control and status registers for frame preemption mode. Refer to
+ * IEEE 802.3br, Clause 99.
+ */
+union cavm_cgxx_smux_mmsi_ctl_sta {
+	u64 u;
+	struct cavm_cgxx_smux_mmsi_ctl_sta_s {
+		u64 p_en                             : 1;
+		u64 dis_v                            : 1;
+		u64 afs                              : 2;
+		u64 v_sta                            : 3;
+		u64 tx_pactive                       : 1;
+		u64 reserved_8_31                    : 24;
+		u64 v_time                           : 24;
+		u64 reserved_56_63                   : 8;
+	} s;
+	/* struct cavm_cgxx_smux_mmsi_ctl_sta_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_MMSI_CTL_STA(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_MMSI_CTL_STA(u64 a)
+{
+	return 0x20220 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_bad_col_ctrl
+ *
+ * CGX SMU RX Bad Column High Registers
+ */
+union cavm_cgxx_smux_rx_bad_col_ctrl {
+	u64 u;
+	struct cavm_cgxx_smux_rx_bad_col_ctrl_s {
+		u64 lane_rxc                         : 16;
+		u64 state                            : 3;
+		u64 val                              : 1;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct cavm_cgxx_smux_rx_bad_col_ctrl_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_RX_BAD_COL_CTRL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_RX_BAD_COL_CTRL(u64 a)
+{
+	return 0x20060 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_bad_col_data_hi
+ *
+ * CGX SMU RX Bad Column Low Registers
+ */
+union cavm_cgxx_smux_rx_bad_col_data_hi {
+	u64 u;
+	struct cavm_cgxx_smux_rx_bad_col_data_hi_s {
+		u64 lane_rxd                         : 64;
+	} s;
+	/* struct cavm_cgxx_smux_rx_bad_col_data_hi_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_RX_BAD_COL_DATA_HI(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_RX_BAD_COL_DATA_HI(u64 a)
+{
+	return 0x20058 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_bad_col_data_lo
+ *
+ * CGX SMU RX Bad Column Low Registers
+ */
+union cavm_cgxx_smux_rx_bad_col_data_lo {
+	u64 u;
+	struct cavm_cgxx_smux_rx_bad_col_data_lo_s {
+		u64 lane_rxd                         : 64;
+	} s;
+	/* struct cavm_cgxx_smux_rx_bad_col_data_lo_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_RX_BAD_COL_DATA_LO(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_RX_BAD_COL_DATA_LO(u64 a)
+{
+	return 0x20050 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_ctl
+ *
+ * CGX SMU RX Control Registers
+ */
+union cavm_cgxx_smux_rx_ctl {
+	u64 u;
+	struct cavm_cgxx_smux_rx_ctl_s {
+		u64 status                           : 2;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cavm_cgxx_smux_rx_ctl_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_RX_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_RX_CTL(u64 a)
+{
+	return 0x20048 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_decision
+ *
+ * CGX SMU Packet Decision Registers This register specifies the byte
+ * count used to determine when to accept or to filter a packet. As each
+ * byte in a packet is received by CGX, the L2 byte count (i.e. the
+ * number of bytes from the beginning of the L2 header (DMAC)) is
+ * compared against CNT. In normal operation, the L2 header begins after
+ * the PREAMBLE + SFD (CGX()_SMU()_RX_FRM_CTL[PRE_CHK] = 1) and any
+ * optional UDD skip data (CGX()_SMU()_RX_UDD_SKP[LEN]).
+ */
+union cavm_cgxx_smux_rx_decision {
+	u64 u;
+	struct cavm_cgxx_smux_rx_decision_s {
+		u64 cnt                              : 5;
+		u64 reserved_5_63                    : 59;
+	} s;
+	/* struct cavm_cgxx_smux_rx_decision_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_RX_DECISION(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_RX_DECISION(u64 a)
+{
+	return 0x20038 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_frm_chk
+ *
+ * CGX SMU RX Frame Check Registers The CSRs provide the enable bits for
+ * a subset of errors passed to CMR encoded.
+ */
+union cavm_cgxx_smux_rx_frm_chk {
+	u64 u;
+	struct cavm_cgxx_smux_rx_frm_chk_s {
+		u64 reserved_0_2                     : 3;
+		u64 jabber                           : 1;
+		u64 fcserr_d                         : 1;
+		u64 fcserr_c                         : 1;
+		u64 reserved_6                       : 1;
+		u64 rcverr                           : 1;
+		u64 skperr                           : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct cavm_cgxx_smux_rx_frm_chk_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_RX_FRM_CHK(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_RX_FRM_CHK(u64 a)
+{
+	return 0x20028 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_frm_ctl
+ *
+ * CGX SMU RX Frame Control Registers This register controls the handling
+ * of the frames. The [CTL_BCK] and [CTL_DRP] bits control how the
+ * hardware handles incoming PAUSE packets. The most common modes of
+ * operation: _ [CTL_BCK] = 1, [CTL_DRP] = 1: hardware handles everything
+ * _ [CTL_BCK] = 0, [CTL_DRP] = 0: software sees all PAUSE frames _
+ * [CTL_BCK] = 0, [CTL_DRP] = 1: all PAUSE frames are completely ignored
+ * These control bits should be set to [CTL_BCK] = 0, [CTL_DRP] = 0 in
+ * half-duplex mode. Since PAUSE packets only apply to full duplex
+ * operation, any PAUSE packet would constitute an exception which should
+ * be handled by the processing cores. PAUSE packets should not be
+ * forwarded.
+ */
+union cavm_cgxx_smux_rx_frm_ctl {
+	u64 u;
+	struct cavm_cgxx_smux_rx_frm_ctl_s {
+		u64 pre_chk                          : 1;
+		u64 pre_strp                         : 1;
+		u64 ctl_drp                          : 1;
+		u64 ctl_bck                          : 1;
+		u64 ctl_mcst                         : 1;
+		u64 ctl_smac                         : 1;
+		u64 reserved_6_11                    : 6;
+		u64 ptp_mode                         : 1;
+		u64 reserved_13_63                   : 51;
+	} s;
+	/* struct cavm_cgxx_smux_rx_frm_ctl_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_RX_FRM_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_RX_FRM_CTL(u64 a)
+{
+	return 0x20020 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_int
+ *
+ * CGX SMU Receive Interrupt Registers SMU Interrupt Register. Internal:
+ * Exception conditions \<9\> and \<4:0\> can also set the rcv/opcode in
+ * the received packet's work queue entry. CGX()_SMU()_RX_FRM_CHK
+ * provides a bit mask for configuring which conditions set the error.
+ */
+union cavm_cgxx_smux_rx_int {
+	u64 u;
+	struct cavm_cgxx_smux_rx_int_s {
+		u64 jabber                           : 1;
+		u64 fcserr                           : 1;
+		u64 rcverr                           : 1;
+		u64 skperr                           : 1;
+		u64 pcterr                           : 1;
+		u64 rsverr                           : 1;
+		u64 loc_fault                        : 1;
+		u64 rem_fault                        : 1;
+		u64 bad_seq                          : 1;
+		u64 bad_term                         : 1;
+		u64 hg2fld                           : 1;
+		u64 hg2cc                            : 1;
+		u64 badver                           : 1;
+		u64 badrsp                           : 1;
+		u64 reserved_14_63                   : 50;
+	} s;
+	/* struct cavm_cgxx_smux_rx_int_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_RX_INT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_RX_INT(u64 a)
+{
+	return 0x20000 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_int_ena_w1c
+ *
+ * CGX SMU Receive Interrupt Enable Clear Registers This register clears
+ * interrupt enable bits.
+ */
+union cavm_cgxx_smux_rx_int_ena_w1c {
+	u64 u;
+	struct cavm_cgxx_smux_rx_int_ena_w1c_s {
+		u64 jabber                           : 1;
+		u64 fcserr                           : 1;
+		u64 rcverr                           : 1;
+		u64 skperr                           : 1;
+		u64 pcterr                           : 1;
+		u64 rsverr                           : 1;
+		u64 loc_fault                        : 1;
+		u64 rem_fault                        : 1;
+		u64 bad_seq                          : 1;
+		u64 bad_term                         : 1;
+		u64 hg2fld                           : 1;
+		u64 hg2cc                            : 1;
+		u64 badver                           : 1;
+		u64 badrsp                           : 1;
+		u64 reserved_14_63                   : 50;
+	} s;
+	/* struct cavm_cgxx_smux_rx_int_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_RX_INT_ENA_W1C(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_RX_INT_ENA_W1C(u64 a)
+{
+	return 0x20010 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_int_ena_w1s
+ *
+ * CGX SMU Receive Interrupt Enable Set Registers This register sets
+ * interrupt enable bits.
+ */
+union cavm_cgxx_smux_rx_int_ena_w1s {
+	u64 u;
+	struct cavm_cgxx_smux_rx_int_ena_w1s_s {
+		u64 jabber                           : 1;
+		u64 fcserr                           : 1;
+		u64 rcverr                           : 1;
+		u64 skperr                           : 1;
+		u64 pcterr                           : 1;
+		u64 rsverr                           : 1;
+		u64 loc_fault                        : 1;
+		u64 rem_fault                        : 1;
+		u64 bad_seq                          : 1;
+		u64 bad_term                         : 1;
+		u64 hg2fld                           : 1;
+		u64 hg2cc                            : 1;
+		u64 badver                           : 1;
+		u64 badrsp                           : 1;
+		u64 reserved_14_63                   : 50;
+	} s;
+	/* struct cavm_cgxx_smux_rx_int_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_RX_INT_ENA_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_RX_INT_ENA_W1S(u64 a)
+{
+	return 0x20018 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_int_w1s
+ *
+ * CGX SMU Receive Interrupt Set Registers This register sets interrupt
+ * bits.
+ */
+union cavm_cgxx_smux_rx_int_w1s {
+	u64 u;
+	struct cavm_cgxx_smux_rx_int_w1s_s {
+		u64 jabber                           : 1;
+		u64 fcserr                           : 1;
+		u64 rcverr                           : 1;
+		u64 skperr                           : 1;
+		u64 pcterr                           : 1;
+		u64 rsverr                           : 1;
+		u64 loc_fault                        : 1;
+		u64 rem_fault                        : 1;
+		u64 bad_seq                          : 1;
+		u64 bad_term                         : 1;
+		u64 hg2fld                           : 1;
+		u64 hg2cc                            : 1;
+		u64 badver                           : 1;
+		u64 badrsp                           : 1;
+		u64 reserved_14_63                   : 50;
+	} s;
+	/* struct cavm_cgxx_smux_rx_int_w1s_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_RX_INT_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_RX_INT_W1S(u64 a)
+{
+	return 0x20008 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_jabber
+ *
+ * CGX SMU Maximum Packet-Size Registers This register specifies the
+ * maximum size for packets, beyond which the SMU truncates. Internal:
+ * JABBER[CNT] is checked against the packet that arrives from SPU.  The
+ * checking is performed before preamble is stripped or PTP is inserted.
+ * If present, preamble is counted as eight bytes of the incoming packet.
+ */
+union cavm_cgxx_smux_rx_jabber {
+	u64 u;
+	struct cavm_cgxx_smux_rx_jabber_s {
+		u64 cnt                              : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_smux_rx_jabber_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_RX_JABBER(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_RX_JABBER(u64 a)
+{
+	return 0x20030 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_udd_skp
+ *
+ * CGX SMU User-Defined Data Skip Registers Internal: (1) The skip bytes
+ * are part of the packet and will be sent down the NCB packet interface
+ * and will be handled by NIX.  (2) The system can determine if the UDD
+ * bytes are included in the FCS check by using the FCSSEL field if the
+ * FCS check is enabled.  (3) Assume that the preamble/sfd is always at
+ * the start of the frame even before UDD bytes.  In most cases, there
+ * will be no preamble in these cases since it will be packet interface
+ * in direct communication to another packet interface (MAC to MAC)
+ * without a PHY involved.  (4) We can still do address filtering and
+ * control packet filtering if the user desires.  (5) In all cases, the
+ * UDD bytes will be sent down the packet interface as part of the
+ * packet.  The UDD bytes are never stripped from the actual packet.
+ */
+union cavm_cgxx_smux_rx_udd_skp {
+	u64 u;
+	struct cavm_cgxx_smux_rx_udd_skp_s {
+		u64 len                              : 7;
+		u64 reserved_7                       : 1;
+		u64 fcssel                           : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct cavm_cgxx_smux_rx_udd_skp_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_RX_UDD_SKP(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_RX_UDD_SKP(u64 a)
+{
+	return 0x20040 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_wol_ctrl0
+ *
+ * CGX SMU RX Wake-on-LAN Control 0 Registers
+ */
+union cavm_cgxx_smux_rx_wol_ctrl0 {
+	u64 u;
+	struct cavm_cgxx_smux_rx_wol_ctrl0_s {
+		u64 dmac                             : 48;
+		u64 pswd_len                         : 4;
+		u64 reserved_52_63                   : 12;
+	} s;
+	/* struct cavm_cgxx_smux_rx_wol_ctrl0_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_RX_WOL_CTRL0(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_RX_WOL_CTRL0(u64 a)
+{
+	return 0x20068 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_wol_ctrl1
+ *
+ * CGX SMU RX Wake-on-LAN Control 1 Registers
+ */
+union cavm_cgxx_smux_rx_wol_ctrl1 {
+	u64 u;
+	struct cavm_cgxx_smux_rx_wol_ctrl1_s {
+		u64 pswd                             : 64;
+	} s;
+	/* struct cavm_cgxx_smux_rx_wol_ctrl1_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_RX_WOL_CTRL1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_RX_WOL_CTRL1(u64 a)
+{
+	return 0x20070 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_wol_int
+ *
+ * CGX SMU RX WOL Interrupt Registers These registers allow WOL
+ * interrupts to be sent to the control processor.
+ */
+union cavm_cgxx_smux_rx_wol_int {
+	u64 u;
+	struct cavm_cgxx_smux_rx_wol_int_s {
+		u64 wol_rcvd                         : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_cgxx_smux_rx_wol_int_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_RX_WOL_INT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_RX_WOL_INT(u64 a)
+{
+	return 0x20078 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_wol_int_ena_w1c
+ *
+ * CGX SMU RX WOL Interrupt Enable Clear Registers This register clears
+ * interrupt enable bits.
+ */
+union cavm_cgxx_smux_rx_wol_int_ena_w1c {
+	u64 u;
+	struct cavm_cgxx_smux_rx_wol_int_ena_w1c_s {
+		u64 wol_rcvd                         : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_cgxx_smux_rx_wol_int_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_RX_WOL_INT_ENA_W1C(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_RX_WOL_INT_ENA_W1C(u64 a)
+{
+	return 0x20088 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_wol_int_ena_w1s
+ *
+ * CGX SMU RX WOL Interrupt Enable Set Registers This register sets
+ * interrupt enable bits.
+ */
+union cavm_cgxx_smux_rx_wol_int_ena_w1s {
+	u64 u;
+	struct cavm_cgxx_smux_rx_wol_int_ena_w1s_s {
+		u64 wol_rcvd                         : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_cgxx_smux_rx_wol_int_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_RX_WOL_INT_ENA_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_RX_WOL_INT_ENA_W1S(u64 a)
+{
+	return 0x20090 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_rx_wol_int_w1s
+ *
+ * CGX SMU RX WOL Interrupt Set Registers This register sets interrupt
+ * bits.
+ */
+union cavm_cgxx_smux_rx_wol_int_w1s {
+	u64 u;
+	struct cavm_cgxx_smux_rx_wol_int_w1s_s {
+		u64 wol_rcvd                         : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_cgxx_smux_rx_wol_int_w1s_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_RX_WOL_INT_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_RX_WOL_INT_W1S(u64 a)
+{
+	return 0x20080 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_smac
+ *
+ * CGX SMU SMAC Registers
+ */
+union cavm_cgxx_smux_smac {
+	u64 u;
+	struct cavm_cgxx_smux_smac_s {
+		u64 smac                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_smux_smac_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_SMAC(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_SMAC(u64 a)
+{
+	return 0x20108 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_append
+ *
+ * CGX SMU TX Append Control Registers For more details on the
+ * interactions between FCS and PAD, see also the description of
+ * CGX()_SMU()_TX_MIN_PKT[MIN_SIZE].
+ */
+union cavm_cgxx_smux_tx_append {
+	u64 u;
+	struct cavm_cgxx_smux_tx_append_s {
+		u64 preamble                         : 1;
+		u64 pad                              : 1;
+		u64 fcs_d                            : 1;
+		u64 fcs_c                            : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cavm_cgxx_smux_tx_append_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_TX_APPEND(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_TX_APPEND(u64 a)
+{
+	return 0x20100 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_ctl
+ *
+ * CGX SMU Transmit Control Registers
+ */
+union cavm_cgxx_smux_tx_ctl {
+	u64 u;
+	struct cavm_cgxx_smux_tx_ctl_s {
+		u64 dic_en                           : 1;
+		u64 uni_en                           : 1;
+		u64 x4a_dis                          : 1;
+		u64 mia_en                           : 1;
+		u64 ls                               : 2;
+		u64 ls_byp                           : 1;
+		u64 l2p_bp_conv                      : 1;
+		u64 hg_en                            : 1;
+		u64 hg_pause_hgi                     : 2;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct cavm_cgxx_smux_tx_ctl_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_TX_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_TX_CTL(u64 a)
+{
+	return 0x20178 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_dack
+ *
+ * CGX SMU TX Drop Counters Registers
+ */
+union cavm_cgxx_smux_tx_dack {
+	u64 u;
+	struct cavm_cgxx_smux_tx_dack_s {
+		u64 dpi_sdrop_ack                    : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_smux_tx_dack_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_TX_DACK(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_TX_DACK(u64 a)
+{
+	return 0x201b0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_dcnt
+ *
+ * CGX SMU TX Drop Counters Registers
+ */
+union cavm_cgxx_smux_tx_dcnt {
+	u64 u;
+	struct cavm_cgxx_smux_tx_dcnt_s {
+		u64 dpi_sdrop_cnt                    : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_smux_tx_dcnt_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_TX_DCNT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_TX_DCNT(u64 a)
+{
+	return 0x201a8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_eee
+ *
+ * INTERNAL: CGX SMU TX EEE Configure Registers  Resvered. Internal:
+ * These registers control when SMU TX requests to enter or exist LPI.
+ * Those registers take effect only when EEE is supported and enabled for
+ * a given LMAC.
+ */
+union cavm_cgxx_smux_tx_eee {
+	u64 u;
+	struct cavm_cgxx_smux_tx_eee_s {
+		u64 idle_thresh                      : 28;
+		u64 reserved_28                      : 1;
+		u64 force_lpi                        : 1;
+		u64 wakeup                           : 1;
+		u64 auto_lpi                         : 1;
+		u64 idle_cnt                         : 28;
+		u64 reserved_60_61                   : 2;
+		u64 tx_lpi_wake                      : 1;
+		u64 tx_lpi                           : 1;
+	} s;
+	/* struct cavm_cgxx_smux_tx_eee_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_TX_EEE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_TX_EEE(u64 a)
+{
+	return 0x20190 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_eee_timer_status
+ *
+ * INTERNAL: CGX SMU TX EEE TIMER STATUS Registers  Reserved. Internal:
+ * These registers configure SMU TX EEE timing parameters.
+ */
+union cavm_cgxx_smux_tx_eee_timer_status {
+	u64 u;
+	struct cavm_cgxx_smux_tx_eee_timer_status_s {
+		u64 lpi_wake_cnt                     : 16;
+		u64 reserved_16_30                   : 15;
+		u64 wake_timer_done                  : 1;
+		u64 link_ok_cnt                      : 30;
+		u64 reserved_62                      : 1;
+		u64 link_timer_done                  : 1;
+	} s;
+	/* struct cavm_cgxx_smux_tx_eee_timer_status_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_TX_EEE_TIMER_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_TX_EEE_TIMER_STATUS(u64 a)
+{
+	return 0x201a0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_eee_timing
+ *
+ * INTERNAL: CGX SMU TX EEE TIMING Parameter Registers  Reserved.
+ * Internal: These registers configure SMU TX EEE timing parameters.
+ */
+union cavm_cgxx_smux_tx_eee_timing {
+	u64 u;
+	struct cavm_cgxx_smux_tx_eee_timing_s {
+		u64 w_sys_tx_min                     : 16;
+		u64 reserved_16_31                   : 16;
+		u64 link_ok_min                      : 30;
+		u64 reserved_62_63                   : 2;
+	} s;
+	/* struct cavm_cgxx_smux_tx_eee_timing_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_TX_EEE_TIMING(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_TX_EEE_TIMING(u64 a)
+{
+	return 0x20198 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_ifg
+ *
+ * CGX SMU TX Interframe-Gap Cycles Registers Programming IFG1 and IFG2:
+ * * For XAUI/RXAUI/10G/25G/40G/50G/100G systems that require IEEE 802.3
+ * compatibility, the [IFG1]+[IFG2] sum must be 12. * In loopback mode,
+ * the [IFG1]+[IFG2] of local and remote parties must match exactly;
+ * otherwise loopback FIFO will overrun: CGX()_SMU()_TX_INT[LB_OVRFLW]. *
+ * When CGX()_SMU()_TX_CTL[DIC_EN] is set, [IFG1]+[IFG2] sum must be at
+ * least 8. The behavior of smaller values is un-determined. * When
+ * CGX()_SMU()_TX_CTL[DIC_EN] is cleared, the minimum value of
+ * [IFG1]+[IFG2] is 1 for 40G/50G/100G LMAC_TYPE configurations and 5 for
+ * all other values. The behavior of smaller values is un-determined.
+ * Internal: When CGX()_SMU()_TX_CTL[DIC_EN] is set, SMU TX treats
+ * ([IFG1]+[IFG2]) \< 8 as 8 for 40G/50G/100G MACs and ([IFG1]+[IFG2]) \<
+ * 8 as 8 for other MACs. When CGX()_SMU()_TX_CTL[DIC_EN] is cleared, SMU
+ * TX can work correctly with any IFG1 and IFG2.
+ */
+union cavm_cgxx_smux_tx_ifg {
+	u64 u;
+	struct cavm_cgxx_smux_tx_ifg_s {
+		u64 ifg1                             : 4;
+		u64 ifg2                             : 4;
+		u64 mia_amt                          : 2;
+		u64 reserved_10_15                   : 6;
+		u64 mia_cnt                          : 8;
+		u64 reserved_24_63                   : 40;
+	} s;
+	/* struct cavm_cgxx_smux_tx_ifg_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_TX_IFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_TX_IFG(u64 a)
+{
+	return 0x20160 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_int
+ *
+ * CGX SMU TX Interrupt Registers
+ */
+union cavm_cgxx_smux_tx_int {
+	u64 u;
+	struct cavm_cgxx_smux_tx_int_s {
+		u64 undflw                           : 1;
+		u64 xchange                          : 1;
+		u64 fake_commit                      : 1;
+		u64 lb_undflw                        : 1;
+		u64 lb_ovrflw                        : 1;
+		u64 dpi_sdrop                        : 1;
+		u64 reserved_6_63                    : 58;
+	} s;
+	/* struct cavm_cgxx_smux_tx_int_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_TX_INT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_TX_INT(u64 a)
+{
+	return 0x20140 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_int_ena_w1c
+ *
+ * CGX SMU TX Interrupt Enable Clear Registers This register clears
+ * interrupt enable bits.
+ */
+union cavm_cgxx_smux_tx_int_ena_w1c {
+	u64 u;
+	struct cavm_cgxx_smux_tx_int_ena_w1c_s {
+		u64 undflw                           : 1;
+		u64 xchange                          : 1;
+		u64 fake_commit                      : 1;
+		u64 lb_undflw                        : 1;
+		u64 lb_ovrflw                        : 1;
+		u64 dpi_sdrop                        : 1;
+		u64 reserved_6_63                    : 58;
+	} s;
+	/* struct cavm_cgxx_smux_tx_int_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_TX_INT_ENA_W1C(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_TX_INT_ENA_W1C(u64 a)
+{
+	return 0x20150 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_int_ena_w1s
+ *
+ * CGX SMU TX Interrupt Enable Set Registers This register sets interrupt
+ * enable bits.
+ */
+union cavm_cgxx_smux_tx_int_ena_w1s {
+	u64 u;
+	struct cavm_cgxx_smux_tx_int_ena_w1s_s {
+		u64 undflw                           : 1;
+		u64 xchange                          : 1;
+		u64 fake_commit                      : 1;
+		u64 lb_undflw                        : 1;
+		u64 lb_ovrflw                        : 1;
+		u64 dpi_sdrop                        : 1;
+		u64 reserved_6_63                    : 58;
+	} s;
+	/* struct cavm_cgxx_smux_tx_int_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_TX_INT_ENA_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_TX_INT_ENA_W1S(u64 a)
+{
+	return 0x20158 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_int_w1s
+ *
+ * CGX SMU TX Interrupt Set Registers This register sets interrupt bits.
+ */
+union cavm_cgxx_smux_tx_int_w1s {
+	u64 u;
+	struct cavm_cgxx_smux_tx_int_w1s_s {
+		u64 undflw                           : 1;
+		u64 xchange                          : 1;
+		u64 fake_commit                      : 1;
+		u64 lb_undflw                        : 1;
+		u64 lb_ovrflw                        : 1;
+		u64 dpi_sdrop                        : 1;
+		u64 reserved_6_63                    : 58;
+	} s;
+	/* struct cavm_cgxx_smux_tx_int_w1s_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_TX_INT_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_TX_INT_W1S(u64 a)
+{
+	return 0x20148 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_min_pkt
+ *
+ * CGX SMU TX Minimum-Size-Packet Registers Internal: [MIN_SIZE] less
+ * than 16 will be ignored by hardware which will use 16 instead.
+ */
+union cavm_cgxx_smux_tx_min_pkt {
+	u64 u;
+	struct cavm_cgxx_smux_tx_min_pkt_s {
+		u64 min_size                         : 8;
+		u64 reserved_8_63                    : 56;
+	} s;
+	/* struct cavm_cgxx_smux_tx_min_pkt_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_TX_MIN_PKT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_TX_MIN_PKT(u64 a)
+{
+	return 0x20118 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_pause_pkt_dmac
+ *
+ * CGX SMU TX PAUSE-Packet DMAC-Field Registers This register provides
+ * the DMAC value that is placed in outbound PAUSE packets.
+ */
+union cavm_cgxx_smux_tx_pause_pkt_dmac {
+	u64 u;
+	struct cavm_cgxx_smux_tx_pause_pkt_dmac_s {
+		u64 dmac                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_smux_tx_pause_pkt_dmac_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_PKT_DMAC(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_PKT_DMAC(u64 a)
+{
+	return 0x20168 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_pause_pkt_interval
+ *
+ * CGX SMU TX PAUSE-Packet Transmission-Interval Registers This register
+ * specifies how often PAUSE packets are sent.
+ */
+union cavm_cgxx_smux_tx_pause_pkt_interval {
+	u64 u;
+	struct cavm_cgxx_smux_tx_pause_pkt_interval_s {
+		u64 interval                         : 16;
+		u64 hg2_intra_interval               : 16;
+		u64 hg2_intra_en                     : 1;
+		u64 reserved_33_63                   : 31;
+	} s;
+	/* struct cavm_cgxx_smux_tx_pause_pkt_interval_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_PKT_INTERVAL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_PKT_INTERVAL(u64 a)
+{
+	return 0x20120 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_pause_pkt_time
+ *
+ * CGX SMU TX PAUSE Packet Time Registers
+ */
+union cavm_cgxx_smux_tx_pause_pkt_time {
+	u64 u;
+	struct cavm_cgxx_smux_tx_pause_pkt_time_s {
+		u64 p_time                           : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_smux_tx_pause_pkt_time_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_PKT_TIME(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_PKT_TIME(u64 a)
+{
+	return 0x20110 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_pause_pkt_type
+ *
+ * CGX SMU TX PAUSE-Packet P_TYPE-Field Registers This register provides
+ * the P_TYPE field that is placed in outbound PAUSE packets.
+ */
+union cavm_cgxx_smux_tx_pause_pkt_type {
+	u64 u;
+	struct cavm_cgxx_smux_tx_pause_pkt_type_s {
+		u64 p_type                           : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_smux_tx_pause_pkt_type_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_PKT_TYPE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_PKT_TYPE(u64 a)
+{
+	return 0x20170 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_pause_togo
+ *
+ * CGX SMU TX Time-to-Backpressure Registers
+ */
+union cavm_cgxx_smux_tx_pause_togo {
+	u64 u;
+	struct cavm_cgxx_smux_tx_pause_togo_s {
+		u64 p_time                           : 16;
+		u64 msg_time                         : 16;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cavm_cgxx_smux_tx_pause_togo_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_TOGO(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_TOGO(u64 a)
+{
+	return 0x20130 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_pause_zero
+ *
+ * CGX SMU TX PAUSE Zero Registers
+ */
+union cavm_cgxx_smux_tx_pause_zero {
+	u64 u;
+	struct cavm_cgxx_smux_tx_pause_zero_s {
+		u64 send                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_cgxx_smux_tx_pause_zero_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_ZERO(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_TX_PAUSE_ZERO(u64 a)
+{
+	return 0x20138 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_soft_pause
+ *
+ * CGX SMU TX Soft PAUSE Registers
+ */
+union cavm_cgxx_smux_tx_soft_pause {
+	u64 u;
+	struct cavm_cgxx_smux_tx_soft_pause_s {
+		u64 p_time                           : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_smux_tx_soft_pause_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_TX_SOFT_PAUSE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_TX_SOFT_PAUSE(u64 a)
+{
+	return 0x20128 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_smu#_tx_thresh
+ *
+ * CGX SMU TX Threshold Registers
+ */
+union cavm_cgxx_smux_tx_thresh {
+	u64 u;
+	struct cavm_cgxx_smux_tx_thresh_s {
+		u64 cnt                              : 12;
+		u64 reserved_12_15                   : 4;
+		u64 dpi_thresh                       : 5;
+		u64 reserved_21_23                   : 3;
+		u64 dpi_depth                        : 5;
+		u64 reserved_29_31                   : 3;
+		u64 ecnt                             : 12;
+		u64 reserved_44_63                   : 20;
+	} s;
+	/* struct cavm_cgxx_smux_tx_thresh_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SMUX_TX_THRESH(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SMUX_TX_THRESH(u64 a)
+{
+	return 0x20180 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_an_adv
+ *
+ * CGX SPU Autonegotiation Advertisement Registers Software programs this
+ * register with the contents of the AN-link code word base page to be
+ * transmitted during autonegotiation. (See IEEE 802.3 section 73.6 for
+ * details.) Any write operations to this register prior to completion of
+ * autonegotiation, as indicated by CGX()_SPU()_AN_STATUS[AN_COMPLETE],
+ * should be followed by a renegotiation in order for the new values to
+ * take effect. Renegotiation is initiated by setting
+ * CGX()_SPU()_AN_CONTROL[AN_RESTART]. Once autonegotiation has
+ * completed, software can examine this register along with
+ * CGX()_SPU()_AN_LP_BASE to determine the highest common denominator
+ * technology.
+ */
+union cavm_cgxx_spux_an_adv {
+	u64 u;
+	struct cavm_cgxx_spux_an_adv_s {
+		u64 s                                : 5;
+		u64 e                                : 5;
+		u64 pause                            : 1;
+		u64 asm_dir                          : 1;
+		u64 xnp_able                         : 1;
+		u64 rf                               : 1;
+		u64 ack                              : 1;
+		u64 np                               : 1;
+		u64 t                                : 5;
+		u64 a1g_kx                           : 1;
+		u64 a10g_kx4                         : 1;
+		u64 a10g_kr                          : 1;
+		u64 a40g_kr4                         : 1;
+		u64 a40g_cr4                         : 1;
+		u64 a100g_cr10                       : 1;
+		u64 a100g_kp4                        : 1;
+		u64 a100g_kr4                        : 1;
+		u64 a100g_cr4                        : 1;
+		u64 a25g_krs_crs                     : 1;
+		u64 a25g_kr_cr                       : 1;
+		u64 arsv                             : 12;
+		u64 a25g_rs_fec_req                  : 1;
+		u64 a25g_br_fec_req                  : 1;
+		u64 fec_able                         : 1;
+		u64 fec_req                          : 1;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_spux_an_adv_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_AN_ADV(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_AN_ADV(u64 a)
+{
+	return 0x10198 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_an_bp_status
+ *
+ * CGX SPU Autonegotiation Backplane Ethernet & BASE-R Copper Status
+ * Registers The contents of this register are updated during
+ * autonegotiation and are valid when CGX()_SPU()_AN_STATUS[AN_COMPLETE]
+ * is set. At that time, one of the port type bits will be set depending
+ * on the AN priority resolution. The port types are listed in order of
+ * decreasing priority. If a BASE-R type is negotiated then [FEC] or
+ * [RS_FEC] will be set to indicate whether/which FEC operation has been
+ * negotiated and will be clear otherwise.
+ */
+union cavm_cgxx_spux_an_bp_status {
+	u64 u;
+	struct cavm_cgxx_spux_an_bp_status_s {
+		u64 bp_an_able                       : 1;
+		u64 n1g_kx                           : 1;
+		u64 n10g_kx4                         : 1;
+		u64 n10g_kr                          : 1;
+		u64 n25g_kr1                         : 1;
+		u64 n25g_cr1                         : 1;
+		u64 n25g_krs_crs                     : 1;
+		u64 n25g_kr_cr                       : 1;
+		u64 n40g_kr4                         : 1;
+		u64 n40g_cr4                         : 1;
+		u64 n50g_kr2                         : 1;
+		u64 n50g_cr2                         : 1;
+		u64 n100g_cr10                       : 1;
+		u64 n100g_kp4                        : 1;
+		u64 n100g_kr4                        : 1;
+		u64 n100g_cr4                        : 1;
+		u64 fec                              : 1;
+		u64 rs_fec                           : 1;
+		u64 reserved_18_63                   : 46;
+	} s;
+	/* struct cavm_cgxx_spux_an_bp_status_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_AN_BP_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_AN_BP_STATUS(u64 a)
+{
+	return 0x101b8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_an_control
+ *
+ * CGX SPU Autonegotiation Control Registers
+ */
+union cavm_cgxx_spux_an_control {
+	u64 u;
+	struct cavm_cgxx_spux_an_control_s {
+		u64 reserved_0_8                     : 9;
+		u64 an_restart                       : 1;
+		u64 reserved_10_11                   : 2;
+		u64 an_en                            : 1;
+		u64 xnp_en                           : 1;
+		u64 reserved_14                      : 1;
+		u64 an_reset                         : 1;
+		u64 an_arb_link_chk_en               : 1;
+		u64 usx_an_arb_link_chk_en           : 1;
+		u64 reserved_18_63                   : 46;
+	} s;
+	/* struct cavm_cgxx_spux_an_control_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_AN_CONTROL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_AN_CONTROL(u64 a)
+{
+	return 0x10188 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_an_lp_base
+ *
+ * CGX SPU Autonegotiation Link-Partner Base-Page Ability Registers This
+ * register captures the contents of the latest AN link code word base
+ * page received from the link partner during autonegotiation. (See IEEE
+ * 802.3 section 73.6 for details.) CGX()_SPU()_AN_STATUS[PAGE_RX] is set
+ * when this register is updated by hardware.
+ */
+union cavm_cgxx_spux_an_lp_base {
+	u64 u;
+	struct cavm_cgxx_spux_an_lp_base_s {
+		u64 s                                : 5;
+		u64 e                                : 5;
+		u64 pause                            : 1;
+		u64 asm_dir                          : 1;
+		u64 xnp_able                         : 1;
+		u64 rf                               : 1;
+		u64 ack                              : 1;
+		u64 np                               : 1;
+		u64 t                                : 5;
+		u64 a1g_kx                           : 1;
+		u64 a10g_kx4                         : 1;
+		u64 a10g_kr                          : 1;
+		u64 a40g_kr4                         : 1;
+		u64 a40g_cr4                         : 1;
+		u64 a100g_cr10                       : 1;
+		u64 a100g_kp4                        : 1;
+		u64 a100g_kr4                        : 1;
+		u64 a100g_cr4                        : 1;
+		u64 a25g_krs_crs                     : 1;
+		u64 a25g_kr_cr                       : 1;
+		u64 arsv                             : 12;
+		u64 a25g_rs_fec_req                  : 1;
+		u64 a25g_br_fec_req                  : 1;
+		u64 fec_able                         : 1;
+		u64 fec_req                          : 1;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_spux_an_lp_base_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_AN_LP_BASE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_AN_LP_BASE(u64 a)
+{
+	return 0x101a0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_an_lp_xnp
+ *
+ * CGX SPU Autonegotiation Link Partner Extended Next Page Ability
+ * Registers This register captures the contents of the latest next page
+ * code word received from the link partner during autonegotiation, if
+ * any. See IEEE 802.3 section 73.7.7 for details.
+ */
+union cavm_cgxx_spux_an_lp_xnp {
+	u64 u;
+	struct cavm_cgxx_spux_an_lp_xnp_s {
+		u64 m_u                              : 11;
+		u64 toggle                           : 1;
+		u64 ack2                             : 1;
+		u64 mp                               : 1;
+		u64 ack                              : 1;
+		u64 np                               : 1;
+		u64 u                                : 32;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_spux_an_lp_xnp_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_AN_LP_XNP(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_AN_LP_XNP(u64 a)
+{
+	return 0x101b0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_an_status
+ *
+ * CGX SPU Autonegotiation Status Registers
+ */
+union cavm_cgxx_spux_an_status {
+	u64 u;
+	struct cavm_cgxx_spux_an_status_s {
+		u64 lp_an_able                       : 1;
+		u64 reserved_1                       : 1;
+		u64 link_status                      : 1;
+		u64 an_able                          : 1;
+		u64 rmt_flt                          : 1;
+		u64 an_complete                      : 1;
+		u64 page_rx                          : 1;
+		u64 xnp_stat                         : 1;
+		u64 reserved_8                       : 1;
+		u64 prl_flt                          : 1;
+		u64 reserved_10_63                   : 54;
+	} s;
+	/* struct cavm_cgxx_spux_an_status_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_AN_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_AN_STATUS(u64 a)
+{
+	return 0x10190 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_an_xnp_tx
+ *
+ * CGX SPU Autonegotiation Extended Next Page Transmit Registers Software
+ * programs this register with the contents of the AN message next page
+ * or unformatted next page link code word to be transmitted during
+ * autonegotiation. Next page exchange occurs after the base link code
+ * words have been exchanged if either end of the link segment sets the
+ * NP bit to 1, indicating that it has at least one next page to send.
+ * Once initiated, next page exchange continues until both ends of the
+ * link segment set their NP bits to 0. See IEEE 802.3 section 73.7.7 for
+ * details.
+ */
+union cavm_cgxx_spux_an_xnp_tx {
+	u64 u;
+	struct cavm_cgxx_spux_an_xnp_tx_s {
+		u64 m_u                              : 11;
+		u64 toggle                           : 1;
+		u64 ack2                             : 1;
+		u64 mp                               : 1;
+		u64 ack                              : 1;
+		u64 np                               : 1;
+		u64 u                                : 32;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_cgxx_spux_an_xnp_tx_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_AN_XNP_TX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_AN_XNP_TX(u64 a)
+{
+	return 0x101a8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_br_algn_status
+ *
+ * CGX SPU Multilane BASE-R PCS Alignment-Status Registers This register
+ * implements the IEEE 802.3 multilane BASE-R PCS alignment status 1-4
+ * registers (3.50-3.53). It is valid only when the LPCS type is
+ * 40GBASE-R, 50GBASE-R, 100GBASE-R, (CGX()_CMR()_CONFIG[LMAC_TYPE] =
+ * CGX_LMAC_TYPES_E::FORTYG_R,FIFTYG_R,HUNDREDG_R), and always returns
+ * 0x0 for all other LPCS types. Service interfaces (lanes) 19-0 (100G)
+ * and 3-0 (all others) are mapped to PCS lanes 19-0 or 3-0 via
+ * CGX()_SPU()_BR_LANE_MAP()[LN_MAPPING]. For 100G, logical lane 0 fans
+ * out to service interfaces 0-4, logical lane 1 fans out to service
+ * interfaces 5-9, ... etc. For all other modes, logical lanes and
+ * service interfaces are identical. Logical interfaces (lanes) map to
+ * SerDes lanes via CGX()_CMR()_CONFIG[LANE_TO_SDS] (programmable).
+ */
+union cavm_cgxx_spux_br_algn_status {
+	u64 u;
+	struct cavm_cgxx_spux_br_algn_status_s {
+		u64 block_lock                       : 20;
+		u64 reserved_20_29                   : 10;
+		u64 alignd                           : 1;
+		u64 reserved_31_40                   : 10;
+		u64 marker_lock                      : 20;
+		u64 reserved_61_63                   : 3;
+	} s;
+	/* struct cavm_cgxx_spux_br_algn_status_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_BR_ALGN_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_BR_ALGN_STATUS(u64 a)
+{
+	return 0x10050 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_br_lane_map#
+ *
+ * CGX SPU 40,50,100GBASE-R Lane-Mapping Registers This register
+ * implements the IEEE 802.3 lane 0-19 mapping registers (3.400-3.403).
+ * It is valid only when the LPCS type is 40GBASE-R, 50GBASE-R,
+ * 100GBASE-R, USXGMII (CGX()_CMR()_CONFIG[LMAC_TYPE]), and always
+ * returns 0x0 for all other LPCS types. The LNx_MAPPING field for each
+ * programmed PCS lane (called service interface in 802.3) is valid when
+ * that lane has achieved alignment marker lock on the receive side (i.e.
+ * the associated CGX()_SPU()_BR_ALGN_STATUS[MARKER_LOCK] = 1), and is
+ * invalid otherwise. When valid, it returns the actual detected receive
+ * PCS lane number based on the received alignment marker contents
+ * received on that service interface.  In RS-FEC mode the LNx_MAPPING
+ * field is valid when that lane has achieved alignment marker lock on
+ * the receive side (i.e. the associated
+ * CGX(0..2)_SPU(0..3)_RSFEC_STATUS[AMPS_LOCK] = 1), and is invalid
+ * otherwise. When valid, it returns the actual detected receive FEC lane
+ * number based on the received alignment marker contents received on
+ * that logical lane therefore expect for RS-FEC that LNx_MAPPING = x.
+ * The mapping is flexible because IEEE 802.3 allows multilane BASE-R
+ * receive lanes to be re-ordered. Note that for the transmit side, each
+ * logical lane is mapped to a physical SerDes lane based on the
+ * programming of CGX()_CMR()_CONFIG[LANE_TO_SDS]. For the receive side,
+ * CGX()_CMR()_CONFIG[LANE_TO_SDS] specifies the logical lane to physical
+ * SerDes lane mapping, and this register specifies the service interface
+ * (or lane) to PCS lane mapping.
+ */
+union cavm_cgxx_spux_br_lane_mapx {
+	u64 u;
+	struct cavm_cgxx_spux_br_lane_mapx_s {
+		u64 ln_mapping                       : 6;
+		u64 reserved_6_63                    : 58;
+	} s;
+	/* struct cavm_cgxx_spux_br_lane_mapx_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_BR_LANE_MAPX(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_BR_LANE_MAPX(u64 a, u64 b)
+{
+	return 0x10600 + 0x40000 * a + 8 * b;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_br_pmd_control
+ *
+ * CGX SPU BASE-R PMD Control Registers
+ */
+union cavm_cgxx_spux_br_pmd_control {
+	u64 u;
+	struct cavm_cgxx_spux_br_pmd_control_s {
+		u64 train_restart                    : 1;
+		u64 train_en                         : 1;
+		u64 use_lane_poly                    : 1;
+		u64 max_wait_disable                 : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	struct cavm_cgxx_spux_br_pmd_control_cn96xx {
+		u64 train_restart                    : 1;
+		u64 train_en                         : 1;
+		u64 use_lane_poly                    : 1;
+		u64 reserved_3_63                    : 61;
+	} cn96xx;
+	/* struct cavm_cgxx_spux_br_pmd_control_s cnf95xx; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_BR_PMD_CONTROL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_BR_PMD_CONTROL(u64 a)
+{
+	return 0x100a8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_br_pmd_ld_cup
+ *
+ * CGX SPU BASE-R PMD Local Device Coefficient Update Registers This
+ * register implements MDIO register 1.154 of 802.3-2012 Section 5 CL45
+ * for 10GBASE-R and and of 802.3by-2016 CL45 for 25GBASE-R. Note that
+ * for 10G, 25G LN0_ only is used.  It implements  MDIO registers
+ * 1.1300-1.1303 for all other BASE-R modes (40G, 50G, 100G) per
+ * 802.3bj-2014 CL45. Note that for 50G LN0_ and LN1_ only are used.  The
+ * fields in this register are read/write even though they are specified
+ * as read-only in 802.3.  The register is automatically cleared at the
+ * start of training. When link training is in progress, each field
+ * reflects the contents of the coefficient update field in the
+ * associated lane's outgoing training frame.  If
+ * CGX()_SPU_DBG_CONTROL[BR_PMD_TRAIN_SOFT_EN] is set, then this register
+ * must be updated by software during link training and hardware updates
+ * are disabled. If CGX()_SPU_DBG_CONTROL[BR_PMD_TRAIN_SOFT_EN] is clear,
+ * this register is automatically updated by hardware, and it should not
+ * be written by software. The lane fields in this register are indexed
+ * by logical PCS lane ID.
+ */
+union cavm_cgxx_spux_br_pmd_ld_cup {
+	u64 u;
+	struct cavm_cgxx_spux_br_pmd_ld_cup_s {
+		u64 ln0_cup                          : 16;
+		u64 ln1_cup                          : 16;
+		u64 ln2_cup                          : 16;
+		u64 ln3_cup                          : 16;
+	} s;
+	/* struct cavm_cgxx_spux_br_pmd_ld_cup_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_BR_PMD_LD_CUP(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_BR_PMD_LD_CUP(u64 a)
+{
+	return 0x100c8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_br_pmd_ld_rep
+ *
+ * CGX SPU BASE-R PMD Local Device Status Report Registers This register
+ * implements MDIO register 1.155 of 802.3-2012 Section 5 CL45 for
+ * 10GBASE-R and and of 802.3by-2016 CL45 for 25GBASE-R. Note that for
+ * 10G, 25G LN0_ only is used.  It implements  MDIO registers
+ * 1.1400-1.1403 for all other BASE-R modes (40G, 50G, 100G) per
+ * 802.3bj-2014 CL45. Note that for 50G LN0_ and LN1_ only are used.  The
+ * fields in this register are read/write even though they are specified
+ * as read-only in 802.3.  The register is automatically cleared at the
+ * start of training. Each field reflects the contents of the status
+ * report field in the associated lane's outgoing training frame.  If
+ * CGX()_SPU_DBG_CONTROL[BR_PMD_TRAIN_SOFT_EN] is set, then this register
+ * must be updated by software during link training and hardware updates
+ * are disabled. If CGX()_SPU_DBG_CONTROL[BR_PMD_TRAIN_SOFT_EN] is clear,
+ * this register is automatically updated by hardware, and it should not
+ * be written by software. The lane fields in this register are indexed
+ * by logical PCS lane ID.
+ */
+union cavm_cgxx_spux_br_pmd_ld_rep {
+	u64 u;
+	struct cavm_cgxx_spux_br_pmd_ld_rep_s {
+		u64 ln0_rep                          : 16;
+		u64 ln1_rep                          : 16;
+		u64 ln2_rep                          : 16;
+		u64 ln3_rep                          : 16;
+	} s;
+	/* struct cavm_cgxx_spux_br_pmd_ld_rep_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_BR_PMD_LD_REP(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_BR_PMD_LD_REP(u64 a)
+{
+	return 0x100d0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_br_pmd_lp_cup
+ *
+ * CGX SPU BASE-R PMD Link Partner Coefficient Update Registers This
+ * register implements MDIO register 1.152 of 802.3-2012 Section 5 CL45
+ * for 10GBASE-R and and of 802.3by-2016 CL45 for 25GBASE-R. Note that
+ * for 10G, 25G LN0_ only is used.  It implements  MDIO registers
+ * 1.1100-1.1103 for all other BASE-R modes (40G, 50G, 100G) per
+ * 802.3bj-2014 CL45. Note that for 50G LN0_ and LN1_ only are used.  The
+ * register is automatically cleared at the start of training. Each field
+ * reflects the contents of the coefficient update field in the lane's
+ * most recently received training frame. This register should not be
+ * written when link training is enabled, i.e. when
+ * CGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] is set. The lane fields in this
+ * register are indexed by logical PCS lane ID.
+ */
+union cavm_cgxx_spux_br_pmd_lp_cup {
+	u64 u;
+	struct cavm_cgxx_spux_br_pmd_lp_cup_s {
+		u64 ln0_cup                          : 16;
+		u64 ln1_cup                          : 16;
+		u64 ln2_cup                          : 16;
+		u64 ln3_cup                          : 16;
+	} s;
+	/* struct cavm_cgxx_spux_br_pmd_lp_cup_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_BR_PMD_LP_CUP(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_BR_PMD_LP_CUP(u64 a)
+{
+	return 0x100b8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_br_pmd_lp_rep
+ *
+ * CGX SPU BASE-R PMD Link Partner Status Report Registers This register
+ * implements MDIO register 1.153 of 802.3-2012 Section 5 CL45 for
+ * 10GBASE-R and and of 802.3by-2016 CL45 for 25GBASE-R. Note that for
+ * 10G, 25G LN0_ only is used.  It implements  MDIO registers
+ * 1.1200-1.1203 for all other BASE-R modes (40G, 50G, 100G) per
+ * 802.3bj-2014 CL45. Note that for 50G LN0_ and LN1_ only are used.  The
+ * register is automatically cleared at the start of training. Each field
+ * reflects the contents of the coefficient update field in the lane's
+ * most recently received training frame. This register should not be
+ * written when link training is enabled, i.e. when
+ * CGX()_SPU()_BR_PMD_CONTROL[TRAIN_EN] is set. The lane fields in this
+ * register are indexed by logical PCS lane ID.
+ */
+union cavm_cgxx_spux_br_pmd_lp_rep {
+	u64 u;
+	struct cavm_cgxx_spux_br_pmd_lp_rep_s {
+		u64 ln0_rep                          : 16;
+		u64 ln1_rep                          : 16;
+		u64 ln2_rep                          : 16;
+		u64 ln3_rep                          : 16;
+	} s;
+	/* struct cavm_cgxx_spux_br_pmd_lp_rep_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_BR_PMD_LP_REP(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_BR_PMD_LP_REP(u64 a)
+{
+	return 0x100c0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_br_pmd_status
+ *
+ * CGX SPU BASE-R PMD Status Registers The lane fields in this register
+ * are indexed by logical PCS lane ID. The lane 0 field (LN0_*) is valid
+ * for 10GBASE-R, 25GBASE-R, 40GBASE-R, 50GBASE-R and 100GBASE-R. The
+ * lane 1 field (LN1_*) is valid for 40GBASE-R, 50GBASE-R and 100GBASE-R.
+ * The remaining fields (LN2_*, LN3_*) are only valid for 40GBASE-R and
+ * 100GBASE-R.
+ */
+union cavm_cgxx_spux_br_pmd_status {
+	u64 u;
+	struct cavm_cgxx_spux_br_pmd_status_s {
+		u64 ln0_train_status                 : 4;
+		u64 ln1_train_status                 : 4;
+		u64 ln2_train_status                 : 4;
+		u64 ln3_train_status                 : 4;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_spux_br_pmd_status_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_BR_PMD_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_BR_PMD_STATUS(u64 a)
+{
+	return 0x100b0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_br_status1
+ *
+ * CGX SPU BASE-R Status 1 Registers
+ */
+union cavm_cgxx_spux_br_status1 {
+	u64 u;
+	struct cavm_cgxx_spux_br_status1_s {
+		u64 blk_lock                         : 1;
+		u64 hi_ber                           : 1;
+		u64 prbs31                           : 1;
+		u64 prbs9                            : 1;
+		u64 reserved_4_11                    : 8;
+		u64 rcv_lnk                          : 1;
+		u64 reserved_13_63                   : 51;
+	} s;
+	/* struct cavm_cgxx_spux_br_status1_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_BR_STATUS1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_BR_STATUS1(u64 a)
+{
+	return 0x10030 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_br_status2
+ *
+ * CGX SPU BASE-R Status 2 Registers This register implements a
+ * combination of the following IEEE 802.3 registers: * BASE-R PCS status
+ * 2 (MDIO address 3.33). * BASE-R BER high-order counter (MDIO address
+ * 3.44). * Errored-blocks high-order counter (MDIO address 3.45).  Note
+ * that the relative locations of some fields have been moved from IEEE
+ * 802.3 in order to make the register layout more software friendly: the
+ * BER counter high-order and low-order bits from sections 3.44 and 3.33
+ * have been combined into the contiguous, 22-bit [BER_CNT] field;
+ * likewise, the errored-blocks counter high-order and low-order bits
+ * from section 3.45 have been combined into the contiguous, 22-bit
+ * [ERR_BLKS] field.
+ */
+union cavm_cgxx_spux_br_status2 {
+	u64 u;
+	struct cavm_cgxx_spux_br_status2_s {
+		u64 reserved_0_13                    : 14;
+		u64 latched_ber                      : 1;
+		u64 latched_lock                     : 1;
+		u64 ber_cnt                          : 22;
+		u64 reserved_38_39                   : 2;
+		u64 err_blks                         : 22;
+		u64 reserved_62_63                   : 2;
+	} s;
+	/* struct cavm_cgxx_spux_br_status2_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_BR_STATUS2(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_BR_STATUS2(u64 a)
+{
+	return 0x10038 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_br_tp_control
+ *
+ * CGX SPU BASE-R Test-Pattern Control Registers Refer to the test
+ * pattern methodology described in 802.3 sections 49.2.8 and 82.2.10.
+ */
+union cavm_cgxx_spux_br_tp_control {
+	u64 u;
+	struct cavm_cgxx_spux_br_tp_control_s {
+		u64 dp_sel                           : 1;
+		u64 tp_sel                           : 1;
+		u64 rx_tp_en                         : 1;
+		u64 tx_tp_en                         : 1;
+		u64 prbs31_tx                        : 1;
+		u64 prbs31_rx                        : 1;
+		u64 prbs9_tx                         : 1;
+		u64 scramble_tp                      : 2;
+		u64 pr_tp_data_type                  : 1;
+		u64 reserved_10_63                   : 54;
+	} s;
+	/* struct cavm_cgxx_spux_br_tp_control_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_BR_TP_CONTROL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_BR_TP_CONTROL(u64 a)
+{
+	return 0x10040 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_br_tp_err_cnt
+ *
+ * CGX SPU BASE-R Test-Pattern Error-Count Registers This register
+ * provides the BASE-R PCS test-pattern error counter.
+ */
+union cavm_cgxx_spux_br_tp_err_cnt {
+	u64 u;
+	struct cavm_cgxx_spux_br_tp_err_cnt_s {
+		u64 err_cnt                          : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_spux_br_tp_err_cnt_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_BR_TP_ERR_CNT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_BR_TP_ERR_CNT(u64 a)
+{
+	return 0x10048 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_br_tp_seed_a
+ *
+ * CGX SPU BASE-R Test-Pattern Seed A Registers Refer to the test pattern
+ * methodology described in 802.3 sections 49.2.8 and 82.2.10.
+ */
+union cavm_cgxx_spux_br_tp_seed_a {
+	u64 u;
+	struct cavm_cgxx_spux_br_tp_seed_a_s {
+		u64 tp_seed_a                        : 58;
+		u64 reserved_58_63                   : 6;
+	} s;
+	/* struct cavm_cgxx_spux_br_tp_seed_a_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_BR_TP_SEED_A(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_BR_TP_SEED_A(u64 a)
+{
+	return 0x10060 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_br_tp_seed_b
+ *
+ * CGX SPU BASE-R Test-Pattern Seed B Registers Refer to the test pattern
+ * methodology described in 802.3 sections 49.2.8 and 82.2.10.
+ */
+union cavm_cgxx_spux_br_tp_seed_b {
+	u64 u;
+	struct cavm_cgxx_spux_br_tp_seed_b_s {
+		u64 tp_seed_b                        : 58;
+		u64 reserved_58_63                   : 6;
+	} s;
+	/* struct cavm_cgxx_spux_br_tp_seed_b_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_BR_TP_SEED_B(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_BR_TP_SEED_B(u64 a)
+{
+	return 0x10068 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_bx_status
+ *
+ * CGX SPU BASE-X Status Registers
+ */
+union cavm_cgxx_spux_bx_status {
+	u64 u;
+	struct cavm_cgxx_spux_bx_status_s {
+		u64 lsync                            : 4;
+		u64 reserved_4_10                    : 7;
+		u64 pattst                           : 1;
+		u64 alignd                           : 1;
+		u64 reserved_13_63                   : 51;
+	} s;
+	/* struct cavm_cgxx_spux_bx_status_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_BX_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_BX_STATUS(u64 a)
+{
+	return 0x10028 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_control1
+ *
+ * CGX SPU Control 1 Registers
+ */
+union cavm_cgxx_spux_control1 {
+	u64 u;
+	struct cavm_cgxx_spux_control1_s {
+		u64 reserved_0_1                     : 2;
+		u64 spd                              : 4;
+		u64 spdsel0                          : 1;
+		u64 reserved_7_10                    : 4;
+		u64 lo_pwr                           : 1;
+		u64 reserved_12                      : 1;
+		u64 spdsel1                          : 1;
+		u64 loopbck                          : 1;
+		u64 reset                            : 1;
+		u64 usxgmii_type                     : 3;
+		u64 usxgmii_rate                     : 3;
+		u64 reserved_22_63                   : 42;
+	} s;
+	/* struct cavm_cgxx_spux_control1_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_CONTROL1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_CONTROL1(u64 a)
+{
+	return 0x10000 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_control2
+ *
+ * CGX SPU Control 2 Registers
+ */
+union cavm_cgxx_spux_control2 {
+	u64 u;
+	struct cavm_cgxx_spux_control2_s {
+		u64 pcs_type                         : 4;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cavm_cgxx_spux_control2_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_CONTROL2(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_CONTROL2(u64 a)
+{
+	return 0x10018 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_fec_abil
+ *
+ * CGX SPU Forward Error Correction Ability Registers
+ */
+union cavm_cgxx_spux_fec_abil {
+	u64 u;
+	struct cavm_cgxx_spux_fec_abil_s {
+		u64 fec_abil                         : 1;
+		u64 err_abil                         : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cavm_cgxx_spux_fec_abil_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_FEC_ABIL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_FEC_ABIL(u64 a)
+{
+	return 0x100d8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_fec_control
+ *
+ * CGX SPU Forward Error Correction Control Registers
+ */
+union cavm_cgxx_spux_fec_control {
+	u64 u;
+	struct cavm_cgxx_spux_fec_control_s {
+		u64 fec_en                           : 2;
+		u64 err_en                           : 1;
+		u64 fec_byp_ind_en                   : 1;
+		u64 fec_byp_cor_en                   : 1;
+		u64 reserved_5_63                    : 59;
+	} s;
+	/* struct cavm_cgxx_spux_fec_control_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_FEC_CONTROL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_FEC_CONTROL(u64 a)
+{
+	return 0x100e0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_fec_ln#_rsfec_err
+ *
+ * CGX SPU Reed-Solomon FEC Symbol Error Counter for FEC Lanes 0-3
+ * Registers This register is valid only when Reed-Solomon FEC is
+ * enabled. The symbol error counters are defined in 802.3 section
+ * 91.6.11 (for 100G and extended to 50G) and 802.3by-2016 section
+ * 108.6.9 (for 25G and extended to USXGMII). The counter is reset to all
+ * zeros when the register is read, and held at all ones in case of
+ * overflow.  The reset operation takes precedence over the increment
+ * operation; if the register is read on the same clock cycle as an
+ * increment operation, the counter is reset to all zeros and the
+ * increment operation is lost. The counters are writable for test
+ * purposes, rather than read-only as specified in IEEE 802.3.
+ */
+union cavm_cgxx_spux_fec_lnx_rsfec_err {
+	u64 u;
+	struct cavm_cgxx_spux_fec_lnx_rsfec_err_s {
+		u64 symb_err_cnt                     : 32;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cavm_cgxx_spux_fec_lnx_rsfec_err_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_FEC_LNX_RSFEC_ERR(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_FEC_LNX_RSFEC_ERR(u64 a, u64 b)
+{
+	return 0x10900 + 0x40000 * a + 8 * b;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_int
+ *
+ * CGX SPU Interrupt Registers
+ */
+union cavm_cgxx_spux_int {
+	u64 u;
+	struct cavm_cgxx_spux_int_s {
+		u64 rx_link_up                       : 1;
+		u64 rx_link_down                     : 1;
+		u64 err_blk                          : 1;
+		u64 bitlckls                         : 1;
+		u64 synlos                           : 1;
+		u64 algnlos                          : 1;
+		u64 dbg_sync                         : 1;
+		u64 bip_err                          : 1;
+		u64 fec_corr                         : 1;
+		u64 fec_uncorr                       : 1;
+		u64 an_page_rx                       : 1;
+		u64 an_link_good                     : 1;
+		u64 an_complete                      : 1;
+		u64 training_done                    : 1;
+		u64 training_failure                 : 1;
+		u64 fec_align_status                 : 1;
+		u64 rsfec_corr                       : 1;
+		u64 rsfec_uncorr                     : 1;
+		u64 hi_ser                           : 1;
+		u64 usx_an_lnk_st                    : 1;
+		u64 usx_an_cpt                       : 1;
+		u64 reserved_21_63                   : 43;
+	} s;
+	/* struct cavm_cgxx_spux_int_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_INT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_INT(u64 a)
+{
+	return 0x10220 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_int_ena_w1c
+ *
+ * CGX SPU Interrupt Enable Clear Registers This register clears
+ * interrupt enable bits.
+ */
+union cavm_cgxx_spux_int_ena_w1c {
+	u64 u;
+	struct cavm_cgxx_spux_int_ena_w1c_s {
+		u64 rx_link_up                       : 1;
+		u64 rx_link_down                     : 1;
+		u64 err_blk                          : 1;
+		u64 bitlckls                         : 1;
+		u64 synlos                           : 1;
+		u64 algnlos                          : 1;
+		u64 dbg_sync                         : 1;
+		u64 bip_err                          : 1;
+		u64 fec_corr                         : 1;
+		u64 fec_uncorr                       : 1;
+		u64 an_page_rx                       : 1;
+		u64 an_link_good                     : 1;
+		u64 an_complete                      : 1;
+		u64 training_done                    : 1;
+		u64 training_failure                 : 1;
+		u64 fec_align_status                 : 1;
+		u64 rsfec_corr                       : 1;
+		u64 rsfec_uncorr                     : 1;
+		u64 hi_ser                           : 1;
+		u64 usx_an_lnk_st                    : 1;
+		u64 usx_an_cpt                       : 1;
+		u64 reserved_21_63                   : 43;
+	} s;
+	/* struct cavm_cgxx_spux_int_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_INT_ENA_W1C(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_INT_ENA_W1C(u64 a)
+{
+	return 0x10230 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_int_ena_w1s
+ *
+ * CGX SPU Interrupt Enable Set Registers This register sets interrupt
+ * enable bits.
+ */
+union cavm_cgxx_spux_int_ena_w1s {
+	u64 u;
+	struct cavm_cgxx_spux_int_ena_w1s_s {
+		u64 rx_link_up                       : 1;
+		u64 rx_link_down                     : 1;
+		u64 err_blk                          : 1;
+		u64 bitlckls                         : 1;
+		u64 synlos                           : 1;
+		u64 algnlos                          : 1;
+		u64 dbg_sync                         : 1;
+		u64 bip_err                          : 1;
+		u64 fec_corr                         : 1;
+		u64 fec_uncorr                       : 1;
+		u64 an_page_rx                       : 1;
+		u64 an_link_good                     : 1;
+		u64 an_complete                      : 1;
+		u64 training_done                    : 1;
+		u64 training_failure                 : 1;
+		u64 fec_align_status                 : 1;
+		u64 rsfec_corr                       : 1;
+		u64 rsfec_uncorr                     : 1;
+		u64 hi_ser                           : 1;
+		u64 usx_an_lnk_st                    : 1;
+		u64 usx_an_cpt                       : 1;
+		u64 reserved_21_63                   : 43;
+	} s;
+	/* struct cavm_cgxx_spux_int_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_INT_ENA_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_INT_ENA_W1S(u64 a)
+{
+	return 0x10238 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_int_w1s
+ *
+ * CGX SPU Interrupt Set Registers This register sets interrupt bits.
+ */
+union cavm_cgxx_spux_int_w1s {
+	u64 u;
+	struct cavm_cgxx_spux_int_w1s_s {
+		u64 rx_link_up                       : 1;
+		u64 rx_link_down                     : 1;
+		u64 err_blk                          : 1;
+		u64 bitlckls                         : 1;
+		u64 synlos                           : 1;
+		u64 algnlos                          : 1;
+		u64 dbg_sync                         : 1;
+		u64 bip_err                          : 1;
+		u64 fec_corr                         : 1;
+		u64 fec_uncorr                       : 1;
+		u64 an_page_rx                       : 1;
+		u64 an_link_good                     : 1;
+		u64 an_complete                      : 1;
+		u64 training_done                    : 1;
+		u64 training_failure                 : 1;
+		u64 fec_align_status                 : 1;
+		u64 rsfec_corr                       : 1;
+		u64 rsfec_uncorr                     : 1;
+		u64 hi_ser                           : 1;
+		u64 usx_an_lnk_st                    : 1;
+		u64 usx_an_cpt                       : 1;
+		u64 reserved_21_63                   : 43;
+	} s;
+	/* struct cavm_cgxx_spux_int_w1s_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_INT_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_INT_W1S(u64 a)
+{
+	return 0x10228 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_ln#_br_bip_err_cnt
+ *
+ * CGX SPU 40,50,100GBASE-R BIP Error-Counter Registers This register
+ * implements the IEEE 802.3 BIP error-counter registers for PCS lanes
+ * 0-19 (3.200-3.203). It is valid only when the LPCS type is 40GBASE-R,
+ * 50GBASE-R, 100GBASE-R, (CGX()_CMR()_CONFIG[LMAC_TYPE]), and always
+ * returns 0x0 for all other LPCS types. The counters are indexed by the
+ * RX PCS lane number based on the alignment marker detected on each lane
+ * and captured in CGX()_SPU()_BR_LANE_MAP(). Each counter counts the BIP
+ * errors for its PCS lane, and is held at all ones in case of overflow.
+ * The counters are reset to all zeros when this register is read by
+ * software.  The reset operation takes precedence over the increment
+ * operation; if the register is read on the same clock cycle as an
+ * increment operation, the counter is reset to all zeros and the
+ * increment operation is lost. The counters are writable for test
+ * purposes, rather than read-only as specified in IEEE 802.3.
+ */
+union cavm_cgxx_spux_lnx_br_bip_err_cnt {
+	u64 u;
+	struct cavm_cgxx_spux_lnx_br_bip_err_cnt_s {
+		u64 bip_err_cnt                      : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_spux_lnx_br_bip_err_cnt_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_LNX_BR_BIP_ERR_CNT(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_LNX_BR_BIP_ERR_CNT(u64 a, u64 b)
+{
+	return 0x10500 + 0x40000 * a + 8 * b;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_ln#_fec_corr_blks
+ *
+ * CGX SPU FEC Corrected-Blocks Counters 0-19 Registers This register is
+ * valid only when the LPCS type is BASE-R
+ * (CGX()_CMR()_CONFIG[LMAC_TYPE]) and applies to BASE-R FEC and Reed-
+ * Solomon FEC (RS-FEC). When BASE-R FEC is enabled, the FEC corrected-
+ * block counters are defined in IEEE 802.3 section 74.8.4.1. Each
+ * corrected-blocks counter increments by one for a corrected FEC block,
+ * i.e. an FEC block that has been received with invalid parity on the
+ * associated PCS lane and has been corrected by the FEC decoder. The
+ * counter is reset to all zeros when the register is read, and held at
+ * all ones in case of overflow.  The reset operation takes precedence
+ * over the increment operation; if the register is read on the same
+ * clock cycle as an increment operation, the counter is reset to all
+ * zeros and the increment operation is lost. The counters are writable
+ * for test purposes, rather than read-only as specified in IEEE 802.3.
+ */
+union cavm_cgxx_spux_lnx_fec_corr_blks {
+	u64 u;
+	struct cavm_cgxx_spux_lnx_fec_corr_blks_s {
+		u64 ln_corr_blks                     : 32;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cavm_cgxx_spux_lnx_fec_corr_blks_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_LNX_FEC_CORR_BLKS(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_LNX_FEC_CORR_BLKS(u64 a, u64 b)
+{
+	return 0x10700 + 0x40000 * a + 8 * b;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_ln#_fec_uncorr_blks
+ *
+ * CGX SPU FEC Uncorrected-Blocks Counters 0-19 Registers This register
+ * is valid only when the LPCS type is BASE-R
+ * (CGX()_CMR()_CONFIG[LMAC_TYPE]) and applies to BASE-R FEC and Reed-
+ * Solomon FEC (RS-FEC). When BASE-R FEC is enabled, the FEC corrected-
+ * block counters are defined in IEEE 802.3 section 74.8.4.2. Each
+ * uncorrected-blocks counter increments by one for an uncorrected FEC
+ * block, i.e. an FEC block that has been received with invalid parity on
+ * the associated PCS lane and has not been corrected by the FEC decoder.
+ * The counter is reset to all zeros when the register is read, and held
+ * at all ones in case of overflow.  The reset operation takes precedence
+ * over the increment operation; if the register is read on the same
+ * clock cycle as an increment operation, the counter is reset to all
+ * zeros and the increment operation is lost. The counters are writable
+ * for test purposes, rather than read-only as specified in IEEE 802.3.
+ */
+union cavm_cgxx_spux_lnx_fec_uncorr_blks {
+	u64 u;
+	struct cavm_cgxx_spux_lnx_fec_uncorr_blks_s {
+		u64 ln_uncorr_blks                   : 32;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cavm_cgxx_spux_lnx_fec_uncorr_blks_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_LNX_FEC_UNCORR_BLKS(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_LNX_FEC_UNCORR_BLKS(u64 a, u64 b)
+{
+	return 0x10800 + 0x40000 * a + 8 * b;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_lpcs_states
+ *
+ * CGX SPU BASE-X Transmit/Receive States Registers
+ */
+union cavm_cgxx_spux_lpcs_states {
+	u64 u;
+	struct cavm_cgxx_spux_lpcs_states_s {
+		u64 deskew_sm                        : 3;
+		u64 reserved_3                       : 1;
+		u64 deskew_am_found                  : 20;
+		u64 bx_rx_sm                         : 2;
+		u64 reserved_26_27                   : 2;
+		u64 br_rx_sm                         : 3;
+		u64 reserved_31_63                   : 33;
+	} s;
+	/* struct cavm_cgxx_spux_lpcs_states_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_LPCS_STATES(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_LPCS_STATES(u64 a)
+{
+	return 0x10208 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_misc_control
+ *
+ * CGX SPU Miscellaneous Control Registers "* RX logical PCS lane
+ * polarity vector \<3:0\> = [XOR_RXPLRT]\<3:0\> ^ {4{[RXPLRT]}}. * TX
+ * logical PCS lane polarity vector \<3:0\> = [XOR_TXPLRT]\<3:0\> ^
+ * {4{[TXPLRT]}}.  In short, keep [RXPLRT] and [TXPLRT] cleared, and use
+ * [XOR_RXPLRT] and [XOR_TXPLRT] fields to define the polarity per
+ * logical PCS lane. Only bit 0 of vector is used for 10GBASE-R, and only
+ * bits 1:0 of vector are used for RXAUI."
+ */
+union cavm_cgxx_spux_misc_control {
+	u64 u;
+	struct cavm_cgxx_spux_misc_control_s {
+		u64 txplrt                           : 1;
+		u64 rxplrt                           : 1;
+		u64 xor_txplrt                       : 4;
+		u64 xor_rxplrt                       : 4;
+		u64 intlv_rdisp                      : 1;
+		u64 skip_after_term                  : 1;
+		u64 rx_packet_dis                    : 1;
+		u64 rx_edet_signal_ok                : 1;
+		u64 reserved_14_63                   : 50;
+	} s;
+	/* struct cavm_cgxx_spux_misc_control_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_MISC_CONTROL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_MISC_CONTROL(u64 a)
+{
+	return 0x10218 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_rsfec_corr
+ *
+ * CGX SPU Reed-Solomon FEC Corrected Codeword Counter Register This
+ * register implements the IEEE 802.3 RS-FEC corrected codewords counter
+ * described in 802.3 section 91.6.8 (for 100G and extended to 50G) and
+ * 802.3by-2016 section 108.6.7 (for 25G and extended to USXGMII).
+ */
+union cavm_cgxx_spux_rsfec_corr {
+	u64 u;
+	struct cavm_cgxx_spux_rsfec_corr_s {
+		u64 cw_cnt                           : 32;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cavm_cgxx_spux_rsfec_corr_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_RSFEC_CORR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_RSFEC_CORR(u64 a)
+{
+	return 0x10088 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_rsfec_status
+ *
+ * CGX SPU Reed-Solomon FEC Status Registers This register implements the
+ * IEEE 802.3 RS-FEC status and lane mapping registers as described in
+ * 802.3 section 91.6 (for 100G and extended to 50G) and 802.3by-2016
+ * section 108-6 (for 25G and extended to USXGMII).
+ */
+union cavm_cgxx_spux_rsfec_status {
+	u64 u;
+	struct cavm_cgxx_spux_rsfec_status_s {
+		u64 fec_lane_mapping                 : 8;
+		u64 fec_align_status                 : 1;
+		u64 amps_lock                        : 4;
+		u64 hi_ser                           : 1;
+		u64 fec_byp_ind_abil                 : 1;
+		u64 fec_byp_cor_abil                 : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_spux_rsfec_status_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_RSFEC_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_RSFEC_STATUS(u64 a)
+{
+	return 0x10080 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_rsfec_uncorr
+ *
+ * CGX SPU Reed-Solomon FEC Uncorrected Codeword Counter Register This
+ * register implements the IEEE 802.3 RS-FEC uncorrected codewords
+ * counter described in 802.3 section 91.6.9 (for 100G and extended to
+ * 50G) and 802.3by-2016 section 108.6.8 (for 25G and extended to
+ * USXGMII).
+ */
+union cavm_cgxx_spux_rsfec_uncorr {
+	u64 u;
+	struct cavm_cgxx_spux_rsfec_uncorr_s {
+		u64 cw_cnt                           : 32;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cavm_cgxx_spux_rsfec_uncorr_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_RSFEC_UNCORR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_RSFEC_UNCORR(u64 a)
+{
+	return 0x10090 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_rx_eee_wake
+ *
+ * INTERNAL: CGX SPU  RX EEE Wake Error Counter  Registers  Reserved.
+ * Internal: A counter that is incremented each time that the LPI receive
+ * state diagram enters the RX_WTF state indicating that a wake time
+ * fault has been detected.
+ */
+union cavm_cgxx_spux_rx_eee_wake {
+	u64 u;
+	struct cavm_cgxx_spux_rx_eee_wake_s {
+		u64 wtf_error_counter                : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_spux_rx_eee_wake_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_RX_EEE_WAKE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_RX_EEE_WAKE(u64 a)
+{
+	return 0x103e0 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_rx_lpi_timing
+ *
+ * INTERNAL: CGX SPU RX EEE LPI Timing Parameters Registers  Reserved.
+ * Internal: This register specifies receiver LPI timing parameters Tqr,
+ * Twr and Twtf.
+ */
+union cavm_cgxx_spux_rx_lpi_timing {
+	u64 u;
+	struct cavm_cgxx_spux_rx_lpi_timing_s {
+		u64 twtf                             : 20;
+		u64 twr                              : 20;
+		u64 tqr                              : 20;
+		u64 reserved_60_61                   : 2;
+		u64 rx_lpi_fw                        : 1;
+		u64 rx_lpi_en                        : 1;
+	} s;
+	/* struct cavm_cgxx_spux_rx_lpi_timing_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_RX_LPI_TIMING(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_RX_LPI_TIMING(u64 a)
+{
+	return 0x103c0 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_rx_lpi_timing2
+ *
+ * INTERNAL: CGX SPU RX EEE LPI Timing2 Parameters Registers  Reserved.
+ * Internal: This register specifies receiver LPI timing parameters
+ * hold_off_timer.
+ */
+union cavm_cgxx_spux_rx_lpi_timing2 {
+	u64 u;
+	struct cavm_cgxx_spux_rx_lpi_timing2_s {
+		u64 hold_off_timer                   : 20;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct cavm_cgxx_spux_rx_lpi_timing2_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_RX_LPI_TIMING2(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_RX_LPI_TIMING2(u64 a)
+{
+	return 0x10420 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_rx_mrk_cnt
+ *
+ * CGX SPU Receiver Marker Interval Count Control Registers
+ */
+union cavm_cgxx_spux_rx_mrk_cnt {
+	u64 u;
+	struct cavm_cgxx_spux_rx_mrk_cnt_s {
+		u64 mrk_cnt                          : 20;
+		u64 reserved_20_43                   : 24;
+		u64 by_mrk_100g                      : 1;
+		u64 reserved_45_47                   : 3;
+		u64 ram_mrk_cnt                      : 8;
+		u64 reserved_56_63                   : 8;
+	} s;
+	/* struct cavm_cgxx_spux_rx_mrk_cnt_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_RX_MRK_CNT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_RX_MRK_CNT(u64 a)
+{
+	return 0x103a0 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_spd_abil
+ *
+ * CGX SPU PCS Speed Ability Registers
+ */
+union cavm_cgxx_spux_spd_abil {
+	u64 u;
+	struct cavm_cgxx_spux_spd_abil_s {
+		u64 tengb                            : 1;
+		u64 tenpasst                         : 1;
+		u64 usxgmii                          : 1;
+		u64 twentyfivegb                     : 1;
+		u64 fortygb                          : 1;
+		u64 fiftygb                          : 1;
+		u64 hundredgb                        : 1;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct cavm_cgxx_spux_spd_abil_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_SPD_ABIL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_SPD_ABIL(u64 a)
+{
+	return 0x10010 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_status1
+ *
+ * CGX SPU Status 1 Registers
+ */
+union cavm_cgxx_spux_status1 {
+	u64 u;
+	struct cavm_cgxx_spux_status1_s {
+		u64 reserved_0                       : 1;
+		u64 lpable                           : 1;
+		u64 rcv_lnk                          : 1;
+		u64 reserved_3_6                     : 4;
+		u64 flt                              : 1;
+		u64 rx_lpi_indication                : 1;
+		u64 tx_lpi_indication                : 1;
+		u64 rx_lpi_received                  : 1;
+		u64 tx_lpi_received                  : 1;
+		u64 reserved_12_63                   : 52;
+	} s;
+	/* struct cavm_cgxx_spux_status1_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_STATUS1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_STATUS1(u64 a)
+{
+	return 0x10008 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_status2
+ *
+ * CGX SPU Status 2 Registers
+ */
+union cavm_cgxx_spux_status2 {
+	u64 u;
+	struct cavm_cgxx_spux_status2_s {
+		u64 tengb_r                          : 1;
+		u64 tengb_x                          : 1;
+		u64 tengb_w                          : 1;
+		u64 tengb_t                          : 1;
+		u64 usxgmii_r                        : 1;
+		u64 twentyfivegb_r                   : 1;
+		u64 fortygb_r                        : 1;
+		u64 fiftygb_r                        : 1;
+		u64 hundredgb_r                      : 1;
+		u64 reserved_9                       : 1;
+		u64 rcvflt                           : 1;
+		u64 xmtflt                           : 1;
+		u64 reserved_12_13                   : 2;
+		u64 dev                              : 2;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_spux_status2_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_STATUS2(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_STATUS2(u64 a)
+{
+	return 0x10020 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_tx_lpi_timing
+ *
+ * INTERNAL: CGX SPU TX EEE LPI Timing Parameters Registers  Reserved.
+ * Internal: Transmit LPI timing parameters Tsl, Tql and Tul
+ */
+union cavm_cgxx_spux_tx_lpi_timing {
+	u64 u;
+	struct cavm_cgxx_spux_tx_lpi_timing_s {
+		u64 tql                              : 19;
+		u64 reserved_19_31                   : 13;
+		u64 tul                              : 12;
+		u64 reserved_44_47                   : 4;
+		u64 tsl                              : 12;
+		u64 reserved_60                      : 1;
+		u64 tx_lpi_ignore_twl                : 1;
+		u64 tx_lpi_fw                        : 1;
+		u64 tx_lpi_en                        : 1;
+	} s;
+	/* struct cavm_cgxx_spux_tx_lpi_timing_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_TX_LPI_TIMING(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_TX_LPI_TIMING(u64 a)
+{
+	return 0x10400 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_tx_lpi_timing2
+ *
+ * INTERNAL: CGX SPU TX EEE LPI Timing2 Parameters Registers  Reserved.
+ * Internal: This register specifies transmit LPI timer parameters.
+ */
+union cavm_cgxx_spux_tx_lpi_timing2 {
+	u64 u;
+	struct cavm_cgxx_spux_tx_lpi_timing2_s {
+		u64 t1u                              : 8;
+		u64 reserved_8_11                    : 4;
+		u64 twl                              : 12;
+		u64 reserved_24_31                   : 8;
+		u64 twl2                             : 12;
+		u64 reserved_44_47                   : 4;
+		u64 tbyp                             : 12;
+		u64 reserved_60_63                   : 4;
+	} s;
+	/* struct cavm_cgxx_spux_tx_lpi_timing2_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_TX_LPI_TIMING2(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_TX_LPI_TIMING2(u64 a)
+{
+	return 0x10440 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_tx_mrk_cnt
+ *
+ * CGX SPU Transmitter Marker Interval Count Control Registers
+ */
+union cavm_cgxx_spux_tx_mrk_cnt {
+	u64 u;
+	struct cavm_cgxx_spux_tx_mrk_cnt_s {
+		u64 mrk_cnt                          : 20;
+		u64 reserved_20_43                   : 24;
+		u64 by_mrk_100g                      : 1;
+		u64 reserved_45_47                   : 3;
+		u64 ram_mrk_cnt                      : 8;
+		u64 reserved_56_63                   : 8;
+	} s;
+	/* struct cavm_cgxx_spux_tx_mrk_cnt_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_TX_MRK_CNT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_TX_MRK_CNT(u64 a)
+{
+	return 0x10380 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_usx_an_adv
+ *
+ * CGX SPU USXGMII Autonegotiation Advertisement Registers Software
+ * programs this register with the contents of the AN-link code word base
+ * page to be transmitted during autonegotiation. Any write operations to
+ * this register prior to completion of autonegotiation should be
+ * followed by a renegotiation in order for the new values to take
+ * effect. Once autonegotiation has completed, software can examine this
+ * register along with CGX()_SPU()_USX_AN_ADV to determine the highest
+ * common denominator technology. The format for this register is from
+ * USXGMII Multiport specification section 1.1.2 Table 2.
+ */
+union cavm_cgxx_spux_usx_an_adv {
+	u64 u;
+	struct cavm_cgxx_spux_usx_an_adv_s {
+		u64 set                              : 1;
+		u64 reserved_1_6                     : 6;
+		u64 eee_clk_stop_abil                : 1;
+		u64 eee_abil                         : 1;
+		u64 spd                              : 3;
+		u64 dplx                             : 1;
+		u64 reserved_13_14                   : 2;
+		u64 lnk_st                           : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_spux_usx_an_adv_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_USX_AN_ADV(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_USX_AN_ADV(u64 a)
+{
+	return 0x101d0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_usx_an_control
+ *
+ * CGX SPU USXGMII Autonegotiation Control Register
+ */
+union cavm_cgxx_spux_usx_an_control {
+	u64 u;
+	struct cavm_cgxx_spux_usx_an_control_s {
+		u64 reserved_0_8                     : 9;
+		u64 rst_an                           : 1;
+		u64 reserved_10_11                   : 2;
+		u64 an_en                            : 1;
+		u64 reserved_13_14                   : 2;
+		u64 an_reset                         : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_spux_usx_an_control_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_USX_AN_CONTROL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_USX_AN_CONTROL(u64 a)
+{
+	return 0x101c0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_usx_an_expansion
+ *
+ * CGX SPU USXGMII Autonegotiation Expansion Register This register is
+ * only used to signal page reception.
+ */
+union cavm_cgxx_spux_usx_an_expansion {
+	u64 u;
+	struct cavm_cgxx_spux_usx_an_expansion_s {
+		u64 reserved_0                       : 1;
+		u64 an_page_received                 : 1;
+		u64 next_page_able                   : 1;
+		u64 reserved_3_63                    : 61;
+	} s;
+	/* struct cavm_cgxx_spux_usx_an_expansion_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_USX_AN_EXPANSION(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_USX_AN_EXPANSION(u64 a)
+{
+	return 0x101e0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_usx_an_flow_ctrl
+ *
+ * CGX SPU USXGMII Flow Control Registers This register is used by
+ * software to affect USXGMII AN hardware behavior.
+ */
+union cavm_cgxx_spux_usx_an_flow_ctrl {
+	u64 u;
+	struct cavm_cgxx_spux_usx_an_flow_ctrl_s {
+		u64 start_idle_detect                : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_cgxx_spux_usx_an_flow_ctrl_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_USX_AN_FLOW_CTRL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_USX_AN_FLOW_CTRL(u64 a)
+{
+	return 0x101e8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_usx_an_link_timer
+ *
+ * CGX SPU USXGMII Link Timer Registers This is the link timer register.
+ */
+union cavm_cgxx_spux_usx_an_link_timer {
+	u64 u;
+	struct cavm_cgxx_spux_usx_an_link_timer_s {
+		u64 count                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_spux_usx_an_link_timer_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_USX_AN_LINK_TIMER(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_USX_AN_LINK_TIMER(u64 a)
+{
+	return 0x101f0 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_usx_an_lp_abil
+ *
+ * CGX SPU USXGMII Autonegotiation Link-Partner Advertisement Registers
+ * This register captures the contents of the latest AN link code word
+ * base page received from the link partner during autonegotiation. This
+ * is register 5 per IEEE 802.3, Clause 37.
+ * CGX()_SPU()_USX_AN_EXPANSION[AN_PAGE_RECEIVED] is set when this
+ * register is updated by hardware.
+ */
+union cavm_cgxx_spux_usx_an_lp_abil {
+	u64 u;
+	struct cavm_cgxx_spux_usx_an_lp_abil_s {
+		u64 set                              : 1;
+		u64 reserved_1_6                     : 6;
+		u64 eee_clk_stop_abil                : 1;
+		u64 eee_abil                         : 1;
+		u64 spd                              : 3;
+		u64 dplx                             : 1;
+		u64 reserved_13_14                   : 2;
+		u64 lnk_st                           : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_cgxx_spux_usx_an_lp_abil_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_USX_AN_LP_ABIL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_USX_AN_LP_ABIL(u64 a)
+{
+	return 0x101d8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu#_usx_an_status
+ *
+ * CGX SPU USXGMII Autonegotiation Status Register
+ */
+union cavm_cgxx_spux_usx_an_status {
+	u64 u;
+	struct cavm_cgxx_spux_usx_an_status_s {
+		u64 extnd                            : 1;
+		u64 reserved_1                       : 1;
+		u64 lnk_st                           : 1;
+		u64 an_abil                          : 1;
+		u64 rmt_flt                          : 1;
+		u64 an_cpt                           : 1;
+		u64 reserved_6_63                    : 58;
+	} s;
+	/* struct cavm_cgxx_spux_usx_an_status_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPUX_USX_AN_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPUX_USX_AN_STATUS(u64 a)
+{
+	return 0x101c8 + 0x40000 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu_dbg_control
+ *
+ * CGX SPU Debug Control Registers
+ */
+union cavm_cgxx_spu_dbg_control {
+	u64 u;
+	struct cavm_cgxx_spu_dbg_control_s {
+		u64 marker_rxp                       : 15;
+		u64 reserved_15                      : 1;
+		u64 scramble_dis                     : 1;
+		u64 reserved_17_18                   : 2;
+		u64 br_pmd_train_soft_en             : 1;
+		u64 reserved_20_27                   : 8;
+		u64 timestamp_norm_dis               : 1;
+		u64 an_nonce_match_dis               : 1;
+		u64 br_ber_mon_dis                   : 1;
+		u64 reserved_31                      : 1;
+		u64 us_clk_period                    : 12;
+		u64 ms_clk_period                    : 12;
+		u64 reserved_56_63                   : 8;
+	} s;
+	/* struct cavm_cgxx_spu_dbg_control_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPU_DBG_CONTROL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPU_DBG_CONTROL(void)
+{
+	return 0x10300;
+}
+
+/**
+ * Register (RSL) cgx#_spu_sds#_skew_status
+ *
+ * CGX SPU SerDes Lane Skew Status Registers This register provides
+ * SerDes lane skew status. One register per physical SerDes lane.
+ */
+union cavm_cgxx_spu_sdsx_skew_status {
+	u64 u;
+	struct cavm_cgxx_spu_sdsx_skew_status_s {
+		u64 skew_status                      : 32;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cavm_cgxx_spu_sdsx_skew_status_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPU_SDSX_SKEW_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPU_SDSX_SKEW_STATUS(u64 a)
+{
+	return 0x10340 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu_sds#_states
+ *
+ * CGX SPU SerDes States Registers This register provides SerDes lane
+ * states. One register per physical SerDes lane.
+ */
+union cavm_cgxx_spu_sdsx_states {
+	u64 u;
+	struct cavm_cgxx_spu_sdsx_states_s {
+		u64 bx_sync_sm                       : 4;
+		u64 br_sh_cnt                        : 11;
+		u64 br_block_lock                    : 1;
+		u64 br_sh_invld_cnt                  : 7;
+		u64 reserved_23                      : 1;
+		u64 fec_sync_cnt                     : 4;
+		u64 fec_block_sync                   : 1;
+		u64 reserved_29                      : 1;
+		u64 an_rx_sm                         : 2;
+		u64 an_arb_sm                        : 3;
+		u64 reserved_35                      : 1;
+		u64 train_lock_bad_markers           : 3;
+		u64 train_lock_found_1st_marker      : 1;
+		u64 train_frame_lock                 : 1;
+		u64 train_code_viol                  : 1;
+		u64 train_sm                         : 3;
+		u64 reserved_45_47                   : 3;
+		u64 am_lock_sm                       : 2;
+		u64 am_lock_invld_cnt                : 2;
+		u64 reserved_52_63                   : 12;
+	} s;
+	/* struct cavm_cgxx_spu_sdsx_states_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPU_SDSX_STATES(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPU_SDSX_STATES(u64 a)
+{
+	return 0x10360 + 8 * a;
+}
+
+/**
+ * Register (RSL) cgx#_spu_usxgmii_control
+ *
+ * CGX SPU Common USXGMII Control Register This register is the common
+ * control register that enables USXGMII Mode. The fields in this
+ * register are preserved across any LMAC soft-resets. For an LMAC in
+ * soft- reset state in USXGMII mode, the CGX will transmit Remote Fault
+ * BASE-R blocks.
+ */
+union cavm_cgxx_spu_usxgmii_control {
+	u64 u;
+	struct cavm_cgxx_spu_usxgmii_control_s {
+		u64 enable                           : 1;
+		u64 usxgmii_type                     : 3;
+		u64 sds_id                           : 2;
+		u64 reserved_6_63                    : 58;
+	} s;
+	/* struct cavm_cgxx_spu_usxgmii_control_s cn; */
+};
+
+static inline u64 CAVM_CGXX_SPU_USXGMII_CONTROL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_CGXX_SPU_USXGMII_CONTROL(void)
+{
+	return 0x10920;
+}
+
+#endif /* __CAVM_CSRS_CGX_H__ */
diff --git a/drivers/net/octeontx2/cavm-csrs-lmt.h b/drivers/net/octeontx2/cavm-csrs-lmt.h
new file mode 100644
index 0000000..1a3ecae
--- /dev/null
+++ b/drivers/net/octeontx2/cavm-csrs-lmt.h
@@ -0,0 +1,61 @@
+#ifndef __CAVM_CSRS_LMT_H__
+#define __CAVM_CSRS_LMT_H__
+/* This file is auto-generated.  Do not edit */
+
+/***********************license start***********************************
+* Copyright (C) 2019 Marvell International Ltd.
+* SPDX-License-Identifier: BSD-3-Clause
+* https://spdx.org/licenses
+***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * Configuration and status register (CSR) address and type definitions for
+ * Cavium LMT.
+ *
+ * This file is auto generated.  Do not edit.
+ *
+ */
+
+/**
+ * Register (RVU_PFVF_BAR2) lmt_lf_lmtcancel
+ *
+ * RVU VF LMT Cancel Register
+ */
+union cavm_lmt_lf_lmtcancel {
+	u64 u;
+	struct cavm_lmt_lf_lmtcancel_s {
+		u64 data                             : 64;
+	} s;
+	/* struct cavm_lmt_lf_lmtcancel_s cn; */
+};
+
+static inline u64 CAVM_LMT_LF_LMTCANCEL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_LMT_LF_LMTCANCEL(void)
+{
+	return 0x400;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) lmt_lf_lmtline#
+ *
+ * RVU VF LMT Line Registers
+ */
+union cavm_lmt_lf_lmtlinex {
+	u64 u;
+	struct cavm_lmt_lf_lmtlinex_s {
+		u64 data                             : 64;
+	} s;
+	/* struct cavm_lmt_lf_lmtlinex_s cn; */
+};
+
+static inline u64 CAVM_LMT_LF_LMTLINEX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_LMT_LF_LMTLINEX(u64 a)
+{
+	return 0 + 8 * a;
+}
+
+#endif /* __CAVM_CSRS_LMT_H__ */
diff --git a/drivers/net/octeontx2/cavm-csrs-nix.h b/drivers/net/octeontx2/cavm-csrs-nix.h
new file mode 100644
index 0000000..a4618fe
--- /dev/null
+++ b/drivers/net/octeontx2/cavm-csrs-nix.h
@@ -0,0 +1,9556 @@
+#ifndef __CAVM_CSRS_NIX_H__
+#define __CAVM_CSRS_NIX_H__
+/* This file is auto-generated.  Do not edit */
+
+/***********************license start***********************************
+* Copyright (C) 2019 Marvell International Ltd.
+* SPDX-License-Identifier: BSD-3-Clause
+* https://spdx.org/licenses
+***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * Configuration and status register (CSR) address and type definitions for
+ * Cavium NIX.
+ *
+ * This file is auto generated.  Do not edit.
+ *
+ */
+
+/**
+ * Enumeration nix_af_int_vec_e
+ *
+ * NIX Admin Function Interrupt Vector Enumeration Enumerates the NIX AF
+ * MSI-X interrupt vectors.
+ */
+#define CAVM_NIX_AF_INT_VEC_E_AF_ERR (3)
+#define CAVM_NIX_AF_INT_VEC_E_AQ_DONE (2)
+#define CAVM_NIX_AF_INT_VEC_E_GEN (1)
+#define CAVM_NIX_AF_INT_VEC_E_POISON (4)
+#define CAVM_NIX_AF_INT_VEC_E_RVU (0)
+
+/**
+ * Enumeration nix_aq_comp_e
+ *
+ * NIX Completion Enumeration Enumerates the values of
+ * NIX_AQ_RES_S[COMPCODE].
+ */
+#define CAVM_NIX_AQ_COMP_E_CTX_FAULT (4)
+#define CAVM_NIX_AQ_COMP_E_CTX_POISON (3)
+#define CAVM_NIX_AQ_COMP_E_GOOD (1)
+#define CAVM_NIX_AQ_COMP_E_LOCKERR (5)
+#define CAVM_NIX_AQ_COMP_E_NOTDONE (0)
+#define CAVM_NIX_AQ_COMP_E_SQB_ALLOC_FAIL (6)
+#define CAVM_NIX_AQ_COMP_E_SWERR (2)
+
+/**
+ * Enumeration nix_aq_ctype_e
+ *
+ * NIX Context Type Enumeration Enumerates NIX_AQ_INST_S[CTYPE] values.
+ */
+#define CAVM_NIX_AQ_CTYPE_E_CQ (2)
+#define CAVM_NIX_AQ_CTYPE_E_DYNO (5)
+#define CAVM_NIX_AQ_CTYPE_E_MCE (3)
+#define CAVM_NIX_AQ_CTYPE_E_RQ (0)
+#define CAVM_NIX_AQ_CTYPE_E_RSS (4)
+#define CAVM_NIX_AQ_CTYPE_E_SQ (1)
+
+/**
+ * Enumeration nix_aq_instop_e
+ *
+ * NIX Admin Queue Opcode Enumeration Enumerates NIX_AQ_INST_S[OP]
+ * values.
+ */
+#define CAVM_NIX_AQ_INSTOP_E_INIT (1)
+#define CAVM_NIX_AQ_INSTOP_E_LOCK (4)
+#define CAVM_NIX_AQ_INSTOP_E_NOP (0)
+#define CAVM_NIX_AQ_INSTOP_E_READ (3)
+#define CAVM_NIX_AQ_INSTOP_E_UNLOCK (5)
+#define CAVM_NIX_AQ_INSTOP_E_WRITE (2)
+
+/**
+ * Enumeration nix_chan_e
+ *
+ * NIX Channel Number Enumeration Enumerates the receive and transmit
+ * channels, and values of NIX_RX_PARSE_S[CHAN],
+ * NIX_SQ_CTX_S[DEFAULT_CHAN]. CNXXXX implements a subset of these
+ * channels. Specifically, only channels for links enumerated by
+ * NIX_LINK_E are implemented.  Internal: P2X/X2P channel enumeration for
+ * t9x.
+ */
+#define CAVM_NIX_CHAN_E_CGXX_LMACX_CHX(a, b, c)	\
+	(0x800 + 0x100 * (a) + 0x10 * (b) + (c))
+#define CAVM_NIX_CHAN_E_LBKX_CHX(a, b) (0 + 0x100 * (a) + (b))
+#define CAVM_NIX_CHAN_E_RX(a) (0 + 0x100 * (a))
+#define CAVM_NIX_CHAN_E_SDP_CHX(a) (0x700 + (a))
+
+/**
+ * Enumeration nix_colorresult_e
+ *
+ * NIX Color Result Enumeration Enumerates the values of
+ * NIX_MEM_RESULT_S[COLOR], NIX_AF_TL1()_MD_DEBUG1[COLOR] and
+ * NIX_AF_TL1()_MD_DEBUG1[COLOR].
+ */
+#define CAVM_NIX_COLORRESULT_E_GREEN (0)
+#define CAVM_NIX_COLORRESULT_E_RED_DROP (3)
+#define CAVM_NIX_COLORRESULT_E_RED_SEND (2)
+#define CAVM_NIX_COLORRESULT_E_YELLOW (1)
+
+/**
+ * Enumeration nix_cqerrint_e
+ *
+ * NIX Completion Queue Interrupt Enumeration Enumerates the bit index of
+ * NIX_CQ_CTX_S[CQ_ERR_INT,CQ_ERR_INT_ENA].
+ */
+#define CAVM_NIX_CQERRINT_E_CQE_FAULT (2)
+#define CAVM_NIX_CQERRINT_E_DOOR_ERR (0)
+#define CAVM_NIX_CQERRINT_E_WR_FULL (1)
+
+/**
+ * Enumeration nix_intf_e
+ *
+ * NIX Interface Number Enumeration Enumerates the bit index of
+ * NIX_AF_STATUS[CALIBRATE_STATUS].
+ */
+#define CAVM_NIX_INTF_E_CGXX(a) (0 + (a))
+#define CAVM_NIX_INTF_E_LBKX(a) (3 + (a))
+#define CAVM_NIX_INTF_E_SDP (4)
+
+/**
+ * Enumeration nix_lf_int_vec_e
+ *
+ * NIX Local Function Interrupt Vector Enumeration Enumerates the NIX
+ * MSI-X interrupt vectors per LF.
+ */
+#define CAVM_NIX_LF_INT_VEC_E_CINTX(a) (0x40 + (a))
+#define CAVM_NIX_LF_INT_VEC_E_ERR_INT (0x81)
+#define CAVM_NIX_LF_INT_VEC_E_GINT (0x80)
+#define CAVM_NIX_LF_INT_VEC_E_POISON (0x82)
+#define CAVM_NIX_LF_INT_VEC_E_QINTX(a) (0 + (a))
+
+/**
+ * Enumeration nix_link_e
+ *
+ * NIX Link Number Enumeration Enumerates the receive and transmit links,
+ * and LINK index of NIX_AF_RX_LINK()_CFG, NIX_AF_RX_LINK()_WRR_CFG,
+ * NIX_AF_TX_LINK()_NORM_CREDIT, NIX_AF_TX_LINK()_EXPR_CREDIT,
+ * NIX_AF_TX_LINK()_HW_XOFF and NIX_AF_TX_LINK()_SW_XOFF,
+ * NIX_AF_TL3_TL2()_LINK()_CFG.
+ */
+#define CAVM_NIX_LINK_E_CGXX_LMACX(a, b) (0 + 4 * (a) + (b))
+#define CAVM_NIX_LINK_E_LBKX(a) (0xc + (a))
+#define CAVM_NIX_LINK_E_MC (0xe)
+#define CAVM_NIX_LINK_E_SDP (0xd)
+
+/**
+ * Enumeration nix_lsoalg_e
+ *
+ * NIX Large Send Offload Algorithm Enumeration Enumerates
+ * NIX_AF_LSO_FORMAT()_FIELD()[ALG] values. Specifies algorithm for
+ * modifying the associated LSO packet field.
+ */
+#define CAVM_NIX_LSOALG_E_ADD_OFFSET (3)
+#define CAVM_NIX_LSOALG_E_ADD_PAYLEN (2)
+#define CAVM_NIX_LSOALG_E_ADD_SEGNUM (1)
+#define CAVM_NIX_LSOALG_E_NOP (0)
+#define CAVM_NIX_LSOALG_E_TCP_FLAGS (4)
+
+/**
+ * Enumeration nix_maxsqesz_e
+ *
+ * NIX Maximum SQE Size Enumeration Enumerates the values of
+ * NIX_SQ_CTX_S[MAX_SQE_SIZE].
+ */
+#define CAVM_NIX_MAXSQESZ_E_W16 (0)
+#define CAVM_NIX_MAXSQESZ_E_W8 (1)
+
+/**
+ * Enumeration nix_mdtype_e
+ *
+ * NIX Meta Descriptor Type Enumeration Enumerates values of
+ * NIX_AF_MDQ()_MD_DEBUG[MD_TYPE].
+ */
+#define CAVM_NIX_MDTYPE_E_FLUSH (1)
+#define CAVM_NIX_MDTYPE_E_PMD (2)
+#define CAVM_NIX_MDTYPE_E_RSVD (0)
+
+/**
+ * Enumeration nix_mnqerr_e
+ *
+ * NIX Meta-Descriptor Enqueue Error Enumeration Enumerates
+ * NIX_LF_MNQ_ERR_DBG[ERRCODE] values.
+ */
+#define CAVM_NIX_MNQERR_E_CQ_QUERY_ERR (6)
+#define CAVM_NIX_MNQERR_E_LSO_ERR (5)
+#define CAVM_NIX_MNQERR_E_MAXLEN_ERR (8)
+#define CAVM_NIX_MNQERR_E_MAX_SQE_SIZE_ERR (7)
+#define CAVM_NIX_MNQERR_E_SQB_FAULT (2)
+#define CAVM_NIX_MNQERR_E_SQB_POISON (3)
+#define CAVM_NIX_MNQERR_E_SQE_SIZEM1_ZERO (9)
+#define CAVM_NIX_MNQERR_E_SQ_CTX_FAULT (0)
+#define CAVM_NIX_MNQERR_E_SQ_CTX_POISON (1)
+#define CAVM_NIX_MNQERR_E_TOTAL_ERR (4)
+
+/**
+ * Enumeration nix_ndc_rx_port_e
+ *
+ * NIX Receive NDC Port Enumeration Enumerates NIX receive NDC
+ * (NDC_IDX_E::NIX()_RX) ports and the PORT index of
+ * NDC_AF_PORT()_RT()_RW()_REQ_PC and NDC_AF_PORT()_RT()_RW()_LAT_PC.
+ */
+#define CAVM_NIX_NDC_RX_PORT_E_AQ (0)
+#define CAVM_NIX_NDC_RX_PORT_E_CINT (2)
+#define CAVM_NIX_NDC_RX_PORT_E_CQ (1)
+#define CAVM_NIX_NDC_RX_PORT_E_MC (3)
+#define CAVM_NIX_NDC_RX_PORT_E_PKT (4)
+#define CAVM_NIX_NDC_RX_PORT_E_RQ (5)
+
+/**
+ * Enumeration nix_ndc_tx_port_e
+ *
+ * NIX Transmit NDC Port Enumeration Enumerates NIX transmit NDC
+ * (NDC_IDX_E::NIX()_TX) ports and the PORT index of
+ * NDC_AF_PORT()_RT()_RW()_REQ_PC and NDC_AF_PORT()_RT()_RW()_LAT_PC.
+ */
+#define CAVM_NIX_NDC_TX_PORT_E_DEQ (3)
+#define CAVM_NIX_NDC_TX_PORT_E_DMA (4)
+#define CAVM_NIX_NDC_TX_PORT_E_ENQ (1)
+#define CAVM_NIX_NDC_TX_PORT_E_LMT (0)
+#define CAVM_NIX_NDC_TX_PORT_E_MNQ (2)
+#define CAVM_NIX_NDC_TX_PORT_E_XQE (5)
+
+/**
+ * Enumeration nix_re_opcode_e
+ *
+ * NIX Receive Error Opcode Enumeration Enumerates
+ * NIX_RX_PARSE_S[ERRCODE] values when NIX_RX_PARSE_S[ERRLEV] =
+ * NPC_ERRLEV_E::RE.
+ */
+#define CAVM_NIX_RE_OPCODE_E_OL2_LENMISM (0x12)
+#define CAVM_NIX_RE_OPCODE_E_OVERSIZE (0x11)
+#define CAVM_NIX_RE_OPCODE_E_RE_DMAPKT (0xf)
+#define CAVM_NIX_RE_OPCODE_E_RE_FCS (7)
+#define CAVM_NIX_RE_OPCODE_E_RE_FCS_RCV (8)
+#define CAVM_NIX_RE_OPCODE_E_RE_JABBER (2)
+#define CAVM_NIX_RE_OPCODE_E_RE_NONE (0)
+#define CAVM_NIX_RE_OPCODE_E_RE_PARTIAL (1)
+#define CAVM_NIX_RE_OPCODE_E_RE_RX_CTL (0xb)
+#define CAVM_NIX_RE_OPCODE_E_RE_SKIP (0xc)
+#define CAVM_NIX_RE_OPCODE_E_RE_TERMINATE (9)
+#define CAVM_NIX_RE_OPCODE_E_UNDERSIZE (0x10)
+
+/**
+ * Enumeration nix_redalg_e
+ *
+ * NIX Red Algorithm Enumeration Enumerates the different algorithms of
+ * NIX_SEND_EXT_S[SHP_RA].
+ */
+#define CAVM_NIX_REDALG_E_DISCARD (3)
+#define CAVM_NIX_REDALG_E_SEND (1)
+#define CAVM_NIX_REDALG_E_STALL (2)
+#define CAVM_NIX_REDALG_E_STD (0)
+
+/**
+ * Enumeration nix_rqint_e
+ *
+ * NIX Receive Queue Interrupt Enumeration Enumerates the bit index of
+ * NIX_RQ_CTX_S[RQ_INT,RQ_INT_ENA].
+ */
+#define CAVM_NIX_RQINT_E_DROP (0)
+#define CAVM_NIX_RQINT_E_RX(a) (0 + (a))
+#define CAVM_NIX_RQINT_E_RED (1)
+
+/**
+ * Enumeration nix_rx_actionop_e
+ *
+ * NIX Receive Action Opcode Enumeration Enumerates the values of
+ * NIX_RX_ACTION_S[OP].
+ */
+#define CAVM_NIX_RX_ACTIONOP_E_DROP (0)
+#define CAVM_NIX_RX_ACTIONOP_E_MCAST (3)
+#define CAVM_NIX_RX_ACTIONOP_E_MIRROR (6)
+#define CAVM_NIX_RX_ACTIONOP_E_PF_FUNC_DROP (5)
+#define CAVM_NIX_RX_ACTIONOP_E_RSS (4)
+#define CAVM_NIX_RX_ACTIONOP_E_UCAST (1)
+#define CAVM_NIX_RX_ACTIONOP_E_UCAST_IPSEC (2)
+
+/**
+ * Enumeration nix_rx_mcop_e
+ *
+ * NIX Receive Multicast/Mirror Opcode Enumeration Enumerates the values
+ * of NIX_RX_MCE_S[OP].
+ */
+#define CAVM_NIX_RX_MCOP_E_RQ (0)
+#define CAVM_NIX_RX_MCOP_E_RSS (1)
+
+/**
+ * Enumeration nix_rx_perrcode_e
+ *
+ * NIX Receive Protocol Error Code Enumeration Enumerates
+ * NIX_RX_PARSE_S[ERRCODE] values when NIX_RX_PARSE_S[ERRLEV] =
+ * NPC_ERRLEV_E::NIX.
+ */
+#define CAVM_NIX_RX_PERRCODE_E_BUFS_OFLOW (0xa)
+#define CAVM_NIX_RX_PERRCODE_E_DATA_FAULT (8)
+#define CAVM_NIX_RX_PERRCODE_E_IL3_LEN (0x20)
+#define CAVM_NIX_RX_PERRCODE_E_IL4_CHK (0x22)
+#define CAVM_NIX_RX_PERRCODE_E_IL4_LEN (0x21)
+#define CAVM_NIX_RX_PERRCODE_E_IL4_PORT (0x23)
+#define CAVM_NIX_RX_PERRCODE_E_MCAST_FAULT (4)
+#define CAVM_NIX_RX_PERRCODE_E_MCAST_POISON (6)
+#define CAVM_NIX_RX_PERRCODE_E_MEMOUT (9)
+#define CAVM_NIX_RX_PERRCODE_E_MIRROR_FAULT (5)
+#define CAVM_NIX_RX_PERRCODE_E_MIRROR_POISON (7)
+#define CAVM_NIX_RX_PERRCODE_E_NPC_RESULT_ERR (2)
+#define CAVM_NIX_RX_PERRCODE_E_OL3_LEN (0x10)
+#define CAVM_NIX_RX_PERRCODE_E_OL4_CHK (0x12)
+#define CAVM_NIX_RX_PERRCODE_E_OL4_LEN (0x11)
+#define CAVM_NIX_RX_PERRCODE_E_OL4_PORT (0x13)
+
+/**
+ * Enumeration nix_send_status_e
+ *
+ * NIX Send Completion Status Enumeration Enumerates values of
+ * NIX_SEND_COMP_S[STATUS] and NIX_LF_SEND_ERR_DBG[ERRCODE].
+ */
+#define CAVM_NIX_SEND_STATUS_E_DATA_FAULT (0x16)
+#define CAVM_NIX_SEND_STATUS_E_DATA_POISON (0x17)
+#define CAVM_NIX_SEND_STATUS_E_GOOD (0)
+#define CAVM_NIX_SEND_STATUS_E_INVALID_SUBDC (0x14)
+#define CAVM_NIX_SEND_STATUS_E_JUMP_FAULT (7)
+#define CAVM_NIX_SEND_STATUS_E_JUMP_POISON (8)
+#define CAVM_NIX_SEND_STATUS_E_LOCK_VIOL (0x21)
+#define CAVM_NIX_SEND_STATUS_E_NPC_DROP_ACTION (0x20)
+#define CAVM_NIX_SEND_STATUS_E_NPC_MCAST_ABORT (0x24)
+#define CAVM_NIX_SEND_STATUS_E_NPC_MCAST_CHAN_ERR (0x23)
+#define CAVM_NIX_SEND_STATUS_E_NPC_UCAST_CHAN_ERR (0x22)
+#define CAVM_NIX_SEND_STATUS_E_NPC_VTAG_PTR_ERR (0x25)
+#define CAVM_NIX_SEND_STATUS_E_NPC_VTAG_SIZE_ERR (0x26)
+#define CAVM_NIX_SEND_STATUS_E_SEND_CRC_ERR (0x10)
+#define CAVM_NIX_SEND_STATUS_E_SEND_EXT_ERR (6)
+#define CAVM_NIX_SEND_STATUS_E_SEND_HDR_ERR (5)
+#define CAVM_NIX_SEND_STATUS_E_SEND_IMM_ERR (0x11)
+#define CAVM_NIX_SEND_STATUS_E_SEND_MEM_ERR (0x13)
+#define CAVM_NIX_SEND_STATUS_E_SEND_MEM_FAULT (0x27)
+#define CAVM_NIX_SEND_STATUS_E_SEND_SG_ERR (0x12)
+#define CAVM_NIX_SEND_STATUS_E_SQB_FAULT (3)
+#define CAVM_NIX_SEND_STATUS_E_SQB_POISON (4)
+#define CAVM_NIX_SEND_STATUS_E_SQ_CTX_FAULT (1)
+#define CAVM_NIX_SEND_STATUS_E_SQ_CTX_POISON (2)
+#define CAVM_NIX_SEND_STATUS_E_SUBDC_ORDER_ERR (0x15)
+
+/**
+ * Enumeration nix_sendcrcalg_e
+ *
+ * NIX Send CRC Algorithm Enumeration Enumerates the CRC algorithm used,
+ * see NIX_SEND_CRC_S[ALG].
+ */
+#define CAVM_NIX_SENDCRCALG_E_CRC32 (0)
+#define CAVM_NIX_SENDCRCALG_E_CRC32C (1)
+#define CAVM_NIX_SENDCRCALG_E_ONES16 (2)
+
+/**
+ * Enumeration nix_sendl3type_e
+ *
+ * NIX Send Layer 3 Header Type Enumeration Enumerates values of
+ * NIX_SEND_HDR_S[OL3TYPE], NIX_SEND_HDR_S[IL3TYPE]. Internal: Encoding
+ * matches DPDK TX IP types: \<pre\> PKT_TX_IP_CKSUM      (1ULL \<\< 54)
+ * PKT_TX_IPV4          (1ULL \<\< 55) PKT_TX_IPV6          (1ULL \<\<
+ * 56)  PKT_TX_OUTER_IP_CKSUM(1ULL \<\< 58) PKT_TX_OUTER_IPV4    (1ULL
+ * \<\< 59) PKT_TX_OUTER_IPV6    (1ULL \<\< 60) \</pre\>
+ */
+#define CAVM_NIX_SENDL3TYPE_E_IP4 (2)
+#define CAVM_NIX_SENDL3TYPE_E_IP4_CKSUM (3)
+#define CAVM_NIX_SENDL3TYPE_E_IP6 (4)
+#define CAVM_NIX_SENDL3TYPE_E_NONE (0)
+
+/**
+ * Enumeration nix_sendl4type_e
+ *
+ * NIX Send Layer 4 Header Type Enumeration Enumerates values of
+ * NIX_SEND_HDR_S[OL4TYPE], NIX_SEND_HDR_S[IL4TYPE]. Internal: Encoding
+ * matches DPDK TX L4 types. \<pre\> PKT_TX_L4_NO_CKSUM   (0ULL \<\< 52)
+ * // Disable L4 cksum of TX pkt. PKT_TX_TCP_CKSUM     (1ULL \<\< 52)  //
+ * TCP cksum of TX pkt. computed by nic. PKT_TX_SCTP_CKSUM    (2ULL \<\<
+ * 52)  // SCTP cksum of TX pkt. computed by nic. PKT_TX_UDP_CKSUM
+ * (3ULL \<\< 52)  // UDP cksum of TX pkt. computed by nic. \</pre\>
+ */
+#define CAVM_NIX_SENDL4TYPE_E_NONE (0)
+#define CAVM_NIX_SENDL4TYPE_E_SCTP_CKSUM (2)
+#define CAVM_NIX_SENDL4TYPE_E_TCP_CKSUM (1)
+#define CAVM_NIX_SENDL4TYPE_E_UDP_CKSUM (3)
+
+/**
+ * Enumeration nix_sendldtype_e
+ *
+ * NIX Send Load Type Enumeration Enumerates the load transaction types
+ * for reading segment bytes specified by NIX_SEND_SG_S[LD_TYPE] and
+ * NIX_SEND_JUMP_S[LD_TYPE].  Internal: The hardware implementation
+ * treats undefined encodings as LDD load type.
+ */
+#define CAVM_NIX_SENDLDTYPE_E_LDD (0)
+#define CAVM_NIX_SENDLDTYPE_E_LDT (1)
+#define CAVM_NIX_SENDLDTYPE_E_LDWB (2)
+
+/**
+ * Enumeration nix_sendmemalg_e
+ *
+ * NIX Memory Modify Algorithm Enumeration Enumerates the different
+ * algorithms for modifying memory; see NIX_SEND_MEM_S[ALG]. mbufs_freed
+ * is the number of gather buffers freed to NPA for the send descriptor.
+ * See NIX_SEND_HDR_S[DF] and NIX_SEND_SG_S[I*].
+ */
+#define CAVM_NIX_SENDMEMALG_E_ADD (8)
+#define CAVM_NIX_SENDMEMALG_E_ADDLEN (0xa)
+#define CAVM_NIX_SENDMEMALG_E_ADDMBUF (0xc)
+#define CAVM_NIX_SENDMEMALG_E_SET (0)
+#define CAVM_NIX_SENDMEMALG_E_SETRSLT (2)
+#define CAVM_NIX_SENDMEMALG_E_SETTSTMP (1)
+#define CAVM_NIX_SENDMEMALG_E_SUB (9)
+#define CAVM_NIX_SENDMEMALG_E_SUBLEN (0xb)
+#define CAVM_NIX_SENDMEMALG_E_SUBMBUF (0xd)
+
+/**
+ * Enumeration nix_sendmemdsz_e
+ *
+ * NIX Memory Data Size Enumeration Enumerates the datum size for
+ * modifying memory; see NIX_SEND_MEM_S[DSZ].
+ */
+#define CAVM_NIX_SENDMEMDSZ_E_B16 (2)
+#define CAVM_NIX_SENDMEMDSZ_E_B32 (1)
+#define CAVM_NIX_SENDMEMDSZ_E_B64 (0)
+#define CAVM_NIX_SENDMEMDSZ_E_B8 (3)
+
+/**
+ * Enumeration nix_sqint_e
+ *
+ * NIX Send Queue Interrupt Enumeration Enumerates the bit index of
+ * NIX_SQ_CTX_S[SQ_INT,SQ_INT_ENA].
+ */
+#define CAVM_NIX_SQINT_E_LMT_ERR (0)
+#define CAVM_NIX_SQINT_E_MNQ_ERR (1)
+#define CAVM_NIX_SQINT_E_SEND_ERR (2)
+#define CAVM_NIX_SQINT_E_SQB_ALLOC_FAIL (3)
+
+/**
+ * Enumeration nix_sqoperr_e
+ *
+ * NIX SQ Operation Error Enumeration Enumerates
+ * NIX_LF_SQ_OP_ERR_DBG[ERRCODE] values.
+ */
+#define CAVM_NIX_SQOPERR_E_MAX_SQE_SIZE_ERR (4)
+#define CAVM_NIX_SQOPERR_E_SQB_FAULT (7)
+#define CAVM_NIX_SQOPERR_E_SQB_NULL (6)
+#define CAVM_NIX_SQOPERR_E_SQE_OFLOW (5)
+#define CAVM_NIX_SQOPERR_E_SQE_SIZEM1_ZERO (8)
+#define CAVM_NIX_SQOPERR_E_SQ_CTX_FAULT (1)
+#define CAVM_NIX_SQOPERR_E_SQ_CTX_POISON (2)
+#define CAVM_NIX_SQOPERR_E_SQ_DISABLED (3)
+#define CAVM_NIX_SQOPERR_E_SQ_OOR (0)
+
+/**
+ * Enumeration nix_stat_lf_rx_e
+ *
+ * NIX Local Function Receive Statistics Enumeration Enumerates the last
+ * index of NIX_AF_LF()_RX_STAT() and NIX_LF_RX_STAT().
+ */
+#define CAVM_NIX_STAT_LF_RX_E_RX_BCAST (2)
+#define CAVM_NIX_STAT_LF_RX_E_RX_DROP (4)
+#define CAVM_NIX_STAT_LF_RX_E_RX_DROP_OCTS (5)
+#define CAVM_NIX_STAT_LF_RX_E_RX_DRP_BCAST (8)
+#define CAVM_NIX_STAT_LF_RX_E_RX_DRP_L3BCAST (0xa)
+#define CAVM_NIX_STAT_LF_RX_E_RX_DRP_L3MCAST (0xb)
+#define CAVM_NIX_STAT_LF_RX_E_RX_DRP_MCAST (9)
+#define CAVM_NIX_STAT_LF_RX_E_RX_ERR (7)
+#define CAVM_NIX_STAT_LF_RX_E_RX_FCS (6)
+#define CAVM_NIX_STAT_LF_RX_E_RX_MCAST (3)
+#define CAVM_NIX_STAT_LF_RX_E_RX_OCTS (0)
+#define CAVM_NIX_STAT_LF_RX_E_RX_UCAST (1)
+
+/**
+ * Enumeration nix_stat_lf_tx_e
+ *
+ * NIX Local Function Transmit Statistics Enumeration Enumerates the
+ * index of NIX_AF_LF()_TX_STAT() and NIX_LF_TX_STAT(). These statistics
+ * do not account for packet replication due to NIX_TX_ACTION_S[OP] =
+ * NIX_TX_ACTIONOP_E::MCAST.
+ */
+#define CAVM_NIX_STAT_LF_TX_E_TX_BCAST (1)
+#define CAVM_NIX_STAT_LF_TX_E_TX_DROP (3)
+#define CAVM_NIX_STAT_LF_TX_E_TX_MCAST (2)
+#define CAVM_NIX_STAT_LF_TX_E_TX_OCTS (4)
+#define CAVM_NIX_STAT_LF_TX_E_TX_UCAST (0)
+
+/**
+ * Enumeration nix_stype_e
+ *
+ * NIX SQB Caching Type Enumeration Enumerates the values of
+ * NIX_SQ_CTX_S[SQE_STYPE].
+ */
+#define CAVM_NIX_STYPE_E_STF (0)
+#define CAVM_NIX_STYPE_E_STP (2)
+#define CAVM_NIX_STYPE_E_STT (1)
+
+/**
+ * Enumeration nix_subdc_e
+ *
+ * NIX Subdescriptor Operation Enumeration Enumerates send and receive
+ * subdescriptor codes. The codes differentiate subdescriptors within a
+ * NIX send or receive descriptor, excluding NIX_SEND_HDR_S for send and
+ * NIX_CQE_HDR_S/NIX_WQE_HDR_S for receive, which are determined by their
+ * position as the first subdescriptor, and NIX_RX_PARSE_S, which is
+ * determined by its position as the second subdescriptor.
+ */
+#define CAVM_NIX_SUBDC_E_CRC (2)
+#define CAVM_NIX_SUBDC_E_EXT (1)
+#define CAVM_NIX_SUBDC_E_IMM (3)
+#define CAVM_NIX_SUBDC_E_JUMP (6)
+#define CAVM_NIX_SUBDC_E_MEM (5)
+#define CAVM_NIX_SUBDC_E_NOP (0)
+#define CAVM_NIX_SUBDC_E_SG (4)
+#define CAVM_NIX_SUBDC_E_SOD (0xf)
+#define CAVM_NIX_SUBDC_E_WORK (7)
+
+/**
+ * Enumeration nix_tx_actionop_e
+ *
+ * NIX Transmit Action Opcode Enumeration Enumerates the values of
+ * NIX_TX_ACTION_S[OP].
+ */
+#define CAVM_NIX_TX_ACTIONOP_E_DROP (0)
+#define CAVM_NIX_TX_ACTIONOP_E_DROP_VIOL (5)
+#define CAVM_NIX_TX_ACTIONOP_E_MCAST (3)
+#define CAVM_NIX_TX_ACTIONOP_E_UCAST_CHAN (2)
+#define CAVM_NIX_TX_ACTIONOP_E_UCAST_DEFAULT (1)
+
+/**
+ * Enumeration nix_tx_vtagop_e
+ *
+ * NIX Transmit Vtag Opcode Enumeration Enumerates the values of
+ * NIX_TX_VTAG_ACTION_S[VTAG0_OP,VTAG1_OP].
+ */
+#define CAVM_NIX_TX_VTAGOP_E_INSERT (1)
+#define CAVM_NIX_TX_VTAGOP_E_NOP (0)
+#define CAVM_NIX_TX_VTAGOP_E_REPLACE (2)
+
+/**
+ * Enumeration nix_txlayer_e
+ *
+ * NIX Transmit Layer Enumeration Enumerates the values of
+ * NIX_AF_LSO_FORMAT()_FIELD()[LAYER].
+ */
+#define CAVM_NIX_TXLAYER_E_IL3 (2)
+#define CAVM_NIX_TXLAYER_E_IL4 (3)
+#define CAVM_NIX_TXLAYER_E_OL3 (0)
+#define CAVM_NIX_TXLAYER_E_OL4 (1)
+
+/**
+ * Enumeration nix_vtagsize_e
+ *
+ * NIX Vtag Size Enumeration Enumerates the values of
+ * NIX_AF_TX_VTAG_DEF()_CTL[SIZE] and NIX_AF_LF()_RX_VTAG_TYPE()[SIZE].
+ */
+#define CAVM_NIX_VTAGSIZE_E_T4 (0)
+#define CAVM_NIX_VTAGSIZE_E_T8 (1)
+
+/**
+ * Enumeration nix_xqe_type_e
+ *
+ * NIX WQE/CQE Type Enumeration Enumerates the values of
+ * NIX_WQE_HDR_S[WQE_TYPE], NIX_CQE_HDR_S[CQE_TYPE].
+ */
+#define CAVM_NIX_XQE_TYPE_E_INVALID (0)
+#define CAVM_NIX_XQE_TYPE_E_RX (1)
+#define CAVM_NIX_XQE_TYPE_E_RX_IPSECD (4)
+#define CAVM_NIX_XQE_TYPE_E_RX_IPSECH (3)
+#define CAVM_NIX_XQE_TYPE_E_RX_IPSECS (2)
+#define CAVM_NIX_XQE_TYPE_E_SEND (8)
+
+/**
+ * Enumeration nix_xqesz_e
+ *
+ * NIX WQE/CQE Size Enumeration Enumerates the values of
+ * NIX_AF_LF()_CFG[XQE_SIZE].
+ */
+#define CAVM_NIX_XQESZ_E_W16 (1)
+#define CAVM_NIX_XQESZ_E_W64 (0)
+
+/**
+ * Structure nix_aq_inst_s
+ *
+ * NIX Admin Queue Instruction Structure This structure specifies the AQ
+ * instruction. Instructions and associated software structures are
+ * stored in memory as little-endian unless NIX_AF_CFG[AF_BE] is set.
+ * Hardware reads of NIX_AQ_INST_S do not allocate into LLC.  Hardware
+ * reads and writes of the context structure selected by [CTYPE], [LF]
+ * and [CINDEX] use the NDC and LLC caching style configured for that
+ * context. For example: * When [CTYPE] = NIX_AQ_CTYPE_E::RQ: use
+ * NIX_AF_LF()_RSS_CFG[CACHING] and NIX_AF_LF()_RSS_CFG[WAY_MASK]. * When
+ * [CTYPE] = NIX_AQ_CTYPE_E::MCE: use NIX_AF_RX_MCAST_CFG[CACHING] and
+ * NIX_AF_RX_MCAST_CFG[WAY_MASK].
+ */
+union cavm_nix_aq_inst_s {
+	u64 u[2];
+	struct cavm_nix_aq_inst_s_s {
+		u64 op                               : 4;
+		u64 ctype                            : 4;
+		u64 lf                               : 7;
+		u64 reserved_15_23                   : 9;
+		u64 cindex                           : 20;
+		u64 reserved_44_62                   : 19;
+		u64 doneint                          : 1;
+		u64 res_addr                         : 64;
+	} s;
+	/* struct cavm_nix_aq_inst_s_s cn; */
+};
+
+/**
+ * Structure nix_aq_res_s
+ *
+ * NIX Admin Queue Result Structure NIX writes this structure after it
+ * completes the NIX_AQ_INST_S instruction. The result structure is
+ * exactly 16 bytes, and each instruction completion produces exactly one
+ * result structure.  Results and associated software structures are
+ * stored in memory as little-endian unless NIX_AF_CFG[AF_BE] is set.
+ * When [OP] = NIX_AQ_INSTOP_E::INIT, WRITE or READ, this structure is
+ * immediately followed by context read or write data. See
+ * NIX_AQ_INSTOP_E.  Hardware writes of NIX_AQ_RES_S and context data
+ * always allocate into LLC. Hardware reads of context data do not
+ * allocate into LLC.
+ */
+union cavm_nix_aq_res_s {
+	u64 u[2];
+	struct cavm_nix_aq_res_s_s {
+		u64 op                               : 4;
+		u64 ctype                            : 4;
+		u64 compcode                         : 8;
+		u64 doneint                          : 1;
+		u64 reserved_17_63                   : 47;
+		u64 reserved_64_127                  : 64;
+	} s;
+	/* struct cavm_nix_aq_res_s_s cn; */
+};
+
+/**
+ * Structure nix_cint_hw_s
+ *
+ * NIX Completion Interrupt Context Hardware Structure This structure
+ * contains context state maintained by hardware for each completion
+ * interrupt (CINT) in NDC/LLC/DRAM. Software accesses this structure
+ * with the NIX_LF_CINT()* registers. Hardware maintains a table of
+ * NIX_AF_CONST2[CINTS] contiguous NIX_CINT_HW_S structures per LF
+ * starting at AF IOVA NIX_AF_LF()_CINTS_BASE. Always stored in byte
+ * invariant little-endian format (LE8).
+ */
+union cavm_nix_cint_hw_s {
+	u64 u[2];
+	struct cavm_nix_cint_hw_s_s {
+		u64 ecount                           : 32;
+		u64 qcount                           : 16;
+		u64 intr                             : 1;
+		u64 ena                              : 1;
+		u64 timer_idx                        : 8;
+		u64 reserved_58_63                   : 6;
+		u64 ecount_wait                      : 32;
+		u64 qcount_wait                      : 16;
+		u64 time_wait                        : 8;
+		u64 reserved_120_127                 : 8;
+	} s;
+	/* struct cavm_nix_cint_hw_s_s cn; */
+};
+
+/**
+ * Structure nix_cq_ctx_s
+ *
+ * NIX Completion Queue Context Structure This structure contains context
+ * state maintained by hardware for each CQ in NDC/LLC/DRAM. Software
+ * uses the same structure format to read and write an CQ context with
+ * the NIX admin queue.
+ */
+union cavm_nix_cq_ctx_s {
+	u64 u[4];
+	struct cavm_nix_cq_ctx_s_s {
+		u64 base                             : 64;
+		u64 reserved_64_67                   : 4;
+		u64 bp_ena                           : 1;
+		u64 reserved_69_71                   : 3;
+		u64 bpid                             : 9;
+		u64 reserved_81_83                   : 3;
+		u64 qint_idx                         : 7;
+		u64 cq_err                           : 1;
+		u64 cint_idx                         : 7;
+		u64 avg_con                          : 9;
+		u64 wrptr                            : 20;
+		u64 tail                             : 20;
+		u64 head                             : 20;
+		u64 avg_level                        : 8;
+		u64 update_time                      : 16;
+		u64 bp                               : 8;
+		u64 drop                             : 8;
+		u64 drop_ena                         : 1;
+		u64 ena                              : 1;
+		u64 reserved_210_211                 : 2;
+		u64 substream                        : 20;
+		u64 caching                          : 1;
+		u64 reserved_233_235                 : 3;
+		u64 qsize                            : 4;
+		u64 cq_err_int                       : 8;
+		u64 cq_err_int_ena                   : 8;
+	} s;
+	/* struct cavm_nix_cq_ctx_s_s cn; */
+};
+
+/**
+ * Structure nix_cqe_hdr_s
+ *
+ * NIX Completion Queue Entry Header Structure This 64-bit structure
+ * defines the first word of every CQE. It is immediately followed by
+ * NIX_RX_PARSE_S in a receive CQE, and by NIX_SEND_COMP_S in a send
+ * completion CQE. Stored in memory as little-endian unless
+ * NIX_AF_LF()_CFG[BE] is set.
+ */
+union cavm_nix_cqe_hdr_s {
+	u64 u;
+	struct cavm_nix_cqe_hdr_s_s {
+		u64 tag                              : 32;
+		u64 q                                : 20;
+		u64 reserved_52_57                   : 6;
+		u64 node                             : 2;
+		u64 cqe_type                         : 4;
+	} s;
+	/* struct cavm_nix_cqe_hdr_s_s cn; */
+};
+
+/**
+ * Structure nix_inst_hdr_s
+ *
+ * NIX Instruction Header Structure This structure defines the
+ * instruction header that precedes the packet header supplied to NPC for
+ * packets to be transmitted by NIX.
+ */
+union cavm_nix_inst_hdr_s {
+	u64 u;
+	struct cavm_nix_inst_hdr_s_s {
+		u64 pf_func                          : 16;
+		u64 sq                               : 20;
+		u64 reserved_36_63                   : 28;
+	} s;
+	/* struct cavm_nix_inst_hdr_s_s cn; */
+};
+
+/**
+ * Structure nix_iova_s
+ *
+ * NIX I/O Virtual Address Structure
+ */
+union cavm_nix_iova_s {
+	u64 u;
+	struct cavm_nix_iova_s_s {
+		u64 addr                             : 64;
+	} s;
+	/* struct cavm_nix_iova_s_s cn; */
+};
+
+/**
+ * Structure nix_ipsec_dyno_s
+ *
+ * INTERNAL: NIX IPSEC Dynamic Ordering Counter Structure  Internal: Not
+ * used; no IPSEC fast-path.
+ */
+union cavm_nix_ipsec_dyno_s {
+	u32 u;
+	struct cavm_nix_ipsec_dyno_s_s {
+		u32 count                            : 32;
+	} s;
+	/* struct cavm_nix_ipsec_dyno_s_s cn; */
+};
+
+/**
+ * Structure nix_mem_result_s
+ *
+ * NIX Memory Value Structure When
+ * NIX_SEND_MEM_S[ALG]=NIX_SENDMEMALG_E::SETRSLT, the value written to
+ * memory is formed with this structure.
+ */
+union cavm_nix_mem_result_s {
+	u64 u;
+	struct cavm_nix_mem_result_s_s {
+		u64 v                                : 1;
+		u64 color                            : 2;
+		u64 reserved_3_63                    : 61;
+	} s;
+	/* struct cavm_nix_mem_result_s_s cn; */
+};
+
+/**
+ * Structure nix_op_q_wdata_s
+ *
+ * NIX Statistics Operation Write Data Structure This structure specifies
+ * the write data format of an atomic 64-bit load-and-add of some
+ * NIX_LF_RQ_OP_*, NIX_LF_SQ_OP* and NIX_LF_CQ_OP* registers.
+ */
+union cavm_nix_op_q_wdata_s {
+	u64 u;
+	struct cavm_nix_op_q_wdata_s_s {
+		u64 reserved_0_31                    : 32;
+		u64 q                                : 20;
+		u64 reserved_52_63                   : 12;
+	} s;
+	/* struct cavm_nix_op_q_wdata_s_s cn; */
+};
+
+/**
+ * Structure nix_qint_hw_s
+ *
+ * NIX Queue Interrupt Context Hardware Structure This structure contains
+ * context state maintained by hardware for each queue interrupt (QINT)
+ * in NDC/LLC/DRAM. Software accesses this structure with the
+ * NIX_LF_QINT()* registers. Hardware maintains a table of
+ * NIX_AF_CONST2[QINTS] contiguous NIX_QINT_HW_S structures per LF
+ * starting at IOVA NIX_AF_LF()_QINTS_BASE. Always stored in byte
+ * invariant little-endian format (LE8).
+ */
+union cavm_nix_qint_hw_s {
+	u32 u;
+	struct cavm_nix_qint_hw_s_s {
+		u32 count                            : 22;
+		u32 reserved_22_30                   : 9;
+		u32 ena                              : 1;
+	} s;
+	/* struct cavm_nix_qint_hw_s_s cn; */
+};
+
+/**
+ * Structure nix_rq_ctx_hw_s
+ *
+ * NIX Receive Queue Context Structure This structure contains context
+ * state maintained by hardware for each RQ in NDC/LLC/DRAM. Software
+ * uses the equivalent NIX_RQ_CTX_S structure format to read and write an
+ * RQ context with the NIX admin queue. Always stored in byte invariant
+ * little-endian format (LE8).
+ */
+union cavm_nix_rq_ctx_hw_s {
+	u64 u[16];
+	struct cavm_nix_rq_ctx_hw_s_s {
+		u64 ena                              : 1;
+		u64 sso_ena                          : 1;
+		u64 ipsech_ena                       : 1;
+		u64 ena_wqwd                         : 1;
+		u64 cq                               : 20;
+		u64 substream                        : 20;
+		u64 wqe_aura                         : 20;
+		u64 spb_aura                         : 20;
+		u64 lpb_aura                         : 20;
+		u64 sso_grp                          : 10;
+		u64 sso_tt                           : 2;
+		u64 pb_caching                       : 2;
+		u64 wqe_caching                      : 1;
+		u64 xqe_drop_ena                     : 1;
+		u64 spb_drop_ena                     : 1;
+		u64 lpb_drop_ena                     : 1;
+		u64 wqe_skip                         : 2;
+		u64 reserved_124_127                 : 4;
+		u64 reserved_128_139                 : 12;
+		u64 spb_sizem1                       : 6;
+		u64 reserved_146_150                 : 5;
+		u64 spb_ena                          : 1;
+		u64 lpb_sizem1                       : 12;
+		u64 first_skip                       : 7;
+		u64 reserved_171                     : 1;
+		u64 later_skip                       : 6;
+		u64 xqe_imm_size                     : 6;
+		u64 reserved_184_189                 : 6;
+		u64 xqe_imm_copy                     : 1;
+		u64 xqe_hdr_split                    : 1;
+		u64 xqe_drop                         : 8;
+		u64 xqe_pass                         : 8;
+		u64 wqe_pool_drop                    : 8;
+		u64 wqe_pool_pass                    : 8;
+		u64 spb_aura_drop                    : 8;
+		u64 spb_aura_pass                    : 8;
+		u64 spb_pool_drop                    : 8;
+		u64 spb_pool_pass                    : 8;
+		u64 lpb_aura_drop                    : 8;
+		u64 lpb_aura_pass                    : 8;
+		u64 lpb_pool_drop                    : 8;
+		u64 lpb_pool_pass                    : 8;
+		u64 reserved_288_319                 : 32;
+		u64 ltag                             : 24;
+		u64 good_utag                        : 8;
+		u64 bad_utag                         : 8;
+		u64 flow_tagw                        : 6;
+		u64 reserved_366_383                 : 18;
+		u64 octs                             : 48;
+		u64 reserved_432_447                 : 16;
+		u64 pkts                             : 48;
+		u64 reserved_496_511                 : 16;
+		u64 drop_octs                        : 48;
+		u64 reserved_560_575                 : 16;
+		u64 drop_pkts                        : 48;
+		u64 reserved_624_639                 : 16;
+		u64 re_pkts                          : 48;
+		u64 reserved_688_702                 : 15;
+		u64 ena_copy                         : 1;
+		u64 reserved_704_739                 : 36;
+		u64 rq_int                           : 8;
+		u64 rq_int_ena                       : 8;
+		u64 qint_idx                         : 7;
+		u64 reserved_763_767                 : 5;
+		u64 reserved_768_831                 : 64;
+		u64 reserved_832_895                 : 64;
+		u64 reserved_896_959                 : 64;
+		u64 reserved_960_1023                : 64;
+	} s;
+	/* struct cavm_nix_rq_ctx_hw_s_s cn; */
+};
+
+/**
+ * Structure nix_rq_ctx_s
+ *
+ * NIX Receive Queue Context Structure This structure specifies the
+ * format used by software to read and write an RQ context with the NIX
+ * admin queue.
+ */
+union cavm_nix_rq_ctx_s {
+	u64 u[16];
+	struct cavm_nix_rq_ctx_s_s {
+		u64 ena                              : 1;
+		u64 sso_ena                          : 1;
+		u64 ipsech_ena                       : 1;
+		u64 ena_wqwd                         : 1;
+		u64 cq                               : 20;
+		u64 substream                        : 20;
+		u64 wqe_aura                         : 20;
+		u64 spb_aura                         : 20;
+		u64 lpb_aura                         : 20;
+		u64 sso_grp                          : 10;
+		u64 sso_tt                           : 2;
+		u64 pb_caching                       : 2;
+		u64 wqe_caching                      : 1;
+		u64 xqe_drop_ena                     : 1;
+		u64 spb_drop_ena                     : 1;
+		u64 lpb_drop_ena                     : 1;
+		u64 reserved_122_127                 : 6;
+		u64 reserved_128_139                 : 12;
+		u64 spb_sizem1                       : 6;
+		u64 wqe_skip                         : 2;
+		u64 reserved_148_150                 : 3;
+		u64 spb_ena                          : 1;
+		u64 lpb_sizem1                       : 12;
+		u64 first_skip                       : 7;
+		u64 reserved_171                     : 1;
+		u64 later_skip                       : 6;
+		u64 xqe_imm_size                     : 6;
+		u64 reserved_184_189                 : 6;
+		u64 xqe_imm_copy                     : 1;
+		u64 xqe_hdr_split                    : 1;
+		u64 xqe_drop                         : 8;
+		u64 xqe_pass                         : 8;
+		u64 wqe_pool_drop                    : 8;
+		u64 wqe_pool_pass                    : 8;
+		u64 spb_aura_drop                    : 8;
+		u64 spb_aura_pass                    : 8;
+		u64 spb_pool_drop                    : 8;
+		u64 spb_pool_pass                    : 8;
+		u64 lpb_aura_drop                    : 8;
+		u64 lpb_aura_pass                    : 8;
+		u64 lpb_pool_drop                    : 8;
+		u64 lpb_pool_pass                    : 8;
+		u64 reserved_288_291                 : 4;
+		u64 rq_int                           : 8;
+		u64 rq_int_ena                       : 8;
+		u64 qint_idx                         : 7;
+		u64 reserved_315_319                 : 5;
+		u64 ltag                             : 24;
+		u64 good_utag                        : 8;
+		u64 bad_utag                         : 8;
+		u64 flow_tagw                        : 6;
+		u64 reserved_366_383                 : 18;
+		u64 octs                             : 48;
+		u64 reserved_432_447                 : 16;
+		u64 pkts                             : 48;
+		u64 reserved_496_511                 : 16;
+		u64 drop_octs                        : 48;
+		u64 reserved_560_575                 : 16;
+		u64 drop_pkts                        : 48;
+		u64 reserved_624_639                 : 16;
+		u64 re_pkts                          : 48;
+		u64 reserved_688_703                 : 16;
+		u64 reserved_704_767                 : 64;
+		u64 reserved_768_831                 : 64;
+		u64 reserved_832_895                 : 64;
+		u64 reserved_896_959                 : 64;
+		u64 reserved_960_1023                : 64;
+	} s;
+	/* struct cavm_nix_rq_ctx_s_s cn; */
+};
+
+/**
+ * Structure nix_rsse_s
+ *
+ * NIX Receive Side Scaling Entry Structure This structure specifies the
+ * format of each hardware entry in the NIX RSS tables in NDC/LLC/DRAM.
+ * See NIX_AF_LF()_RSS_BASE and NIX_AF_LF()_RSS_GRP(). Software uses the
+ * same structure format to read and write an RSS table entry with the
+ * NIX admin queue.
+ */
+union cavm_nix_rsse_s {
+	u32 u;
+	struct cavm_nix_rsse_s_s {
+		u32 rq                               : 20;
+		u32 reserved_20_31                   : 12;
+	} s;
+	/* struct cavm_nix_rsse_s_s cn; */
+};
+
+/**
+ * Structure nix_rx_action_s
+ *
+ * NIX Receive Action Structure This structure defines the format of
+ * NPC_RESULT_S[ACTION] for a receive packet.
+ */
+union cavm_nix_rx_action_s {
+	u64 u;
+	struct cavm_nix_rx_action_s_s {
+		u64 op                               : 4;
+		u64 pf_func                          : 16;
+		u64 index                            : 20;
+		u64 match_id                         : 16;
+		u64 flow_key_alg                     : 5;
+		u64 reserved_61_63                   : 3;
+	} s;
+	/* struct cavm_nix_rx_action_s_s cn; */
+};
+
+/**
+ * Structure nix_rx_imm_s
+ *
+ * NIX Receive Immediate Subdescriptor Structure The receive immediate
+ * subdescriptor indicates that bytes immediately following this
+ * NIX_RX_IMM_S (after skipping [APAD] bytes) were saved from the
+ * received packet. The next subdescriptor following this NIX_RX_IMM_S
+ * (when one exists) will follow the immediate bytes, after rounding up
+ * the address to a multiple of 16 bytes.
+ */
+union cavm_nix_rx_imm_s {
+	u64 u;
+	struct cavm_nix_rx_imm_s_s {
+		u64 size                             : 16;
+		u64 apad                             : 3;
+		u64 reserved_19_59                   : 41;
+		u64 subdc                            : 4;
+	} s;
+	/* struct cavm_nix_rx_imm_s_s cn; */
+};
+
+/**
+ * Structure nix_rx_mce_s
+ *
+ * NIX Receive Multicast/Mirror Entry Structure This structure specifies
+ * the format of entries in the NIX receive multicast/mirror table
+ * maintained by hardware in NDC/LLC/DRAM. See NIX_AF_RX_MCAST_BASE and
+ * NIX_AF_RX_MCAST_CFG. Note the table may contain both multicast and
+ * mirror replication lists. Software uses the same structure format to
+ * read and write a multicast/mirror table entry with the NIX admin
+ * queue.
+ */
+union cavm_nix_rx_mce_s {
+	u64 u;
+	struct cavm_nix_rx_mce_s_s {
+		u64 op                               : 2;
+		u64 reserved_2                       : 1;
+		u64 eol                              : 1;
+		u64 index                            : 20;
+		u64 reserved_24_31                   : 8;
+		u64 pf_func                          : 16;
+		u64 next                             : 16;
+	} s;
+	/* struct cavm_nix_rx_mce_s_s cn; */
+};
+
+/**
+ * Structure nix_rx_parse_s
+ *
+ * NIX Receive Parse Structure This structure contains the receive packet
+ * parse result. It immediately follows NIX_CQE_HDR_S in a receive CQE,
+ * or NIX_WQE_HDR_S in a receive WQE. Stored in memory as little-endian
+ * unless NIX_AF_LF()_CFG[BE] is set.  Header layers are always 2-byte
+ * aligned, so all header pointers in this structure ([EOH_PTR], [LAPTR]
+ * through [LHPTR], [VTAG*_PTR]) are even.
+ */
+union cavm_nix_rx_parse_s {
+	u64 u[7];
+	struct cavm_nix_rx_parse_s_s {
+		u64 chan                             : 12;
+		u64 desc_sizem1                      : 5;
+		u64 imm_copy                         : 1;
+		u64 express                          : 1;
+		u64 wqwd                             : 1;
+		u64 errlev                           : 4;
+		u64 errcode                          : 8;
+		u64 latype                           : 4;
+		u64 lbtype                           : 4;
+		u64 lctype                           : 4;
+		u64 ldtype                           : 4;
+		u64 letype                           : 4;
+		u64 lftype                           : 4;
+		u64 lgtype                           : 4;
+		u64 lhtype                           : 4;
+		u64 pkt_lenm1                        : 16;
+		u64 l2m                              : 1;
+		u64 l2b                              : 1;
+		u64 l3m                              : 1;
+		u64 l3b                              : 1;
+		u64 vtag0_valid                      : 1;
+		u64 vtag0_gone                       : 1;
+		u64 vtag1_valid                      : 1;
+		u64 vtag1_gone                       : 1;
+		u64 pkind                            : 6;
+		u64 reserved_94_95                   : 2;
+		u64 vtag0_tci                        : 16;
+		u64 vtag1_tci                        : 16;
+		u64 laflags                          : 8;
+		u64 lbflags                          : 8;
+		u64 lcflags                          : 8;
+		u64 ldflags                          : 8;
+		u64 leflags                          : 8;
+		u64 lfflags                          : 8;
+		u64 lgflags                          : 8;
+		u64 lhflags                          : 8;
+		u64 eoh_ptr                          : 8;
+		u64 wqe_aura                         : 20;
+		u64 pb_aura                          : 20;
+		u64 match_id                         : 16;
+		u64 laptr                            : 8;
+		u64 lbptr                            : 8;
+		u64 lcptr                            : 8;
+		u64 ldptr                            : 8;
+		u64 leptr                            : 8;
+		u64 lfptr                            : 8;
+		u64 lgptr                            : 8;
+		u64 lhptr                            : 8;
+		u64 vtag0_ptr                        : 8;
+		u64 vtag1_ptr                        : 8;
+		u64 flow_key_alg                     : 5;
+		u64 reserved_341_383                 : 43;
+		u64 reserved_384_447                 : 64;
+	} s;
+	/* struct cavm_nix_rx_parse_s_s cn; */
+};
+
+/**
+ * Structure nix_rx_sg_s
+ *
+ * NIX Receive Scatter/Gather Subdescriptor Structure The receive
+ * scatter/gather subdescriptor specifies one to three segments of packet
+ * data bytes. There may be multiple NIX_RX_SG_Ss in each NIX receive
+ * descriptor.  NIX_RX_SG_S is immediately followed by one NIX_IOVA_S
+ * word when [SEGS] = 1, three NIX_IOVA_S words when [SEGS] \>= 2. Each
+ * NIX_IOVA_S word specifies the LF IOVA of first packet data byte in the
+ * corresponding segment; first NIX_IOVA_S word for segment 1, second
+ * word for segment 2, third word for segment 3. Note the third word is
+ * present when [SEGS] \>= 2 but only valid when [SEGS] = 3.
+ */
+union cavm_nix_rx_sg_s {
+	u64 u;
+	struct cavm_nix_rx_sg_s_s {
+		u64 seg1_size                        : 16;
+		u64 seg2_size                        : 16;
+		u64 seg3_size                        : 16;
+		u64 segs                             : 2;
+		u64 reserved_50_59                   : 10;
+		u64 subdc                            : 4;
+	} s;
+	/* struct cavm_nix_rx_sg_s_s cn; */
+};
+
+/**
+ * Structure nix_rx_vtag_action_s
+ *
+ * NIX Receive Vtag Action Structure This structure defines the format of
+ * NPC_RESULT_S[VTAG_ACTION] for a receive packet. It specifies up to two
+ * Vtags (e.g. C-VLAN/S-VLAN tags, 802.1BR E-TAG) for optional capture
+ * and/or stripping.
+ */
+union cavm_nix_rx_vtag_action_s {
+	u64 u;
+	struct cavm_nix_rx_vtag_action_s_s {
+		u64 vtag0_relptr                     : 8;
+		u64 vtag0_lid                        : 3;
+		u64 reserved_11                      : 1;
+		u64 vtag0_type                       : 3;
+		u64 vtag0_valid                      : 1;
+		u64 reserved_16_31                   : 16;
+		u64 vtag1_relptr                     : 8;
+		u64 vtag1_lid                        : 3;
+		u64 reserved_43                      : 1;
+		u64 vtag1_type                       : 3;
+		u64 vtag1_valid                      : 1;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_nix_rx_vtag_action_s_s cn; */
+};
+
+/**
+ * Structure nix_send_comp_s
+ *
+ * NIX Send Completion Structure This structure immediately follows
+ * NIX_CQE_HDR_S in a send completion CQE.
+ */
+union cavm_nix_send_comp_s {
+	u64 u;
+	struct cavm_nix_send_comp_s_s {
+		u64 status                           : 8;
+		u64 sqe_id                           : 16;
+		u64 reserved_24_63                   : 40;
+	} s;
+	/* struct cavm_nix_send_comp_s_s cn; */
+};
+
+/**
+ * Structure nix_send_crc_s
+ *
+ * NIX Send CRC Subdescriptor Structure The send CRC subdescriptor
+ * specifies a CRC calculation be performed during transmission. Ignored
+ * when present in a send descriptor with NIX_SEND_EXT_S[LSO] set. There
+ * may be up to two NIX_SEND_CRC_Ss per send descriptor.  NIX_SEND_CRC_S
+ * constraints: * When present, NIX_SEND_CRC_S subdescriptors must
+ * precede all NIX_SEND_SG_S, NIX_SEND_IMM_S and NIX_SEND_MEM_S
+ * subdescriptors in the send descriptor. * NIX_SEND_CRC_S subdescriptors
+ * must follow the same order as their checksum and insert regions in the
+ * packet, i.e. the checksum and insert regions of a NIX_SEND_CRC_S must
+ * come after the checksum and insert regions of a preceding
+ * NIX_SEND_CRC_S. There must be no overlap between any NIX_SEND_CRC_S
+ * checksum and insert regions. * If either
+ * NIX_SEND_HDR_S[OL4TYPE,IL4TYPE] = NIX_SENDL4TYPE_E::SCTP_CKSUM, the
+ * SCTP checksum region and NIX_SEND_CRC_S insert region must not
+ * overlap, and likewise the NIX_SEND_CRC_S checksum region and SCTP
+ * insert region must not overlap. * If either
+ * NIX_SEND_HDR_S[OL3TYPE,IL3TYPE] = NIX_SENDL3TYPE_E::IP4_CKSUM, the
+ * IPv4 header checksum region and NIX_SEND_CRC_S insert region must not
+ * overlap. * Any checksums inserted by
+ * NIX_SEND_HDR_S[OL3TYPE,OL4TYPE,IL3TYPE,IL4TYPE] must be outside of the
+ * NIX_SEND_CRC_S checksum and insert regions.  Hardware adjusts [START],
+ * [SIZE] and [INSERT] as needed to account for any VLAN inserted by
+ * NIX_SEND_EXT_S[VLAN*] or Vtag inserted by NIX_TX_VTAG_ACTION_S.
+ */
+union cavm_nix_send_crc_s {
+	u64 u[2];
+	struct cavm_nix_send_crc_s_s {
+		u64 size                             : 16;
+		u64 start                            : 16;
+		u64 insert                           : 16;
+		u64 reserved_48_57                   : 10;
+		u64 alg                              : 2;
+		u64 subdc                            : 4;
+		u64 iv                               : 32;
+		u64 reserved_96_127                  : 32;
+	} s;
+	/* struct cavm_nix_send_crc_s_s cn; */
+};
+
+/**
+ * Structure nix_send_ext_s
+ *
+ * NIX Send Extended Header Subdescriptor Structure The send extended
+ * header specifies LSO, VLAN insertion, timestamp and/or scheduling
+ * services on the packet. If present, it must immediately follow
+ * NIX_SEND_HDR_S. All fields are assumed to be zero when this
+ * subdescriptor is not present.
+ */
+union cavm_nix_send_ext_s {
+	u64 u[2];
+	struct cavm_nix_send_ext_s_s {
+		u64 lso_mps                          : 14;
+		u64 lso                              : 1;
+		u64 tstmp                            : 1;
+		u64 lso_sb                           : 8;
+		u64 lso_format                       : 5;
+		u64 reserved_29_31                   : 3;
+		u64 shp_chg                          : 9;
+		u64 shp_dis                          : 1;
+		u64 shp_ra                           : 2;
+		u64 markptr                          : 8;
+		u64 markform                         : 7;
+		u64 mark_en                          : 1;
+		u64 subdc                            : 4;
+		u64 vlan0_ins_ptr                    : 8;
+		u64 vlan0_ins_tci                    : 16;
+		u64 vlan1_ins_ptr                    : 8;
+		u64 vlan1_ins_tci                    : 16;
+		u64 vlan0_ins_ena                    : 1;
+		u64 vlan1_ins_ena                    : 1;
+		u64 reserved_114_127                 : 14;
+	} s;
+	/* struct cavm_nix_send_ext_s_s cn; */
+};
+
+/**
+ * Structure nix_send_hdr_s
+ *
+ * NIX Send Header Subdescriptor Structure The send header is the first
+ * subdescriptor of every send descriptor.
+ */
+union cavm_nix_send_hdr_s {
+	u64 u[2];
+	struct cavm_nix_send_hdr_s_s {
+		u64 total                            : 18;
+		u64 reserved_18                      : 1;
+		u64 df                               : 1;
+		u64 aura                             : 20;
+		u64 sizem1                           : 3;
+		u64 pnc                              : 1;
+		u64 sq                               : 20;
+		u64 ol3ptr                           : 8;
+		u64 ol4ptr                           : 8;
+		u64 il3ptr                           : 8;
+		u64 il4ptr                           : 8;
+		u64 ol3type                          : 4;
+		u64 ol4type                          : 4;
+		u64 il3type                          : 4;
+		u64 il4type                          : 4;
+		u64 sqe_id                           : 16;
+	} s;
+	/* struct cavm_nix_send_hdr_s_s cn; */
+};
+
+/**
+ * Structure nix_send_imm_s
+ *
+ * NIX Send Immediate Subdescriptor Structure The send immediate
+ * subdescriptor requests that bytes immediately following this
+ * NIX_SEND_IMM_S (after skipping [APAD] bytes) are to be included in the
+ * packet data. The next subdescriptor following this NIX_SEND_IMM_S
+ * (when one exists) will follow the immediate bytes, after rounding up
+ * the address to a multiple of 16 bytes.  There may be multiple
+ * NIX_SEND_IMM_S in one NIX send descriptor. A NIX_SEND_IMM_S is ignored
+ * in a NIX send descriptor if the sum of all prior
+ * NIX_SEND_SG_S[SEG*_SIZE]s and NIX_SEND_IMM_S[SIZE]s meets or exceeds
+ * NIX_SEND_HDR_S[TOTAL].  When NIX_SEND_EXT_S[LSO] is set in the
+ * descriptor, all NIX_SEND_IMM_S bytes must be included in the first
+ * NIX_SEND_EXT_S[LSO_SB] bytes of the source packet.
+ */
+union cavm_nix_send_imm_s {
+	u64 u;
+	struct cavm_nix_send_imm_s_s {
+		u64 size                             : 16;
+		u64 apad                             : 3;
+		u64 reserved_19_59                   : 41;
+		u64 subdc                            : 4;
+	} s;
+	/* struct cavm_nix_send_imm_s_s cn; */
+};
+
+/**
+ * Structure nix_send_jump_s
+ *
+ * NIX Send Jump Subdescriptor Structure The send jump subdescriptor
+ * selects a new address for fetching the remaining subdescriptors of a
+ * send descriptor. This allows software to create a send descriptor
+ * longer than SQE size selected by NIX_SQ_CTX_S[MAX_SQE_SIZE].  There
+ * can be only one NIX_SEND_JUMP_S subdescriptor in a send descriptor. If
+ * present, it must immediately follow NIX_SEND_HDR_S if NIX_SEND_EXT_S
+ * is not present, else it must immediately follow NIX_SEND_EXT_S. In
+ * either case, it must terminate the SQE enqueued by software.
+ */
+union cavm_nix_send_jump_s {
+	u64 u[2];
+	struct cavm_nix_send_jump_s_s {
+		u64 sizem1                           : 7;
+		u64 reserved_7_13                    : 7;
+		u64 ld_type                          : 2;
+		u64 aura                             : 20;
+		u64 reserved_36_58                   : 23;
+		u64 f                                : 1;
+		u64 subdc                            : 4;
+		u64 addr                             : 64;
+	} s;
+	/* struct cavm_nix_send_jump_s_s cn; */
+};
+
+/**
+ * Structure nix_send_mem_s
+ *
+ * NIX Send Memory Subdescriptor Structure The send memory subdescriptor
+ * atomically sets, increments or decrements a memory location.
+ * NIX_SEND_MEM_S subdescriptors must follow all NIX_SEND_SG_S and
+ * NIX_SEND_IMM_S subdescriptors in the NIX send descriptor. NIX will not
+ * initiate the memory update for this subdescriptor until after it has
+ * completed all LLC/DRAM fetches that service all prior NIX_SEND_SG_S
+ * subdescriptors. The memory update is executed once, even if the packet
+ * is replicated due to NIX_TX_ACTION_S[OP] = NIX_TX_ACTIONOP_E::MCAST.
+ * Performance is best if a memory decrement by one is used rather than
+ * any other memory set/increment/decrement. (Less internal bus bandwidth
+ * is used with memory decrements by one.)  When NIX_SEND_EXT_S[LSO] is
+ * set in the descriptor, NIX executes the memory update only while
+ * processing the last LSO segment, after processing prior segments.
+ */
+union cavm_nix_send_mem_s {
+	u64 u[2];
+	struct cavm_nix_send_mem_s_s {
+		u64 offset                           : 16;
+		u64 reserved_16_52                   : 37;
+		u64 wmem                             : 1;
+		u64 dsz                              : 2;
+		u64 alg                              : 4;
+		u64 subdc                            : 4;
+		u64 addr                             : 64;
+	} s;
+	/* struct cavm_nix_send_mem_s_s cn; */
+};
+
+/**
+ * Structure nix_send_sg_s
+ *
+ * NIX Send Scatter/Gather Subdescriptor Structure The send
+ * scatter/gather subdescriptor requests one to three segments of packet
+ * data bytes to be transmitted. There may be multiple NIX_SEND_SG_Ss in
+ * each NIX send descriptor.  NIX_SEND_SG_S is immediately followed by
+ * one NIX_IOVA_S word when [SEGS] = 1, three NIX_IOVA_S words when
+ * [SEGS] \>= 2. Each NIX_IOVA_S word specifies the LF IOVA of first
+ * packet data byte in the corresponding segment; first NIX_IOVA_S word
+ * for segment 1, second word for segment 2, third word for segment 3.
+ * Note the third word is present when [SEGS] \>= 2 but only valid when
+ * [SEGS] = 3.  If the sum of all prior NIX_SEND_SG_S[SEG*_SIZE]s and
+ * NIX_SEND_IMM_S[SIZE]s meets or exceeds NIX_SEND_HDR_S[TOTAL], this
+ * subdescriptor will not contribute any packet data but may free buffers
+ * to NPA (see [I1]).
+ */
+union cavm_nix_send_sg_s {
+	u64 u;
+	struct cavm_nix_send_sg_s_s {
+		u64 seg1_size                        : 16;
+		u64 seg2_size                        : 16;
+		u64 seg3_size                        : 16;
+		u64 segs                             : 2;
+		u64 reserved_50_54                   : 5;
+		u64 i1                               : 1;
+		u64 i2                               : 1;
+		u64 i3                               : 1;
+		u64 ld_type                          : 2;
+		u64 subdc                            : 4;
+	} s;
+	/* struct cavm_nix_send_sg_s_s cn; */
+};
+
+/**
+ * Structure nix_send_work_s
+ *
+ * NIX Send Work Subdescriptor Structure This subdescriptor adds work to
+ * the SSO. At most one NIX_SEND_WORK_S subdescriptor can exist in the
+ * NIX send descriptor. If a NIX_SEND_WORK_S exists in the descriptor, it
+ * must be the last subdescriptor. NIX will not initiate the work add for
+ * this subdescriptor until after (1) it has completed all LLC/DRAM
+ * fetches that service all prior NIX_SEND_SG_S subdescriptors, (2) it
+ * has fetched all subdescriptors in the descriptor, and (3) all
+ * NIX_SEND_MEM_S[WMEM]=1 LLC/DRAM updates have completed.  Provided the
+ * path of descriptors from the SQ through NIX to an output FIFO is
+ * unmodified between the descriptors (as should normally be the case,
+ * but it is possible for software to change the path), NIX also (1) will
+ * submit the SSO add works from all descriptors in the SQ in order, and
+ * (2) will not submit an SSO work add until after all prior descriptors
+ * in the SQ have completed their NIX_SEND_SG_S processing, and (3) will
+ * not submit an SSO work add until after it has fetched all
+ * subdescriptors from prior descriptors in the SQ.  When
+ * NIX_SEND_EXT_S[LSO] is set in the descriptor, NIX executes the
+ * NIX_SEND_WORK_S work add only while processing the last LSO segment,
+ * after processing prior segments.  Hardware ignores NIX_SEND_WORK_S
+ * when NIX_SQ_CTX_S[SSO_ENA] is clear.
+ */
+union cavm_nix_send_work_s {
+	u64 u[2];
+	struct cavm_nix_send_work_s_s {
+		u64 tag                              : 32;
+		u64 tt                               : 2;
+		u64 grp                              : 10;
+		u64 reserved_44_59                   : 16;
+		u64 subdc                            : 4;
+		u64 addr                             : 64;
+	} s;
+	/* struct cavm_nix_send_work_s_s cn; */
+};
+
+/**
+ * Structure nix_sq_ctx_hw_s
+ *
+ * NIX SQ Context Hardware Structure This structure contains context
+ * state maintained by hardware for each SQ in NDC/LLC/DRAM. Software
+ * uses the equivalent NIX_SQ_CTX_S structure format to read and write an
+ * SQ context with the NIX admin queue. Always stored in byte invariant
+ * little-endian format (LE8).
+ */
+union cavm_nix_sq_ctx_hw_s {
+	u64 u[16];
+	struct cavm_nix_sq_ctx_hw_s_s {
+		u64 ena                              : 1;
+		u64 substream                        : 20;
+		u64 max_sqe_size                     : 2;
+		u64 sqe_way_mask                     : 16;
+		u64 sqb_aura                         : 20;
+		u64 gbl_rsvd1                        : 5;
+		u64 cq_id                            : 20;
+		u64 cq_ena                           : 1;
+		u64 qint_idx                         : 6;
+		u64 gbl_rsvd2                        : 1;
+		u64 sq_int                           : 8;
+		u64 sq_int_ena                       : 8;
+		u64 xoff                             : 1;
+		u64 sqe_stype                        : 2;
+		u64 gbl_rsvd                         : 17;
+		u64 head_sqb                         : 64;
+		u64 head_offset                      : 6;
+		u64 sqb_dequeue_count                : 16;
+		u64 default_chan                     : 12;
+		u64 sdp_mcast                        : 1;
+		u64 sso_ena                          : 1;
+		u64 dse_rsvd1                        : 28;
+		u64 sqb_enqueue_count                : 16;
+		u64 tail_offset                      : 6;
+		u64 lmt_dis                          : 1;
+		u64 smq_rr_quantum                   : 24;
+		u64 dnq_rsvd1                        : 17;
+		u64 tail_sqb                         : 64;
+		u64 next_sqb                         : 64;
+		u64 mnq_dis                          : 1;
+		u64 smq                              : 9;
+		u64 smq_pend                         : 1;
+		u64 smq_next_sq                      : 20;
+		u64 smq_next_sq_vld                  : 1;
+		u64 scm1_rsvd2                       : 32;
+		u64 smenq_sqb                        : 64;
+		u64 smenq_offset                     : 6;
+		u64 cq_limit                         : 8;
+		u64 smq_rr_count                     : 25;
+		u64 scm_lso_rem                      : 18;
+		u64 scm_dq_rsvd0                     : 7;
+		u64 smq_lso_segnum                   : 8;
+		u64 vfi_lso_total                    : 18;
+		u64 vfi_lso_sizem1                   : 3;
+		u64 vfi_lso_sb                       : 8;
+		u64 vfi_lso_mps                      : 14;
+		u64 vfi_lso_vlan0_ins_ena            : 1;
+		u64 vfi_lso_vlan1_ins_ena            : 1;
+		u64 vfi_lso_vld                      : 1;
+		u64 smenq_next_sqb_vld               : 1;
+		u64 scm_dq_rsvd1                     : 9;
+		u64 smenq_next_sqb                   : 64;
+		u64 seb_rsvd1                        : 64;
+		u64 drop_pkts                        : 48;
+		u64 drop_octs_lsw                    : 16;
+		u64 drop_octs_msw                    : 32;
+		u64 pkts_lsw                         : 32;
+		u64 pkts_msw                         : 16;
+		u64 octs                             : 48;
+	} s;
+	/* struct cavm_nix_sq_ctx_hw_s_s cn; */
+};
+
+/**
+ * Structure nix_sq_ctx_s
+ *
+ * NIX Send Queue Context Structure This structure specifies the format
+ * used by software with the NIX admin queue to read and write a send
+ * queue's NIX_SQ_CTX_HW_S structure maintained by hardware in
+ * NDC/LLC/DRAM.  The SQ statistics ([OCTS], [PKTS], [DROP_OCTS],
+ * [DROP_PKTS]) do not account for packet replication due to
+ * NIX_TX_ACTION_S[OP] = NIX_TX_ACTIONOP_E::MCAST.
+ */
+union cavm_nix_sq_ctx_s {
+	u64 u[16];
+	struct cavm_nix_sq_ctx_s_s {
+		u64 ena                              : 1;
+		u64 qint_idx                         : 6;
+		u64 substream                        : 20;
+		u64 sdp_mcast                        : 1;
+		u64 cq                               : 20;
+		u64 sqe_way_mask                     : 16;
+		u64 smq                              : 9;
+		u64 cq_ena                           : 1;
+		u64 xoff                             : 1;
+		u64 sso_ena                          : 1;
+		u64 smq_rr_quantum                   : 24;
+		u64 default_chan                     : 12;
+		u64 sqb_count                        : 16;
+		u64 smq_rr_count                     : 25;
+		u64 sqb_aura                         : 20;
+		u64 sq_int                           : 8;
+		u64 sq_int_ena                       : 8;
+		u64 sqe_stype                        : 2;
+		u64 reserved_191                     : 1;
+		u64 max_sqe_size                     : 2;
+		u64 cq_limit                         : 8;
+		u64 lmt_dis                          : 1;
+		u64 mnq_dis                          : 1;
+		u64 smq_next_sq                      : 20;
+		u64 smq_lso_segnum                   : 8;
+		u64 tail_offset                      : 6;
+		u64 smenq_offset                     : 6;
+		u64 head_offset                      : 6;
+		u64 smenq_next_sqb_vld               : 1;
+		u64 smq_pend                         : 1;
+		u64 smq_next_sq_vld                  : 1;
+		u64 reserved_253_255                 : 3;
+		u64 next_sqb                         : 64;
+		u64 tail_sqb                         : 64;
+		u64 smenq_sqb                        : 64;
+		u64 smenq_next_sqb                   : 64;
+		u64 head_sqb                         : 64;
+		u64 reserved_576_583                 : 8;
+		u64 vfi_lso_total                    : 18;
+		u64 vfi_lso_sizem1                   : 3;
+		u64 vfi_lso_sb                       : 8;
+		u64 vfi_lso_mps                      : 14;
+		u64 vfi_lso_vlan0_ins_ena            : 1;
+		u64 vfi_lso_vlan1_ins_ena            : 1;
+		u64 vfi_lso_vld                      : 1;
+		u64 reserved_630_639                 : 10;
+		u64 scm_lso_rem                      : 18;
+		u64 reserved_658_703                 : 46;
+		u64 octs                             : 48;
+		u64 reserved_752_767                 : 16;
+		u64 pkts                             : 48;
+		u64 reserved_816_831                 : 16;
+		u64 reserved_832_895                 : 64;
+		u64 drop_octs                        : 48;
+		u64 reserved_944_959                 : 16;
+		u64 drop_pkts                        : 48;
+		u64 reserved_1008_1023               : 16;
+	} s;
+	/* struct cavm_nix_sq_ctx_s_s cn; */
+};
+
+/**
+ * Structure nix_tx_action_s
+ *
+ * NIX Transmit Action Structure This structure defines the format of
+ * NPC_RESULT_S[ACTION] for a transmit packet.
+ */
+union cavm_nix_tx_action_s {
+	u64 u;
+	struct cavm_nix_tx_action_s_s {
+		u64 op                               : 4;
+		u64 reserved_4_11                    : 8;
+		u64 index                            : 20;
+		u64 match_id                         : 16;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_nix_tx_action_s_s cn; */
+};
+
+/**
+ * Structure nix_tx_vtag_action_s
+ *
+ * NIX Transmit Vtag Action Structure This structure defines the format
+ * of NPC_RESULT_S[VTAG_ACTION] for a transmit packet. It specifies the
+ * optional insertion or replacement of up to two Vtags (e.g.
+ * C-VLAN/S-VLAN tags, 802.1BR E-TAG).  If two Vtags are specified: * The
+ * Vtag 0 byte offset from packet start (see [VTAG0_RELPTR]) must be less
+ * than or equal to the Vtag 1 byte offset. * Hardware executes the Vtag
+ * 0 action first, Vtag 1 action second. * If Vtag 0 is inserted,
+ * hardware adjusts the Vtag 1 byte offset accordingly. Thus, if the two
+ * offsets are equal in the structure, hardware inserts Vtag 1
+ * immediately after Vtag 0 in the packet.  A Vtag must not be inserted
+ * or replaced within an outer or inner L3/L4 header, but may be inserted
+ * or replaced within an outer L4 payload.
+ */
+union cavm_nix_tx_vtag_action_s {
+	u64 u;
+	struct cavm_nix_tx_vtag_action_s_s {
+		u64 vtag0_relptr                     : 8;
+		u64 vtag0_lid                        : 3;
+		u64 reserved_11                      : 1;
+		u64 vtag0_op                         : 2;
+		u64 reserved_14_15                   : 2;
+		u64 vtag0_def                        : 10;
+		u64 reserved_26_31                   : 6;
+		u64 vtag1_relptr                     : 8;
+		u64 vtag1_lid                        : 3;
+		u64 reserved_43                      : 1;
+		u64 vtag1_op                         : 2;
+		u64 reserved_46_47                   : 2;
+		u64 vtag1_def                        : 10;
+		u64 reserved_58_63                   : 6;
+	} s;
+	/* struct cavm_nix_tx_vtag_action_s_s cn; */
+};
+
+/**
+ * Structure nix_wqe_hdr_s
+ *
+ * NIX Work Queue Entry Header Structure This 64-bit structure defines
+ * the first word of every receive WQE generated by NIX. It is
+ * immediately followed by NIX_RX_PARSE_S. Stored in memory as little-
+ * endian unless NIX_AF_LF()_CFG[BE] is set.
+ */
+union cavm_nix_wqe_hdr_s {
+	u64 u;
+	struct cavm_nix_wqe_hdr_s_s {
+		u64 tag                              : 32;
+		u64 tt                               : 2;
+		u64 grp                              : 10;
+		u64 node                             : 2;
+		u64 q                                : 14;
+		u64 wqe_type                         : 4;
+	} s;
+	/* struct cavm_nix_wqe_hdr_s_s cn; */
+};
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_aq_base
+ *
+ * NIX AF Admin Queue Base Address Register
+ */
+union cavm_nixx_af_aq_base {
+	u64 u;
+	struct cavm_nixx_af_aq_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 base_addr                        : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct cavm_nixx_af_aq_base_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_AQ_BASE(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_AQ_BASE(void)
+{
+	return 0x410;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_aq_cfg
+ *
+ * NIX AF Admin Queue Configuration Register
+ */
+union cavm_nixx_af_aq_cfg {
+	u64 u;
+	struct cavm_nixx_af_aq_cfg_s {
+		u64 qsize                            : 4;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cavm_nixx_af_aq_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_AQ_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_AQ_CFG(void)
+{
+	return 0x400;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_aq_done
+ *
+ * NIX AF Admin Queue Done Count Register
+ */
+union cavm_nixx_af_aq_done {
+	u64 u;
+	struct cavm_nixx_af_aq_done_s {
+		u64 done                             : 20;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct cavm_nixx_af_aq_done_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_AQ_DONE(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_AQ_DONE(void)
+{
+	return 0x450;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_aq_done_ack
+ *
+ * NIX AF Admin Queue Done Count Ack Register This register is written by
+ * software to acknowledge interrupts.
+ */
+union cavm_nixx_af_aq_done_ack {
+	u64 u;
+	struct cavm_nixx_af_aq_done_ack_s {
+		u64 done_ack                         : 20;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct cavm_nixx_af_aq_done_ack_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_AQ_DONE_ACK(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_AQ_DONE_ACK(void)
+{
+	return 0x460;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_aq_done_ena_w1c
+ *
+ * NIX AF Admin Queue Done Interrupt Enable Clear Register
+ */
+union cavm_nixx_af_aq_done_ena_w1c {
+	u64 u;
+	struct cavm_nixx_af_aq_done_ena_w1c_s {
+		u64 done                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_nixx_af_aq_done_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_AQ_DONE_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_AQ_DONE_ENA_W1C(void)
+{
+	return 0x498;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_aq_done_ena_w1s
+ *
+ * NIX AF Admin Queue Done Interrupt Enable Set Register
+ */
+union cavm_nixx_af_aq_done_ena_w1s {
+	u64 u;
+	struct cavm_nixx_af_aq_done_ena_w1s_s {
+		u64 done                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_nixx_af_aq_done_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_AQ_DONE_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_AQ_DONE_ENA_W1S(void)
+{
+	return 0x490;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_aq_done_int
+ *
+ * INTERNAL: NIX AF Admin Queue Done Interrupt Register
+ */
+union cavm_nixx_af_aq_done_int {
+	u64 u;
+	struct cavm_nixx_af_aq_done_int_s {
+		u64 done                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_nixx_af_aq_done_int_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_AQ_DONE_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_AQ_DONE_INT(void)
+{
+	return 0x480;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_aq_done_int_w1s
+ *
+ * INTERNAL: NIX AF Admin Queue Done Interrupt Set Register
+ */
+union cavm_nixx_af_aq_done_int_w1s {
+	u64 u;
+	struct cavm_nixx_af_aq_done_int_w1s_s {
+		u64 done                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_nixx_af_aq_done_int_w1s_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_AQ_DONE_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_AQ_DONE_INT_W1S(void)
+{
+	return 0x488;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_aq_done_timer
+ *
+ * NIX AF Admin Queue Done Interrupt Timer Register
+ */
+union cavm_nixx_af_aq_done_timer {
+	u64 u;
+	struct cavm_nixx_af_aq_done_timer_s {
+		u64 count                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_nixx_af_aq_done_timer_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_AQ_DONE_TIMER(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_AQ_DONE_TIMER(void)
+{
+	return 0x470;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_aq_done_wait
+ *
+ * NIX AF Admin Queue Done Interrupt Coalescing Wait Register Specifies
+ * the queue interrupt coalescing settings.
+ */
+union cavm_nixx_af_aq_done_wait {
+	u64 u;
+	struct cavm_nixx_af_aq_done_wait_s {
+		u64 num_wait                         : 20;
+		u64 reserved_20_31                   : 12;
+		u64 time_wait                        : 16;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_nixx_af_aq_done_wait_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_AQ_DONE_WAIT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_AQ_DONE_WAIT(void)
+{
+	return 0x440;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_aq_door
+ *
+ * NIX AF Admin Queue Doorbell Register Software writes to this register
+ * to enqueue entries to AQ.
+ */
+union cavm_nixx_af_aq_door {
+	u64 u;
+	struct cavm_nixx_af_aq_door_s {
+		u64 count                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_nixx_af_aq_door_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_AQ_DOOR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_AQ_DOOR(void)
+{
+	return 0x430;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_aq_status
+ *
+ * NIX AF Admin Queue Status Register
+ */
+union cavm_nixx_af_aq_status {
+	u64 u;
+	struct cavm_nixx_af_aq_status_s {
+		u64 reserved_0_3                     : 4;
+		u64 head_ptr                         : 20;
+		u64 reserved_24_35                   : 12;
+		u64 tail_ptr                         : 20;
+		u64 reserved_56_61                   : 6;
+		u64 aq_busy                          : 1;
+		u64 aq_err                           : 1;
+	} s;
+	struct cavm_nixx_af_aq_status_cn {
+		u64 reserved_0_3                     : 4;
+		u64 head_ptr                         : 20;
+		u64 reserved_24_31                   : 8;
+		u64 reserved_32_35                   : 4;
+		u64 tail_ptr                         : 20;
+		u64 reserved_56_61                   : 6;
+		u64 aq_busy                          : 1;
+		u64 aq_err                           : 1;
+	} cn;
+};
+
+static inline u64 CAVM_NIXX_AF_AQ_STATUS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_AQ_STATUS(void)
+{
+	return 0x420;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_avg_delay
+ *
+ * NIX AF Queue Average Delay Register
+ */
+union cavm_nixx_af_avg_delay {
+	u64 u;
+	struct cavm_nixx_af_avg_delay_s {
+		u64 avg_dly                          : 19;
+		u64 reserved_19_23                   : 5;
+		u64 avg_timer                        : 16;
+		u64 reserved_40_63                   : 24;
+	} s;
+	/* struct cavm_nixx_af_avg_delay_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_AVG_DELAY(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_AVG_DELAY(void)
+{
+	return 0xe0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_bar2_alias#
+ *
+ * INTERNAL: NIX Admin Function  BAR2 Alias Registers  These registers
+ * alias to the NIX BAR2 registers for the PF and function selected by
+ * NIX_AF_BAR2_SEL[PF_FUNC].  Internal: Not implemented. Placeholder for
+ * bug33464.
+ */
+union cavm_nixx_af_bar2_aliasx {
+	u64 u;
+	struct cavm_nixx_af_bar2_aliasx_s {
+		u64 data                             : 64;
+	} s;
+	/* struct cavm_nixx_af_bar2_aliasx_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_BAR2_ALIASX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_BAR2_ALIASX(u64 a)
+{
+	return 0x9100000 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_bar2_sel
+ *
+ * INTERNAL: NIX Admin Function BAR2 Select Register  This register
+ * configures BAR2 accesses from the NIX_AF_BAR2_ALIAS() registers in
+ * BAR0. Internal: Not implemented. Placeholder for bug33464.
+ */
+union cavm_nixx_af_bar2_sel {
+	u64 u;
+	struct cavm_nixx_af_bar2_sel_s {
+		u64 alias_pf_func                    : 16;
+		u64 alias_ena                        : 1;
+		u64 reserved_17_63                   : 47;
+	} s;
+	/* struct cavm_nixx_af_bar2_sel_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_BAR2_SEL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_BAR2_SEL(void)
+{
+	return 0x9000000;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_blk_rst
+ *
+ * NIX AF Block Reset Register
+ */
+union cavm_nixx_af_blk_rst {
+	u64 u;
+	struct cavm_nixx_af_blk_rst_s {
+		u64 rst                              : 1;
+		u64 reserved_1_62                    : 62;
+		u64 busy                             : 1;
+	} s;
+	/* struct cavm_nixx_af_blk_rst_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_BLK_RST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_BLK_RST(void)
+{
+	return 0xb0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_cfg
+ *
+ * NIX AF General Configuration Register
+ */
+union cavm_nixx_af_cfg {
+	u64 u;
+	struct cavm_nixx_af_cfg_s {
+		u64 force_cond_clk_en                : 1;
+		u64 force_rx_gbl_clk_en              : 1;
+		u64 force_rx_strm_clk_en             : 1;
+		u64 force_cqm_clk_en                 : 1;
+		u64 force_seb_clk_en                 : 1;
+		u64 force_sqm_clk_en                 : 1;
+		u64 force_pse_clk_en                 : 1;
+		u64 reserved_7                       : 1;
+		u64 af_be                            : 1;
+		u64 calibrate_x2p                    : 1;
+		u64 force_intf_clk_en                : 1;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct cavm_nixx_af_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_CFG(void)
+{
+	return 0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_cint_delay
+ *
+ * NIX AF Completion Interrupt Delay Register
+ */
+union cavm_nixx_af_cint_delay {
+	u64 u;
+	struct cavm_nixx_af_cint_delay_s {
+		u64 cint_dly                         : 10;
+		u64 reserved_10_15                   : 6;
+		u64 cint_timer                       : 16;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cavm_nixx_af_cint_delay_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_CINT_DELAY(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_CINT_DELAY(void)
+{
+	return 0xf0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_cint_timer#
+ *
+ * NIX AF Completion Interrupt Timer Registers
+ */
+union cavm_nixx_af_cint_timerx {
+	u64 u;
+	struct cavm_nixx_af_cint_timerx_s {
+		u64 expir_time                       : 16;
+		u64 cint                             : 7;
+		u64 reserved_23                      : 1;
+		u64 lf                               : 8;
+		u64 active                           : 1;
+		u64 reserved_33_63                   : 31;
+	} s;
+	/* struct cavm_nixx_af_cint_timerx_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_CINT_TIMERX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_CINT_TIMERX(u64 a)
+{
+	return 0x1a40 + 0x40000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_const
+ *
+ * NIX AF Constants Register This register contains constants for
+ * software discovery.
+ */
+union cavm_nixx_af_const {
+	u64 u;
+	struct cavm_nixx_af_const_s {
+		u64 cgx_lmac_channels                : 8;
+		u64 cgx_lmacs                        : 4;
+		u64 num_cgx                          : 4;
+		u64 lbk_channels                     : 8;
+		u64 num_lbk                          : 4;
+		u64 num_sdp                          : 4;
+		u64 reserved_32_47                   : 16;
+		u64 links                            : 8;
+		u64 intfs                            : 4;
+		u64 reserved_60_63                   : 4;
+	} s;
+	/* struct cavm_nixx_af_const_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_CONST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_CONST(void)
+{
+	return 0x20;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_const1
+ *
+ * NIX AF Constants 1 Register This register contains constants for
+ * software discovery.
+ */
+union cavm_nixx_af_const1 {
+	u64 u;
+	struct cavm_nixx_af_const1_s {
+		u64 sdp_channels                     : 12;
+		u64 rx_bpids                         : 12;
+		u64 lf_tx_stats                      : 8;
+		u64 lf_rx_stats                      : 8;
+		u64 lso_format_fields                : 8;
+		u64 lso_formats                      : 8;
+		u64 reserved_56_63                   : 8;
+	} s;
+	/* struct cavm_nixx_af_const1_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_CONST1(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_CONST1(void)
+{
+	return 0x28;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_const2
+ *
+ * NIX AF Constants 2 Register This register contains constants for
+ * software discovery.
+ */
+union cavm_nixx_af_const2 {
+	u64 u;
+	struct cavm_nixx_af_const2_s {
+		u64 lfs                              : 12;
+		u64 qints                            : 12;
+		u64 cints                            : 12;
+		u64 reserved_36_63                   : 28;
+	} s;
+	/* struct cavm_nixx_af_const2_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_CONST2(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_CONST2(void)
+{
+	return 0x30;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_const3
+ *
+ * NIX AF Constants 2 Register This register contains constants for
+ * software discovery.
+ */
+union cavm_nixx_af_const3 {
+	u64 u;
+	struct cavm_nixx_af_const3_s {
+		u64 sq_ctx_log2bytes                 : 4;
+		u64 rq_ctx_log2bytes                 : 4;
+		u64 cq_ctx_log2bytes                 : 4;
+		u64 rsse_log2bytes                   : 4;
+		u64 mce_log2bytes                    : 4;
+		u64 qint_log2bytes                   : 4;
+		u64 cint_log2bytes                   : 4;
+		u64 dyno_log2bytes                   : 4;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cavm_nixx_af_const3_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_CONST3(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_CONST3(void)
+{
+	return 0x38;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_cq_const
+ *
+ * NIX AF CQ Constants Register This register contains constants for
+ * software discovery.
+ */
+union cavm_nixx_af_cq_const {
+	u64 u;
+	struct cavm_nixx_af_cq_const_s {
+		u64 queues_per_lf                    : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	/* struct cavm_nixx_af_cq_const_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_CQ_CONST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_CQ_CONST(void)
+{
+	return 0x48;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_cqm_bp_test
+ *
+ * INTERNAL: NIX AF CQM Backpressure Test Registers
+ */
+union cavm_nixx_af_cqm_bp_test {
+	u64 u;
+	struct cavm_nixx_af_cqm_bp_test_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 24;
+		u64 enable                           : 12;
+		u64 reserved_52_63                   : 12;
+	} s;
+	/* struct cavm_nixx_af_cqm_bp_test_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_CQM_BP_TEST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_CQM_BP_TEST(void)
+{
+	return 0x48c0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_cqm_eco
+ *
+ * INTERNAL: AF CQM ECO Register
+ */
+union cavm_nixx_af_cqm_eco {
+	u64 u;
+	struct cavm_nixx_af_cqm_eco_s {
+		u64 eco_rw                           : 64;
+	} s;
+	/* struct cavm_nixx_af_cqm_eco_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_CQM_ECO(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_CQM_ECO(void)
+{
+	return 0x590;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_csi_eco
+ *
+ * INTERNAL: AF CSI ECO Register
+ */
+union cavm_nixx_af_csi_eco {
+	u64 u;
+	struct cavm_nixx_af_csi_eco_s {
+		u64 eco_rw                           : 64;
+	} s;
+	/* struct cavm_nixx_af_csi_eco_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_CSI_ECO(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_CSI_ECO(void)
+{
+	return 0x580;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_err_int
+ *
+ * NIX Admin Function Error Interrupt Register
+ */
+union cavm_nixx_af_err_int {
+	u64 u;
+	struct cavm_nixx_af_err_int_s {
+		u64 rx_mcast_data_fault              : 1;
+		u64 rx_mirror_data_fault             : 1;
+		u64 rx_mcast_wqe_fault               : 1;
+		u64 rx_mirror_wqe_fault              : 1;
+		u64 rx_mce_fault                     : 1;
+		u64 rx_mce_list_err                  : 1;
+		u64 rx_unmapped_pf_func              : 1;
+		u64 reserved_7_11                    : 5;
+		u64 aq_door_err                      : 1;
+		u64 aq_res_fault                     : 1;
+		u64 aq_inst_fault                    : 1;
+		u64 reserved_15_63                   : 49;
+	} s;
+	/* struct cavm_nixx_af_err_int_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_ERR_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_ERR_INT(void)
+{
+	return 0x180;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_err_int_ena_w1c
+ *
+ * NIX Admin Function Error Interrupt Enable Clear Register This register
+ * clears interrupt enable bits.
+ */
+union cavm_nixx_af_err_int_ena_w1c {
+	u64 u;
+	struct cavm_nixx_af_err_int_ena_w1c_s {
+		u64 rx_mcast_data_fault              : 1;
+		u64 rx_mirror_data_fault             : 1;
+		u64 rx_mcast_wqe_fault               : 1;
+		u64 rx_mirror_wqe_fault              : 1;
+		u64 rx_mce_fault                     : 1;
+		u64 rx_mce_list_err                  : 1;
+		u64 rx_unmapped_pf_func              : 1;
+		u64 reserved_7_11                    : 5;
+		u64 aq_door_err                      : 1;
+		u64 aq_res_fault                     : 1;
+		u64 aq_inst_fault                    : 1;
+		u64 reserved_15_63                   : 49;
+	} s;
+	/* struct cavm_nixx_af_err_int_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_ERR_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_ERR_INT_ENA_W1C(void)
+{
+	return 0x198;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_err_int_ena_w1s
+ *
+ * NIX Admin Function Error Interrupt Enable Set Register This register
+ * sets interrupt enable bits.
+ */
+union cavm_nixx_af_err_int_ena_w1s {
+	u64 u;
+	struct cavm_nixx_af_err_int_ena_w1s_s {
+		u64 rx_mcast_data_fault              : 1;
+		u64 rx_mirror_data_fault             : 1;
+		u64 rx_mcast_wqe_fault               : 1;
+		u64 rx_mirror_wqe_fault              : 1;
+		u64 rx_mce_fault                     : 1;
+		u64 rx_mce_list_err                  : 1;
+		u64 rx_unmapped_pf_func              : 1;
+		u64 reserved_7_11                    : 5;
+		u64 aq_door_err                      : 1;
+		u64 aq_res_fault                     : 1;
+		u64 aq_inst_fault                    : 1;
+		u64 reserved_15_63                   : 49;
+	} s;
+	/* struct cavm_nixx_af_err_int_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_ERR_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_ERR_INT_ENA_W1S(void)
+{
+	return 0x190;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_err_int_w1s
+ *
+ * NIX Admin Function Error Interrupt Set Register This register sets
+ * interrupt bits.
+ */
+union cavm_nixx_af_err_int_w1s {
+	u64 u;
+	struct cavm_nixx_af_err_int_w1s_s {
+		u64 rx_mcast_data_fault              : 1;
+		u64 rx_mirror_data_fault             : 1;
+		u64 rx_mcast_wqe_fault               : 1;
+		u64 rx_mirror_wqe_fault              : 1;
+		u64 rx_mce_fault                     : 1;
+		u64 rx_mce_list_err                  : 1;
+		u64 rx_unmapped_pf_func              : 1;
+		u64 reserved_7_11                    : 5;
+		u64 aq_door_err                      : 1;
+		u64 aq_res_fault                     : 1;
+		u64 aq_inst_fault                    : 1;
+		u64 reserved_15_63                   : 49;
+	} s;
+	/* struct cavm_nixx_af_err_int_w1s_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_ERR_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_ERR_INT_W1S(void)
+{
+	return 0x188;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_expr_tx_fifo_status
+ *
+ * NIX AF Express Transmit FIFO Status Register Status of FIFO which
+ * transmits express packets to CGX and LBK.
+ */
+union cavm_nixx_af_expr_tx_fifo_status {
+	u64 u;
+	struct cavm_nixx_af_expr_tx_fifo_status_s {
+		u64 count                            : 12;
+		u64 reserved_12_63                   : 52;
+	} s;
+	/* struct cavm_nixx_af_expr_tx_fifo_status_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_EXPR_TX_FIFO_STATUS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_EXPR_TX_FIFO_STATUS(void)
+{
+	return 0x640;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_gen_int
+ *
+ * NIX AF General Interrupt Register
+ */
+union cavm_nixx_af_gen_int {
+	u64 u;
+	struct cavm_nixx_af_gen_int_s {
+		u64 rx_mcast_drop                    : 1;
+		u64 rx_mirror_drop                   : 1;
+		u64 reserved_2                       : 1;
+		u64 tl1_drain                        : 1;
+		u64 smq_flush_done                   : 1;
+		u64 reserved_5_63                    : 59;
+	} s;
+	/* struct cavm_nixx_af_gen_int_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_GEN_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_GEN_INT(void)
+{
+	return 0x160;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_gen_int_ena_w1c
+ *
+ * NIX AF General Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union cavm_nixx_af_gen_int_ena_w1c {
+	u64 u;
+	struct cavm_nixx_af_gen_int_ena_w1c_s {
+		u64 rx_mcast_drop                    : 1;
+		u64 rx_mirror_drop                   : 1;
+		u64 reserved_2                       : 1;
+		u64 tl1_drain                        : 1;
+		u64 smq_flush_done                   : 1;
+		u64 reserved_5_63                    : 59;
+	} s;
+	/* struct cavm_nixx_af_gen_int_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_GEN_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_GEN_INT_ENA_W1C(void)
+{
+	return 0x178;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_gen_int_ena_w1s
+ *
+ * NIX AF General Interrupt Enable Set Register This register sets
+ * interrupt enable bits.
+ */
+union cavm_nixx_af_gen_int_ena_w1s {
+	u64 u;
+	struct cavm_nixx_af_gen_int_ena_w1s_s {
+		u64 rx_mcast_drop                    : 1;
+		u64 rx_mirror_drop                   : 1;
+		u64 reserved_2                       : 1;
+		u64 tl1_drain                        : 1;
+		u64 smq_flush_done                   : 1;
+		u64 reserved_5_63                    : 59;
+	} s;
+	/* struct cavm_nixx_af_gen_int_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_GEN_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_GEN_INT_ENA_W1S(void)
+{
+	return 0x170;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_gen_int_w1s
+ *
+ * NIX AF General Interrupt Set Register This register sets interrupt
+ * bits.
+ */
+union cavm_nixx_af_gen_int_w1s {
+	u64 u;
+	struct cavm_nixx_af_gen_int_w1s_s {
+		u64 rx_mcast_drop                    : 1;
+		u64 rx_mirror_drop                   : 1;
+		u64 reserved_2                       : 1;
+		u64 tl1_drain                        : 1;
+		u64 smq_flush_done                   : 1;
+		u64 reserved_5_63                    : 59;
+	} s;
+	/* struct cavm_nixx_af_gen_int_w1s_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_GEN_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_GEN_INT_W1S(void)
+{
+	return 0x168;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_cfg
+ *
+ * NIX AF Local Function Configuration Registers
+ */
+union cavm_nixx_af_lfx_cfg {
+	u64 u;
+	struct cavm_nixx_af_lfx_cfg_s {
+		u64 npa_pf_func                      : 16;
+		u64 sso_pf_func                      : 16;
+		u64 be                               : 1;
+		u64 xqe_size                         : 2;
+		u64 reserved_35_63                   : 29;
+	} s;
+	/* struct cavm_nixx_af_lfx_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_LFX_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LFX_CFG(u64 a)
+{
+	return 0x4000 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_cints_base
+ *
+ * NIX AF Local Function Completion Interrupts Base Address Registers
+ * This register specifies the base AF IOVA of LF's completion interrupt
+ * context table in NDC/LLC/DRAM. The table consists of
+ * NIX_AF_CONST2[CINTS] contiguous NIX_CINT_HW_S structures.
+ */
+union cavm_nixx_af_lfx_cints_base {
+	u64 u;
+	struct cavm_nixx_af_lfx_cints_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 addr                             : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct cavm_nixx_af_lfx_cints_base_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_LFX_CINTS_BASE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LFX_CINTS_BASE(u64 a)
+{
+	return 0x4130 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_cints_cfg
+ *
+ * NIX AF Local Function Completion Interrupts Configuration Registers
+ * This register controls access to the LF's completion interrupt context
+ * table in NDC/LLC/DRAM. The table consists of NIX_AF_CONST2[CINTS]
+ * contiguous NIX_CINT_HW_S structures. The size of each structure is 1
+ * \<\< NIX_AF_CONST3[CINT_LOG2BYTES].
+ */
+union cavm_nixx_af_lfx_cints_cfg {
+	u64 u;
+	struct cavm_nixx_af_lfx_cints_cfg_s {
+		u64 reserved_0_19                    : 20;
+		u64 way_mask                         : 16;
+		u64 caching                          : 1;
+		u64 reserved_37_63                   : 27;
+	} s;
+	/* struct cavm_nixx_af_lfx_cints_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_LFX_CINTS_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LFX_CINTS_CFG(u64 a)
+{
+	return 0x4120 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_cqs_base
+ *
+ * NIX AF Local Function Completion Queues Base Address Register This
+ * register specifies the base AF IOVA of the LF's CQ context table. The
+ * table consists of NIX_AF_LF()_CQS_CFG[MAX_QUEUESM1]+1 contiguous
+ * NIX_CQ_CTX_S structures.
+ */
+union cavm_nixx_af_lfx_cqs_base {
+	u64 u;
+	struct cavm_nixx_af_lfx_cqs_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 addr                             : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct cavm_nixx_af_lfx_cqs_base_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_LFX_CQS_BASE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LFX_CQS_BASE(u64 a)
+{
+	return 0x4070 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_cqs_cfg
+ *
+ * NIX AF Local Function Completion Queues Configuration Register This
+ * register configures completion queues in the LF.
+ */
+union cavm_nixx_af_lfx_cqs_cfg {
+	u64 u;
+	struct cavm_nixx_af_lfx_cqs_cfg_s {
+		u64 max_queuesm1                     : 20;
+		u64 way_mask                         : 16;
+		u64 caching                          : 1;
+		u64 reserved_37_63                   : 27;
+	} s;
+	/* struct cavm_nixx_af_lfx_cqs_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_LFX_CQS_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LFX_CQS_CFG(u64 a)
+{
+	return 0x4060 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_lock#
+ *
+ * NIX AF Local Function Lockdown Registers Internal: The NIX lockdown
+ * depth of 32 bytes is shallow compared to 96 bytes for NIC and meant
+ * for outer MAC and/or VLAN (optionally preceded by a small number of
+ * skip bytes). NPC's MCAM can be used for deeper protocol-aware
+ * lockdown.
+ */
+union cavm_nixx_af_lfx_lockx {
+	u64 u;
+	struct cavm_nixx_af_lfx_lockx_s {
+		u64 data                             : 32;
+		u64 bit_ena                          : 32;
+	} s;
+	/* struct cavm_nixx_af_lfx_lockx_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_LFX_LOCKX(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LFX_LOCKX(u64 a, u64 b)
+{
+	return 0x4300 + 0x20000 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_qints_base
+ *
+ * NIX AF Local Function Queue Interrupts Base Address Registers This
+ * register specifies the base AF IOVA of LF's queue interrupt context
+ * table in NDC/LLC/DRAM. The table consists of NIX_AF_CONST2[QINTS]
+ * contiguous NIX_QINT_HW_S structures.
+ */
+union cavm_nixx_af_lfx_qints_base {
+	u64 u;
+	struct cavm_nixx_af_lfx_qints_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 addr                             : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct cavm_nixx_af_lfx_qints_base_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_LFX_QINTS_BASE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LFX_QINTS_BASE(u64 a)
+{
+	return 0x4110 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_qints_cfg
+ *
+ * NIX AF Local Function Queue Interrupts Configuration Registers This
+ * register controls access to the LF's queue interrupt context table in
+ * NDC/LLC/DRAM. The table consists of NIX_AF_CONST2[QINTS] contiguous
+ * NIX_QINT_HW_S structures. The size of each structure is 1 \<\<
+ * NIX_AF_CONST3[QINT_LOG2BYTES].
+ */
+union cavm_nixx_af_lfx_qints_cfg {
+	u64 u;
+	struct cavm_nixx_af_lfx_qints_cfg_s {
+		u64 reserved_0_19                    : 20;
+		u64 way_mask                         : 16;
+		u64 caching                          : 1;
+		u64 reserved_37_63                   : 27;
+	} s;
+	/* struct cavm_nixx_af_lfx_qints_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_LFX_QINTS_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LFX_QINTS_CFG(u64 a)
+{
+	return 0x4100 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_rqs_base
+ *
+ * NIX AF Local Function Receive Queues Base Address Register This
+ * register specifies the base AF IOVA of the LF's RQ context table. The
+ * table consists of NIX_AF_LF()_RQS_CFG[MAX_QUEUESM1]+1 contiguous
+ * NIX_RQ_CTX_S structures.
+ */
+union cavm_nixx_af_lfx_rqs_base {
+	u64 u;
+	struct cavm_nixx_af_lfx_rqs_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 addr                             : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct cavm_nixx_af_lfx_rqs_base_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_LFX_RQS_BASE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LFX_RQS_BASE(u64 a)
+{
+	return 0x4050 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_rqs_cfg
+ *
+ * NIX AF Local Function Receive Queues Configuration Register This
+ * register configures receive queues in the LF.
+ */
+union cavm_nixx_af_lfx_rqs_cfg {
+	u64 u;
+	struct cavm_nixx_af_lfx_rqs_cfg_s {
+		u64 max_queuesm1                     : 20;
+		u64 way_mask                         : 16;
+		u64 caching                          : 1;
+		u64 reserved_37_63                   : 27;
+	} s;
+	/* struct cavm_nixx_af_lfx_rqs_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_LFX_RQS_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LFX_RQS_CFG(u64 a)
+{
+	return 0x4040 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_rss_base
+ *
+ * NIX AF Local Function Receive Size Scaling Table Base Address Register
+ * This register specifies the base AF IOVA of the RSS table per LF. The
+ * table is present when NIX_AF_LF()_RSS_CFG[ENA] is set and consists of
+ * 1 \<\< (NIX_AF_LF()_RSS_CFG[SIZE] + 8) contiguous NIX_RSSE_S
+ * structures, where the size of each structure is 1 \<\<
+ * NIX_AF_CONST3[RSSE_LOG2BYTES]. See NIX_AF_LF()_RSS_GRP().
+ */
+union cavm_nixx_af_lfx_rss_base {
+	u64 u;
+	struct cavm_nixx_af_lfx_rss_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 addr                             : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct cavm_nixx_af_lfx_rss_base_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_LFX_RSS_BASE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LFX_RSS_BASE(u64 a)
+{
+	return 0x40d0 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_rss_cfg
+ *
+ * NIX AF Local Function Receive Size Scaling Table Configuration
+ * Register See NIX_AF_LF()_RSS_BASE and NIX_AF_LF()_RSS_GRP().
+ */
+union cavm_nixx_af_lfx_rss_cfg {
+	u64 u;
+	struct cavm_nixx_af_lfx_rss_cfg_s {
+		u64 size                             : 4;
+		u64 ena                              : 1;
+		u64 reserved_5_19                    : 15;
+		u64 way_mask                         : 16;
+		u64 caching                          : 1;
+		u64 reserved_37_63                   : 27;
+	} s;
+	/* struct cavm_nixx_af_lfx_rss_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_LFX_RSS_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LFX_RSS_CFG(u64 a)
+{
+	return 0x40c0 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_rss_grp#
+ *
+ * NIX AF Local Function Receive Side Scaling Group Registers A receive
+ * packet targets a LF's RSS group when its NIX_RX_ACTION_S[OP] =
+ * NIX_RX_ACTIONOP_E::RSS, or its target multicast list has an entry with
+ * NIX_RX_MCE_S[OP] = NIX_RX_MCOP_E::RSS. The RSS group index (this
+ * register's last index) is NIX_RX_ACTION_S[INDEX] or
+ * NIX_RX_MCE_S[INDEX].  The RSS computation is as follows: * The
+ * packet's flow_tag (see NIX_LF_RX_SECRET()) and RSS group are used to
+ * select a NIX_RSSE_S entry in the LF's RSS table (see [SIZEM1]). *
+ * NIX_RSSE_S selects the packet's destination RQ.
+ */
+union cavm_nixx_af_lfx_rss_grpx {
+	u64 u;
+	struct cavm_nixx_af_lfx_rss_grpx_s {
+		u64 offset                           : 11;
+		u64 reserved_11_15                   : 5;
+		u64 sizem1                           : 3;
+		u64 reserved_19_63                   : 45;
+	} s;
+	/* struct cavm_nixx_af_lfx_rss_grpx_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_LFX_RSS_GRPX(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LFX_RSS_GRPX(u64 a, u64 b)
+{
+	return 0x4600 + 0x20000 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_rx_cfg
+ *
+ * NIX AF Local Function Receive Configuration Register
+ */
+union cavm_nixx_af_lfx_rx_cfg {
+	u64 u;
+	struct cavm_nixx_af_lfx_rx_cfg_s {
+		u64 reserved_0_31                    : 32;
+		u64 drop_re                          : 1;
+		u64 lenerr_en                        : 1;
+		u64 ip6_udp_opt                      : 1;
+		u64 dis_apad                         : 1;
+		u64 csum_il4                         : 1;
+		u64 csum_ol4                         : 1;
+		u64 len_il4                          : 1;
+		u64 len_il3                          : 1;
+		u64 len_ol4                          : 1;
+		u64 len_ol3                          : 1;
+		u64 reserved_42_63                   : 22;
+	} s;
+	struct cavm_nixx_af_lfx_rx_cfg_cn96xx {
+		u64 reserved_0_31                    : 32;
+		u64 reserved_32                      : 1;
+		u64 lenerr_en                        : 1;
+		u64 ip6_udp_opt                      : 1;
+		u64 dis_apad                         : 1;
+		u64 csum_il4                         : 1;
+		u64 csum_ol4                         : 1;
+		u64 len_il4                          : 1;
+		u64 len_il3                          : 1;
+		u64 len_ol4                          : 1;
+		u64 len_ol3                          : 1;
+		u64 reserved_42_63                   : 22;
+	} cn96xx;
+	/* struct cavm_nixx_af_lfx_rx_cfg_s cnf95xx; */
+};
+
+static inline u64 CAVM_NIXX_AF_LFX_RX_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LFX_RX_CFG(u64 a)
+{
+	return 0x40a0 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_rx_ipsec_cfg0
+ *
+ * INTERNAL: NIX AF LF Receive IPSEC Configuration Registers  Internal:
+ * Not used; no IPSEC fast-path.
+ */
+union cavm_nixx_af_lfx_rx_ipsec_cfg0 {
+	u64 u;
+	struct cavm_nixx_af_lfx_rx_ipsec_cfg0_s {
+		u64 lenm1_max                        : 14;
+		u64 reserved_14_15                   : 2;
+		u64 sa_pow2_size                     : 4;
+		u64 tag_const                        : 24;
+		u64 tt                               : 2;
+		u64 defcpt                           : 1;
+		u64 hshcpt                           : 1;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_nixx_af_lfx_rx_ipsec_cfg0_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_LFX_RX_IPSEC_CFG0(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LFX_RX_IPSEC_CFG0(u64 a)
+{
+	return 0x4140 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_rx_ipsec_cfg1
+ *
+ * INTERNAL: NIX AF LF Receive IPSEC Security Association Configuration
+ * Register  Internal: Not used; no IPSEC fast-path.
+ */
+union cavm_nixx_af_lfx_rx_ipsec_cfg1 {
+	u64 u;
+	struct cavm_nixx_af_lfx_rx_ipsec_cfg1_s {
+		u64 sa_idx_max                       : 32;
+		u64 sa_idx_w                         : 5;
+		u64 reserved_37_63                   : 27;
+	} s;
+	/* struct cavm_nixx_af_lfx_rx_ipsec_cfg1_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_LFX_RX_IPSEC_CFG1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LFX_RX_IPSEC_CFG1(u64 a)
+{
+	return 0x4148 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_rx_ipsec_dyno_base
+ *
+ * INTERNAL: NIX AF LF Receive IPSEC Dynamic Ordering Base Address
+ * Registers  Internal: Not used; no IPSEC fast-path.
+ */
+union cavm_nixx_af_lfx_rx_ipsec_dyno_base {
+	u64 u;
+	struct cavm_nixx_af_lfx_rx_ipsec_dyno_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 addr                             : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct cavm_nixx_af_lfx_rx_ipsec_dyno_base_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_LFX_RX_IPSEC_DYNO_BASE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LFX_RX_IPSEC_DYNO_BASE(u64 a)
+{
+	return 0x4158 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_rx_ipsec_dyno_cfg
+ *
+ * INTERNAL: NIX AF LF Receive IPSEC Dynamic Ordering Base Address
+ * Registers  Internal: Not used; no IPSEC fast-path.
+ */
+union cavm_nixx_af_lfx_rx_ipsec_dyno_cfg {
+	u64 u;
+	struct cavm_nixx_af_lfx_rx_ipsec_dyno_cfg_s {
+		u64 dyno_idx_w                       : 4;
+		u64 dyno_ena                         : 1;
+		u64 reserved_5_19                    : 15;
+		u64 way_mask                         : 16;
+		u64 caching                          : 1;
+		u64 reserved_37_63                   : 27;
+	} s;
+	/* struct cavm_nixx_af_lfx_rx_ipsec_dyno_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_LFX_RX_IPSEC_DYNO_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LFX_RX_IPSEC_DYNO_CFG(u64 a)
+{
+	return 0x4150 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_rx_ipsec_sa_base
+ *
+ * INTERNAL: NIX AF LF Receive IPSEC Security Association Base Address
+ * Register  Internal: Not used; no IPSEC fast-path.
+ */
+union cavm_nixx_af_lfx_rx_ipsec_sa_base {
+	u64 u;
+	struct cavm_nixx_af_lfx_rx_ipsec_sa_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 addr                             : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct cavm_nixx_af_lfx_rx_ipsec_sa_base_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_LFX_RX_IPSEC_SA_BASE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LFX_RX_IPSEC_SA_BASE(u64 a)
+{
+	return 0x4170 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_rx_stat#
+ *
+ * NIX AF Local Function Receive Statistics Registers The last dimension
+ * indicates which statistic, and is enumerated by NIX_STAT_LF_RX_E.
+ */
+union cavm_nixx_af_lfx_rx_statx {
+	u64 u;
+	struct cavm_nixx_af_lfx_rx_statx_s {
+		u64 stat                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_nixx_af_lfx_rx_statx_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_LFX_RX_STATX(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LFX_RX_STATX(u64 a, u64 b)
+{
+	return 0x4500 + 0x20000 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_rx_vtag_type#
+ *
+ * NIX AF Local Function Receive Vtag Type Registers These registers
+ * specify optional Vtag (e.g. VLAN, E-TAG) actions for received packets.
+ * Indexed by NIX_RX_VTAG_ACTION_S[VTAG*_TYPE].
+ */
+union cavm_nixx_af_lfx_rx_vtag_typex {
+	u64 u;
+	struct cavm_nixx_af_lfx_rx_vtag_typex_s {
+		u64 size                             : 1;
+		u64 reserved_1_3                     : 3;
+		u64 strip                            : 1;
+		u64 capture                          : 1;
+		u64 reserved_6_63                    : 58;
+	} s;
+	/* struct cavm_nixx_af_lfx_rx_vtag_typex_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_LFX_RX_VTAG_TYPEX(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LFX_RX_VTAG_TYPEX(u64 a, u64 b)
+{
+	return 0x4200 + 0x20000 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_sqs_base
+ *
+ * NIX AF Local Function Send Queues Base Address Register This register
+ * specifies the base AF IOVA of the LF's SQ context table. The table
+ * consists of NIX_AF_LF()_SQS_CFG[MAX_QUEUESM1]+1 contiguous
+ * NIX_SQ_CTX_HW_S structures.
+ */
+union cavm_nixx_af_lfx_sqs_base {
+	u64 u;
+	struct cavm_nixx_af_lfx_sqs_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 addr                             : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct cavm_nixx_af_lfx_sqs_base_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_LFX_SQS_BASE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LFX_SQS_BASE(u64 a)
+{
+	return 0x4030 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_sqs_cfg
+ *
+ * NIX AF Local Function Send Queues Configuration Register This register
+ * configures send queues in the LF.
+ */
+union cavm_nixx_af_lfx_sqs_cfg {
+	u64 u;
+	struct cavm_nixx_af_lfx_sqs_cfg_s {
+		u64 max_queuesm1                     : 20;
+		u64 way_mask                         : 16;
+		u64 caching                          : 1;
+		u64 reserved_37_63                   : 27;
+	} s;
+	/* struct cavm_nixx_af_lfx_sqs_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_LFX_SQS_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LFX_SQS_CFG(u64 a)
+{
+	return 0x4020 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_tx_cfg
+ *
+ * NIX AF Local Function Transmit Configuration Register
+ */
+union cavm_nixx_af_lfx_tx_cfg {
+	u64 u;
+	struct cavm_nixx_af_lfx_tx_cfg_s {
+		u64 vlan0_ins_etype                  : 16;
+		u64 vlan1_ins_etype                  : 16;
+		u64 send_tstmp_ena                   : 1;
+		u64 lock_viol_cqe_ena                : 1;
+		u64 lock_ena                         : 1;
+		u64 reserved_35_63                   : 29;
+	} s;
+	/* struct cavm_nixx_af_lfx_tx_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_LFX_TX_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LFX_TX_CFG(u64 a)
+{
+	return 0x4080 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_tx_cfg2
+ *
+ * NIX AF Local Function Transmit Configuration Register
+ */
+union cavm_nixx_af_lfx_tx_cfg2 {
+	u64 u;
+	struct cavm_nixx_af_lfx_tx_cfg2_s {
+		u64 lmt_ena                          : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_nixx_af_lfx_tx_cfg2_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_LFX_TX_CFG2(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LFX_TX_CFG2(u64 a)
+{
+	return 0x4028 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_tx_parse_cfg
+ *
+ * NIX AF Local Function Transmit Parse Configuration Register
+ */
+union cavm_nixx_af_lfx_tx_parse_cfg {
+	u64 u;
+	struct cavm_nixx_af_lfx_tx_parse_cfg_s {
+		u64 pkind                            : 6;
+		u64 reserved_6_63                    : 58;
+	} s;
+	/* struct cavm_nixx_af_lfx_tx_parse_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_LFX_TX_PARSE_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LFX_TX_PARSE_CFG(u64 a)
+{
+	return 0x4090 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_tx_stat#
+ *
+ * NIX AF Local Function Transmit Statistics Registers The last dimension
+ * indicates which statistic, and is enumerated by NIX_STAT_LF_TX_E.
+ */
+union cavm_nixx_af_lfx_tx_statx {
+	u64 u;
+	struct cavm_nixx_af_lfx_tx_statx_s {
+		u64 stat                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_nixx_af_lfx_tx_statx_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_LFX_TX_STATX(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LFX_TX_STATX(u64 a, u64 b)
+{
+	return 0x4400 + 0x20000 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf#_tx_status
+ *
+ * NIX AF LF Transmit Status Register
+ */
+union cavm_nixx_af_lfx_tx_status {
+	u64 u;
+	struct cavm_nixx_af_lfx_tx_status_s {
+		u64 sq_ctx_err                       : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_nixx_af_lfx_tx_status_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_LFX_TX_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LFX_TX_STATUS(u64 a)
+{
+	return 0x4180 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lf_rst
+ *
+ * NIX Admin Function LF Reset Register
+ */
+union cavm_nixx_af_lf_rst {
+	u64 u;
+	struct cavm_nixx_af_lf_rst_s {
+		u64 lf                               : 8;
+		u64 reserved_8_11                    : 4;
+		u64 exec                             : 1;
+		u64 reserved_13_63                   : 51;
+	} s;
+	/* struct cavm_nixx_af_lf_rst_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_LF_RST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LF_RST(void)
+{
+	return 0x150;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lso_cfg
+ *
+ * NIX AF Large Send Offload Configuration Register
+ */
+union cavm_nixx_af_lso_cfg {
+	u64 u;
+	struct cavm_nixx_af_lso_cfg_s {
+		u64 tcp_lsf                          : 16;
+		u64 tcp_msf                          : 16;
+		u64 tcp_fsf                          : 16;
+		u64 reserved_48_62                   : 15;
+		u64 enable                           : 1;
+	} s;
+	/* struct cavm_nixx_af_lso_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_LSO_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LSO_CFG(void)
+{
+	return 0xa8;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_lso_format#_field#
+ *
+ * NIX AF Large Send Offload Format Field Registers These registers
+ * specify LSO packet modification formats. Each format may modify up to
+ * eight packet fields with the following constraints: * If fewer than
+ * eight fields are modified, [ALG] must be NIX_LSOALG_E::NOP in the
+ * unused field registers. * Modified fields must be specified in
+ * contiguous field registers starting with NIX_AF_LSO_FORMAT()_FIELD(0).
+ * * Modified fields cannot overlap. * Multiple fields with the same
+ * [LAYER] value must be specified in ascending [OFFSET] order. * Fields
+ * in different layers must be specified in ascending [LAYER] order.
+ */
+union cavm_nixx_af_lso_formatx_fieldx {
+	u64 u;
+	struct cavm_nixx_af_lso_formatx_fieldx_s {
+		u64 offset                           : 8;
+		u64 layer                            : 2;
+		u64 reserved_10_11                   : 2;
+		u64 sizem1                           : 2;
+		u64 reserved_14_15                   : 2;
+		u64 alg                              : 3;
+		u64 reserved_19_63                   : 45;
+	} s;
+	/* struct cavm_nixx_af_lso_formatx_fieldx_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_LSO_FORMATX_FIELDX(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_LSO_FORMATX_FIELDX(u64 a, u64 b)
+{
+	return 0x1b00 + 0x10000 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_mark_format#_ctl
+ *
+ * NIX AF Packet Marking Format Registers Describes packet marking
+ * calculations for YELLOW and for NIX_COLORRESULT_E::RED_SEND packets.
+ * NIX_SEND_EXT_S[MARKFORM] selects the CSR used for the packet
+ * descriptor.  All the packet marking offset calculations assume big-
+ * endian bits within a byte.  For example, if NIX_SEND_EXT_S[MARKPTR] is
+ * 3 and [OFFSET] is 5 and the packet is YELLOW, the NIX marking hardware
+ * would do this:  _  byte[3]\<2:0\> |=   [Y_VAL]\<3:1\> _
+ * byte[3]\<2:0\> &= ~[Y_MASK]\<3:1\> _  byte[4]\<7\>   |=   [Y_VAL]\<0\>
+ * _  byte[4]\<7\>   &= ~[Y_MASK]\<0\>  where byte[3] is the third byte
+ * in the packet, and byte[4] the fourth.  For another example, if
+ * NIX_SEND_EXT_S[MARKPTR] is 3 and [OFFSET] is 0 and the packet is
+ * NIX_COLORRESULT_E::RED_SEND,  _   byte[3]\<7:4\> |=   [R_VAL]\<3:0\> _
+ * byte[3]\<7:4\> &= ~[R_MASK]\<3:0\>
+ */
+union cavm_nixx_af_mark_formatx_ctl {
+	u64 u;
+	struct cavm_nixx_af_mark_formatx_ctl_s {
+		u64 r_val                            : 4;
+		u64 r_mask                           : 4;
+		u64 y_val                            : 4;
+		u64 y_mask                           : 4;
+		u64 offset                           : 3;
+		u64 reserved_19_63                   : 45;
+	} s;
+	/* struct cavm_nixx_af_mark_formatx_ctl_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_MARK_FORMATX_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_MARK_FORMATX_CTL(u64 a)
+{
+	return 0x900 + 0x40000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_mc_mirror_const
+ *
+ * NIX AF Multicast/Mirror Constants Register This register contains
+ * constants for software discovery.
+ */
+union cavm_nixx_af_mc_mirror_const {
+	u64 u;
+	struct cavm_nixx_af_mc_mirror_const_s {
+		u64 buf_size                         : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_nixx_af_mc_mirror_const_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_MC_MIRROR_CONST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_MC_MIRROR_CONST(void)
+{
+	return 0x98;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_mdq#_cir
+ *
+ * NIX AF Meta Descriptor Queue Committed Information Rate Registers This
+ * register has the same bit fields as NIX_AF_TL1()_CIR.
+ */
+union cavm_nixx_af_mdqx_cir {
+	u64 u;
+	struct cavm_nixx_af_mdqx_cir_s {
+		u64 enable                           : 1;
+		u64 rate_mantissa                    : 8;
+		u64 rate_exponent                    : 4;
+		u64 rate_divider_exponent            : 4;
+		u64 reserved_17_28                   : 12;
+		u64 burst_mantissa                   : 8;
+		u64 burst_exponent                   : 4;
+		u64 reserved_41_63                   : 23;
+	} s;
+	/* struct cavm_nixx_af_mdqx_cir_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_MDQX_CIR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_MDQX_CIR(u64 a)
+{
+	return 0x1420 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_mdq#_md_debug
+ *
+ * NIX AF Meta Descriptor Queue Meta Descriptor State Debug Registers
+ * This register provides access to the meta descriptor at the front of
+ * the MDQ. An MDQ can hold up to 8 packet meta descriptors (PMD) and one
+ * flush meta descriptor (FMD).
+ */
+union cavm_nixx_af_mdqx_md_debug {
+	u64 u;
+	struct cavm_nixx_af_mdqx_md_debug_s {
+		u64 pkt_len                          : 16;
+		u64 red_algo_override                : 2;
+		u64 shp_dis                          : 1;
+		u64 reserved_19                      : 1;
+		u64 shp_chg                          : 9;
+		u64 reserved_29_31                   : 3;
+		u64 sqm_pkt_id                       : 13;
+		u64 reserved_45_60                   : 16;
+		u64 md_type                          : 2;
+		u64 reserved_63                      : 1;
+	} s;
+	/* struct cavm_nixx_af_mdqx_md_debug_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_MDQX_MD_DEBUG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_MDQX_MD_DEBUG(u64 a)
+{
+	return 0x14c0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_mdq#_parent
+ *
+ * NIX AF Meta Descriptor Queue Topology Registers
+ */
+union cavm_nixx_af_mdqx_parent {
+	u64 u;
+	struct cavm_nixx_af_mdqx_parent_s {
+		u64 reserved_0_15                    : 16;
+		u64 parent                           : 9;
+		u64 reserved_25_63                   : 39;
+	} s;
+	/* struct cavm_nixx_af_mdqx_parent_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_MDQX_PARENT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_MDQX_PARENT(u64 a)
+{
+	return 0x1480 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_mdq#_pir
+ *
+ * NIX AF Meta Descriptor Queue Peak Information Rate Registers This
+ * register has the same bit fields as NIX_AF_TL1()_CIR.
+ */
+union cavm_nixx_af_mdqx_pir {
+	u64 u;
+	struct cavm_nixx_af_mdqx_pir_s {
+		u64 enable                           : 1;
+		u64 rate_mantissa                    : 8;
+		u64 rate_exponent                    : 4;
+		u64 rate_divider_exponent            : 4;
+		u64 reserved_17_28                   : 12;
+		u64 burst_mantissa                   : 8;
+		u64 burst_exponent                   : 4;
+		u64 reserved_41_63                   : 23;
+	} s;
+	/* struct cavm_nixx_af_mdqx_pir_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_MDQX_PIR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_MDQX_PIR(u64 a)
+{
+	return 0x1430 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_mdq#_pointers
+ *
+ * INTERNAL: NIX AF Meta Descriptor 4 Linked List Pointers Debug Register
+ * This register has the same bit fields as NIX_AF_TL4()_POINTERS.
+ */
+union cavm_nixx_af_mdqx_pointers {
+	u64 u;
+	struct cavm_nixx_af_mdqx_pointers_s {
+		u64 next                             : 9;
+		u64 reserved_9_15                    : 7;
+		u64 prev                             : 9;
+		u64 reserved_25_63                   : 39;
+	} s;
+	/* struct cavm_nixx_af_mdqx_pointers_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_MDQX_POINTERS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_MDQX_POINTERS(u64 a)
+{
+	return 0x1460 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_mdq#_ptr_fifo
+ *
+ * INTERNAL: NIX Meta Descriptor Queue Pointer FIFO State Debug Registers
+ */
+union cavm_nixx_af_mdqx_ptr_fifo {
+	u64 u;
+	struct cavm_nixx_af_mdqx_ptr_fifo_s {
+		u64 tail                             : 4;
+		u64 head                             : 4;
+		u64 p_con                            : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct cavm_nixx_af_mdqx_ptr_fifo_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_MDQX_PTR_FIFO(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_MDQX_PTR_FIFO(u64 a)
+{
+	return 0x14d0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_mdq#_sched_state
+ *
+ * NIX AF Meta Descriptor Queue Scheduling Control State Registers This
+ * register has the same bit fields as NIX_AF_TL2()_SCHED_STATE.
+ */
+union cavm_nixx_af_mdqx_sched_state {
+	u64 u;
+	struct cavm_nixx_af_mdqx_sched_state_s {
+		u64 rr_count                         : 25;
+		u64 reserved_25_63                   : 39;
+	} s;
+	/* struct cavm_nixx_af_mdqx_sched_state_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_MDQX_SCHED_STATE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_MDQX_SCHED_STATE(u64 a)
+{
+	return 0x1440 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_mdq#_schedule
+ *
+ * NIX AF Meta Descriptor Queue Scheduling Control Registers This
+ * register has the same bit fields as NIX_AF_TL2()_SCHEDULE.
+ */
+union cavm_nixx_af_mdqx_schedule {
+	u64 u;
+	struct cavm_nixx_af_mdqx_schedule_s {
+		u64 rr_quantum                       : 24;
+		u64 prio                             : 4;
+		u64 reserved_28_63                   : 36;
+	} s;
+	/* struct cavm_nixx_af_mdqx_schedule_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_MDQX_SCHEDULE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_MDQX_SCHEDULE(u64 a)
+{
+	return 0x1400 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_mdq#_shape
+ *
+ * NIX AF Meta Descriptor Queue Shaping Control Registers This register
+ * has the same bit fields as NIX_AF_TL3()_SHAPE.
+ */
+union cavm_nixx_af_mdqx_shape {
+	u64 u;
+	struct cavm_nixx_af_mdqx_shape_s {
+		u64 adjust                           : 9;
+		u64 red_algo                         : 2;
+		u64 red_disable                      : 1;
+		u64 yellow_disable                   : 1;
+		u64 reserved_13_23                   : 11;
+		u64 length_disable                   : 1;
+		u64 schedule_list                    : 2;
+		u64 reserved_27_63                   : 37;
+	} s;
+	/* struct cavm_nixx_af_mdqx_shape_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_MDQX_SHAPE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_MDQX_SHAPE(u64 a)
+{
+	return 0x1410 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_mdq#_shape_state
+ *
+ * NIX AF Meta Descriptor Queue Shaping State Registers This register has
+ * the same bit fields as NIX_AF_TL2()_SHAPE_STATE. This register must
+ * not be written during normal operation.
+ */
+union cavm_nixx_af_mdqx_shape_state {
+	u64 u;
+	struct cavm_nixx_af_mdqx_shape_state_s {
+		u64 cir_accum                        : 26;
+		u64 pir_accum                        : 26;
+		u64 color                            : 2;
+		u64 reserved_54_63                   : 10;
+	} s;
+	/* struct cavm_nixx_af_mdqx_shape_state_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_MDQX_SHAPE_STATE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_MDQX_SHAPE_STATE(u64 a)
+{
+	return 0x1450 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_mdq#_sw_xoff
+ *
+ * NIX AF Meta Descriptor Controlled XOFF Registers This register has the
+ * same bit fields as NIX_AF_TL1()_SW_XOFF
+ */
+union cavm_nixx_af_mdqx_sw_xoff {
+	u64 u;
+	struct cavm_nixx_af_mdqx_sw_xoff_s {
+		u64 xoff                             : 1;
+		u64 drain                            : 1;
+		u64 reserved_2                       : 1;
+		u64 drain_irq                        : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cavm_nixx_af_mdqx_sw_xoff_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_MDQX_SW_XOFF(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_MDQX_SW_XOFF(u64 a)
+{
+	return 0x1470 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_mdq_const
+ *
+ * NIX AF Meta Descriptor Queue Constants Register This register contains
+ * constants for software discovery.
+ */
+union cavm_nixx_af_mdq_const {
+	u64 u;
+	struct cavm_nixx_af_mdq_const_s {
+		u64 count                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_nixx_af_mdq_const_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_MDQ_CONST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_MDQ_CONST(void)
+{
+	return 0x90;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_ndc_cfg
+ *
+ * NIX AF General Configuration Register
+ */
+union cavm_nixx_af_ndc_cfg {
+	u64 u;
+	struct cavm_nixx_af_ndc_cfg_s {
+		u64 ndc_ign_pois                     : 1;
+		u64 byp_sq                           : 1;
+		u64 byp_sqb                          : 1;
+		u64 byp_cqs                          : 1;
+		u64 byp_cints                        : 1;
+		u64 byp_dyno                         : 1;
+		u64 byp_mce                          : 1;
+		u64 byp_rqc                          : 1;
+		u64 byp_rsse                         : 1;
+		u64 byp_mc_data                      : 1;
+		u64 byp_mc_wqe                       : 1;
+		u64 byp_mr_data                      : 1;
+		u64 byp_mr_wqe                       : 1;
+		u64 byp_qints                        : 1;
+		u64 reserved_14_63                   : 50;
+	} s;
+	/* struct cavm_nixx_af_ndc_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_NDC_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_NDC_CFG(void)
+{
+	return 0x18;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_ndc_rx_sync
+ *
+ * NIX AF Receive NDC Sync Register Used to synchronize the NIX receive
+ * NDC (NDC_IDX_E::NIX()_RX).
+ */
+union cavm_nixx_af_ndc_rx_sync {
+	u64 u;
+	struct cavm_nixx_af_ndc_rx_sync_s {
+		u64 lf                               : 8;
+		u64 reserved_8_11                    : 4;
+		u64 exec                             : 1;
+		u64 reserved_13_63                   : 51;
+	} s;
+	/* struct cavm_nixx_af_ndc_rx_sync_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_NDC_RX_SYNC(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_NDC_RX_SYNC(void)
+{
+	return 0x3e0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_ndc_tx_sync
+ *
+ * NIX AF NDC_TX Sync Register Used to synchronize the NIX transmit NDC
+ * (NDC_IDX_E::NIX()_TX).
+ */
+union cavm_nixx_af_ndc_tx_sync {
+	u64 u;
+	struct cavm_nixx_af_ndc_tx_sync_s {
+		u64 lf                               : 8;
+		u64 reserved_8_11                    : 4;
+		u64 exec                             : 1;
+		u64 reserved_13_63                   : 51;
+	} s;
+	/* struct cavm_nixx_af_ndc_tx_sync_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_NDC_TX_SYNC(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_NDC_TX_SYNC(void)
+{
+	return 0x3f0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_norm_tx_fifo_status
+ *
+ * NIX AF Normal Transmit FIFO Status Register Status of FIFO which
+ * transmits normal (potentially preemptable) packets to CGX and LBK.
+ */
+union cavm_nixx_af_norm_tx_fifo_status {
+	u64 u;
+	struct cavm_nixx_af_norm_tx_fifo_status_s {
+		u64 count                            : 12;
+		u64 reserved_12_63                   : 52;
+	} s;
+	/* struct cavm_nixx_af_norm_tx_fifo_status_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_NORM_TX_FIFO_STATUS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_NORM_TX_FIFO_STATUS(void)
+{
+	return 0x648;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pse_400_rate_divider
+ *
+ * INTERNAL: NIX AF PSE 400 Rate Divider Register
+ */
+union cavm_nixx_af_pse_400_rate_divider {
+	u64 u;
+	struct cavm_nixx_af_pse_400_rate_divider_s {
+		u64 rate_div_cfg                     : 9;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct cavm_nixx_af_pse_400_rate_divider_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_PSE_400_RATE_DIVIDER(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_PSE_400_RATE_DIVIDER(void)
+{
+	return 0x830;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pse_active_cycles_pc
+ *
+ * NIX AF Active Cycles Register These registers are indexed by the
+ * conditional clock domain number.
+ */
+union cavm_nixx_af_pse_active_cycles_pc {
+	u64 u;
+	struct cavm_nixx_af_pse_active_cycles_pc_s {
+		u64 act_cyc                          : 64;
+	} s;
+	/* struct cavm_nixx_af_pse_active_cycles_pc_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_PSE_ACTIVE_CYCLES_PC(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_PSE_ACTIVE_CYCLES_PC(void)
+{
+	return 0x8c0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pse_bp_test0
+ *
+ * INTERNAL: NIX AF PSE Backpressure Test 0 Register
+ */
+union cavm_nixx_af_pse_bp_test0 {
+	u64 u;
+	struct cavm_nixx_af_pse_bp_test0_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 8;
+		u64 reserved_24_59                   : 36;
+		u64 enable                           : 4;
+	} s;
+	/* struct cavm_nixx_af_pse_bp_test0_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_PSE_BP_TEST0(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_PSE_BP_TEST0(void)
+{
+	return 0x840;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pse_bp_test1
+ *
+ * INTERNAL: NIX AF PSE Backpressure Test 1 Register
+ */
+union cavm_nixx_af_pse_bp_test1 {
+	u64 u;
+	struct cavm_nixx_af_pse_bp_test1_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 8;
+		u64 reserved_24_59                   : 36;
+		u64 enable                           : 4;
+	} s;
+	/* struct cavm_nixx_af_pse_bp_test1_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_PSE_BP_TEST1(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_PSE_BP_TEST1(void)
+{
+	return 0x850;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pse_bp_test2
+ *
+ * INTERNAL: NIX AF PSE Backpressure Test 2 Register
+ */
+union cavm_nixx_af_pse_bp_test2 {
+	u64 u;
+	struct cavm_nixx_af_pse_bp_test2_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 8;
+		u64 reserved_24_59                   : 36;
+		u64 enable                           : 4;
+	} s;
+	/* struct cavm_nixx_af_pse_bp_test2_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_PSE_BP_TEST2(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_PSE_BP_TEST2(void)
+{
+	return 0x860;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pse_bp_test3
+ *
+ * INTERNAL: NIX AF PSE Backpressure Test 3 Register
+ */
+union cavm_nixx_af_pse_bp_test3 {
+	u64 u;
+	struct cavm_nixx_af_pse_bp_test3_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 8;
+		u64 reserved_24_59                   : 36;
+		u64 enable                           : 4;
+	} s;
+	/* struct cavm_nixx_af_pse_bp_test3_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_PSE_BP_TEST3(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_PSE_BP_TEST3(void)
+{
+	return 0x870;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pse_channel_level
+ *
+ * NIX AF PSE Channel Level Register
+ */
+union cavm_nixx_af_pse_channel_level {
+	u64 u;
+	struct cavm_nixx_af_pse_channel_level_s {
+		u64 bp_level                         : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_nixx_af_pse_channel_level_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_PSE_CHANNEL_LEVEL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_PSE_CHANNEL_LEVEL(void)
+{
+	return 0x800;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pse_const
+ *
+ * NIX AF PSE Constants Register This register contains constants for
+ * software discovery.
+ */
+union cavm_nixx_af_pse_const {
+	u64 u;
+	struct cavm_nixx_af_pse_const_s {
+		u64 levels                           : 4;
+		u64 reserved_4_7                     : 4;
+		u64 mark_formats                     : 8;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_nixx_af_pse_const_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_PSE_CONST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_PSE_CONST(void)
+{
+	return 0x60;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pse_eco
+ *
+ * INTERNAL: AF PSE ECO Register
+ */
+union cavm_nixx_af_pse_eco {
+	u64 u;
+	struct cavm_nixx_af_pse_eco_s {
+		u64 eco_rw                           : 64;
+	} s;
+	/* struct cavm_nixx_af_pse_eco_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_PSE_ECO(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_PSE_ECO(void)
+{
+	return 0x5d0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pse_expr_bp_test
+ *
+ * INTERNAL: NIX AF PSE Express Backpressure Test Register
+ */
+union cavm_nixx_af_pse_expr_bp_test {
+	u64 u;
+	struct cavm_nixx_af_pse_expr_bp_test_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 32;
+		u64 enable                           : 16;
+	} s;
+	/* struct cavm_nixx_af_pse_expr_bp_test_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_PSE_EXPR_BP_TEST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_PSE_EXPR_BP_TEST(void)
+{
+	return 0x890;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pse_norm_bp_test
+ *
+ * INTERNAL: NIX AF PSE Normal Backpressure Test Register
+ */
+union cavm_nixx_af_pse_norm_bp_test {
+	u64 u;
+	struct cavm_nixx_af_pse_norm_bp_test_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 32;
+		u64 enable                           : 16;
+	} s;
+	/* struct cavm_nixx_af_pse_norm_bp_test_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_PSE_NORM_BP_TEST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_PSE_NORM_BP_TEST(void)
+{
+	return 0x880;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_pse_shaper_cfg
+ *
+ * NIX AF PSE Shaper Configuration Register
+ */
+union cavm_nixx_af_pse_shaper_cfg {
+	u64 u;
+	struct cavm_nixx_af_pse_shaper_cfg_s {
+		u64 red_send_as_yellow               : 1;
+		u64 color_aware                      : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cavm_nixx_af_pse_shaper_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_PSE_SHAPER_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_PSE_SHAPER_CFG(void)
+{
+	return 0x810;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_ras
+ *
+ * NIX AF RAS Interrupt Register This register is intended for delivery
+ * of RAS events to the SCP, so should be ignored by OS drivers.
+ */
+union cavm_nixx_af_ras {
+	u64 u;
+	struct cavm_nixx_af_ras_s {
+		u64 rx_mce_poison                    : 1;
+		u64 rx_mcast_wqe_poison              : 1;
+		u64 rx_mirror_wqe_poison             : 1;
+		u64 rx_mcast_data_poison             : 1;
+		u64 rx_mirror_data_poison            : 1;
+		u64 reserved_5_31                    : 27;
+		u64 aq_ctx_poison                    : 1;
+		u64 aq_res_poison                    : 1;
+		u64 aq_inst_poison                   : 1;
+		u64 reserved_35_63                   : 29;
+	} s;
+	/* struct cavm_nixx_af_ras_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RAS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RAS(void)
+{
+	return 0x1a0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_ras_ena_w1c
+ *
+ * NIX AF RAS Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union cavm_nixx_af_ras_ena_w1c {
+	u64 u;
+	struct cavm_nixx_af_ras_ena_w1c_s {
+		u64 rx_mce_poison                    : 1;
+		u64 rx_mcast_wqe_poison              : 1;
+		u64 rx_mirror_wqe_poison             : 1;
+		u64 rx_mcast_data_poison             : 1;
+		u64 rx_mirror_data_poison            : 1;
+		u64 reserved_5_31                    : 27;
+		u64 aq_ctx_poison                    : 1;
+		u64 aq_res_poison                    : 1;
+		u64 aq_inst_poison                   : 1;
+		u64 reserved_35_63                   : 29;
+	} s;
+	/* struct cavm_nixx_af_ras_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RAS_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RAS_ENA_W1C(void)
+{
+	return 0x1b8;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_ras_ena_w1s
+ *
+ * NIX AF RAS Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
+ */
+union cavm_nixx_af_ras_ena_w1s {
+	u64 u;
+	struct cavm_nixx_af_ras_ena_w1s_s {
+		u64 rx_mce_poison                    : 1;
+		u64 rx_mcast_wqe_poison              : 1;
+		u64 rx_mirror_wqe_poison             : 1;
+		u64 rx_mcast_data_poison             : 1;
+		u64 rx_mirror_data_poison            : 1;
+		u64 reserved_5_31                    : 27;
+		u64 aq_ctx_poison                    : 1;
+		u64 aq_res_poison                    : 1;
+		u64 aq_inst_poison                   : 1;
+		u64 reserved_35_63                   : 29;
+	} s;
+	/* struct cavm_nixx_af_ras_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RAS_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RAS_ENA_W1S(void)
+{
+	return 0x1b0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_ras_w1s
+ *
+ * NIX AF RAS Interrupt Set Register This register sets interrupt bits.
+ */
+union cavm_nixx_af_ras_w1s {
+	u64 u;
+	struct cavm_nixx_af_ras_w1s_s {
+		u64 rx_mce_poison                    : 1;
+		u64 rx_mcast_wqe_poison              : 1;
+		u64 rx_mirror_wqe_poison             : 1;
+		u64 rx_mcast_data_poison             : 1;
+		u64 rx_mirror_data_poison            : 1;
+		u64 reserved_5_31                    : 27;
+		u64 aq_ctx_poison                    : 1;
+		u64 aq_res_poison                    : 1;
+		u64 aq_inst_poison                   : 1;
+		u64 reserved_35_63                   : 29;
+	} s;
+	/* struct cavm_nixx_af_ras_w1s_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RAS_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RAS_W1S(void)
+{
+	return 0x1a8;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_reb_bp_test#
+ *
+ * INTERNAL: NIX AF REB Backpressure Test Registers
+ */
+union cavm_nixx_af_reb_bp_testx {
+	u64 u;
+	struct cavm_nixx_af_reb_bp_testx_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 8;
+		u64 reserved_24_47                   : 24;
+		u64 enable                           : 4;
+		u64 reserved_52_63                   : 12;
+	} s;
+	/* struct cavm_nixx_af_reb_bp_testx_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_REB_BP_TESTX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_REB_BP_TESTX(u64 a)
+{
+	return 0x4840 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rq_const
+ *
+ * NIX AF RQ Constants Register This register contains constants for
+ * software discovery.
+ */
+union cavm_nixx_af_rq_const {
+	u64 u;
+	struct cavm_nixx_af_rq_const_s {
+		u64 queues_per_lf                    : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	/* struct cavm_nixx_af_rq_const_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RQ_CONST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RQ_CONST(void)
+{
+	return 0x50;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rqm_bp_test
+ *
+ * INTERNAL: NIX AF REB Backpressure Test Registers
+ */
+union cavm_nixx_af_rqm_bp_test {
+	u64 u;
+	struct cavm_nixx_af_rqm_bp_test_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 16;
+		u64 reserved_32_47                   : 16;
+		u64 enable                           : 8;
+		u64 reserved_56_63                   : 8;
+	} s;
+	/* struct cavm_nixx_af_rqm_bp_test_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RQM_BP_TEST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RQM_BP_TEST(void)
+{
+	return 0x4880;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rqm_eco
+ *
+ * INTERNAL: AF RQM ECO Register
+ */
+union cavm_nixx_af_rqm_eco {
+	u64 u;
+	struct cavm_nixx_af_rqm_eco_s {
+		u64 eco_rw                           : 64;
+	} s;
+	/* struct cavm_nixx_af_rqm_eco_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RQM_ECO(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RQM_ECO(void)
+{
+	return 0x5a0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rvu_int
+ *
+ * NIX AF RVU Interrupt Register This register contains RVU error
+ * interrupt summary bits.
+ */
+union cavm_nixx_af_rvu_int {
+	u64 u;
+	struct cavm_nixx_af_rvu_int_s {
+		u64 unmapped_slot                    : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_nixx_af_rvu_int_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RVU_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RVU_INT(void)
+{
+	return 0x1c0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rvu_int_ena_w1c
+ *
+ * NIX AF RVU Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union cavm_nixx_af_rvu_int_ena_w1c {
+	u64 u;
+	struct cavm_nixx_af_rvu_int_ena_w1c_s {
+		u64 unmapped_slot                    : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_nixx_af_rvu_int_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RVU_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RVU_INT_ENA_W1C(void)
+{
+	return 0x1d8;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rvu_int_ena_w1s
+ *
+ * NIX AF RVU Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
+ */
+union cavm_nixx_af_rvu_int_ena_w1s {
+	u64 u;
+	struct cavm_nixx_af_rvu_int_ena_w1s_s {
+		u64 unmapped_slot                    : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_nixx_af_rvu_int_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RVU_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RVU_INT_ENA_W1S(void)
+{
+	return 0x1d0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rvu_int_w1s
+ *
+ * NIX AF RVU Interrupt Set Register This register sets interrupt bits.
+ */
+union cavm_nixx_af_rvu_int_w1s {
+	u64 u;
+	struct cavm_nixx_af_rvu_int_w1s_s {
+		u64 unmapped_slot                    : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_nixx_af_rvu_int_w1s_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RVU_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RVU_INT_W1S(void)
+{
+	return 0x1c8;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rvu_lf_cfg_debug
+ *
+ * NIX Privileged LF Configuration Debug Register This debug register
+ * allows software to lookup the reverse mapping from VF/PF slot to LF.
+ * The forward mapping is programmed with NIX_PRIV_LF()_CFG.
+ */
+union cavm_nixx_af_rvu_lf_cfg_debug {
+	u64 u;
+	struct cavm_nixx_af_rvu_lf_cfg_debug_s {
+		u64 lf                               : 12;
+		u64 lf_valid                         : 1;
+		u64 exec                             : 1;
+		u64 reserved_14_15                   : 2;
+		u64 slot                             : 8;
+		u64 pf_func                          : 16;
+		u64 reserved_40_63                   : 24;
+	} s;
+	/* struct cavm_nixx_af_rvu_lf_cfg_debug_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RVU_LF_CFG_DEBUG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RVU_LF_CFG_DEBUG(void)
+{
+	return 0x8000030;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_active_cycles_pc#
+ *
+ * NIX AF Active Cycles Register These registers are indexed by the
+ * conditional clock domain number.
+ */
+union cavm_nixx_af_rx_active_cycles_pcx {
+	u64 u;
+	struct cavm_nixx_af_rx_active_cycles_pcx_s {
+		u64 act_cyc                          : 64;
+	} s;
+	/* struct cavm_nixx_af_rx_active_cycles_pcx_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_ACTIVE_CYCLES_PCX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_ACTIVE_CYCLES_PCX(u64 a)
+{
+	return 0x4800 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_bpid#_status
+ *
+ * NIX AF Receive Backpressure ID Status Registers
+ */
+union cavm_nixx_af_rx_bpidx_status {
+	u64 u;
+	struct cavm_nixx_af_rx_bpidx_status_s {
+		u64 aura_cnt                         : 32;
+		u64 cq_cnt                           : 32;
+	} s;
+	/* struct cavm_nixx_af_rx_bpidx_status_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_BPIDX_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_BPIDX_STATUS(u64 a)
+{
+	return 0x1a20 + 0x20000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_cfg
+ *
+ * NIX AF Receive Configuration Register
+ */
+union cavm_nixx_af_rx_cfg {
+	u64 u;
+	struct cavm_nixx_af_rx_cfg_s {
+		u64 cbp_ena                          : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_nixx_af_rx_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_CFG(void)
+{
+	return 0xd0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_chan#_cfg
+ *
+ * NIX AF Receive Channel Configuration Registers
+ */
+union cavm_nixx_af_rx_chanx_cfg {
+	u64 u;
+	struct cavm_nixx_af_rx_chanx_cfg_s {
+		u64 bpid                             : 9;
+		u64 reserved_9_15                    : 7;
+		u64 bp_ena                           : 1;
+		u64 sw_xoff                          : 1;
+		u64 imp                              : 1;
+		u64 reserved_19_63                   : 45;
+	} s;
+	/* struct cavm_nixx_af_rx_chanx_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_CHANX_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_CHANX_CFG(u64 a)
+{
+	return 0x1a30 + 0x8000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_cpt#_credit
+ *
+ * NIX AF Receive CPT Credit Register
+ */
+union cavm_nixx_af_rx_cptx_credit {
+	u64 u;
+	struct cavm_nixx_af_rx_cptx_credit_s {
+		u64 inst_cred_cnt                    : 22;
+		u64 reserved_22_63                   : 42;
+	} s;
+	/* struct cavm_nixx_af_rx_cptx_credit_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_CPTX_CREDIT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_CPTX_CREDIT(u64 a)
+{
+	return 0x360 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_cpt#_inst_qsel
+ *
+ * NIX AF Receive CPT Instruction Queue Select Register Selects the CPT
+ * queue to which instructions (CPT_INST_S) are sent. Internal: NIX sends
+ * CPT_INST_S to the CPT_LF_NQ() physical address for [PF_FUNC] and
+ * [SLOT]: \<pre\> // CPT_LF_NQ() physical address:
+ * chip_pa_defs::io_rvu2a_t cpt_addr; cpt_addr =
+ * RVU_BAR_E::RVU_PF()_FUNC()_BAR2(pf, func); cpt_addr.block =
+ * RVU_BLOCK_ADDR_E::CPT()({a}); // {a} = CPT index cpt_addr.slot =
+ * [SLOT]; cpt_addr.offset = `CPT_LF_NQX__BASE;  // NDC/NCBI command:
+ * ncbi_cmd.paddr = 1; // Physical address ncbi_cmd.addr = cpt_addr;
+ * \</pre\>
+ */
+union cavm_nixx_af_rx_cptx_inst_qsel {
+	u64 u;
+	struct cavm_nixx_af_rx_cptx_inst_qsel_s {
+		u64 slot                             : 8;
+		u64 pf_func                          : 16;
+		u64 reserved_24_63                   : 40;
+	} s;
+	/* struct cavm_nixx_af_rx_cptx_inst_qsel_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_CPTX_INST_QSEL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_CPTX_INST_QSEL(u64 a)
+{
+	return 0x320 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_def_iip4
+ *
+ * NIX AF Receive Inner IPv4 Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an inner IPv4 header.
+ * Typically the same as NPC_PCK_DEF_IIP4.
+ */
+union cavm_nixx_af_rx_def_iip4 {
+	u64 u;
+	struct cavm_nixx_af_rx_def_iip4_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct cavm_nixx_af_rx_def_iip4_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_DEF_IIP4(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_DEF_IIP4(void)
+{
+	return 0x220;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_def_iip6
+ *
+ * NIX AF Receive Inner IPv6 Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an inner IPv6 header.
+ */
+union cavm_nixx_af_rx_def_iip6 {
+	u64 u;
+	struct cavm_nixx_af_rx_def_iip6_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct cavm_nixx_af_rx_def_iip6_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_DEF_IIP6(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_DEF_IIP6(void)
+{
+	return 0x240;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_def_ipsec#
+ *
+ * INTERNAL: NIX AF Receive IPSEC Header Definition Registers  Internal:
+ * Not used; no IPSEC fast-path.
+ */
+union cavm_nixx_af_rx_def_ipsecx {
+	u64 u;
+	struct cavm_nixx_af_rx_def_ipsecx_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11                      : 1;
+		u64 spi_offset                       : 4;
+		u64 spi_nz                           : 1;
+		u64 reserved_17_63                   : 47;
+	} s;
+	/* struct cavm_nixx_af_rx_def_ipsecx_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_DEF_IPSECX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_DEF_IPSECX(u64 a)
+{
+	return 0x2b0 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_def_isctp
+ *
+ * NIX AF Receive Inner SCTP Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an inner SCTP header.
+ */
+union cavm_nixx_af_rx_def_isctp {
+	u64 u;
+	struct cavm_nixx_af_rx_def_isctp_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct cavm_nixx_af_rx_def_isctp_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_DEF_ISCTP(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_DEF_ISCTP(void)
+{
+	return 0x2a0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_def_itcp
+ *
+ * NIX AF Receive Inner TCP Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an inner TCP header.
+ */
+union cavm_nixx_af_rx_def_itcp {
+	u64 u;
+	struct cavm_nixx_af_rx_def_itcp_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct cavm_nixx_af_rx_def_itcp_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_DEF_ITCP(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_DEF_ITCP(void)
+{
+	return 0x260;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_def_iudp
+ *
+ * NIX AF Receive Inner UDP Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an inner UDP header.
+ */
+union cavm_nixx_af_rx_def_iudp {
+	u64 u;
+	struct cavm_nixx_af_rx_def_iudp_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct cavm_nixx_af_rx_def_iudp_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_DEF_IUDP(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_DEF_IUDP(void)
+{
+	return 0x280;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_def_oip4
+ *
+ * NIX AF Receive Outer IPv4 Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an outer IPv4 L3 header.
+ * Typically the same as NPC_PCK_DEF_OIP4.
+ */
+union cavm_nixx_af_rx_def_oip4 {
+	u64 u;
+	struct cavm_nixx_af_rx_def_oip4_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct cavm_nixx_af_rx_def_oip4_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_DEF_OIP4(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_DEF_OIP4(void)
+{
+	return 0x210;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_def_oip6
+ *
+ * NIX AF Receive Outer IPv6 Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an outer IPv6 header.
+ * Typically the same as NPC_PCK_DEF_OIP6.
+ */
+union cavm_nixx_af_rx_def_oip6 {
+	u64 u;
+	struct cavm_nixx_af_rx_def_oip6_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct cavm_nixx_af_rx_def_oip6_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_DEF_OIP6(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_DEF_OIP6(void)
+{
+	return 0x230;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_def_ol2
+ *
+ * NIX AF Receive Outer L2 Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an outer L2/Ethernet header.
+ * Typically the same as NPC_PCK_DEF_OL2.
+ */
+union cavm_nixx_af_rx_def_ol2 {
+	u64 u;
+	struct cavm_nixx_af_rx_def_ol2_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct cavm_nixx_af_rx_def_ol2_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_DEF_OL2(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_DEF_OL2(void)
+{
+	return 0x200;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_def_osctp
+ *
+ * NIX AF Receive Outer SCTP Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an outer SCTP header.
+ */
+union cavm_nixx_af_rx_def_osctp {
+	u64 u;
+	struct cavm_nixx_af_rx_def_osctp_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct cavm_nixx_af_rx_def_osctp_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_DEF_OSCTP(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_DEF_OSCTP(void)
+{
+	return 0x290;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_def_otcp
+ *
+ * NIX AF Receive Outer TCP Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an outer TCP header.
+ */
+union cavm_nixx_af_rx_def_otcp {
+	u64 u;
+	struct cavm_nixx_af_rx_def_otcp_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct cavm_nixx_af_rx_def_otcp_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_DEF_OTCP(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_DEF_OTCP(void)
+{
+	return 0x250;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_def_oudp
+ *
+ * NIX AF Receive Outer UDP Header Definition Register Defines layer
+ * information in NPC_RESULT_S to identify an outer UDP header.
+ */
+union cavm_nixx_af_rx_def_oudp {
+	u64 u;
+	struct cavm_nixx_af_rx_def_oudp_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct cavm_nixx_af_rx_def_oudp_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_DEF_OUDP(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_DEF_OUDP(void)
+{
+	return 0x270;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_flow_key_alg#_field#
+ *
+ * NIX AF Receive Flow Key Algorithm Field Registers A flow key algorithm
+ * defines how the 40-byte FLOW_KEY is formed from the received packet
+ * header. FLOW_KEY is formed using up to five header fields (this
+ * register's last index) with up to 16 bytes per field.  The algorithm
+ * (index {a} (ALG) of these registers) is selected by
+ * NIX_RX_ACTION_S[FLOW_KEY_ALG] from the packet's NPC_RESULT_S[ACTION].
+ * Internal: 40-byte FLOW_KEY is wide enough to support an IPv6 5-tuple
+ * that includes a VXLAN/GENEVE/NVGRE tunnel ID, e.g: _ Source IP: 16B. _
+ * Dest IP: 16B. _ Source port: 2B. _ Dest port: 2B. _ Tunnel VNI/VSI:
+ * 3B. _ Total: 39B.
+ */
+union cavm_nixx_af_rx_flow_key_algx_fieldx {
+	u64 u;
+	struct cavm_nixx_af_rx_flow_key_algx_fieldx_s {
+		u64 key_offset                       : 6;
+		u64 ln_mask                          : 1;
+		u64 fn_mask                          : 1;
+		u64 hdr_offset                       : 8;
+		u64 bytesm1                          : 5;
+		u64 lid                              : 3;
+		u64 reserved_24                      : 1;
+		u64 ena                              : 1;
+		u64 sel_chan                         : 1;
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 reserved_35_63                   : 29;
+	} s;
+	/* struct cavm_nixx_af_rx_flow_key_algx_fieldx_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_FLOW_KEY_ALGX_FIELDX(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_FLOW_KEY_ALGX_FIELDX(u64 a, u64 b)
+{
+	return 0x1800 + 0x40000 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_ipsec_gen_cfg
+ *
+ * INTERNAL: NIX AF Receive IPSEC General Configuration Register
+ * Internal: Not used; no IPSEC fast-path.
+ */
+union cavm_nixx_af_rx_ipsec_gen_cfg {
+	u64 u;
+	struct cavm_nixx_af_rx_ipsec_gen_cfg_s {
+		u64 param2                           : 16;
+		u64 param1                           : 16;
+		u64 opcode                           : 16;
+		u64 egrp                             : 3;
+		u64 reserved_51_63                   : 13;
+	} s;
+	/* struct cavm_nixx_af_rx_ipsec_gen_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_IPSEC_GEN_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_IPSEC_GEN_CFG(void)
+{
+	return 0x300;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_link#_cfg
+ *
+ * NIX AF Receive Link Configuration Registers Index enumerated by
+ * NIX_LINK_E.
+ */
+union cavm_nixx_af_rx_linkx_cfg {
+	u64 u;
+	struct cavm_nixx_af_rx_linkx_cfg_s {
+		u64 minlen                           : 16;
+		u64 maxlen                           : 16;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cavm_nixx_af_rx_linkx_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_LINKX_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_LINKX_CFG(u64 a)
+{
+	return 0x540 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_link#_sl#_spkt_cnt
+ *
+ * INTERNAL: NIX Receive Software Sync Link Packet Count Registers  For
+ * diagnostic use only for debug of NIX_AF_RX_SW_SYNC[ENA] function. LINK
+ * index is enumerated by NIX_LINK_E. SL index is zero for non-express
+ * packets, one for express packets. For the internal NIX_LINK_E::MC, SL
+ * index is zero for multicast replay, one for mirror replay.
+ */
+union cavm_nixx_af_rx_linkx_slx_spkt_cnt {
+	u64 u;
+	struct cavm_nixx_af_rx_linkx_slx_spkt_cnt_s {
+		u64 in_cnt                           : 20;
+		u64 reserved_20_31                   : 12;
+		u64 out_cnt                          : 20;
+		u64 reserved_52_63                   : 12;
+	} s;
+	/* struct cavm_nixx_af_rx_linkx_slx_spkt_cnt_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_LINKX_SLX_SPKT_CNT(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_LINKX_SLX_SPKT_CNT(u64 a, u64 b)
+{
+	return 0x500 + 0x10000 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_link#_wrr_cfg
+ *
+ * NIX AF Receive Link Weighted Round Robin Configuration Registers Index
+ * enumerated by NIX_LINK_E.
+ */
+union cavm_nixx_af_rx_linkx_wrr_cfg {
+	u64 u;
+	struct cavm_nixx_af_rx_linkx_wrr_cfg_s {
+		u64 weight                           : 8;
+		u64 reserved_8_63                    : 56;
+	} s;
+	/* struct cavm_nixx_af_rx_linkx_wrr_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_LINKX_WRR_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_LINKX_WRR_CFG(u64 a)
+{
+	return 0x560 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_mcast_base
+ *
+ * NIX AF Receive Multicast/Mirror Table Base Address Register This
+ * register specifies the base AF IOVA of the receive multicast/mirror
+ * table in NDC/LLC/DRAM. The table consists of 1 \<\<
+ * (NIX_AF_RX_MCAST_CFG[SIZE] + 8) contiguous NIX_RX_MCE_S structures.
+ * The size of each structure is 1 \<\< NIX_AF_CONST3[MCE_LOG2BYTES].
+ * The table contains multicast/mirror replication lists. Each list
+ * consists of linked entries with NIX_RX_MCE_S[EOL] = 1 in the last
+ * entry. All lists must reside within the table size specified by
+ * NIX_AF_RX_MCAST_CFG[SIZE]. A mirror replication list will typically
+ * consist of two entries, but that is not checked or enforced by
+ * hardware.  A receive packet is multicast when the action returned by
+ * NPC has NIX_RX_ACTION_S[OP] = NIX_RX_ACTIONOP_E::MCAST. A receive
+ * packet is mirrored when the action returned by NPC has
+ * NIX_RX_ACTION_S[OP] = NIX_RX_ACTIONOP_E::MIRROR. In both cases,
+ * NIX_RX_ACTION_S[INDEX] specifies the index of the replication list's
+ * first NIX_RX_MCE_S in the table, and a linked entry with
+ * NIX_RX_MCE_S[EOL] = 1 indicates the end of list.  If a mirrored flow
+ * is part of a multicast replication list, software should include the
+ * two mirror entries in that list.  Internal: A multicast list may have
+ * multiple entries for the same LF (e.g. for future RoCE/IB multicast).
+ */
+union cavm_nixx_af_rx_mcast_base {
+	u64 u;
+	struct cavm_nixx_af_rx_mcast_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 addr                             : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct cavm_nixx_af_rx_mcast_base_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_MCAST_BASE(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_MCAST_BASE(void)
+{
+	return 0x100;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_mcast_buf_base
+ *
+ * NIX AF Receive Multicast Buffer Base Address Register This register
+ * specifies the base AF IOVA of the receive multicast buffers in
+ * NDC/LLC/DRAM. These buffers are used to temporarily store packets
+ * whose action returned by NPC has NIX_RX_ACTION_S[OP] =
+ * NIX_RX_ACTIONOP_E::MCAST. The number of buffers is configured by
+ * NIX_AF_RX_MCAST_BUF_CFG[SIZE].  If the number of free buffers is
+ * insufficient for a received multicast packet, hardware tail drops the
+ * packet and sets NIX_AF_GEN_INT[RX_MCAST_DROP].  Hardware prioritizes
+ * the processing of RX mirror packets over RX multicast packets.
+ */
+union cavm_nixx_af_rx_mcast_buf_base {
+	u64 u;
+	struct cavm_nixx_af_rx_mcast_buf_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 addr                             : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct cavm_nixx_af_rx_mcast_buf_base_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_MCAST_BUF_BASE(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_MCAST_BUF_BASE(void)
+{
+	return 0x120;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_mcast_buf_cfg
+ *
+ * NIX AF Receive Multicast Buffer Configuration Register See
+ * NIX_AF_RX_MCAST_BUF_BASE.
+ */
+union cavm_nixx_af_rx_mcast_buf_cfg {
+	u64 u;
+	struct cavm_nixx_af_rx_mcast_buf_cfg_s {
+		u64 size                             : 4;
+		u64 way_mask                         : 16;
+		u64 caching                          : 1;
+		u64 reserved_21_23                   : 3;
+		u64 npc_replay_pkind                 : 6;
+		u64 reserved_30_31                   : 2;
+		u64 free_buf_level                   : 11;
+		u64 reserved_43_62                   : 20;
+		u64 ena                              : 1;
+	} s;
+	/* struct cavm_nixx_af_rx_mcast_buf_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_MCAST_BUF_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_MCAST_BUF_CFG(void)
+{
+	return 0x130;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_mcast_cfg
+ *
+ * NIX AF Receive Multicast/Mirror Table Configuration Register See
+ * NIX_AF_RX_MCAST_BASE.
+ */
+union cavm_nixx_af_rx_mcast_cfg {
+	u64 u;
+	struct cavm_nixx_af_rx_mcast_cfg_s {
+		u64 size                             : 4;
+		u64 max_list_lenm1                   : 8;
+		u64 reserved_12_19                   : 8;
+		u64 way_mask                         : 16;
+		u64 caching                          : 1;
+		u64 reserved_37_63                   : 27;
+	} s;
+	/* struct cavm_nixx_af_rx_mcast_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_MCAST_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_MCAST_CFG(void)
+{
+	return 0x110;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_mirror_buf_base
+ *
+ * NIX AF Receive Mirror Buffer Base Address Register This register
+ * specifies the base AF IOVA of the receive mirror buffers in
+ * NDC/LLC/DRAM. These buffers are used to temporarily store packets
+ * whose action returned by NPC has NIX_RX_ACTION_S[OP] =
+ * NIX_RX_ACTIONOP_E::MIRROR. The number of buffers is configured by
+ * NIX_AF_RX_MIRROR_BUF_CFG[SIZE].  If the number of free buffers is
+ * insufficient for a received multicast packet, hardware tail drops the
+ * packet and sets NIX_AF_GEN_INT[RX_MIRROR_DROP].  Hardware prioritizes
+ * the processing of RX mirror packets over RX multicast packets.
+ */
+union cavm_nixx_af_rx_mirror_buf_base {
+	u64 u;
+	struct cavm_nixx_af_rx_mirror_buf_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 addr                             : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct cavm_nixx_af_rx_mirror_buf_base_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_MIRROR_BUF_BASE(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_MIRROR_BUF_BASE(void)
+{
+	return 0x140;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_mirror_buf_cfg
+ *
+ * NIX AF Receive Mirror Buffer Configuration Register See
+ * NIX_AF_RX_MIRROR_BUF_BASE.
+ */
+union cavm_nixx_af_rx_mirror_buf_cfg {
+	u64 u;
+	struct cavm_nixx_af_rx_mirror_buf_cfg_s {
+		u64 size                             : 4;
+		u64 way_mask                         : 16;
+		u64 caching                          : 1;
+		u64 reserved_21_23                   : 3;
+		u64 npc_replay_pkind                 : 6;
+		u64 reserved_30_31                   : 2;
+		u64 free_buf_level                   : 11;
+		u64 reserved_43_62                   : 20;
+		u64 ena                              : 1;
+	} s;
+	/* struct cavm_nixx_af_rx_mirror_buf_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_MIRROR_BUF_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_MIRROR_BUF_CFG(void)
+{
+	return 0x148;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_npc_mc_drop
+ *
+ * NIX AF Multicast Drop Statistics Register The counter increments for
+ * every dropped MC packet marked by the NPC.
+ */
+union cavm_nixx_af_rx_npc_mc_drop {
+	u64 u;
+	struct cavm_nixx_af_rx_npc_mc_drop_s {
+		u64 stat                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_nixx_af_rx_npc_mc_drop_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_NPC_MC_DROP(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_NPC_MC_DROP(void)
+{
+	return 0x4710;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_npc_mc_rcv
+ *
+ * NIX AF Multicast Receive Statistics Register The counter increments
+ * for every received MC packet marked by the NPC.
+ */
+union cavm_nixx_af_rx_npc_mc_rcv {
+	u64 u;
+	struct cavm_nixx_af_rx_npc_mc_rcv_s {
+		u64 stat                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_nixx_af_rx_npc_mc_rcv_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_NPC_MC_RCV(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_NPC_MC_RCV(void)
+{
+	return 0x4700;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_npc_mirror_drop
+ *
+ * NIX AF Mirror Drop Statistics Register The counter increments for
+ * every dropped MIRROR packet marked by the NPC.
+ */
+union cavm_nixx_af_rx_npc_mirror_drop {
+	u64 u;
+	struct cavm_nixx_af_rx_npc_mirror_drop_s {
+		u64 stat                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_nixx_af_rx_npc_mirror_drop_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_NPC_MIRROR_DROP(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_NPC_MIRROR_DROP(void)
+{
+	return 0x4730;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_npc_mirror_rcv
+ *
+ * NIX AF Mirror Receive Statistics Register The counter increments for
+ * every received MIRROR packet marked by the NPC.
+ */
+union cavm_nixx_af_rx_npc_mirror_rcv {
+	u64 u;
+	struct cavm_nixx_af_rx_npc_mirror_rcv_s {
+		u64 stat                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_nixx_af_rx_npc_mirror_rcv_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_NPC_MIRROR_RCV(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_NPC_MIRROR_RCV(void)
+{
+	return 0x4720;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_rx_sw_sync
+ *
+ * NIX AF Receive Software Sync Register
+ */
+union cavm_nixx_af_rx_sw_sync {
+	u64 u;
+	struct cavm_nixx_af_rx_sw_sync_s {
+		u64 ena                              : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_nixx_af_rx_sw_sync_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_RX_SW_SYNC(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_RX_SW_SYNC(void)
+{
+	return 0x550;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_sdp_hw_xoff#
+ *
+ * NIX AF SDP Transmit Link Hardware Controlled XOFF Registers .
+ */
+union cavm_nixx_af_sdp_hw_xoffx {
+	u64 u;
+	struct cavm_nixx_af_sdp_hw_xoffx_s {
+		u64 chan_xoff                        : 64;
+	} s;
+	/* struct cavm_nixx_af_sdp_hw_xoffx_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_SDP_HW_XOFFX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_SDP_HW_XOFFX(u64 a)
+{
+	return 0xac0 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_sdp_link_credit
+ *
+ * NIX AF Transmit Link SDP Credit Register This register tracks SDP link
+ * credits.
+ */
+union cavm_nixx_af_sdp_link_credit {
+	u64 u;
+	struct cavm_nixx_af_sdp_link_credit_s {
+		u64 reserved_0                       : 1;
+		u64 cc_enable                        : 1;
+		u64 cc_packet_cnt                    : 10;
+		u64 cc_unit_cnt                      : 20;
+		u64 reserved_32_62                   : 31;
+		u64 pse_pkt_id_lmt                   : 1;
+	} s;
+	struct cavm_nixx_af_sdp_link_credit_cn96xx {
+		u64 reserved_0                       : 1;
+		u64 cc_enable                        : 1;
+		u64 cc_packet_cnt                    : 10;
+		u64 cc_unit_cnt                      : 20;
+		u64 reserved_32_63                   : 32;
+	} cn96xx;
+	/* struct cavm_nixx_af_sdp_link_credit_s cnf95xx; */
+};
+
+static inline u64 CAVM_NIXX_AF_SDP_LINK_CREDIT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_SDP_LINK_CREDIT(void)
+{
+	return 0xa40;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_sdp_sw_xoff#
+ *
+ * NIX AF SDP Transmit Link Software Controlled XOFF Registers
+ */
+union cavm_nixx_af_sdp_sw_xoffx {
+	u64 u;
+	struct cavm_nixx_af_sdp_sw_xoffx_s {
+		u64 chan_xoff                        : 64;
+	} s;
+	/* struct cavm_nixx_af_sdp_sw_xoffx_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_SDP_SW_XOFFX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_SDP_SW_XOFFX(u64 a)
+{
+	return 0xa60 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_sdp_tx_fifo_status
+ *
+ * NIX AF SDP Transmit FIFO Status Register Status of FIFO which
+ * transmits packets to SDP.
+ */
+union cavm_nixx_af_sdp_tx_fifo_status {
+	u64 u;
+	struct cavm_nixx_af_sdp_tx_fifo_status_s {
+		u64 count                            : 12;
+		u64 reserved_12_63                   : 52;
+	} s;
+	/* struct cavm_nixx_af_sdp_tx_fifo_status_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_SDP_TX_FIFO_STATUS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_SDP_TX_FIFO_STATUS(void)
+{
+	return 0x650;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_seb_active_cycles_pc#
+ *
+ * NIX AF Active Cycles Register These registers are indexed by the
+ * conditional clock domain number.
+ */
+union cavm_nixx_af_seb_active_cycles_pcx {
+	u64 u;
+	struct cavm_nixx_af_seb_active_cycles_pcx_s {
+		u64 act_cyc                          : 64;
+	} s;
+	/* struct cavm_nixx_af_seb_active_cycles_pcx_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_SEB_ACTIVE_CYCLES_PCX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_SEB_ACTIVE_CYCLES_PCX(u64 a)
+{
+	return 0x6c0 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_seb_bp_test
+ *
+ * INTERNAL: NIX AF SEB Backpressure Test Register
+ */
+union cavm_nixx_af_seb_bp_test {
+	u64 u;
+	struct cavm_nixx_af_seb_bp_test_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 14;
+		u64 reserved_30_47                   : 18;
+		u64 enable                           : 7;
+		u64 reserved_55_63                   : 9;
+	} s;
+	/* struct cavm_nixx_af_seb_bp_test_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_SEB_BP_TEST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_SEB_BP_TEST(void)
+{
+	return 0x630;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_seb_eco
+ *
+ * INTERNAL: AF SEB ECO Register
+ */
+union cavm_nixx_af_seb_eco {
+	u64 u;
+	struct cavm_nixx_af_seb_eco_s {
+		u64 eco_rw                           : 64;
+	} s;
+	/* struct cavm_nixx_af_seb_eco_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_SEB_ECO(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_SEB_ECO(void)
+{
+	return 0x5c0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_seb_pipe_bp_test#
+ *
+ * INTERNAL: NIX AF SEB Pipe Backpressure Test Registers
+ */
+union cavm_nixx_af_seb_pipe_bp_testx {
+	u64 u;
+	struct cavm_nixx_af_seb_pipe_bp_testx_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 24;
+		u64 reserved_40_47                   : 8;
+		u64 enable                           : 12;
+		u64 reserved_60_63                   : 4;
+	} s;
+	/* struct cavm_nixx_af_seb_pipe_bp_testx_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_SEB_PIPE_BP_TESTX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_SEB_PIPE_BP_TESTX(u64 a)
+{
+	return 0x600 + 0x10 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_seb_pipeb_bp_test#
+ *
+ * INTERNAL: NIX AF SEB Pipe Backpressure Test Registers
+ */
+union cavm_nixx_af_seb_pipeb_bp_testx {
+	u64 u;
+	struct cavm_nixx_af_seb_pipeb_bp_testx_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 18;
+		u64 reserved_34_47                   : 14;
+		u64 enable                           : 9;
+		u64 reserved_57_63                   : 7;
+	} s;
+	/* struct cavm_nixx_af_seb_pipeb_bp_testx_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_SEB_PIPEB_BP_TESTX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_SEB_PIPEB_BP_TESTX(u64 a)
+{
+	return 0x608 + 0x10 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_seb_wd_tick_divider
+ *
+ * INTERNAL: NIX AF SEB TSTMP Watchdog Tick Divider Register
+ */
+union cavm_nixx_af_seb_wd_tick_divider {
+	u64 u;
+	struct cavm_nixx_af_seb_wd_tick_divider_s {
+		u64 tick_div_cfg                     : 7;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct cavm_nixx_af_seb_wd_tick_divider_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_SEB_WD_TICK_DIVIDER(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_SEB_WD_TICK_DIVIDER(void)
+{
+	return 0x6f0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_smq#_cfg
+ *
+ * NIX AF SQM PSE Queue Configuration Registers
+ */
+union cavm_nixx_af_smqx_cfg {
+	u64 u;
+	struct cavm_nixx_af_smqx_cfg_s {
+		u64 minlen                           : 7;
+		u64 desc_shp_ctl_dis                 : 1;
+		u64 maxlen                           : 16;
+		u64 lf                               : 7;
+		u64 reserved_31_35                   : 5;
+		u64 max_vtag_ins                     : 3;
+		u64 rr_minlen                        : 9;
+		u64 express                          : 1;
+		u64 flush                            : 1;
+		u64 enq_xoff                         : 1;
+		u64 pri_thr                          : 6;
+		u64 reserved_57_63                   : 7;
+	} s;
+	/* struct cavm_nixx_af_smqx_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_SMQX_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_SMQX_CFG(u64 a)
+{
+	return 0x700 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_smq#_head
+ *
+ * NIX AF SQM SMQ Head Register These registers track the head of the SMQ
+ * linked list.
+ */
+union cavm_nixx_af_smqx_head {
+	u64 u;
+	struct cavm_nixx_af_smqx_head_s {
+		u64 sq_idx                           : 20;
+		u64 valid                            : 1;
+		u64 reserved_21_63                   : 43;
+	} s;
+	/* struct cavm_nixx_af_smqx_head_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_SMQX_HEAD(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_SMQX_HEAD(u64 a)
+{
+	return 0x710 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_smq#_nxt_head
+ *
+ * NIX AF SQM SMQ Next Head Register These registers track the next head
+ * of the SMQ linked list.
+ */
+union cavm_nixx_af_smqx_nxt_head {
+	u64 u;
+	struct cavm_nixx_af_smqx_nxt_head_s {
+		u64 sq_idx                           : 20;
+		u64 valid                            : 1;
+		u64 reserved_21_63                   : 43;
+	} s;
+	/* struct cavm_nixx_af_smqx_nxt_head_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_SMQX_NXT_HEAD(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_SMQX_NXT_HEAD(u64 a)
+{
+	return 0x740 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_smq#_status
+ *
+ * NIX AF SQM SMQ Status Register These registers track the status of the
+ * SMQ FIFO.
+ */
+union cavm_nixx_af_smqx_status {
+	u64 u;
+	struct cavm_nixx_af_smqx_status_s {
+		u64 level                            : 7;
+		u64 reserved_7_63                    : 57;
+	} s;
+	/* struct cavm_nixx_af_smqx_status_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_SMQX_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_SMQX_STATUS(u64 a)
+{
+	return 0x730 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_smq#_tail
+ *
+ * NIX AF SQM SMQ Head Register These registers track the tail of SMQ
+ * linked list.
+ */
+union cavm_nixx_af_smqx_tail {
+	u64 u;
+	struct cavm_nixx_af_smqx_tail_s {
+		u64 sq_idx                           : 20;
+		u64 valid                            : 1;
+		u64 reserved_21_63                   : 43;
+	} s;
+	/* struct cavm_nixx_af_smqx_tail_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_SMQX_TAIL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_SMQX_TAIL(u64 a)
+{
+	return 0x720 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_sq_const
+ *
+ * NIX AF SQ Constants Register This register contains constants for
+ * software discovery.
+ */
+union cavm_nixx_af_sq_const {
+	u64 u;
+	struct cavm_nixx_af_sq_const_s {
+		u64 queues_per_lf                    : 24;
+		u64 smq_depth                        : 10;
+		u64 sqb_size                         : 16;
+		u64 reserved_50_63                   : 14;
+	} s;
+	/* struct cavm_nixx_af_sq_const_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_SQ_CONST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_SQ_CONST(void)
+{
+	return 0x40;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_sqm_active_cycles_pc
+ *
+ * NIX AF SQM Active Cycles Register These registers are indexed by the
+ * conditional clock domain number.
+ */
+union cavm_nixx_af_sqm_active_cycles_pc {
+	u64 u;
+	struct cavm_nixx_af_sqm_active_cycles_pc_s {
+		u64 act_cyc                          : 64;
+	} s;
+	/* struct cavm_nixx_af_sqm_active_cycles_pc_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_SQM_ACTIVE_CYCLES_PC(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_SQM_ACTIVE_CYCLES_PC(void)
+{
+	return 0x770;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_sqm_bp_test#
+ *
+ * INTERNAL: NIX AF SQM Backpressure Test Register
+ */
+union cavm_nixx_af_sqm_bp_testx {
+	u64 u;
+	struct cavm_nixx_af_sqm_bp_testx_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 8;
+		u64 reserved_24_59                   : 36;
+		u64 enable                           : 4;
+	} s;
+	/* struct cavm_nixx_af_sqm_bp_testx_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_SQM_BP_TESTX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_SQM_BP_TESTX(u64 a)
+{
+	return 0x760 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_sqm_dbg_ctl_status
+ *
+ * INTERNAL: NIX AF SQM Debug Register  This register is for SQM
+ * diagnostic use only.
+ */
+union cavm_nixx_af_sqm_dbg_ctl_status {
+	u64 u;
+	struct cavm_nixx_af_sqm_dbg_ctl_status_s {
+		u64 tm1                              : 8;
+		u64 tm2                              : 1;
+		u64 tm3                              : 4;
+		u64 tm4                              : 1;
+		u64 tm5                              : 1;
+		u64 tm6                              : 1;
+		u64 tm7                              : 4;
+		u64 tm8                              : 1;
+		u64 tm9                              : 1;
+		u64 reserved_22_63                   : 42;
+	} s;
+	/* struct cavm_nixx_af_sqm_dbg_ctl_status_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_SQM_DBG_CTL_STATUS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_SQM_DBG_CTL_STATUS(void)
+{
+	return 0x750;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_sqm_eco
+ *
+ * INTERNAL: AF SQM ECO Register
+ */
+union cavm_nixx_af_sqm_eco {
+	u64 u;
+	struct cavm_nixx_af_sqm_eco_s {
+		u64 eco_rw                           : 64;
+	} s;
+	/* struct cavm_nixx_af_sqm_eco_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_SQM_ECO(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_SQM_ECO(void)
+{
+	return 0x5b0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_status
+ *
+ * NIX AF General Status Register
+ */
+union cavm_nixx_af_status {
+	u64 u;
+	struct cavm_nixx_af_status_s {
+		u64 blk_busy                         : 10;
+		u64 calibrate_done                   : 1;
+		u64 reserved_11_15                   : 5;
+		u64 calibrate_status                 : 15;
+		u64 reserved_31_63                   : 33;
+	} s;
+	/* struct cavm_nixx_af_status_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_STATUS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_STATUS(void)
+{
+	return 0x10;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tcp_timer
+ *
+ * NIX TCP Timer Register
+ */
+union cavm_nixx_af_tcp_timer {
+	u64 u;
+	struct cavm_nixx_af_tcp_timer_s {
+		u64 dur_counter                      : 16;
+		u64 lf_counter                       : 8;
+		u64 reserved_24_31                   : 8;
+		u64 duration                         : 16;
+		u64 reserved_48_62                   : 15;
+		u64 ena                              : 1;
+	} s;
+	/* struct cavm_nixx_af_tcp_timer_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TCP_TIMER(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TCP_TIMER(void)
+{
+	return 0x1e0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_cir
+ *
+ * NIX AF Transmit Level 1 Committed Information Rate Register
+ */
+union cavm_nixx_af_tl1x_cir {
+	u64 u;
+	struct cavm_nixx_af_tl1x_cir_s {
+		u64 enable                           : 1;
+		u64 rate_mantissa                    : 8;
+		u64 rate_exponent                    : 4;
+		u64 rate_divider_exponent            : 4;
+		u64 reserved_17_28                   : 12;
+		u64 burst_mantissa                   : 8;
+		u64 burst_exponent                   : 4;
+		u64 reserved_41_63                   : 23;
+	} s;
+	/* struct cavm_nixx_af_tl1x_cir_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL1X_CIR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL1X_CIR(u64 a)
+{
+	return 0xc20 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_dropped_bytes
+ *
+ * NIX AF Transmit Level 1 Dropped Bytes Registers This register has the
+ * same bit fields as NIX_AF_TL1()_GREEN_BYTES.
+ */
+union cavm_nixx_af_tl1x_dropped_bytes {
+	u64 u;
+	struct cavm_nixx_af_tl1x_dropped_bytes_s {
+		u64 count                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_nixx_af_tl1x_dropped_bytes_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL1X_DROPPED_BYTES(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL1X_DROPPED_BYTES(u64 a)
+{
+	return 0xd30 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_dropped_packets
+ *
+ * NIX AF Transmit Level 1 Dropped Packets Registers This register has
+ * the same bit fields as NIX_AF_TL1()_GREEN_PACKETS.
+ */
+union cavm_nixx_af_tl1x_dropped_packets {
+	u64 u;
+	struct cavm_nixx_af_tl1x_dropped_packets_s {
+		u64 count                            : 40;
+		u64 reserved_40_63                   : 24;
+	} s;
+	/* struct cavm_nixx_af_tl1x_dropped_packets_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL1X_DROPPED_PACKETS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL1X_DROPPED_PACKETS(u64 a)
+{
+	return 0xd20 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_green
+ *
+ * INTERNAL: NIX Transmit Level 1 Green State Debug Register
+ */
+union cavm_nixx_af_tl1x_green {
+	u64 u;
+	struct cavm_nixx_af_tl1x_green_s {
+		u64 tail                             : 8;
+		u64 reserved_8_9                     : 2;
+		u64 head                             : 8;
+		u64 reserved_18_19                   : 2;
+		u64 active_vec                       : 20;
+		u64 rr_active                        : 1;
+		u64 reserved_41_63                   : 23;
+	} s;
+	/* struct cavm_nixx_af_tl1x_green_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL1X_GREEN(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL1X_GREEN(u64 a)
+{
+	return 0xc90 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_green_bytes
+ *
+ * NIX AF Transmit Level 1 Green Sent Bytes Registers
+ */
+union cavm_nixx_af_tl1x_green_bytes {
+	u64 u;
+	struct cavm_nixx_af_tl1x_green_bytes_s {
+		u64 count                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_nixx_af_tl1x_green_bytes_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL1X_GREEN_BYTES(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL1X_GREEN_BYTES(u64 a)
+{
+	return 0xd90 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_green_packets
+ *
+ * NIX AF Transmit Level 1 Green Sent Packets Registers
+ */
+union cavm_nixx_af_tl1x_green_packets {
+	u64 u;
+	struct cavm_nixx_af_tl1x_green_packets_s {
+		u64 count                            : 40;
+		u64 reserved_40_63                   : 24;
+	} s;
+	/* struct cavm_nixx_af_tl1x_green_packets_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL1X_GREEN_PACKETS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL1X_GREEN_PACKETS(u64 a)
+{
+	return 0xd80 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_md_debug0
+ *
+ * NIX AF Transmit Level 1 Meta Descriptor Debug 0 Registers
+ * NIX_AF_TL1()_MD_DEBUG0, NIX_AF_TL1()_MD_DEBUG1, NIX_AF_TL1()_MD_DEBUG2
+ * and NIX_AF_TL1()_MD_DEBUG3 provide access to the TLn queue meta
+ * descriptor. A TLn queue can hold up to two packet meta descriptors
+ * (PMD) and one flush meta descriptor (FMD): * PMD0 state is accessed
+ * with [PMD0_VLD], [PMD0_LENGTH] and NIX_AF_TL1()_MD_DEBUG1. * PMD1 is
+ * accessed with [PMD1_VLD], [PMD1_LENGTH] and NIX_AF_TL1()_MD_DEBUG2. *
+ * FMD is accessed with NIX_AF_TL1()_MD_DEBUG3.
+ */
+union cavm_nixx_af_tl1x_md_debug0 {
+	u64 u;
+	struct cavm_nixx_af_tl1x_md_debug0_s {
+		u64 pmd0_length                      : 16;
+		u64 pmd1_length                      : 16;
+		u64 pmd0_vld                         : 1;
+		u64 pmd1_vld                         : 1;
+		u64 reserved_34_45                   : 12;
+		u64 drain_pri                        : 1;
+		u64 drain                            : 1;
+		u64 c_con                            : 1;
+		u64 p_con                            : 1;
+		u64 reserved_50_51                   : 2;
+		u64 child                            : 10;
+		u64 reserved_62                      : 1;
+		u64 pmd_count                        : 1;
+	} s;
+	/* struct cavm_nixx_af_tl1x_md_debug0_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL1X_MD_DEBUG0(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL1X_MD_DEBUG0(u64 a)
+{
+	return 0xcc0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_md_debug1
+ *
+ * NIX AF Transmit Level 1 Meta Descriptor Debug 1 Registers Packet meta
+ * descriptor 0 debug. See NIX_AF_TL1()_MD_DEBUG0.
+ */
+union cavm_nixx_af_tl1x_md_debug1 {
+	u64 u;
+	struct cavm_nixx_af_tl1x_md_debug1_s {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 drain                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} s;
+	/* struct cavm_nixx_af_tl1x_md_debug1_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL1X_MD_DEBUG1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL1X_MD_DEBUG1(u64 a)
+{
+	return 0xcc8 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_md_debug2
+ *
+ * NIX AF Transmit Level 1 Meta Descriptor Debug 2 Registers Packet meta
+ * descriptor 1 debug. See NIX_AF_TL1()_MD_DEBUG0.
+ */
+union cavm_nixx_af_tl1x_md_debug2 {
+	u64 u;
+	struct cavm_nixx_af_tl1x_md_debug2_s {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 drain                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} s;
+	/* struct cavm_nixx_af_tl1x_md_debug2_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL1X_MD_DEBUG2(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL1X_MD_DEBUG2(u64 a)
+{
+	return 0xcd0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_md_debug3
+ *
+ * NIX AF Transmit Level 1 Meta Descriptor Debug 3 Registers Flush meta
+ * descriptor debug. See NIX_AF_TL1()_MD_DEBUG0.
+ */
+union cavm_nixx_af_tl1x_md_debug3 {
+	u64 u;
+	struct cavm_nixx_af_tl1x_md_debug3_s {
+		u64 reserved_0_36                    : 37;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} s;
+	/* struct cavm_nixx_af_tl1x_md_debug3_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL1X_MD_DEBUG3(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL1X_MD_DEBUG3(u64 a)
+{
+	return 0xcd8 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_red
+ *
+ * INTERNAL: NIX Transmit Level 1 Red State Debug Register  This register
+ * has the same bit fields as NIX_AF_TL1()_YELLOW.
+ */
+union cavm_nixx_af_tl1x_red {
+	u64 u;
+	struct cavm_nixx_af_tl1x_red_s {
+		u64 tail                             : 8;
+		u64 reserved_8_9                     : 2;
+		u64 head                             : 8;
+		u64 reserved_18_63                   : 46;
+	} s;
+	/* struct cavm_nixx_af_tl1x_red_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL1X_RED(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL1X_RED(u64 a)
+{
+	return 0xcb0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_red_bytes
+ *
+ * NIX AF Transmit Level 1 Red Sent Bytes Registers This register has the
+ * same bit fields as NIX_AF_TL1()_GREEN_BYTES.
+ */
+union cavm_nixx_af_tl1x_red_bytes {
+	u64 u;
+	struct cavm_nixx_af_tl1x_red_bytes_s {
+		u64 count                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_nixx_af_tl1x_red_bytes_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL1X_RED_BYTES(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL1X_RED_BYTES(u64 a)
+{
+	return 0xd50 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_red_packets
+ *
+ * NIX AF Transmit Level 1 Red Sent Packets Registers This register has
+ * the same bit fields as NIX_AF_TL1()_GREEN_PACKETS.
+ */
+union cavm_nixx_af_tl1x_red_packets {
+	u64 u;
+	struct cavm_nixx_af_tl1x_red_packets_s {
+		u64 count                            : 40;
+		u64 reserved_40_63                   : 24;
+	} s;
+	/* struct cavm_nixx_af_tl1x_red_packets_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL1X_RED_PACKETS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL1X_RED_PACKETS(u64 a)
+{
+	return 0xd40 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_schedule
+ *
+ * NIX AF Transmit Level 1 Scheduling Control Register
+ */
+union cavm_nixx_af_tl1x_schedule {
+	u64 u;
+	struct cavm_nixx_af_tl1x_schedule_s {
+		u64 rr_quantum                       : 24;
+		u64 reserved_24_63                   : 40;
+	} s;
+	/* struct cavm_nixx_af_tl1x_schedule_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL1X_SCHEDULE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL1X_SCHEDULE(u64 a)
+{
+	return 0xc00 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_shape
+ *
+ * NIX AF Transmit Level 1 Shaping Control Register
+ */
+union cavm_nixx_af_tl1x_shape {
+	u64 u;
+	struct cavm_nixx_af_tl1x_shape_s {
+		u64 adjust                           : 9;
+		u64 reserved_9_23                    : 15;
+		u64 length_disable                   : 1;
+		u64 reserved_25_63                   : 39;
+	} s;
+	struct cavm_nixx_af_tl1x_shape_cn {
+		u64 adjust                           : 9;
+		u64 reserved_9_17                    : 9;
+		u64 reserved_18_23                   : 6;
+		u64 length_disable                   : 1;
+		u64 reserved_25_63                   : 39;
+	} cn;
+};
+
+static inline u64 CAVM_NIXX_AF_TL1X_SHAPE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL1X_SHAPE(u64 a)
+{
+	return 0xc10 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_shape_state
+ *
+ * NIX AF Transmit Level 1 Shape State Register This register must not be
+ * written during normal operation.
+ */
+union cavm_nixx_af_tl1x_shape_state {
+	u64 u;
+	struct cavm_nixx_af_tl1x_shape_state_s {
+		u64 cir_accum                        : 26;
+		u64 reserved_26_51                   : 26;
+		u64 color                            : 1;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct cavm_nixx_af_tl1x_shape_state_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL1X_SHAPE_STATE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL1X_SHAPE_STATE(u64 a)
+{
+	return 0xc50 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_sw_xoff
+ *
+ * NIX AF Transmit Level 1 Software Controlled XOFF Registers
+ */
+union cavm_nixx_af_tl1x_sw_xoff {
+	u64 u;
+	struct cavm_nixx_af_tl1x_sw_xoff_s {
+		u64 xoff                             : 1;
+		u64 drain                            : 1;
+		u64 reserved_2                       : 1;
+		u64 drain_irq                        : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cavm_nixx_af_tl1x_sw_xoff_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL1X_SW_XOFF(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL1X_SW_XOFF(u64 a)
+{
+	return 0xc70 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_topology
+ *
+ * NIX AF Transmit Level 1 Topology Registers
+ */
+union cavm_nixx_af_tl1x_topology {
+	u64 u;
+	struct cavm_nixx_af_tl1x_topology_s {
+		u64 reserved_0                       : 1;
+		u64 rr_prio                          : 4;
+		u64 reserved_5_31                    : 27;
+		u64 prio_anchor                      : 8;
+		u64 reserved_40_63                   : 24;
+	} s;
+	/* struct cavm_nixx_af_tl1x_topology_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL1X_TOPOLOGY(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL1X_TOPOLOGY(u64 a)
+{
+	return 0xc80 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_yellow
+ *
+ * INTERNAL: NIX Transmit Level 1 Yellow State Debug Register
+ */
+union cavm_nixx_af_tl1x_yellow {
+	u64 u;
+	struct cavm_nixx_af_tl1x_yellow_s {
+		u64 tail                             : 8;
+		u64 reserved_8_9                     : 2;
+		u64 head                             : 8;
+		u64 reserved_18_63                   : 46;
+	} s;
+	/* struct cavm_nixx_af_tl1x_yellow_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL1X_YELLOW(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL1X_YELLOW(u64 a)
+{
+	return 0xca0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_yellow_bytes
+ *
+ * NIX AF Transmit Level 1 Yellow Sent Bytes Registers This register has
+ * the same bit fields as NIX_AF_TL1()_GREEN_BYTES.
+ */
+union cavm_nixx_af_tl1x_yellow_bytes {
+	u64 u;
+	struct cavm_nixx_af_tl1x_yellow_bytes_s {
+		u64 count                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_nixx_af_tl1x_yellow_bytes_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL1X_YELLOW_BYTES(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL1X_YELLOW_BYTES(u64 a)
+{
+	return 0xd70 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1#_yellow_packets
+ *
+ * NIX AF Transmit Level 1 Yellow Sent Packets Registers This register
+ * has the same bit fields as NIX_AF_TL1()_GREEN_PACKETS.
+ */
+union cavm_nixx_af_tl1x_yellow_packets {
+	u64 u;
+	struct cavm_nixx_af_tl1x_yellow_packets_s {
+		u64 count                            : 40;
+		u64 reserved_40_63                   : 24;
+	} s;
+	/* struct cavm_nixx_af_tl1x_yellow_packets_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL1X_YELLOW_PACKETS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL1X_YELLOW_PACKETS(u64 a)
+{
+	return 0xd60 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl1_const
+ *
+ * NIX AF Transmit Level 1 Constants Register This register contains
+ * constants for software discovery.
+ */
+union cavm_nixx_af_tl1_const {
+	u64 u;
+	struct cavm_nixx_af_tl1_const_s {
+		u64 count                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_nixx_af_tl1_const_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL1_CONST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL1_CONST(void)
+{
+	return 0x70;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_cir
+ *
+ * NIX AF Transmit Level 2 Committed Information Rate Registers This
+ * register has the same bit fields as NIX_AF_TL1()_CIR.
+ */
+union cavm_nixx_af_tl2x_cir {
+	u64 u;
+	struct cavm_nixx_af_tl2x_cir_s {
+		u64 enable                           : 1;
+		u64 rate_mantissa                    : 8;
+		u64 rate_exponent                    : 4;
+		u64 rate_divider_exponent            : 4;
+		u64 reserved_17_28                   : 12;
+		u64 burst_mantissa                   : 8;
+		u64 burst_exponent                   : 4;
+		u64 reserved_41_63                   : 23;
+	} s;
+	/* struct cavm_nixx_af_tl2x_cir_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL2X_CIR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL2X_CIR(u64 a)
+{
+	return 0xe20 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_green
+ *
+ * INTERNAL: NIX Transmit Level 2 Green State Debug Register  This
+ * register has the same bit fields as NIX_AF_TL1()_GREEN.
+ */
+union cavm_nixx_af_tl2x_green {
+	u64 u;
+	struct cavm_nixx_af_tl2x_green_s {
+		u64 tail                             : 8;
+		u64 reserved_8_9                     : 2;
+		u64 head                             : 8;
+		u64 reserved_18_19                   : 2;
+		u64 active_vec                       : 20;
+		u64 rr_active                        : 1;
+		u64 reserved_41_63                   : 23;
+	} s;
+	/* struct cavm_nixx_af_tl2x_green_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL2X_GREEN(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL2X_GREEN(u64 a)
+{
+	return 0xe90 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_md_debug0
+ *
+ * NIX AF Transmit Level 2 Meta Descriptor Debug 0 Registers See
+ * NIX_AF_TL1()_MD_DEBUG0
+ */
+union cavm_nixx_af_tl2x_md_debug0 {
+	u64 u;
+	struct cavm_nixx_af_tl2x_md_debug0_s {
+		u64 pmd0_length                      : 16;
+		u64 pmd1_length                      : 16;
+		u64 pmd0_vld                         : 1;
+		u64 pmd1_vld                         : 1;
+		u64 reserved_34_45                   : 12;
+		u64 drain_pri                        : 1;
+		u64 drain                            : 1;
+		u64 c_con                            : 1;
+		u64 p_con                            : 1;
+		u64 reserved_50_51                   : 2;
+		u64 child                            : 10;
+		u64 reserved_62                      : 1;
+		u64 pmd_count                        : 1;
+	} s;
+	/* struct cavm_nixx_af_tl2x_md_debug0_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL2X_MD_DEBUG0(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL2X_MD_DEBUG0(u64 a)
+{
+	return 0xec0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_md_debug1
+ *
+ * NIX AF Transmit Level 2 Meta Descriptor Debug 1 Registers Packet meta
+ * descriptor 0 debug. See NIX_AF_TL1()_MD_DEBUG0.
+ */
+union cavm_nixx_af_tl2x_md_debug1 {
+	u64 u;
+	struct cavm_nixx_af_tl2x_md_debug1_s {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 drain                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} s;
+	/* struct cavm_nixx_af_tl2x_md_debug1_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL2X_MD_DEBUG1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL2X_MD_DEBUG1(u64 a)
+{
+	return 0xec8 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_md_debug2
+ *
+ * NIX AF Transmit Level 2 Meta Descriptor Debug 2 Registers Packet meta
+ * descriptor 1 debug. See NIX_AF_TL1()_MD_DEBUG0.
+ */
+union cavm_nixx_af_tl2x_md_debug2 {
+	u64 u;
+	struct cavm_nixx_af_tl2x_md_debug2_s {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 drain                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} s;
+	/* struct cavm_nixx_af_tl2x_md_debug2_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL2X_MD_DEBUG2(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL2X_MD_DEBUG2(u64 a)
+{
+	return 0xed0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_md_debug3
+ *
+ * NIX AF Transmit Level 2 Meta Descriptor Debug 3 Registers Flush meta
+ * descriptor debug. See NIX_AF_TL1()_MD_DEBUG0.
+ */
+union cavm_nixx_af_tl2x_md_debug3 {
+	u64 u;
+	struct cavm_nixx_af_tl2x_md_debug3_s {
+		u64 reserved_0_36                    : 37;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} s;
+	/* struct cavm_nixx_af_tl2x_md_debug3_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL2X_MD_DEBUG3(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL2X_MD_DEBUG3(u64 a)
+{
+	return 0xed8 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_parent
+ *
+ * NIX AF Transmit Level 2 Parent Registers
+ */
+union cavm_nixx_af_tl2x_parent {
+	u64 u;
+	struct cavm_nixx_af_tl2x_parent_s {
+		u64 reserved_0_15                    : 16;
+		u64 parent                           : 5;
+		u64 reserved_21_63                   : 43;
+	} s;
+	/* struct cavm_nixx_af_tl2x_parent_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL2X_PARENT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL2X_PARENT(u64 a)
+{
+	return 0xe88 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_pir
+ *
+ * NIX AF Transmit Level 2 Peak Information Rate Registers This register
+ * has the same bit fields as NIX_AF_TL1()_CIR.
+ */
+union cavm_nixx_af_tl2x_pir {
+	u64 u;
+	struct cavm_nixx_af_tl2x_pir_s {
+		u64 enable                           : 1;
+		u64 rate_mantissa                    : 8;
+		u64 rate_exponent                    : 4;
+		u64 rate_divider_exponent            : 4;
+		u64 reserved_17_28                   : 12;
+		u64 burst_mantissa                   : 8;
+		u64 burst_exponent                   : 4;
+		u64 reserved_41_63                   : 23;
+	} s;
+	/* struct cavm_nixx_af_tl2x_pir_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL2X_PIR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL2X_PIR(u64 a)
+{
+	return 0xe30 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_pointers
+ *
+ * INTERNAL: NIX Transmit Level 2 Linked List Pointers Debug Register
+ */
+union cavm_nixx_af_tl2x_pointers {
+	u64 u;
+	struct cavm_nixx_af_tl2x_pointers_s {
+		u64 next                             : 8;
+		u64 reserved_8_15                    : 8;
+		u64 prev                             : 8;
+		u64 reserved_24_63                   : 40;
+	} s;
+	/* struct cavm_nixx_af_tl2x_pointers_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL2X_POINTERS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL2X_POINTERS(u64 a)
+{
+	return 0xe60 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_red
+ *
+ * INTERNAL: NIX Transmit Level 2 Red State Debug Register  This register
+ * has the same bit fields as NIX_AF_TL1()_RED.
+ */
+union cavm_nixx_af_tl2x_red {
+	u64 u;
+	struct cavm_nixx_af_tl2x_red_s {
+		u64 tail                             : 8;
+		u64 reserved_8_9                     : 2;
+		u64 head                             : 8;
+		u64 reserved_18_63                   : 46;
+	} s;
+	/* struct cavm_nixx_af_tl2x_red_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL2X_RED(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL2X_RED(u64 a)
+{
+	return 0xeb0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_sched_state
+ *
+ * NIX AF Transmit Level 2 Scheduling Control State Registers
+ */
+union cavm_nixx_af_tl2x_sched_state {
+	u64 u;
+	struct cavm_nixx_af_tl2x_sched_state_s {
+		u64 rr_count                         : 25;
+		u64 reserved_25_63                   : 39;
+	} s;
+	/* struct cavm_nixx_af_tl2x_sched_state_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL2X_SCHED_STATE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL2X_SCHED_STATE(u64 a)
+{
+	return 0xe40 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_schedule
+ *
+ * NIX AF Transmit Level 2 Scheduling Control Registers
+ */
+union cavm_nixx_af_tl2x_schedule {
+	u64 u;
+	struct cavm_nixx_af_tl2x_schedule_s {
+		u64 rr_quantum                       : 24;
+		u64 prio                             : 4;
+		u64 reserved_28_63                   : 36;
+	} s;
+	/* struct cavm_nixx_af_tl2x_schedule_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL2X_SCHEDULE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL2X_SCHEDULE(u64 a)
+{
+	return 0xe00 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_shape
+ *
+ * NIX AF Transmit Level 2 Shaping Control Registers
+ */
+union cavm_nixx_af_tl2x_shape {
+	u64 u;
+	struct cavm_nixx_af_tl2x_shape_s {
+		u64 adjust                           : 9;
+		u64 red_algo                         : 2;
+		u64 red_disable                      : 1;
+		u64 yellow_disable                   : 1;
+		u64 reserved_13_23                   : 11;
+		u64 length_disable                   : 1;
+		u64 schedule_list                    : 2;
+		u64 reserved_27_63                   : 37;
+	} s;
+	/* struct cavm_nixx_af_tl2x_shape_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL2X_SHAPE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL2X_SHAPE(u64 a)
+{
+	return 0xe10 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_shape_state
+ *
+ * NIX AF Transmit Level 2 Shape State Registers This register must not
+ * be written during normal operation.
+ */
+union cavm_nixx_af_tl2x_shape_state {
+	u64 u;
+	struct cavm_nixx_af_tl2x_shape_state_s {
+		u64 cir_accum                        : 26;
+		u64 pir_accum                        : 26;
+		u64 color                            : 2;
+		u64 reserved_54_63                   : 10;
+	} s;
+	/* struct cavm_nixx_af_tl2x_shape_state_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL2X_SHAPE_STATE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL2X_SHAPE_STATE(u64 a)
+{
+	return 0xe50 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_sw_xoff
+ *
+ * NIX AF Transmit Level 2 Software Controlled XOFF Registers This
+ * register has the same bit fields as NIX_AF_TL1()_SW_XOFF.
+ */
+union cavm_nixx_af_tl2x_sw_xoff {
+	u64 u;
+	struct cavm_nixx_af_tl2x_sw_xoff_s {
+		u64 xoff                             : 1;
+		u64 drain                            : 1;
+		u64 reserved_2                       : 1;
+		u64 drain_irq                        : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cavm_nixx_af_tl2x_sw_xoff_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL2X_SW_XOFF(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL2X_SW_XOFF(u64 a)
+{
+	return 0xe70 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_topology
+ *
+ * NIX AF Transmit Level 2 Topology Registers
+ */
+union cavm_nixx_af_tl2x_topology {
+	u64 u;
+	struct cavm_nixx_af_tl2x_topology_s {
+		u64 reserved_0                       : 1;
+		u64 rr_prio                          : 4;
+		u64 reserved_5_31                    : 27;
+		u64 prio_anchor                      : 8;
+		u64 reserved_40_63                   : 24;
+	} s;
+	/* struct cavm_nixx_af_tl2x_topology_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL2X_TOPOLOGY(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL2X_TOPOLOGY(u64 a)
+{
+	return 0xe80 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2#_yellow
+ *
+ * INTERNAL: NIX Transmit Level 2 Yellow State Debug Register  This
+ * register has the same bit fields as NIX_AF_TL1()_YELLOW.
+ */
+union cavm_nixx_af_tl2x_yellow {
+	u64 u;
+	struct cavm_nixx_af_tl2x_yellow_s {
+		u64 tail                             : 8;
+		u64 reserved_8_9                     : 2;
+		u64 head                             : 8;
+		u64 reserved_18_63                   : 46;
+	} s;
+	/* struct cavm_nixx_af_tl2x_yellow_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL2X_YELLOW(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL2X_YELLOW(u64 a)
+{
+	return 0xea0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl2_const
+ *
+ * NIX AF Transmit Level 2 Constants Register This register contains
+ * constants for software discovery.
+ */
+union cavm_nixx_af_tl2_const {
+	u64 u;
+	struct cavm_nixx_af_tl2_const_s {
+		u64 count                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_nixx_af_tl2_const_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL2_CONST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL2_CONST(void)
+{
+	return 0x78;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_cir
+ *
+ * NIX AF Transmit Level 3 Committed Information Rate Registers This
+ * register has the same bit fields as NIX_AF_TL1()_CIR.
+ */
+union cavm_nixx_af_tl3x_cir {
+	u64 u;
+	struct cavm_nixx_af_tl3x_cir_s {
+		u64 enable                           : 1;
+		u64 rate_mantissa                    : 8;
+		u64 rate_exponent                    : 4;
+		u64 rate_divider_exponent            : 4;
+		u64 reserved_17_28                   : 12;
+		u64 burst_mantissa                   : 8;
+		u64 burst_exponent                   : 4;
+		u64 reserved_41_63                   : 23;
+	} s;
+	/* struct cavm_nixx_af_tl3x_cir_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL3X_CIR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL3X_CIR(u64 a)
+{
+	return 0x1020 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_green
+ *
+ * INTERNAL: NIX Transmit Level 3 Green State Debug Register
+ */
+union cavm_nixx_af_tl3x_green {
+	u64 u;
+	struct cavm_nixx_af_tl3x_green_s {
+		u64 tail                             : 9;
+		u64 reserved_9                       : 1;
+		u64 head                             : 9;
+		u64 reserved_19                      : 1;
+		u64 active_vec                       : 20;
+		u64 rr_active                        : 1;
+		u64 reserved_41_63                   : 23;
+	} s;
+	/* struct cavm_nixx_af_tl3x_green_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL3X_GREEN(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL3X_GREEN(u64 a)
+{
+	return 0x1090 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_md_debug0
+ *
+ * NIX AF Transmit Level 3 Meta Descriptor Debug 0 Registers See
+ * NIX_AF_TL1()_MD_DEBUG0.
+ */
+union cavm_nixx_af_tl3x_md_debug0 {
+	u64 u;
+	struct cavm_nixx_af_tl3x_md_debug0_s {
+		u64 pmd0_length                      : 16;
+		u64 pmd1_length                      : 16;
+		u64 pmd0_vld                         : 1;
+		u64 pmd1_vld                         : 1;
+		u64 reserved_34_45                   : 12;
+		u64 drain_pri                        : 1;
+		u64 drain                            : 1;
+		u64 c_con                            : 1;
+		u64 p_con                            : 1;
+		u64 reserved_50_51                   : 2;
+		u64 child                            : 10;
+		u64 reserved_62                      : 1;
+		u64 pmd_count                        : 1;
+	} s;
+	/* struct cavm_nixx_af_tl3x_md_debug0_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL3X_MD_DEBUG0(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL3X_MD_DEBUG0(u64 a)
+{
+	return 0x10c0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_md_debug1
+ *
+ * NIX AF Transmit Level 3 Meta Descriptor Debug 1 Registers Packet meta
+ * descriptor 0 debug. See NIX_AF_TL1()_MD_DEBUG0.
+ */
+union cavm_nixx_af_tl3x_md_debug1 {
+	u64 u;
+	struct cavm_nixx_af_tl3x_md_debug1_s {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 drain                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} s;
+	/* struct cavm_nixx_af_tl3x_md_debug1_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL3X_MD_DEBUG1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL3X_MD_DEBUG1(u64 a)
+{
+	return 0x10c8 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_md_debug2
+ *
+ * NIX AF Transmit Level 3 Meta Descriptor Debug 2 Registers Packet meta
+ * descriptor 1 debug. See NIX_AF_TL1()_MD_DEBUG0.
+ */
+union cavm_nixx_af_tl3x_md_debug2 {
+	u64 u;
+	struct cavm_nixx_af_tl3x_md_debug2_s {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 drain                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} s;
+	/* struct cavm_nixx_af_tl3x_md_debug2_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL3X_MD_DEBUG2(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL3X_MD_DEBUG2(u64 a)
+{
+	return 0x10d0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_md_debug3
+ *
+ * NIX AF Transmit Level 3 Meta Descriptor Debug 3 Registers Flush meta
+ * descriptor debug. See NIX_AF_TL1()_MD_DEBUG0.
+ */
+union cavm_nixx_af_tl3x_md_debug3 {
+	u64 u;
+	struct cavm_nixx_af_tl3x_md_debug3_s {
+		u64 reserved_0_36                    : 37;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} s;
+	/* struct cavm_nixx_af_tl3x_md_debug3_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL3X_MD_DEBUG3(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL3X_MD_DEBUG3(u64 a)
+{
+	return 0x10d8 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_parent
+ *
+ * NIX AF Transmit Level 3 Parent Registers
+ */
+union cavm_nixx_af_tl3x_parent {
+	u64 u;
+	struct cavm_nixx_af_tl3x_parent_s {
+		u64 reserved_0_15                    : 16;
+		u64 parent                           : 8;
+		u64 reserved_24_63                   : 40;
+	} s;
+	/* struct cavm_nixx_af_tl3x_parent_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL3X_PARENT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL3X_PARENT(u64 a)
+{
+	return 0x1088 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_pir
+ *
+ * NIX AF Transmit Level 3 Peak Information Rate Registers This register
+ * has the same bit fields as NIX_AF_TL1()_CIR.
+ */
+union cavm_nixx_af_tl3x_pir {
+	u64 u;
+	struct cavm_nixx_af_tl3x_pir_s {
+		u64 enable                           : 1;
+		u64 rate_mantissa                    : 8;
+		u64 rate_exponent                    : 4;
+		u64 rate_divider_exponent            : 4;
+		u64 reserved_17_28                   : 12;
+		u64 burst_mantissa                   : 8;
+		u64 burst_exponent                   : 4;
+		u64 reserved_41_63                   : 23;
+	} s;
+	/* struct cavm_nixx_af_tl3x_pir_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL3X_PIR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL3X_PIR(u64 a)
+{
+	return 0x1030 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_pointers
+ *
+ * INTERNAL: NIX Transmit Level 3 Linked List Pointers Debug Register
+ * This register has the same bit fields as NIX_AF_TL2()_POINTERS.
+ */
+union cavm_nixx_af_tl3x_pointers {
+	u64 u;
+	struct cavm_nixx_af_tl3x_pointers_s {
+		u64 next                             : 8;
+		u64 reserved_8_15                    : 8;
+		u64 prev                             : 8;
+		u64 reserved_24_63                   : 40;
+	} s;
+	/* struct cavm_nixx_af_tl3x_pointers_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL3X_POINTERS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL3X_POINTERS(u64 a)
+{
+	return 0x1060 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_red
+ *
+ * INTERNAL: NIX Transmit Level 3 Red State Debug Register  This register
+ * has the same bit fields as NIX_AF_TL3()_YELLOW.
+ */
+union cavm_nixx_af_tl3x_red {
+	u64 u;
+	struct cavm_nixx_af_tl3x_red_s {
+		u64 tail                             : 9;
+		u64 reserved_9                       : 1;
+		u64 head                             : 9;
+		u64 reserved_19_63                   : 45;
+	} s;
+	/* struct cavm_nixx_af_tl3x_red_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL3X_RED(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL3X_RED(u64 a)
+{
+	return 0x10b0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_sched_state
+ *
+ * NIX AF Transmit Level 3 Scheduling Control State Registers This
+ * register has the same bit fields as NIX_AF_TL2()_SCHED_STATE.
+ */
+union cavm_nixx_af_tl3x_sched_state {
+	u64 u;
+	struct cavm_nixx_af_tl3x_sched_state_s {
+		u64 rr_count                         : 25;
+		u64 reserved_25_63                   : 39;
+	} s;
+	/* struct cavm_nixx_af_tl3x_sched_state_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL3X_SCHED_STATE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL3X_SCHED_STATE(u64 a)
+{
+	return 0x1040 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_schedule
+ *
+ * NIX AF Transmit Level 3 Scheduling Control Registers This register has
+ * the same bit fields as NIX_AF_TL2()_SCHEDULE.
+ */
+union cavm_nixx_af_tl3x_schedule {
+	u64 u;
+	struct cavm_nixx_af_tl3x_schedule_s {
+		u64 rr_quantum                       : 24;
+		u64 prio                             : 4;
+		u64 reserved_28_63                   : 36;
+	} s;
+	/* struct cavm_nixx_af_tl3x_schedule_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL3X_SCHEDULE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL3X_SCHEDULE(u64 a)
+{
+	return 0x1000 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_shape
+ *
+ * NIX AF Transmit Level 3 Shaping Control Registers
+ */
+union cavm_nixx_af_tl3x_shape {
+	u64 u;
+	struct cavm_nixx_af_tl3x_shape_s {
+		u64 adjust                           : 9;
+		u64 red_algo                         : 2;
+		u64 red_disable                      : 1;
+		u64 yellow_disable                   : 1;
+		u64 reserved_13_23                   : 11;
+		u64 length_disable                   : 1;
+		u64 schedule_list                    : 2;
+		u64 reserved_27_63                   : 37;
+	} s;
+	/* struct cavm_nixx_af_tl3x_shape_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL3X_SHAPE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL3X_SHAPE(u64 a)
+{
+	return 0x1010 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_shape_state
+ *
+ * NIX AF Transmit Level 3 Shaping State Registers This register has the
+ * same bit fields as NIX_AF_TL2()_SHAPE_STATE. This register must not be
+ * written during normal operation.
+ */
+union cavm_nixx_af_tl3x_shape_state {
+	u64 u;
+	struct cavm_nixx_af_tl3x_shape_state_s {
+		u64 cir_accum                        : 26;
+		u64 pir_accum                        : 26;
+		u64 color                            : 2;
+		u64 reserved_54_63                   : 10;
+	} s;
+	/* struct cavm_nixx_af_tl3x_shape_state_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL3X_SHAPE_STATE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL3X_SHAPE_STATE(u64 a)
+{
+	return 0x1050 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_sw_xoff
+ *
+ * NIX AF Transmit Level 3 Software Controlled XOFF Registers This
+ * register has the same bit fields as NIX_AF_TL1()_SW_XOFF
+ */
+union cavm_nixx_af_tl3x_sw_xoff {
+	u64 u;
+	struct cavm_nixx_af_tl3x_sw_xoff_s {
+		u64 xoff                             : 1;
+		u64 drain                            : 1;
+		u64 reserved_2                       : 1;
+		u64 drain_irq                        : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cavm_nixx_af_tl3x_sw_xoff_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL3X_SW_XOFF(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL3X_SW_XOFF(u64 a)
+{
+	return 0x1070 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_topology
+ *
+ * NIX AF Transmit Level 3 Topology Registers
+ */
+union cavm_nixx_af_tl3x_topology {
+	u64 u;
+	struct cavm_nixx_af_tl3x_topology_s {
+		u64 reserved_0                       : 1;
+		u64 rr_prio                          : 4;
+		u64 reserved_5_31                    : 27;
+		u64 prio_anchor                      : 9;
+		u64 reserved_41_63                   : 23;
+	} s;
+	/* struct cavm_nixx_af_tl3x_topology_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL3X_TOPOLOGY(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL3X_TOPOLOGY(u64 a)
+{
+	return 0x1080 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3#_yellow
+ *
+ * INTERNAL: NIX Transmit Level 3 Yellow State Debug Register
+ */
+union cavm_nixx_af_tl3x_yellow {
+	u64 u;
+	struct cavm_nixx_af_tl3x_yellow_s {
+		u64 tail                             : 9;
+		u64 reserved_9                       : 1;
+		u64 head                             : 9;
+		u64 reserved_19_63                   : 45;
+	} s;
+	/* struct cavm_nixx_af_tl3x_yellow_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL3X_YELLOW(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL3X_YELLOW(u64 a)
+{
+	return 0x10a0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3_const
+ *
+ * NIX AF Transmit Level 3 Constants Register This register contains
+ * constants for software discovery.
+ */
+union cavm_nixx_af_tl3_const {
+	u64 u;
+	struct cavm_nixx_af_tl3_const_s {
+		u64 count                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_nixx_af_tl3_const_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL3_CONST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL3_CONST(void)
+{
+	return 0x80;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3_tl2#_bp_status
+ *
+ * NIX AF Transmit Level 3/2 Backpressure Status Registers
+ */
+union cavm_nixx_af_tl3_tl2x_bp_status {
+	u64 u;
+	struct cavm_nixx_af_tl3_tl2x_bp_status_s {
+		u64 hw_xoff                          : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_nixx_af_tl3_tl2x_bp_status_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL3_TL2X_BP_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL3_TL2X_BP_STATUS(u64 a)
+{
+	return 0x1610 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3_tl2#_cfg
+ *
+ * NIX AF Transmit Level 3/2 Configuration Registers
+ */
+union cavm_nixx_af_tl3_tl2x_cfg {
+	u64 u;
+	struct cavm_nixx_af_tl3_tl2x_cfg_s {
+		u64 express                          : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_nixx_af_tl3_tl2x_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL3_TL2X_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL3_TL2X_CFG(u64 a)
+{
+	return 0x1600 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl3_tl2#_link#_cfg
+ *
+ * NIX AF Transmit Level 3/2 Link Configuration Registers These registers
+ * specify the links and associated channels that a given TL3 or TL2
+ * queue (depending on NIX_AF_PSE_CHANNEL_LEVEL[BP_LEVEL]) can transmit
+ * on. Each TL3/TL2 queue can be enabled to transmit on and be
+ * backpressured by one or more links and associated channels. The last
+ * index (LINK) is enumerated by NIX_LINK_E.
+ */
+union cavm_nixx_af_tl3_tl2x_linkx_cfg {
+	u64 u;
+	struct cavm_nixx_af_tl3_tl2x_linkx_cfg_s {
+		u64 relchan                          : 8;
+		u64 reserved_8_11                    : 4;
+		u64 ena                              : 1;
+		u64 bp_ena                           : 1;
+		u64 reserved_14_63                   : 50;
+	} s;
+	/* struct cavm_nixx_af_tl3_tl2x_linkx_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL3_TL2X_LINKX_CFG(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL3_TL2X_LINKX_CFG(u64 a, u64 b)
+{
+	return 0x1700 + 0x10000 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_bp_status
+ *
+ * NIX AF Transmit Level 4 Backpressure Status Registers
+ */
+union cavm_nixx_af_tl4x_bp_status {
+	u64 u;
+	struct cavm_nixx_af_tl4x_bp_status_s {
+		u64 hw_xoff                          : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_nixx_af_tl4x_bp_status_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL4X_BP_STATUS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL4X_BP_STATUS(u64 a)
+{
+	return 0xb00 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_cir
+ *
+ * NIX AF Transmit Level 4 Committed Information Rate Registers This
+ * register has the same bit fields as NIX_AF_TL1()_CIR.
+ */
+union cavm_nixx_af_tl4x_cir {
+	u64 u;
+	struct cavm_nixx_af_tl4x_cir_s {
+		u64 enable                           : 1;
+		u64 rate_mantissa                    : 8;
+		u64 rate_exponent                    : 4;
+		u64 rate_divider_exponent            : 4;
+		u64 reserved_17_28                   : 12;
+		u64 burst_mantissa                   : 8;
+		u64 burst_exponent                   : 4;
+		u64 reserved_41_63                   : 23;
+	} s;
+	/* struct cavm_nixx_af_tl4x_cir_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL4X_CIR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL4X_CIR(u64 a)
+{
+	return 0x1220 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_green
+ *
+ * INTERNAL: NIX Transmit Level 4 Green State Debug Register  This
+ * register has the same bit fields as NIX_AF_TL3()_GREEN.
+ */
+union cavm_nixx_af_tl4x_green {
+	u64 u;
+	struct cavm_nixx_af_tl4x_green_s {
+		u64 tail                             : 9;
+		u64 reserved_9                       : 1;
+		u64 head                             : 9;
+		u64 reserved_19                      : 1;
+		u64 active_vec                       : 20;
+		u64 rr_active                        : 1;
+		u64 reserved_41_63                   : 23;
+	} s;
+	/* struct cavm_nixx_af_tl4x_green_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL4X_GREEN(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL4X_GREEN(u64 a)
+{
+	return 0x1290 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_md_debug0
+ *
+ * NIX AF Transmit Level 4 Meta Descriptor Debug 0 Registers See
+ * NIX_AF_TL1()_MD_DEBUG0.
+ */
+union cavm_nixx_af_tl4x_md_debug0 {
+	u64 u;
+	struct cavm_nixx_af_tl4x_md_debug0_s {
+		u64 pmd0_length                      : 16;
+		u64 pmd1_length                      : 16;
+		u64 pmd0_vld                         : 1;
+		u64 pmd1_vld                         : 1;
+		u64 reserved_34_45                   : 12;
+		u64 drain_pri                        : 1;
+		u64 drain                            : 1;
+		u64 c_con                            : 1;
+		u64 p_con                            : 1;
+		u64 reserved_50_51                   : 2;
+		u64 child                            : 10;
+		u64 reserved_62                      : 1;
+		u64 pmd_count                        : 1;
+	} s;
+	/* struct cavm_nixx_af_tl4x_md_debug0_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL4X_MD_DEBUG0(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL4X_MD_DEBUG0(u64 a)
+{
+	return 0x12c0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_md_debug1
+ *
+ * NIX AF Transmit Level 4 Meta Descriptor Debug 1 Registers Packet meta
+ * descriptor 0 debug. See NIX_AF_TL1()_MD_DEBUG0.
+ */
+union cavm_nixx_af_tl4x_md_debug1 {
+	u64 u;
+	struct cavm_nixx_af_tl4x_md_debug1_s {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 drain                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} s;
+	/* struct cavm_nixx_af_tl4x_md_debug1_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL4X_MD_DEBUG1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL4X_MD_DEBUG1(u64 a)
+{
+	return 0x12c8 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_md_debug2
+ *
+ * NIX AF Transmit Level 4 Meta Descriptor Debug 2 Registers Packet meta
+ * descriptor 1 debug. See NIX_AF_TL1()_MD_DEBUG0.
+ */
+union cavm_nixx_af_tl4x_md_debug2 {
+	u64 u;
+	struct cavm_nixx_af_tl4x_md_debug2_s {
+		u64 reserved_0_5                     : 6;
+		u64 red_algo_override                : 2;
+		u64 cir_dis                          : 1;
+		u64 pir_dis                          : 1;
+		u64 adjust                           : 9;
+		u64 uid                              : 4;
+		u64 drain                            : 1;
+		u64 bubble                           : 1;
+		u64 color                            : 2;
+		u64 pse_pkt_id                       : 9;
+		u64 reserved_36                      : 1;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} s;
+	/* struct cavm_nixx_af_tl4x_md_debug2_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL4X_MD_DEBUG2(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL4X_MD_DEBUG2(u64 a)
+{
+	return 0x12d0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_md_debug3
+ *
+ * NIX AF Transmit Level 4 Meta Descriptor Debug 3 Registers Flush meta
+ * descriptor debug. See NIX_AF_TL1()_MD_DEBUG0.
+ */
+union cavm_nixx_af_tl4x_md_debug3 {
+	u64 u;
+	struct cavm_nixx_af_tl4x_md_debug3_s {
+		u64 reserved_0_36                    : 37;
+		u64 tx_pkt_p2x                       : 2;
+		u64 sqm_pkt_id                       : 13;
+		u64 mdq_idx                          : 10;
+		u64 reserved_62                      : 1;
+		u64 vld                              : 1;
+	} s;
+	/* struct cavm_nixx_af_tl4x_md_debug3_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL4X_MD_DEBUG3(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL4X_MD_DEBUG3(u64 a)
+{
+	return 0x12d8 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_parent
+ *
+ * NIX AF Transmit Level 4 Parent Registers
+ */
+union cavm_nixx_af_tl4x_parent {
+	u64 u;
+	struct cavm_nixx_af_tl4x_parent_s {
+		u64 reserved_0_15                    : 16;
+		u64 parent                           : 8;
+		u64 reserved_24_63                   : 40;
+	} s;
+	/* struct cavm_nixx_af_tl4x_parent_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL4X_PARENT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL4X_PARENT(u64 a)
+{
+	return 0x1288 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_pir
+ *
+ * NIX AF Transmit Level 4 Peak Information Rate Registers This register
+ * has the same bit fields as NIX_AF_TL1()_CIR.
+ */
+union cavm_nixx_af_tl4x_pir {
+	u64 u;
+	struct cavm_nixx_af_tl4x_pir_s {
+		u64 enable                           : 1;
+		u64 rate_mantissa                    : 8;
+		u64 rate_exponent                    : 4;
+		u64 rate_divider_exponent            : 4;
+		u64 reserved_17_28                   : 12;
+		u64 burst_mantissa                   : 8;
+		u64 burst_exponent                   : 4;
+		u64 reserved_41_63                   : 23;
+	} s;
+	/* struct cavm_nixx_af_tl4x_pir_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL4X_PIR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL4X_PIR(u64 a)
+{
+	return 0x1230 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_pointers
+ *
+ * INTERNAL: NIX Transmit Level 4 Linked List Pointers Debug Register
+ * This register has the same bit fields as NIX_AF_TL2()_POINTERS.
+ */
+union cavm_nixx_af_tl4x_pointers {
+	u64 u;
+	struct cavm_nixx_af_tl4x_pointers_s {
+		u64 next                             : 9;
+		u64 reserved_9_15                    : 7;
+		u64 prev                             : 9;
+		u64 reserved_25_63                   : 39;
+	} s;
+	/* struct cavm_nixx_af_tl4x_pointers_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL4X_POINTERS(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL4X_POINTERS(u64 a)
+{
+	return 0x1260 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_red
+ *
+ * INTERNAL: NIX Transmit Level 4 Red State Debug Register  This register
+ * has the same bit fields as NIX_AF_TL3()_YELLOW.
+ */
+union cavm_nixx_af_tl4x_red {
+	u64 u;
+	struct cavm_nixx_af_tl4x_red_s {
+		u64 tail                             : 9;
+		u64 reserved_9                       : 1;
+		u64 head                             : 9;
+		u64 reserved_19_63                   : 45;
+	} s;
+	/* struct cavm_nixx_af_tl4x_red_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL4X_RED(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL4X_RED(u64 a)
+{
+	return 0x12b0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_sched_state
+ *
+ * NIX AF Transmit Level 4 Scheduling Control State Registers This
+ * register has the same bit fields as NIX_AF_TL2()_SCHED_STATE.
+ */
+union cavm_nixx_af_tl4x_sched_state {
+	u64 u;
+	struct cavm_nixx_af_tl4x_sched_state_s {
+		u64 rr_count                         : 25;
+		u64 reserved_25_63                   : 39;
+	} s;
+	/* struct cavm_nixx_af_tl4x_sched_state_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL4X_SCHED_STATE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL4X_SCHED_STATE(u64 a)
+{
+	return 0x1240 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_schedule
+ *
+ * NIX AF Transmit Level 4 Scheduling Control Registers This register has
+ * the same bit fields as NIX_AF_TL2()_SCHEDULE.
+ */
+union cavm_nixx_af_tl4x_schedule {
+	u64 u;
+	struct cavm_nixx_af_tl4x_schedule_s {
+		u64 rr_quantum                       : 24;
+		u64 prio                             : 4;
+		u64 reserved_28_63                   : 36;
+	} s;
+	/* struct cavm_nixx_af_tl4x_schedule_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL4X_SCHEDULE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL4X_SCHEDULE(u64 a)
+{
+	return 0x1200 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_sdp_link_cfg
+ *
+ * NIX AF Transmit Level 4 Link Configuration Registers These registers
+ * specify which TL4 queues transmit to and are optionally backpressured
+ * by SDP.
+ */
+union cavm_nixx_af_tl4x_sdp_link_cfg {
+	u64 u;
+	struct cavm_nixx_af_tl4x_sdp_link_cfg_s {
+		u64 relchan                          : 8;
+		u64 reserved_8_11                    : 4;
+		u64 ena                              : 1;
+		u64 bp_ena                           : 1;
+		u64 reserved_14_63                   : 50;
+	} s;
+	/* struct cavm_nixx_af_tl4x_sdp_link_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL4X_SDP_LINK_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL4X_SDP_LINK_CFG(u64 a)
+{
+	return 0xb10 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_shape
+ *
+ * NIX AF Transmit Level 4 Shaping Control Registers This register has
+ * the same bit fields as NIX_AF_TL2()_SHAPE.
+ */
+union cavm_nixx_af_tl4x_shape {
+	u64 u;
+	struct cavm_nixx_af_tl4x_shape_s {
+		u64 adjust                           : 9;
+		u64 red_algo                         : 2;
+		u64 red_disable                      : 1;
+		u64 yellow_disable                   : 1;
+		u64 reserved_13_23                   : 11;
+		u64 length_disable                   : 1;
+		u64 schedule_list                    : 2;
+		u64 reserved_27_63                   : 37;
+	} s;
+	/* struct cavm_nixx_af_tl4x_shape_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL4X_SHAPE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL4X_SHAPE(u64 a)
+{
+	return 0x1210 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_shape_state
+ *
+ * NIX AF Transmit Level 4 Shaping State Registers This register has the
+ * same bit fields as NIX_AF_TL2()_SHAPE_STATE. This register must not be
+ * written during normal operation.
+ */
+union cavm_nixx_af_tl4x_shape_state {
+	u64 u;
+	struct cavm_nixx_af_tl4x_shape_state_s {
+		u64 cir_accum                        : 26;
+		u64 pir_accum                        : 26;
+		u64 color                            : 2;
+		u64 reserved_54_63                   : 10;
+	} s;
+	/* struct cavm_nixx_af_tl4x_shape_state_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL4X_SHAPE_STATE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL4X_SHAPE_STATE(u64 a)
+{
+	return 0x1250 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_sw_xoff
+ *
+ * NIX AF Transmit Level 4 Software Controlled XOFF Registers This
+ * register has the same bit fields as NIX_AF_TL1()_SW_XOFF
+ */
+union cavm_nixx_af_tl4x_sw_xoff {
+	u64 u;
+	struct cavm_nixx_af_tl4x_sw_xoff_s {
+		u64 xoff                             : 1;
+		u64 drain                            : 1;
+		u64 reserved_2                       : 1;
+		u64 drain_irq                        : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cavm_nixx_af_tl4x_sw_xoff_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL4X_SW_XOFF(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL4X_SW_XOFF(u64 a)
+{
+	return 0x1270 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_topology
+ *
+ * NIX AF Transmit Level 4 Topology Registers
+ */
+union cavm_nixx_af_tl4x_topology {
+	u64 u;
+	struct cavm_nixx_af_tl4x_topology_s {
+		u64 reserved_0                       : 1;
+		u64 rr_prio                          : 4;
+		u64 reserved_5_31                    : 27;
+		u64 prio_anchor                      : 9;
+		u64 reserved_41_63                   : 23;
+	} s;
+	/* struct cavm_nixx_af_tl4x_topology_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL4X_TOPOLOGY(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL4X_TOPOLOGY(u64 a)
+{
+	return 0x1280 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4#_yellow
+ *
+ * INTERNAL: NIX Transmit Level 4 Yellow State Debug Register  This
+ * register has the same bit fields as NIX_AF_TL3()_YELLOW
+ */
+union cavm_nixx_af_tl4x_yellow {
+	u64 u;
+	struct cavm_nixx_af_tl4x_yellow_s {
+		u64 tail                             : 9;
+		u64 reserved_9                       : 1;
+		u64 head                             : 9;
+		u64 reserved_19_63                   : 45;
+	} s;
+	/* struct cavm_nixx_af_tl4x_yellow_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL4X_YELLOW(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL4X_YELLOW(u64 a)
+{
+	return 0x12a0 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tl4_const
+ *
+ * NIX AF Transmit Level 4 Constants Register This register contains
+ * constants for software discovery.
+ */
+union cavm_nixx_af_tl4_const {
+	u64 u;
+	struct cavm_nixx_af_tl4_const_s {
+		u64 count                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_nixx_af_tl4_const_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TL4_CONST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TL4_CONST(void)
+{
+	return 0x88;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tx_link#_expr_credit
+ *
+ * NIX AF Transmit Link Express Credit Registers These registers track
+ * credits per link for express packets that may potentially preempt
+ * normal packets. Link index enumerated by NIX_LINK_E.
+ */
+union cavm_nixx_af_tx_linkx_expr_credit {
+	u64 u;
+	struct cavm_nixx_af_tx_linkx_expr_credit_s {
+		u64 reserved_0                       : 1;
+		u64 cc_enable                        : 1;
+		u64 cc_packet_cnt                    : 10;
+		u64 cc_unit_cnt                      : 20;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cavm_nixx_af_tx_linkx_expr_credit_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TX_LINKX_EXPR_CREDIT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TX_LINKX_EXPR_CREDIT(u64 a)
+{
+	return 0xa10 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tx_link#_hw_xoff
+ *
+ * NIX AF Transmit Link Hardware Controlled XOFF Registers Link index
+ * enumerated by NIX_LINK_E.
+ */
+union cavm_nixx_af_tx_linkx_hw_xoff {
+	u64 u;
+	struct cavm_nixx_af_tx_linkx_hw_xoff_s {
+		u64 chan_xoff                        : 64;
+	} s;
+	/* struct cavm_nixx_af_tx_linkx_hw_xoff_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TX_LINKX_HW_XOFF(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TX_LINKX_HW_XOFF(u64 a)
+{
+	return 0xa30 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tx_link#_norm_credit
+ *
+ * NIX AF Transmit Link Normal Credit Registers These registers track
+ * credits per link for normal (potentially preemptable) packets sent to
+ * CGX and LBK. Link index enumerated by NIX_LINK_E.
+ */
+union cavm_nixx_af_tx_linkx_norm_credit {
+	u64 u;
+	struct cavm_nixx_af_tx_linkx_norm_credit_s {
+		u64 reserved_0                       : 1;
+		u64 cc_enable                        : 1;
+		u64 cc_packet_cnt                    : 10;
+		u64 cc_unit_cnt                      : 20;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cavm_nixx_af_tx_linkx_norm_credit_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TX_LINKX_NORM_CREDIT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TX_LINKX_NORM_CREDIT(u64 a)
+{
+	return 0xa00 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tx_link#_sw_xoff
+ *
+ * NIX AF Transmit Link Software Controlled XOFF Registers Link index
+ * enumerated by NIX_LINK_E.
+ */
+union cavm_nixx_af_tx_linkx_sw_xoff {
+	u64 u;
+	struct cavm_nixx_af_tx_linkx_sw_xoff_s {
+		u64 chan_xoff                        : 64;
+	} s;
+	/* struct cavm_nixx_af_tx_linkx_sw_xoff_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TX_LINKX_SW_XOFF(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TX_LINKX_SW_XOFF(u64 a)
+{
+	return 0xa20 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tx_mcast#
+ *
+ * NIX AF Transmit Multicast Registers These registers access transmit
+ * multicast table entries used to specify multicast replication lists.
+ * Each list consists of linked entries with [EOL] = 1 in the last entry.
+ * A transmit packet is multicast when the action returned by NPC has
+ * NIX_TX_ACTION_S[OP] = NIX_TX_ACTIONOP_E::MCAST. NIX_TX_ACTION_S[INDEX]
+ * points to the start of the multicast replication list, and [EOL] = 1
+ * indicates the end of list.
+ */
+union cavm_nixx_af_tx_mcastx {
+	u64 u;
+	struct cavm_nixx_af_tx_mcastx_s {
+		u64 channel                          : 12;
+		u64 eol                              : 1;
+		u64 reserved_13_15                   : 3;
+		u64 next                             : 16;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cavm_nixx_af_tx_mcastx_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TX_MCASTX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TX_MCASTX(u64 a)
+{
+	return 0x1900 + 0x8000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tx_npc_capture_config
+ *
+ * NIX AF Transmit NPC Response Capture Configuration Register Configures
+ * the NPC response capture logic for transmit packets. When enabled,
+ * allows NPC responses for selected packets to be captured in
+ * NIX_AF_TX_NPC_CAPTURE_INFO and NIX_AF_TX_NPC_CAPTURE_RESP().
+ */
+union cavm_nixx_af_tx_npc_capture_config {
+	u64 u;
+	struct cavm_nixx_af_tx_npc_capture_config_s {
+		u64 en                               : 1;
+		u64 continuous                       : 1;
+		u64 lso_segnum_en                    : 1;
+		u64 sqe_id_en                        : 1;
+		u64 sq_id_en                         : 1;
+		u64 lf_id_en                         : 1;
+		u64 reserved_6_11                    : 6;
+		u64 lso_segnum                       : 8;
+		u64 sqe_id                           : 16;
+		u64 sq_id                            : 20;
+		u64 lf_id                            : 8;
+	} s;
+	/* struct cavm_nixx_af_tx_npc_capture_config_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TX_NPC_CAPTURE_CONFIG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TX_NPC_CAPTURE_CONFIG(void)
+{
+	return 0x660;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tx_npc_capture_info
+ *
+ * NIX AF Transmit NPC Response Capture Information Register This
+ * register contains captured NPC response information for a transmit
+ * packet. See NIX_AF_TX_NPC_CAPTURE_CONFIG.
+ */
+union cavm_nixx_af_tx_npc_capture_info {
+	u64 u;
+	struct cavm_nixx_af_tx_npc_capture_info_s {
+		u64 vld                              : 1;
+		u64 reserved_1_11                    : 11;
+		u64 lso_segnum                       : 8;
+		u64 sqe_id                           : 16;
+		u64 sq_id                            : 20;
+		u64 lf_id                            : 8;
+	} s;
+	/* struct cavm_nixx_af_tx_npc_capture_info_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TX_NPC_CAPTURE_INFO(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TX_NPC_CAPTURE_INFO(void)
+{
+	return 0x668;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tx_npc_capture_resp#
+ *
+ * NIX AF Transmit NPC Capture Response Registers These registers contain
+ * the captured NPC response for a transmit packet when
+ * NIX_AF_TX_NPC_CAPTURE_INFO[VLD] is set. See also
+ * NIX_AF_TX_NPC_CAPTURE_CONFIG.
+ */
+union cavm_nixx_af_tx_npc_capture_respx {
+	u64 u;
+	struct cavm_nixx_af_tx_npc_capture_respx_s {
+		u64 data                             : 64;
+	} s;
+	/* struct cavm_nixx_af_tx_npc_capture_respx_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TX_NPC_CAPTURE_RESPX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TX_NPC_CAPTURE_RESPX(u64 a)
+{
+	return 0x680 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tx_tstmp_cfg
+ *
+ * NIX AF Transmit Timestamp Configuration Register
+ */
+union cavm_nixx_af_tx_tstmp_cfg {
+	u64 u;
+	struct cavm_nixx_af_tx_tstmp_cfg_s {
+		u64 tstmp_wd_period                  : 4;
+		u64 reserved_4_7                     : 4;
+		u64 express                          : 16;
+		u64 reserved_24_63                   : 40;
+	} s;
+	/* struct cavm_nixx_af_tx_tstmp_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TX_TSTMP_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TX_TSTMP_CFG(void)
+{
+	return 0xc0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tx_vtag_def#_ctl
+ *
+ * NIX AF Transmit Vtag Definition Control Registers The transmit Vtag
+ * definition table specifies Vtag layers (e.g. VLAN, E-TAG) to
+ * optionally insert or replace in the TX packet header. Indexed by
+ * NIX_TX_VTAG_ACTION_S[VTAG*_DEF].
+ */
+union cavm_nixx_af_tx_vtag_defx_ctl {
+	u64 u;
+	struct cavm_nixx_af_tx_vtag_defx_ctl_s {
+		u64 size                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_nixx_af_tx_vtag_defx_ctl_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TX_VTAG_DEFX_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TX_VTAG_DEFX_CTL(u64 a)
+{
+	return 0x1a00 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_af_tx_vtag_def#_data
+ *
+ * NIX AF Transmit Vtag Definition Data Registers See
+ * NIX_AF_TX_VTAG_DEF()_CTL.
+ */
+union cavm_nixx_af_tx_vtag_defx_data {
+	u64 u;
+	struct cavm_nixx_af_tx_vtag_defx_data_s {
+		u64 data                             : 64;
+	} s;
+	/* struct cavm_nixx_af_tx_vtag_defx_data_s cn; */
+};
+
+static inline u64 CAVM_NIXX_AF_TX_VTAG_DEFX_DATA(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_AF_TX_VTAG_DEFX_DATA(u64 a)
+{
+	return 0x1a10 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_cfg
+ *
+ * NIX LF Configuration Register
+ */
+union cavm_nixx_lf_cfg {
+	u64 u;
+	struct cavm_nixx_lf_cfg_s {
+		u64 tcp_timer_int_ena                : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_nixx_lf_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_CFG(void)
+{
+	return 0x100;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_cint#_cnt
+ *
+ * NIX LF Completion Interrupt Count Registers
+ */
+union cavm_nixx_lf_cintx_cnt {
+	u64 u;
+	struct cavm_nixx_lf_cintx_cnt_s {
+		u64 ecount                           : 32;
+		u64 qcount                           : 16;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_nixx_lf_cintx_cnt_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_CINTX_CNT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_CINTX_CNT(u64 a)
+{
+	return 0xd00 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_cint#_ena_w1c
+ *
+ * NIX LF Completion Interrupt Enable Clear Registers This register
+ * clears interrupt enable bits.
+ */
+union cavm_nixx_lf_cintx_ena_w1c {
+	u64 u;
+	struct cavm_nixx_lf_cintx_ena_w1c_s {
+		u64 intr                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_nixx_lf_cintx_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_CINTX_ENA_W1C(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_CINTX_ENA_W1C(u64 a)
+{
+	return 0xd50 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_cint#_ena_w1s
+ *
+ * NIX LF Completion Interrupt Enable Set Registers This register sets
+ * interrupt enable bits.
+ */
+union cavm_nixx_lf_cintx_ena_w1s {
+	u64 u;
+	struct cavm_nixx_lf_cintx_ena_w1s_s {
+		u64 intr                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_nixx_lf_cintx_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_CINTX_ENA_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_CINTX_ENA_W1S(u64 a)
+{
+	return 0xd40 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_cint#_int
+ *
+ * NIX LF Completion Interrupt Registers
+ */
+union cavm_nixx_lf_cintx_int {
+	u64 u;
+	struct cavm_nixx_lf_cintx_int_s {
+		u64 intr                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_nixx_lf_cintx_int_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_CINTX_INT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_CINTX_INT(u64 a)
+{
+	return 0xd20 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_cint#_int_w1s
+ *
+ * NIX LF Completion Interrupt Set Registers This register sets interrupt
+ * bits.
+ */
+union cavm_nixx_lf_cintx_int_w1s {
+	u64 u;
+	struct cavm_nixx_lf_cintx_int_w1s_s {
+		u64 intr                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_nixx_lf_cintx_int_w1s_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_CINTX_INT_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_CINTX_INT_W1S(u64 a)
+{
+	return 0xd30 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_cint#_wait
+ *
+ * NIX LF Completion Interrupt Count Registers
+ */
+union cavm_nixx_lf_cintx_wait {
+	u64 u;
+	struct cavm_nixx_lf_cintx_wait_s {
+		u64 ecount_wait                      : 32;
+		u64 qcount_wait                      : 16;
+		u64 time_wait                        : 8;
+		u64 reserved_56_63                   : 8;
+	} s;
+	/* struct cavm_nixx_lf_cintx_wait_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_CINTX_WAIT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_CINTX_WAIT(u64 a)
+{
+	return 0xd10 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_cq_op_door
+ *
+ * NIX LF CQ Doorbell Operation Register A write to this register
+ * dequeues CQEs from a CQ ring within the LF. A read is RAZ.  RSL
+ * accesses to this register are RAZ/WI.
+ */
+union cavm_nixx_lf_cq_op_door {
+	u64 u;
+	struct cavm_nixx_lf_cq_op_door_s {
+		u64 count                            : 16;
+		u64 reserved_16_31                   : 16;
+		u64 cq                               : 20;
+		u64 reserved_52_63                   : 12;
+	} s;
+	/* struct cavm_nixx_lf_cq_op_door_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_CQ_OP_DOOR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_CQ_OP_DOOR(void)
+{
+	return 0xb30;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_cq_op_int
+ *
+ * NIX LF Completion Queue Interrupt Operation Register A 64-bit atomic
+ * load-and-add to this register reads CQ interrupts and interrupt
+ * enables. A write optionally sets or clears interrupts and interrupt
+ * enables. A read is RAZ.  RSL accesses to this register are RAZ/WI.
+ */
+union cavm_nixx_lf_cq_op_int {
+	u64 u;
+	struct cavm_nixx_lf_cq_op_int_s {
+		u64 cq_err_int                       : 8;
+		u64 cq_err_int_ena                   : 8;
+		u64 reserved_16_41                   : 26;
+		u64 op_err                           : 1;
+		u64 setop                            : 1;
+		u64 cq                               : 20;
+	} s;
+	/* struct cavm_nixx_lf_cq_op_int_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_CQ_OP_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_CQ_OP_INT(void)
+{
+	return 0xb00;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_cq_op_status
+ *
+ * NIX LF Completion Queue Status Operation Register A 64-bit atomic
+ * load-and-add to this register reads NIX_CQ_CTX_S[HEAD,TAIL]. The
+ * atomic write data has format NIX_OP_Q_WDATA_S and selects the CQ
+ * within LF.  All other accesses to this register (e.g. reads and
+ * writes) are RAZ/WI.  RSL accesses to this register are RAZ/WI.
+ */
+union cavm_nixx_lf_cq_op_status {
+	u64 u;
+	struct cavm_nixx_lf_cq_op_status_s {
+		u64 tail                             : 20;
+		u64 head                             : 20;
+		u64 reserved_40_45                   : 6;
+		u64 cq_err                           : 1;
+		u64 reserved_47_62                   : 16;
+		u64 op_err                           : 1;
+	} s;
+	/* struct cavm_nixx_lf_cq_op_status_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_CQ_OP_STATUS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_CQ_OP_STATUS(void)
+{
+	return 0xb40;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_err_int
+ *
+ * NIX LF Error Interrupt Register
+ */
+union cavm_nixx_lf_err_int {
+	u64 u;
+	struct cavm_nixx_lf_err_int_s {
+		u64 sqb_fault                        : 1;
+		u64 sq_ctx_fault                     : 1;
+		u64 rq_ctx_fault                     : 1;
+		u64 cq_ctx_fault                     : 1;
+		u64 reserved_4                       : 1;
+		u64 rsse_fault                       : 1;
+		u64 ipsec_dyno_fault                 : 1;
+		u64 sq_disabled                      : 1;
+		u64 sq_oor                           : 1;
+		u64 send_jump_fault                  : 1;
+		u64 send_sg_fault                    : 1;
+		u64 rq_disabled                      : 1;
+		u64 rq_oor                           : 1;
+		u64 rx_wqe_fault                     : 1;
+		u64 rss_err                          : 1;
+		u64 reserved_15_19                   : 5;
+		u64 dyno_err                         : 1;
+		u64 reserved_21_23                   : 3;
+		u64 cq_disabled                      : 1;
+		u64 cq_oor                           : 1;
+		u64 reserved_26_27                   : 2;
+		u64 qint_fault                       : 1;
+		u64 cint_fault                       : 1;
+		u64 reserved_30_63                   : 34;
+	} s;
+	/* struct cavm_nixx_lf_err_int_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_ERR_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_ERR_INT(void)
+{
+	return 0x220;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_err_int_ena_w1c
+ *
+ * NIX LF Error Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union cavm_nixx_lf_err_int_ena_w1c {
+	u64 u;
+	struct cavm_nixx_lf_err_int_ena_w1c_s {
+		u64 sqb_fault                        : 1;
+		u64 sq_ctx_fault                     : 1;
+		u64 rq_ctx_fault                     : 1;
+		u64 cq_ctx_fault                     : 1;
+		u64 reserved_4                       : 1;
+		u64 rsse_fault                       : 1;
+		u64 ipsec_dyno_fault                 : 1;
+		u64 sq_disabled                      : 1;
+		u64 sq_oor                           : 1;
+		u64 send_jump_fault                  : 1;
+		u64 send_sg_fault                    : 1;
+		u64 rq_disabled                      : 1;
+		u64 rq_oor                           : 1;
+		u64 rx_wqe_fault                     : 1;
+		u64 rss_err                          : 1;
+		u64 reserved_15_19                   : 5;
+		u64 dyno_err                         : 1;
+		u64 reserved_21_23                   : 3;
+		u64 cq_disabled                      : 1;
+		u64 cq_oor                           : 1;
+		u64 reserved_26_27                   : 2;
+		u64 qint_fault                       : 1;
+		u64 cint_fault                       : 1;
+		u64 reserved_30_63                   : 34;
+	} s;
+	/* struct cavm_nixx_lf_err_int_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_ERR_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_ERR_INT_ENA_W1C(void)
+{
+	return 0x230;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_err_int_ena_w1s
+ *
+ * NIX LF Error Interrupt Enable Set Register This register sets
+ * interrupt enable bits.
+ */
+union cavm_nixx_lf_err_int_ena_w1s {
+	u64 u;
+	struct cavm_nixx_lf_err_int_ena_w1s_s {
+		u64 sqb_fault                        : 1;
+		u64 sq_ctx_fault                     : 1;
+		u64 rq_ctx_fault                     : 1;
+		u64 cq_ctx_fault                     : 1;
+		u64 reserved_4                       : 1;
+		u64 rsse_fault                       : 1;
+		u64 ipsec_dyno_fault                 : 1;
+		u64 sq_disabled                      : 1;
+		u64 sq_oor                           : 1;
+		u64 send_jump_fault                  : 1;
+		u64 send_sg_fault                    : 1;
+		u64 rq_disabled                      : 1;
+		u64 rq_oor                           : 1;
+		u64 rx_wqe_fault                     : 1;
+		u64 rss_err                          : 1;
+		u64 reserved_15_19                   : 5;
+		u64 dyno_err                         : 1;
+		u64 reserved_21_23                   : 3;
+		u64 cq_disabled                      : 1;
+		u64 cq_oor                           : 1;
+		u64 reserved_26_27                   : 2;
+		u64 qint_fault                       : 1;
+		u64 cint_fault                       : 1;
+		u64 reserved_30_63                   : 34;
+	} s;
+	/* struct cavm_nixx_lf_err_int_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_ERR_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_ERR_INT_ENA_W1S(void)
+{
+	return 0x238;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_err_int_w1s
+ *
+ * NIX LF Error Interrupt Set Register This register sets interrupt bits.
+ */
+union cavm_nixx_lf_err_int_w1s {
+	u64 u;
+	struct cavm_nixx_lf_err_int_w1s_s {
+		u64 sqb_fault                        : 1;
+		u64 sq_ctx_fault                     : 1;
+		u64 rq_ctx_fault                     : 1;
+		u64 cq_ctx_fault                     : 1;
+		u64 reserved_4                       : 1;
+		u64 rsse_fault                       : 1;
+		u64 ipsec_dyno_fault                 : 1;
+		u64 sq_disabled                      : 1;
+		u64 sq_oor                           : 1;
+		u64 send_jump_fault                  : 1;
+		u64 send_sg_fault                    : 1;
+		u64 rq_disabled                      : 1;
+		u64 rq_oor                           : 1;
+		u64 rx_wqe_fault                     : 1;
+		u64 rss_err                          : 1;
+		u64 reserved_15_19                   : 5;
+		u64 dyno_err                         : 1;
+		u64 reserved_21_23                   : 3;
+		u64 cq_disabled                      : 1;
+		u64 cq_oor                           : 1;
+		u64 reserved_26_27                   : 2;
+		u64 qint_fault                       : 1;
+		u64 cint_fault                       : 1;
+		u64 reserved_30_63                   : 34;
+	} s;
+	/* struct cavm_nixx_lf_err_int_w1s_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_ERR_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_ERR_INT_W1S(void)
+{
+	return 0x228;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_gint
+ *
+ * NIX LF General Interrupt Register
+ */
+union cavm_nixx_lf_gint {
+	u64 u;
+	struct cavm_nixx_lf_gint_s {
+		u64 drop                             : 1;
+		u64 tcp_timer                        : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cavm_nixx_lf_gint_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_GINT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_GINT(void)
+{
+	return 0x200;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_gint_ena_w1c
+ *
+ * NIX LF General Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union cavm_nixx_lf_gint_ena_w1c {
+	u64 u;
+	struct cavm_nixx_lf_gint_ena_w1c_s {
+		u64 drop                             : 1;
+		u64 tcp_timer                        : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cavm_nixx_lf_gint_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_GINT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_GINT_ENA_W1C(void)
+{
+	return 0x210;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_gint_ena_w1s
+ *
+ * NIX LF General Interrupt Enable Set Register This register sets
+ * interrupt enable bits.
+ */
+union cavm_nixx_lf_gint_ena_w1s {
+	u64 u;
+	struct cavm_nixx_lf_gint_ena_w1s_s {
+		u64 drop                             : 1;
+		u64 tcp_timer                        : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cavm_nixx_lf_gint_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_GINT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_GINT_ENA_W1S(void)
+{
+	return 0x218;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_gint_w1s
+ *
+ * NIX LF General Interrupt Set Register This register sets interrupt
+ * bits.
+ */
+union cavm_nixx_lf_gint_w1s {
+	u64 u;
+	struct cavm_nixx_lf_gint_w1s_s {
+		u64 drop                             : 1;
+		u64 tcp_timer                        : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cavm_nixx_lf_gint_w1s_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_GINT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_GINT_W1S(void)
+{
+	return 0x208;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_mnq_err_dbg
+ *
+ * NIX LF Meta-descriptor Enqueue Error Debug Register This register
+ * captures debug info for an error detected during send meta-descriptor
+ * enqueue from an SQ to an SMQ. Hardware sets [VALID] when the debug
+ * info is captured, and subsequent errors are not captured until
+ * software clears [VALID] by writing a one to it.
+ */
+union cavm_nixx_lf_mnq_err_dbg {
+	u64 u;
+	struct cavm_nixx_lf_mnq_err_dbg_s {
+		u64 errcode                          : 8;
+		u64 sq                               : 20;
+		u64 sqe_id                           : 16;
+		u64 valid                            : 1;
+		u64 reserved_45_63                   : 19;
+	} s;
+	/* struct cavm_nixx_lf_mnq_err_dbg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_MNQ_ERR_DBG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_MNQ_ERR_DBG(void)
+{
+	return 0x270;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_op_ipsec_dyno_cnt
+ *
+ * INTERNAL: NIX LF IPSEC Dynamic Ordering Counter Operation Register
+ * Internal: Not used; no IPSEC fast-path. All accesses are RAZ/WI.
+ */
+union cavm_nixx_lf_op_ipsec_dyno_cnt {
+	u64 u;
+	struct cavm_nixx_lf_op_ipsec_dyno_cnt_s {
+		u64 count                            : 32;
+		u64 reserved_32_46                   : 15;
+		u64 storeop                          : 1;
+		u64 dyno_sel                         : 15;
+		u64 op_err                           : 1;
+	} s;
+	/* struct cavm_nixx_lf_op_ipsec_dyno_cnt_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_OP_IPSEC_DYNO_CNT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_OP_IPSEC_DYNO_CNT(void)
+{
+	return 0x980;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_op_send#
+ *
+ * NIX LF Send Operation Registers An LMTST (or large store from CPT) to
+ * this address enqueues one or more SQEs to a send queue.
+ * NIX_SEND_HDR_S[SQ] in the first SQE selects the send queue.The maximum
+ * size of each SQE is specified by NIX_SQ_CTX_S[MAX_SQE_SIZE].  A read
+ * to this address is RAZ.  An RSL access to this address will fault.
+ * The endianness of the instruction write data is controlled by
+ * NIX_AF_LF()_CFG[BE].  When a NIX_SEND_JUMP_S is not present in the
+ * SQE, the SQE consists of the entire send descriptor.  When a
+ * NIX_SEND_JUMP_S is present in the SQE, the SQE must contain exactly
+ * the portion of the send descriptor up to and including the
+ * NIX_SEND_JUMP_S, and the remainder of the send descriptor must be at
+ * LF IOVA NIX_SEND_JUMP_S[ADDR] in LLC/DRAM.  Software must ensure that
+ * all LLC/DRAM locations that will be referenced by NIX while processing
+ * this descriptor, including all packet data and post-jump
+ * subdescriptors contain the latest updates before issuing the LMTST. A
+ * DMB instruction may be required prior to the LMTST to ensure this. A
+ * DMB following the LMTST may be useful if SQ descriptor ordering
+ * matters and more than one CPU core is simultaneously enqueueing to the
+ * same SQ.
+ */
+union cavm_nixx_lf_op_sendx {
+	u64 u;
+	struct cavm_nixx_lf_op_sendx_s {
+		u64 data                             : 64;
+	} s;
+	/* struct cavm_nixx_lf_op_sendx_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_OP_SENDX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_OP_SENDX(u64 a)
+{
+	return 0x800 + 8 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_qint#_cnt
+ *
+ * NIX LF Queue Interrupt Count Registers
+ */
+union cavm_nixx_lf_qintx_cnt {
+	u64 u;
+	struct cavm_nixx_lf_qintx_cnt_s {
+		u64 count                            : 22;
+		u64 reserved_22_63                   : 42;
+	} s;
+	/* struct cavm_nixx_lf_qintx_cnt_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_QINTX_CNT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_QINTX_CNT(u64 a)
+{
+	return 0xc00 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_qint#_ena_w1c
+ *
+ * NIX LF Queue Interrupt Enable Clear Registers This register clears
+ * interrupt enable bits.
+ */
+union cavm_nixx_lf_qintx_ena_w1c {
+	u64 u;
+	struct cavm_nixx_lf_qintx_ena_w1c_s {
+		u64 intr                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_nixx_lf_qintx_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_QINTX_ENA_W1C(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_QINTX_ENA_W1C(u64 a)
+{
+	return 0xc30 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_qint#_ena_w1s
+ *
+ * NIX LF Queue Interrupt Enable Set Registers This register sets
+ * interrupt enable bits.
+ */
+union cavm_nixx_lf_qintx_ena_w1s {
+	u64 u;
+	struct cavm_nixx_lf_qintx_ena_w1s_s {
+		u64 intr                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_nixx_lf_qintx_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_QINTX_ENA_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_QINTX_ENA_W1S(u64 a)
+{
+	return 0xc20 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_qint#_int
+ *
+ * NIX LF Queue Interrupt Registers
+ */
+union cavm_nixx_lf_qintx_int {
+	u64 u;
+	struct cavm_nixx_lf_qintx_int_s {
+		u64 intr                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_nixx_lf_qintx_int_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_QINTX_INT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_QINTX_INT(u64 a)
+{
+	return 0xc10 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_qint#_int_w1s
+ *
+ * INTERNAL: NIX LF Queue Interrupt Set Registers
+ */
+union cavm_nixx_lf_qintx_int_w1s {
+	u64 u;
+	struct cavm_nixx_lf_qintx_int_w1s_s {
+		u64 intr                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_nixx_lf_qintx_int_w1s_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_QINTX_INT_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_QINTX_INT_W1S(u64 a)
+{
+	return 0xc18 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_ras
+ *
+ * NIX LF RAS Interrupt Register
+ */
+union cavm_nixx_lf_ras {
+	u64 u;
+	struct cavm_nixx_lf_ras_s {
+		u64 sqb_poison                       : 1;
+		u64 sq_ctx_poison                    : 1;
+		u64 rq_ctx_poison                    : 1;
+		u64 cq_ctx_poison                    : 1;
+		u64 reserved_4                       : 1;
+		u64 rsse_poison                      : 1;
+		u64 ipsec_dyno_poison                : 1;
+		u64 send_jump_poison                 : 1;
+		u64 send_sg_poison                   : 1;
+		u64 qint_poison                      : 1;
+		u64 cint_poison                      : 1;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct cavm_nixx_lf_ras_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_RAS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_RAS(void)
+{
+	return 0x240;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_ras_ena_w1c
+ *
+ * NIX LF RAS Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union cavm_nixx_lf_ras_ena_w1c {
+	u64 u;
+	struct cavm_nixx_lf_ras_ena_w1c_s {
+		u64 sqb_poison                       : 1;
+		u64 sq_ctx_poison                    : 1;
+		u64 rq_ctx_poison                    : 1;
+		u64 cq_ctx_poison                    : 1;
+		u64 reserved_4                       : 1;
+		u64 rsse_poison                      : 1;
+		u64 ipsec_dyno_poison                : 1;
+		u64 send_jump_poison                 : 1;
+		u64 send_sg_poison                   : 1;
+		u64 qint_poison                      : 1;
+		u64 cint_poison                      : 1;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct cavm_nixx_lf_ras_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_RAS_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_RAS_ENA_W1C(void)
+{
+	return 0x250;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_ras_ena_w1s
+ *
+ * NIX LF RAS Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
+ */
+union cavm_nixx_lf_ras_ena_w1s {
+	u64 u;
+	struct cavm_nixx_lf_ras_ena_w1s_s {
+		u64 sqb_poison                       : 1;
+		u64 sq_ctx_poison                    : 1;
+		u64 rq_ctx_poison                    : 1;
+		u64 cq_ctx_poison                    : 1;
+		u64 reserved_4                       : 1;
+		u64 rsse_poison                      : 1;
+		u64 ipsec_dyno_poison                : 1;
+		u64 send_jump_poison                 : 1;
+		u64 send_sg_poison                   : 1;
+		u64 qint_poison                      : 1;
+		u64 cint_poison                      : 1;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct cavm_nixx_lf_ras_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_RAS_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_RAS_ENA_W1S(void)
+{
+	return 0x258;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_ras_w1s
+ *
+ * NIX LF RAS Interrupt Set Register This register sets interrupt bits.
+ */
+union cavm_nixx_lf_ras_w1s {
+	u64 u;
+	struct cavm_nixx_lf_ras_w1s_s {
+		u64 sqb_poison                       : 1;
+		u64 sq_ctx_poison                    : 1;
+		u64 rq_ctx_poison                    : 1;
+		u64 cq_ctx_poison                    : 1;
+		u64 reserved_4                       : 1;
+		u64 rsse_poison                      : 1;
+		u64 ipsec_dyno_poison                : 1;
+		u64 send_jump_poison                 : 1;
+		u64 send_sg_poison                   : 1;
+		u64 qint_poison                      : 1;
+		u64 cint_poison                      : 1;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct cavm_nixx_lf_ras_w1s_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_RAS_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_RAS_W1S(void)
+{
+	return 0x248;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_rq_op_drop_octs
+ *
+ * NIX LF Receive Queue Dropped Octets Operation Register A 64-bit atomic
+ * load-and-add to this register reads NIX_RQ_CTX_S[DROP_OCTS]. The
+ * atomic write data has format NIX_OP_Q_WDATA_S and selects the RQ
+ * within LF.  All other accesses to this register (e.g. reads and
+ * writes) are RAZ/WI.  RSL accesses to this register are RAZ/WI.
+ */
+union cavm_nixx_lf_rq_op_drop_octs {
+	u64 u;
+	struct cavm_nixx_lf_rq_op_drop_octs_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_62                   : 15;
+		u64 op_err                           : 1;
+	} s;
+	/* struct cavm_nixx_lf_rq_op_drop_octs_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_RQ_OP_DROP_OCTS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_RQ_OP_DROP_OCTS(void)
+{
+	return 0x930;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_rq_op_drop_pkts
+ *
+ * NIX LF Receive Queue Dropped Packets Operation Register A 64-bit
+ * atomic load-and-add to this register reads NIX_RQ_CTX_S[DROP_PKTS].
+ * The atomic write data has format NIX_OP_Q_WDATA_S and selects the RQ
+ * within LF.  All other accesses to this register (e.g. reads and
+ * writes) are RAZ/WI.  RSL accesses to this register are RAZ/WI.
+ */
+union cavm_nixx_lf_rq_op_drop_pkts {
+	u64 u;
+	struct cavm_nixx_lf_rq_op_drop_pkts_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_62                   : 15;
+		u64 op_err                           : 1;
+	} s;
+	/* struct cavm_nixx_lf_rq_op_drop_pkts_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_RQ_OP_DROP_PKTS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_RQ_OP_DROP_PKTS(void)
+{
+	return 0x940;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_rq_op_int
+ *
+ * NIX LF Receive Queue Interrupt Operation Register A 64-bit atomic
+ * load-and-add to this register reads RQ interrupts and interrupt
+ * enables. A 64-bit write optionally sets or clears interrupts and
+ * interrupt enables.  All other accesses to this register (e.g. reads,
+ * 128-bit accesses) are RAZ/WI.  RSL accesses to this register are
+ * RAZ/WI.
+ */
+union cavm_nixx_lf_rq_op_int {
+	u64 u;
+	struct cavm_nixx_lf_rq_op_int_s {
+		u64 rq_int                           : 8;
+		u64 rq_int_ena                       : 8;
+		u64 reserved_16_41                   : 26;
+		u64 op_err                           : 1;
+		u64 setop                            : 1;
+		u64 rq                               : 20;
+	} s;
+	/* struct cavm_nixx_lf_rq_op_int_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_RQ_OP_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_RQ_OP_INT(void)
+{
+	return 0x900;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_rq_op_octs
+ *
+ * NIX LF Receive Queue Octets Operation Register A 64-bit atomic load-
+ * and-add to this register reads NIX_RQ_CTX_S[OCTS]. The atomic write
+ * data has format NIX_OP_Q_WDATA_S and selects the RQ within LF.  All
+ * other accesses to this register (e.g. reads and writes) are RAZ/WI.
+ * RSL accesses to this register are RAZ/WI.
+ */
+union cavm_nixx_lf_rq_op_octs {
+	u64 u;
+	struct cavm_nixx_lf_rq_op_octs_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_62                   : 15;
+		u64 op_err                           : 1;
+	} s;
+	/* struct cavm_nixx_lf_rq_op_octs_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_RQ_OP_OCTS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_RQ_OP_OCTS(void)
+{
+	return 0x910;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_rq_op_pkts
+ *
+ * NIX LF Receive Queue Packets Operation Register A 64-bit atomic load-
+ * and-add to this register reads NIX_RQ_CTX_S[PKTS]. The atomic write
+ * data has format NIX_OP_Q_WDATA_S and selects the RQ within LF.  All
+ * other accesses to this register (e.g. reads and writes) are RAZ/WI.
+ * RSL accesses to this register are RAZ/WI.
+ */
+union cavm_nixx_lf_rq_op_pkts {
+	u64 u;
+	struct cavm_nixx_lf_rq_op_pkts_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_62                   : 15;
+		u64 op_err                           : 1;
+	} s;
+	/* struct cavm_nixx_lf_rq_op_pkts_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_RQ_OP_PKTS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_RQ_OP_PKTS(void)
+{
+	return 0x920;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_rq_op_re_pkts
+ *
+ * NIX LF Receive Queue Errored Packets Operation Register A 64-bit
+ * atomic load-and-add to this register reads NIX_RQ_CTX_S[RE_PKTS]. The
+ * atomic write data has format NIX_OP_Q_WDATA_S and selects the RQ
+ * within LF.  All other accesses to this register (e.g. reads and
+ * writes) are RAZ/WI.  RSL accesses to this register are RAZ/WI.
+ */
+union cavm_nixx_lf_rq_op_re_pkts {
+	u64 u;
+	struct cavm_nixx_lf_rq_op_re_pkts_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_62                   : 15;
+		u64 op_err                           : 1;
+	} s;
+	/* struct cavm_nixx_lf_rq_op_re_pkts_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_RQ_OP_RE_PKTS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_RQ_OP_RE_PKTS(void)
+{
+	return 0x950;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_rx_secret#
+ *
+ * NIX LF Receive Secret Key Registers
+ */
+union cavm_nixx_lf_rx_secretx {
+	u64 u;
+	struct cavm_nixx_lf_rx_secretx_s {
+		u64 key                              : 64;
+	} s;
+	/* struct cavm_nixx_lf_rx_secretx_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_RX_SECRETX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_RX_SECRETX(u64 a)
+{
+	return 0 + 8 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_rx_stat#
+ *
+ * NIX LF Receive Statistics Registers The last dimension indicates which
+ * statistic, and is enumerated by NIX_STAT_LF_RX_E.
+ */
+union cavm_nixx_lf_rx_statx {
+	u64 u;
+	struct cavm_nixx_lf_rx_statx_s {
+		u64 stat                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_nixx_lf_rx_statx_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_RX_STATX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_RX_STATX(u64 a)
+{
+	return 0x400 + 8 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_send_err_dbg
+ *
+ * NIX LF Send Error Debug Register This register captures debug info an
+ * error detected on packet send after a meta-descriptor is granted by
+ * PSE. Hardware sets [VALID] when the debug info is captured, and
+ * subsequent errors are not captured until software clears [VALID] by
+ * writing a one to it.
+ */
+union cavm_nixx_lf_send_err_dbg {
+	u64 u;
+	struct cavm_nixx_lf_send_err_dbg_s {
+		u64 errcode                          : 8;
+		u64 sq                               : 20;
+		u64 sqe_id                           : 16;
+		u64 valid                            : 1;
+		u64 reserved_45_63                   : 19;
+	} s;
+	/* struct cavm_nixx_lf_send_err_dbg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_SEND_ERR_DBG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_SEND_ERR_DBG(void)
+{
+	return 0x280;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_sq_op_drop_octs
+ *
+ * NIX LF Send Queue Dropped Octets Operation Register A 64-bit atomic
+ * load-and-add to this register reads NIX_SQ_CTX_S[DROP_OCTS]. The
+ * atomic write data has format NIX_OP_Q_WDATA_S and selects the SQ
+ * within LF.  All other accesses to this register (e.g. reads and
+ * writes) are RAZ/WI.  RSL accesses to this register are RAZ/WI.
+ */
+union cavm_nixx_lf_sq_op_drop_octs {
+	u64 u;
+	struct cavm_nixx_lf_sq_op_drop_octs_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_62                   : 15;
+		u64 op_err                           : 1;
+	} s;
+	/* struct cavm_nixx_lf_sq_op_drop_octs_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_SQ_OP_DROP_OCTS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_SQ_OP_DROP_OCTS(void)
+{
+	return 0xa40;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_sq_op_drop_pkts
+ *
+ * NIX LF Send Queue Dropped Packets Operation Register A 64-bit atomic
+ * load-and-add to this register reads NIX_SQ_CTX_S[DROP_PKTS]. The
+ * atomic write data has format NIX_OP_Q_WDATA_S and selects the SQ
+ * within LF.  All other accesses to this register (e.g. reads and
+ * writes) are RAZ/WI.  RSL accesses to this register are RAZ/WI.
+ */
+union cavm_nixx_lf_sq_op_drop_pkts {
+	u64 u;
+	struct cavm_nixx_lf_sq_op_drop_pkts_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_62                   : 15;
+		u64 op_err                           : 1;
+	} s;
+	/* struct cavm_nixx_lf_sq_op_drop_pkts_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_SQ_OP_DROP_PKTS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_SQ_OP_DROP_PKTS(void)
+{
+	return 0xa50;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_sq_op_err_dbg
+ *
+ * NIX LF SQ Operation Error Debug Register This register captures debug
+ * info for an error detected on LMT store to NIX_LF_OP_SEND() or when a
+ * NIX_LF_SQ_OP_* register is accessed. Hardware sets [VALID] when the
+ * debug info is captured, and subsequent errors are not captured until
+ * software clears [VALID] by writing a one to it.
+ */
+union cavm_nixx_lf_sq_op_err_dbg {
+	u64 u;
+	struct cavm_nixx_lf_sq_op_err_dbg_s {
+		u64 errcode                          : 8;
+		u64 sq                               : 20;
+		u64 sqe_id                           : 16;
+		u64 valid                            : 1;
+		u64 reserved_45_63                   : 19;
+	} s;
+	/* struct cavm_nixx_lf_sq_op_err_dbg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_SQ_OP_ERR_DBG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_SQ_OP_ERR_DBG(void)
+{
+	return 0x260;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_sq_op_int
+ *
+ * NIX LF Send Queue Interrupt Operation Register A 64-bit atomic load-
+ * and-add to this register reads SQ interrupts, interrupt enables and
+ * XOFF status. A write optionally sets or clears interrupts, interrupt
+ * enables and XOFF status. A read is RAZ.  RSL accesses to this register
+ * are RAZ/WI.
+ */
+union cavm_nixx_lf_sq_op_int {
+	u64 u;
+	struct cavm_nixx_lf_sq_op_int_s {
+		u64 sq_int                           : 8;
+		u64 sq_int_ena                       : 8;
+		u64 xoff                             : 1;
+		u64 reserved_17_41                   : 25;
+		u64 op_err                           : 1;
+		u64 setop                            : 1;
+		u64 sq                               : 20;
+	} s;
+	/* struct cavm_nixx_lf_sq_op_int_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_SQ_OP_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_SQ_OP_INT(void)
+{
+	return 0xa00;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_sq_op_octs
+ *
+ * NIX LF Send Queue Octets Operation Register A 64-bit atomic load-and-
+ * add to this register reads NIX_SQ_CTX_S[OCTS]. The atomic write data
+ * has format NIX_OP_Q_WDATA_S and selects the SQ within LF.  All other
+ * accesses to this register (e.g. reads and writes) are RAZ/WI.  RSL
+ * accesses to this register are RAZ/WI.
+ */
+union cavm_nixx_lf_sq_op_octs {
+	u64 u;
+	struct cavm_nixx_lf_sq_op_octs_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_62                   : 15;
+		u64 op_err                           : 1;
+	} s;
+	/* struct cavm_nixx_lf_sq_op_octs_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_SQ_OP_OCTS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_SQ_OP_OCTS(void)
+{
+	return 0xa10;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_sq_op_pkts
+ *
+ * NIX LF Send Queue Packets Operation Register A 64-bit atomic load-and-
+ * add to this register reads NIX_SQ_CTX_S[PKTS]. The atomic write data
+ * has format NIX_OP_Q_WDATA_S and selects the SQ within LF.  All other
+ * accesses to this register (e.g. reads and writes) are RAZ/WI.  RSL
+ * accesses to this register are RAZ/WI.
+ */
+union cavm_nixx_lf_sq_op_pkts {
+	u64 u;
+	struct cavm_nixx_lf_sq_op_pkts_s {
+		u64 cnt                              : 48;
+		u64 reserved_48_62                   : 15;
+		u64 op_err                           : 1;
+	} s;
+	/* struct cavm_nixx_lf_sq_op_pkts_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_SQ_OP_PKTS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_SQ_OP_PKTS(void)
+{
+	return 0xa20;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_sq_op_status
+ *
+ * NIX LF Send Queue Status Operation Register A 64-bit atomic load-and-
+ * add to this register reads status fields in NIX_SQ_CTX_S. The atomic
+ * write data has format NIX_OP_Q_WDATA_S and selects the SQ within LF.
+ * Completion of the load-and-add operation also ensures that all
+ * previously issued LMT stores to NIX_LF_OP_SEND() have completed.  All
+ * other accesses to this register (e.g. reads and writes) are RAZ/WI.
+ * RSL accesses to this register are RAZ/WI.
+ */
+union cavm_nixx_lf_sq_op_status {
+	u64 u;
+	struct cavm_nixx_lf_sq_op_status_s {
+		u64 sqb_count                        : 16;
+		u64 reserved_16_19                   : 4;
+		u64 head_offset                      : 6;
+		u64 reserved_26_27                   : 2;
+		u64 tail_offset                      : 6;
+		u64 reserved_34_62                   : 29;
+		u64 op_err                           : 1;
+	} s;
+	struct cavm_nixx_lf_sq_op_status_cn {
+		u64 sqb_count                        : 16;
+		u64 reserved_16_19                   : 4;
+		u64 head_offset                      : 6;
+		u64 reserved_26_27                   : 2;
+		u64 tail_offset                      : 6;
+		u64 reserved_34_35                   : 2;
+		u64 reserved_36_62                   : 27;
+		u64 op_err                           : 1;
+	} cn;
+};
+
+static inline u64 CAVM_NIXX_LF_SQ_OP_STATUS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_SQ_OP_STATUS(void)
+{
+	return 0xa30;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) nix#_lf_tx_stat#
+ *
+ * NIX LF Transmit Statistics Registers The last dimension indicates
+ * which statistic, and is enumerated by NIX_STAT_LF_TX_E.
+ */
+union cavm_nixx_lf_tx_statx {
+	u64 u;
+	struct cavm_nixx_lf_tx_statx_s {
+		u64 stat                             : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_nixx_lf_tx_statx_s cn; */
+};
+
+static inline u64 CAVM_NIXX_LF_TX_STATX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_LF_TX_STATX(u64 a)
+{
+	return 0x300 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_priv_af_int_cfg
+ *
+ * NIX Privileged Admin Function Interrupt Configuration Register
+ */
+union cavm_nixx_priv_af_int_cfg {
+	u64 u;
+	struct cavm_nixx_priv_af_int_cfg_s {
+		u64 msix_offset                      : 11;
+		u64 reserved_11                      : 1;
+		u64 msix_size                        : 8;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct cavm_nixx_priv_af_int_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_PRIV_AF_INT_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_PRIV_AF_INT_CFG(void)
+{
+	return 0x8000000;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_priv_lf#_cfg
+ *
+ * NIX Privileged Local Function Configuration Registers These registers
+ * allow each NIX local function (LF) to be provisioned to a VF/PF for
+ * RVU. See also NIX_AF_RVU_LF_CFG_DEBUG.  Software should read this
+ * register after write to ensure that the LF is mapped to [PF_FUNC]
+ * before issuing transactions to the mapped PF and function.  [SLOT]
+ * must be zero.  Internal: Hardware ignores [SLOT] and always assumes
+ * 0x0.
+ */
+union cavm_nixx_priv_lfx_cfg {
+	u64 u;
+	struct cavm_nixx_priv_lfx_cfg_s {
+		u64 slot                             : 8;
+		u64 pf_func                          : 16;
+		u64 reserved_24_62                   : 39;
+		u64 ena                              : 1;
+	} s;
+	/* struct cavm_nixx_priv_lfx_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_PRIV_LFX_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_PRIV_LFX_CFG(u64 a)
+{
+	return 0x8000010 + 0x100 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) nix#_priv_lf#_int_cfg
+ *
+ * NIX Privileged LF Interrupt Configuration Registers
+ */
+union cavm_nixx_priv_lfx_int_cfg {
+	u64 u;
+	struct cavm_nixx_priv_lfx_int_cfg_s {
+		u64 msix_offset                      : 11;
+		u64 reserved_11                      : 1;
+		u64 msix_size                        : 8;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct cavm_nixx_priv_lfx_int_cfg_s cn; */
+};
+
+static inline u64 CAVM_NIXX_PRIV_LFX_INT_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NIXX_PRIV_LFX_INT_CFG(u64 a)
+{
+	return 0x8000020 + 0x100 * a;
+}
+
+#endif /* __CAVM_CSRS_NIX_H__ */
diff --git a/drivers/net/octeontx2/cavm-csrs-npa.h b/drivers/net/octeontx2/cavm-csrs-npa.h
new file mode 100644
index 0000000..312954a
--- /dev/null
+++ b/drivers/net/octeontx2/cavm-csrs-npa.h
@@ -0,0 +1,2294 @@
+#ifndef __CAVM_CSRS_NPA_H__
+#define __CAVM_CSRS_NPA_H__
+/* This file is auto-generated.  Do not edit */
+
+/***********************license start***********************************
+* Copyright (C) 2019 Marvell International Ltd.
+* SPDX-License-Identifier: BSD-3-Clause
+* https://spdx.org/licenses
+***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * Configuration and status register (CSR) address and type definitions for
+ * Cavium NPA.
+ *
+ * This file is auto generated.  Do not edit.
+ *
+ */
+
+/**
+ * Enumeration npa_af_int_vec_e
+ *
+ * NPA Admin Function Interrupt Vector Enumeration Enumerates the NPA AF
+ * MSI-X interrupt vectors.
+ */
+#define CAVM_NPA_AF_INT_VEC_E_AF_ERR (3)
+#define CAVM_NPA_AF_INT_VEC_E_AQ_DONE (2)
+#define CAVM_NPA_AF_INT_VEC_E_GEN (1)
+#define CAVM_NPA_AF_INT_VEC_E_POISON (4)
+#define CAVM_NPA_AF_INT_VEC_E_RVU (0)
+
+/**
+ * Enumeration npa_aq_comp_e
+ *
+ * NPA Admin Queue Completion Enumeration Enumerates the values of
+ * NPA_AQ_RES_S[COMPCODE].
+ */
+#define CAVM_NPA_AQ_COMP_E_CTX_FAULT (4)
+#define CAVM_NPA_AQ_COMP_E_CTX_POISON (3)
+#define CAVM_NPA_AQ_COMP_E_GOOD (1)
+#define CAVM_NPA_AQ_COMP_E_LOCKERR (5)
+#define CAVM_NPA_AQ_COMP_E_NOTDONE (0)
+#define CAVM_NPA_AQ_COMP_E_SWERR (2)
+
+/**
+ * Enumeration npa_aq_ctype_e
+ *
+ * NPA Admin Queue Context Type Enumeration Enumerates
+ * NPA_AQ_INST_S[CTYPE] values.
+ */
+#define CAVM_NPA_AQ_CTYPE_E_AURA (0)
+#define CAVM_NPA_AQ_CTYPE_E_POOL (1)
+
+/**
+ * Enumeration npa_aq_instop_e
+ *
+ * NPA Admin Queue Opcode Enumeration Enumerates NPA_AQ_INST_S[OP]
+ * values.
+ */
+#define CAVM_NPA_AQ_INSTOP_E_INIT (1)
+#define CAVM_NPA_AQ_INSTOP_E_LOCK (4)
+#define CAVM_NPA_AQ_INSTOP_E_NOP (0)
+#define CAVM_NPA_AQ_INSTOP_E_READ (3)
+#define CAVM_NPA_AQ_INSTOP_E_UNLOCK (5)
+#define CAVM_NPA_AQ_INSTOP_E_WRITE (2)
+
+/**
+ * Enumeration npa_aura_err_int_e
+ *
+ * NPA Aura Error Interrupt Enumeration Enumerates the bit index of
+ * NPA_AURA_S[ERR_INT], and NPA_AURA_S[ERR_INT_ENA].
+ */
+#define CAVM_NPA_AURA_ERR_INT_E_AURA_ADD_OVER (1)
+#define CAVM_NPA_AURA_ERR_INT_E_AURA_ADD_UNDER (2)
+#define CAVM_NPA_AURA_ERR_INT_E_AURA_FREE_UNDER (0)
+#define CAVM_NPA_AURA_ERR_INT_E_POOL_DIS (3)
+#define CAVM_NPA_AURA_ERR_INT_E_RX(a) (0 + (a))
+
+/**
+ * Enumeration npa_bpintf_e
+ *
+ * NPA Backpressure Interface Enumeration Enumerates index of
+ * NPA_AURA_S[BP_ENA].
+ */
+#define CAVM_NPA_BPINTF_E_NIXX_RX(a) (0 + (a))
+
+/**
+ * Enumeration npa_inpq_e
+ *
+ * NPA Input Queue Enumeration Enumerates ALLOC/FREE input queues from
+ * coprocessors.
+ */
+#define CAVM_NPA_INPQ_E_AURA_OP (0xe)
+#define CAVM_NPA_INPQ_E_BPHY (7)
+#define CAVM_NPA_INPQ_E_DPI (6)
+#define CAVM_NPA_INPQ_E_INTERNAL_RSV (0xf)
+#define CAVM_NPA_INPQ_E_NIXX_RX(a) (0 + 2 * (a))
+#define CAVM_NPA_INPQ_E_NIXX_TX(a) (1 + 2 * (a))
+#define CAVM_NPA_INPQ_E_RX(a) (0 + (a))
+#define CAVM_NPA_INPQ_E_SSO (4)
+#define CAVM_NPA_INPQ_E_TIM (5)
+
+/**
+ * Enumeration npa_lf_int_vec_e
+ *
+ * NPA Local Function Interrupt Vector Enumeration Enumerates the NPA
+ * MSI-X interrupt vectors per LF.
+ */
+#define CAVM_NPA_LF_INT_VEC_E_ERR_INT (0x40)
+#define CAVM_NPA_LF_INT_VEC_E_POISON (0x41)
+#define CAVM_NPA_LF_INT_VEC_E_QINTX(a) (0 + (a))
+
+/**
+ * Enumeration npa_ndc0_port_e
+ *
+ * NPA NDC0 Port Enumeration Enumerates NPA NDC0 (NDC_IDX_E::NPA_U(0))
+ * ports and the PORT index of NDC_AF_PORT()_RT()_RW()_REQ_PC and
+ * NDC_AF_PORT()_RT()_RW()_LAT_PC.
+ */
+#define CAVM_NPA_NDC0_PORT_E_AURA0 (0)
+#define CAVM_NPA_NDC0_PORT_E_AURA1 (1)
+#define CAVM_NPA_NDC0_PORT_E_POOL0 (2)
+#define CAVM_NPA_NDC0_PORT_E_POOL1 (3)
+#define CAVM_NPA_NDC0_PORT_E_STACK0 (4)
+#define CAVM_NPA_NDC0_PORT_E_STACK1 (5)
+
+/**
+ * Enumeration npa_pool_err_int_e
+ *
+ * NPA Pool Error Interrupt Enumeration Enumerates the bit index of
+ * NPA_POOL_S[ERR_INT] and NPA_POOL_S[ERR_INT_ENA].
+ */
+#define CAVM_NPA_POOL_ERR_INT_E_OVFLS (0)
+#define CAVM_NPA_POOL_ERR_INT_E_PERR (2)
+#define CAVM_NPA_POOL_ERR_INT_E_RX(a) (0 + (a))
+#define CAVM_NPA_POOL_ERR_INT_E_RANGE (1)
+
+/**
+ * Structure npa_aq_inst_s
+ *
+ * NPA Admin Queue Instruction Structure This structure specifies the AQ
+ * instruction. Instructions and associated software structures are
+ * stored in memory as little-endian unless NPA_AF_GEN_CFG[AF_BE] is set.
+ * Hardware reads of NPA_AQ_INST_S do not allocate into LLC.  Hardware
+ * reads and writes of the context structure selected by [CTYPE], [LF]
+ * and [CINDEX] use the NDC and LLC caching style configured for that
+ * context, i.e.: * NPA_AURA_HW_S reads and writes use
+ * NPA_AF_LF()_AURAS_CFG[CACHING] and NPA_AF_LF()_AURAS_CFG[WAY_MASK]. *
+ * NPA_POOL_HW_S reads and writes use NPA_AURA_HW_S[POOL_CACHING] and
+ * NPA_AURA_HW_S[POOL_WAY_MASK].
+ */
+union cavm_npa_aq_inst_s {
+	u64 u[2];
+	struct cavm_npa_aq_inst_s_s {
+		u64 op                               : 4;
+		u64 ctype                            : 4;
+		u64 lf                               : 9;
+		u64 reserved_17_23                   : 7;
+		u64 cindex                           : 20;
+		u64 reserved_44_62                   : 19;
+		u64 doneint                          : 1;
+		u64 res_addr                         : 64;
+	} s;
+	/* struct cavm_npa_aq_inst_s_s cn; */
+};
+
+/**
+ * Structure npa_aq_res_s
+ *
+ * NPA Admin Queue Result Structure NPA writes this structure after it
+ * completes the NPA_AQ_INST_S instruction. The result structure is
+ * exactly 16 bytes, and each instruction completion produces exactly one
+ * result structure.  Results and associated software structures are
+ * stored in memory as little-endian unless NPA_AF_GEN_CFG[AF_BE] is set.
+ * When [OP] = NPA_AQ_INSTOP_E::INIT, WRITE or READ, this structure is
+ * immediately followed by context read or write data. See
+ * NPA_AQ_INSTOP_E.  Hardware writes of NPA_AQ_RES_S and context data
+ * always allocate into LLC. Hardware reads of context data do not
+ * allocate into LLC.
+ */
+union cavm_npa_aq_res_s {
+	u64 u[2];
+	struct cavm_npa_aq_res_s_s {
+		u64 op                               : 4;
+		u64 ctype                            : 4;
+		u64 compcode                         : 8;
+		u64 doneint                          : 1;
+		u64 reserved_17_63                   : 47;
+		u64 reserved_64_127                  : 64;
+	} s;
+	/* struct cavm_npa_aq_res_s_s cn; */
+};
+
+/**
+ * Structure npa_aura_op_wdata_s
+ *
+ * NPA Aura Operation Write Data Structure This structure specifies the
+ * write data format of a 64-bit atomic load-and-add to
+ * NPA_LF_AURA_OP_ALLOC() and NPA_LF_POOL_OP_PC, and a 128-bit atomic
+ * CASP operation to NPA_LF_AURA_OP_ALLOC().
+ */
+union cavm_npa_aura_op_wdata_s {
+	u64 u;
+	struct cavm_npa_aura_op_wdata_s_s {
+		u64 aura                             : 20;
+		u64 reserved_20_62                   : 43;
+		u64 drop                             : 1;
+	} s;
+	/* struct cavm_npa_aura_op_wdata_s_s cn; */
+};
+
+/**
+ * Structure npa_aura_s
+ *
+ * NPA Aura Context Structure This structure specifies the format used by
+ * software with the NPA admin queue to read and write an aura's
+ * NPA_AURA_HW_S structure maintained by hardware in LLC/DRAM.
+ */
+union cavm_npa_aura_s {
+	u64 u[8];
+	struct cavm_npa_aura_s_s {
+		u64 pool_addr                        : 64;
+		u64 ena                              : 1;
+		u64 reserved_65_66                   : 2;
+		u64 pool_caching                     : 1;
+		u64 pool_way_mask                    : 16;
+		u64 avg_con                          : 9;
+		u64 reserved_93                      : 1;
+		u64 pool_drop_ena                    : 1;
+		u64 aura_drop_ena                    : 1;
+		u64 bp_ena                           : 2;
+		u64 reserved_98_103                  : 6;
+		u64 aura_drop                        : 8;
+		u64 shift                            : 6;
+		u64 reserved_118_119                 : 2;
+		u64 avg_level                        : 8;
+		u64 count                            : 36;
+		u64 reserved_164_167                 : 4;
+		u64 nix0_bpid                        : 9;
+		u64 reserved_177_179                 : 3;
+		u64 nix1_bpid                        : 9;
+		u64 reserved_189_191                 : 3;
+		u64 limit                            : 36;
+		u64 reserved_228_231                 : 4;
+		u64 bp                               : 8;
+		u64 reserved_240_243                 : 4;
+		u64 fc_ena                           : 1;
+		u64 fc_up_crossing                   : 1;
+		u64 fc_stype                         : 2;
+		u64 fc_hyst_bits                     : 4;
+		u64 reserved_252_255                 : 4;
+		u64 fc_addr                          : 64;
+		u64 pool_drop                        : 8;
+		u64 update_time                      : 16;
+		u64 err_int                          : 8;
+		u64 err_int_ena                      : 8;
+		u64 thresh_int                       : 1;
+		u64 thresh_int_ena                   : 1;
+		u64 thresh_up                        : 1;
+		u64 reserved_363                     : 1;
+		u64 thresh_qint_idx                  : 7;
+		u64 reserved_371                     : 1;
+		u64 err_qint_idx                     : 7;
+		u64 reserved_379_383                 : 5;
+		u64 thresh                           : 36;
+		u64 reserved_420_447                 : 28;
+		u64 reserved_448_511                 : 64;
+	} s;
+	/* struct cavm_npa_aura_s_s cn; */
+};
+
+/**
+ * Structure npa_pool_s
+ *
+ * NPA Pool Context Structure This structure specifies the format used by
+ * software with the NPA admin queue to read and write a pool's
+ * NPA_POOL_HW_S structure maintained by hardware in LLC/DRAM.
+ */
+union cavm_npa_pool_s {
+	u64 u[16];
+	struct cavm_npa_pool_s_s {
+		u64 stack_base                       : 64;
+		u64 ena                              : 1;
+		u64 nat_align                        : 1;
+		u64 reserved_66_67                   : 2;
+		u64 stack_caching                    : 1;
+		u64 reserved_69_71                   : 3;
+		u64 stack_way_mask                   : 16;
+		u64 buf_offset                       : 12;
+		u64 reserved_100_103                 : 4;
+		u64 buf_size                         : 11;
+		u64 reserved_115_127                 : 13;
+		u64 stack_max_pages                  : 32;
+		u64 stack_pages                      : 32;
+		u64 op_pc                            : 48;
+		u64 reserved_240_255                 : 16;
+		u64 stack_offset                     : 4;
+		u64 reserved_260_263                 : 4;
+		u64 shift                            : 6;
+		u64 reserved_270_271                 : 2;
+		u64 avg_level                        : 8;
+		u64 avg_con                          : 9;
+		u64 fc_ena                           : 1;
+		u64 fc_stype                         : 2;
+		u64 fc_hyst_bits                     : 4;
+		u64 fc_up_crossing                   : 1;
+		u64 reserved_297_299                 : 3;
+		u64 update_time                      : 16;
+		u64 reserved_316_319                 : 4;
+		u64 fc_addr                          : 64;
+		u64 ptr_start                        : 64;
+		u64 ptr_end                          : 64;
+		u64 reserved_512_535                 : 24;
+		u64 err_int                          : 8;
+		u64 err_int_ena                      : 8;
+		u64 thresh_int                       : 1;
+		u64 thresh_int_ena                   : 1;
+		u64 thresh_up                        : 1;
+		u64 reserved_555                     : 1;
+		u64 thresh_qint_idx                  : 7;
+		u64 reserved_563                     : 1;
+		u64 err_qint_idx                     : 7;
+		u64 reserved_571_575                 : 5;
+		u64 thresh                           : 36;
+		u64 reserved_612_639                 : 28;
+		u64 reserved_640_703                 : 64;
+		u64 reserved_704_767                 : 64;
+		u64 reserved_768_831                 : 64;
+		u64 reserved_832_895                 : 64;
+		u64 reserved_896_959                 : 64;
+		u64 reserved_960_1023                : 64;
+	} s;
+	/* struct cavm_npa_pool_s_s cn; */
+};
+
+/**
+ * Structure npa_qint_hw_s
+ *
+ * NPA Queue Interrupt Context Hardware Structure This structure contains
+ * context state maintained by hardware for each queue interrupt (QINT)
+ * in NDC/LLC/DRAM. Software accesses this structure with the
+ * NPA_LF_QINT()_* registers. Hardware maintains a table of
+ * NPA_AF_CONST[QINTS] contiguous NPA_QINT_HW_S structures per LF
+ * starting at IOVA NPA_AF_LF()_QINTS_BASE. Always stored in byte
+ * invariant little-endian format (LE8).
+ */
+union cavm_npa_qint_hw_s {
+	u32 u;
+	struct cavm_npa_qint_hw_s_s {
+		u32 count                            : 22;
+		u32 reserved_22_30                   : 9;
+		u32 ena                              : 1;
+	} s;
+	/* struct cavm_npa_qint_hw_s_s cn; */
+};
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_active_cycles_pc
+ *
+ * NPA AF Active Cycles Register
+ */
+union cavm_npa_af_active_cycles_pc {
+	u64 u;
+	struct cavm_npa_af_active_cycles_pc_s {
+		u64 act_cyc                          : 64;
+	} s;
+	/* struct cavm_npa_af_active_cycles_pc_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_ACTIVE_CYCLES_PC(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_ACTIVE_CYCLES_PC(void)
+{
+	return 0xf0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_aq_base
+ *
+ * NPA AF Admin Queue Base Address Register
+ */
+union cavm_npa_af_aq_base {
+	u64 u;
+	struct cavm_npa_af_aq_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 base_addr                        : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct cavm_npa_af_aq_base_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_AQ_BASE(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_AQ_BASE(void)
+{
+	return 0x610;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_aq_cfg
+ *
+ * NPA AF Admin Queue Configuration Register
+ */
+union cavm_npa_af_aq_cfg {
+	u64 u;
+	struct cavm_npa_af_aq_cfg_s {
+		u64 qsize                            : 4;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cavm_npa_af_aq_cfg_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_AQ_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_AQ_CFG(void)
+{
+	return 0x600;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_aq_done
+ *
+ * NPA AF AQ Done Count Register
+ */
+union cavm_npa_af_aq_done {
+	u64 u;
+	struct cavm_npa_af_aq_done_s {
+		u64 done                             : 20;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct cavm_npa_af_aq_done_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_AQ_DONE(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_AQ_DONE(void)
+{
+	return 0x650;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_aq_done_ack
+ *
+ * NPA AF AQ Done Count Ack Register This register is written by software
+ * to acknowledge interrupts.
+ */
+union cavm_npa_af_aq_done_ack {
+	u64 u;
+	struct cavm_npa_af_aq_done_ack_s {
+		u64 done_ack                         : 20;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct cavm_npa_af_aq_done_ack_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_AQ_DONE_ACK(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_AQ_DONE_ACK(void)
+{
+	return 0x660;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_aq_done_ena_w1c
+ *
+ * NPA AF AQ Done Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union cavm_npa_af_aq_done_ena_w1c {
+	u64 u;
+	struct cavm_npa_af_aq_done_ena_w1c_s {
+		u64 done                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_npa_af_aq_done_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_AQ_DONE_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_AQ_DONE_ENA_W1C(void)
+{
+	return 0x698;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_aq_done_ena_w1s
+ *
+ * NPA AF AQ Done Interrupt Enable Set Register This register sets
+ * interrupt enable bits.
+ */
+union cavm_npa_af_aq_done_ena_w1s {
+	u64 u;
+	struct cavm_npa_af_aq_done_ena_w1s_s {
+		u64 done                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_npa_af_aq_done_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_AQ_DONE_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_AQ_DONE_ENA_W1S(void)
+{
+	return 0x690;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_aq_done_int
+ *
+ * NPA AF AQ Done Interrupt Register
+ */
+union cavm_npa_af_aq_done_int {
+	u64 u;
+	struct cavm_npa_af_aq_done_int_s {
+		u64 done                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_npa_af_aq_done_int_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_AQ_DONE_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_AQ_DONE_INT(void)
+{
+	return 0x680;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_aq_done_int_w1s
+ *
+ * INTERNAL: NPA AF AQ Done Interrupt Set Register
+ */
+union cavm_npa_af_aq_done_int_w1s {
+	u64 u;
+	struct cavm_npa_af_aq_done_int_w1s_s {
+		u64 done                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_npa_af_aq_done_int_w1s_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_AQ_DONE_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_AQ_DONE_INT_W1S(void)
+{
+	return 0x688;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_aq_done_timer
+ *
+ * NPA AF Admin Queue Done Interrupt Timer Register Used to debug the
+ * queue interrupt coalescing timer.
+ */
+union cavm_npa_af_aq_done_timer {
+	u64 u;
+	struct cavm_npa_af_aq_done_timer_s {
+		u64 count                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_npa_af_aq_done_timer_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_AQ_DONE_TIMER(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_AQ_DONE_TIMER(void)
+{
+	return 0x670;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_aq_done_wait
+ *
+ * NPA AF AQ Done Interrupt Coalescing Wait Register Specifies the queue
+ * interrupt coalescing settings.
+ */
+union cavm_npa_af_aq_done_wait {
+	u64 u;
+	struct cavm_npa_af_aq_done_wait_s {
+		u64 num_wait                         : 20;
+		u64 reserved_20_31                   : 12;
+		u64 time_wait                        : 16;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_npa_af_aq_done_wait_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_AQ_DONE_WAIT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_AQ_DONE_WAIT(void)
+{
+	return 0x640;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_aq_door
+ *
+ * NPA AF Admin Queue Doorbell Register Software writes to this register
+ * to enqueue one or more entries to AQ.
+ */
+union cavm_npa_af_aq_door {
+	u64 u;
+	struct cavm_npa_af_aq_door_s {
+		u64 count                            : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_npa_af_aq_door_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_AQ_DOOR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_AQ_DOOR(void)
+{
+	return 0x630;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_aq_status
+ *
+ * NPA AF Admin Queue Status Register
+ */
+union cavm_npa_af_aq_status {
+	u64 u;
+	struct cavm_npa_af_aq_status_s {
+		u64 reserved_0_3                     : 4;
+		u64 head_ptr                         : 20;
+		u64 reserved_24_35                   : 12;
+		u64 tail_ptr                         : 20;
+		u64 reserved_56_61                   : 6;
+		u64 aq_busy                          : 1;
+		u64 aq_err                           : 1;
+	} s;
+	struct cavm_npa_af_aq_status_cn {
+		u64 reserved_0_3                     : 4;
+		u64 head_ptr                         : 20;
+		u64 reserved_24_31                   : 8;
+		u64 reserved_32_35                   : 4;
+		u64 tail_ptr                         : 20;
+		u64 reserved_56_61                   : 6;
+		u64 aq_busy                          : 1;
+		u64 aq_err                           : 1;
+	} cn;
+};
+
+static inline u64 CAVM_NPA_AF_AQ_STATUS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_AQ_STATUS(void)
+{
+	return 0x620;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_avg_delay
+ *
+ * NPA AF Queue Average Delay Register
+ */
+union cavm_npa_af_avg_delay {
+	u64 u;
+	struct cavm_npa_af_avg_delay_s {
+		u64 avg_dly                          : 19;
+		u64 reserved_19_23                   : 5;
+		u64 avg_timer                        : 16;
+		u64 reserved_40_62                   : 23;
+		u64 avg_timer_dis                    : 1;
+	} s;
+	/* struct cavm_npa_af_avg_delay_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_AVG_DELAY(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_AVG_DELAY(void)
+{
+	return 0x100;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_bar2_alias#
+ *
+ * INTERNAL: NPA Admin Function  BAR2 Alias Registers  These registers
+ * alias to the NPA BAR2 registers for the PF and function selected by
+ * NPA_AF_BAR2_SEL[PF_FUNC].  Internal: Not implemented. Placeholder for
+ * bug33464.
+ */
+union cavm_npa_af_bar2_aliasx {
+	u64 u;
+	struct cavm_npa_af_bar2_aliasx_s {
+		u64 data                             : 64;
+	} s;
+	/* struct cavm_npa_af_bar2_aliasx_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_BAR2_ALIASX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_BAR2_ALIASX(u64 a)
+{
+	return 0x9100000 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_bar2_sel
+ *
+ * INTERNAL: NPA Admin Function BAR2 Select Register  This register
+ * configures BAR2 accesses from the NPA_AF_BAR2_ALIAS() registers in
+ * BAR0. Internal: Not implemented. Placeholder for bug33464.
+ */
+union cavm_npa_af_bar2_sel {
+	u64 u;
+	struct cavm_npa_af_bar2_sel_s {
+		u64 alias_pf_func                    : 16;
+		u64 alias_ena                        : 1;
+		u64 reserved_17_63                   : 47;
+	} s;
+	/* struct cavm_npa_af_bar2_sel_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_BAR2_SEL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_BAR2_SEL(void)
+{
+	return 0x9000000;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_blk_rst
+ *
+ * NPA AF Block Reset Register
+ */
+union cavm_npa_af_blk_rst {
+	u64 u;
+	struct cavm_npa_af_blk_rst_s {
+		u64 rst                              : 1;
+		u64 reserved_1_62                    : 62;
+		u64 busy                             : 1;
+	} s;
+	/* struct cavm_npa_af_blk_rst_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_BLK_RST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_BLK_RST(void)
+{
+	return 0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_bp_test
+ *
+ * INTERNAL: NPA AF Backpressure Test Register
+ */
+union cavm_npa_af_bp_test {
+	u64 u;
+	struct cavm_npa_af_bp_test_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 32;
+		u64 enable                           : 16;
+	} s;
+	/* struct cavm_npa_af_bp_test_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_BP_TEST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_BP_TEST(void)
+{
+	return 0x200;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_const
+ *
+ * NPA AF Constants Register This register contains constants for
+ * software discovery.
+ */
+union cavm_npa_af_const {
+	u64 u;
+	struct cavm_npa_af_const_s {
+		u64 stack_page_bytes                 : 8;
+		u64 stack_page_ptrs                  : 8;
+		u64 lfs                              : 12;
+		u64 qints                            : 12;
+		u64 num_ndc                          : 3;
+		u64 reserved_43_63                   : 21;
+	} s;
+	/* struct cavm_npa_af_const_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_CONST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_CONST(void)
+{
+	return 0x10;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_const1
+ *
+ * NPA AF Constants Register 1 This register contains constants for
+ * software discovery.
+ */
+union cavm_npa_af_const1 {
+	u64 u;
+	struct cavm_npa_af_const1_s {
+		u64 aura_log2bytes                   : 4;
+		u64 pool_log2bytes                   : 4;
+		u64 qint_log2bytes                   : 4;
+		u64 reserved_12_63                   : 52;
+	} s;
+	/* struct cavm_npa_af_const1_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_CONST1(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_CONST1(void)
+{
+	return 0x18;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_dtx_filter_ctl
+ *
+ * NPA AF DTX LF Filter Control Register
+ */
+union cavm_npa_af_dtx_filter_ctl {
+	u64 u;
+	struct cavm_npa_af_dtx_filter_ctl_s {
+		u64 ena                              : 1;
+		u64 reserved_1_3                     : 3;
+		u64 lf                               : 7;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct cavm_npa_af_dtx_filter_ctl_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_DTX_FILTER_CTL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_DTX_FILTER_CTL(void)
+{
+	return 0x10040;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_eco
+ *
+ * INTERNAL: NPA AF ECO Register
+ */
+union cavm_npa_af_eco {
+	u64 u;
+	struct cavm_npa_af_eco_s {
+		u64 eco_rw                           : 32;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cavm_npa_af_eco_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_ECO(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_ECO(void)
+{
+	return 0x300;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_err_int
+ *
+ * NPA Admin Function Error Interrupt Register
+ */
+union cavm_npa_af_err_int {
+	u64 u;
+	struct cavm_npa_af_err_int_s {
+		u64 reserved_0_11                    : 12;
+		u64 aq_door_err                      : 1;
+		u64 aq_res_fault                     : 1;
+		u64 aq_inst_fault                    : 1;
+		u64 reserved_15_63                   : 49;
+	} s;
+	/* struct cavm_npa_af_err_int_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_ERR_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_ERR_INT(void)
+{
+	return 0x180;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_err_int_ena_w1c
+ *
+ * NPA Admin Function Error Interrupt Enable Clear Register This register
+ * clears interrupt enable bits.
+ */
+union cavm_npa_af_err_int_ena_w1c {
+	u64 u;
+	struct cavm_npa_af_err_int_ena_w1c_s {
+		u64 reserved_0_11                    : 12;
+		u64 aq_door_err                      : 1;
+		u64 aq_res_fault                     : 1;
+		u64 aq_inst_fault                    : 1;
+		u64 reserved_15_63                   : 49;
+	} s;
+	/* struct cavm_npa_af_err_int_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_ERR_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_ERR_INT_ENA_W1C(void)
+{
+	return 0x198;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_err_int_ena_w1s
+ *
+ * NPA Admin Function Error Interrupt Enable Set Register This register
+ * sets interrupt enable bits.
+ */
+union cavm_npa_af_err_int_ena_w1s {
+	u64 u;
+	struct cavm_npa_af_err_int_ena_w1s_s {
+		u64 reserved_0_11                    : 12;
+		u64 aq_door_err                      : 1;
+		u64 aq_res_fault                     : 1;
+		u64 aq_inst_fault                    : 1;
+		u64 reserved_15_63                   : 49;
+	} s;
+	/* struct cavm_npa_af_err_int_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_ERR_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_ERR_INT_ENA_W1S(void)
+{
+	return 0x190;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_err_int_w1s
+ *
+ * NPA Admin Function Error Interrupt Set Register This register sets
+ * interrupt bits.
+ */
+union cavm_npa_af_err_int_w1s {
+	u64 u;
+	struct cavm_npa_af_err_int_w1s_s {
+		u64 reserved_0_11                    : 12;
+		u64 aq_door_err                      : 1;
+		u64 aq_res_fault                     : 1;
+		u64 aq_inst_fault                    : 1;
+		u64 reserved_15_63                   : 49;
+	} s;
+	/* struct cavm_npa_af_err_int_w1s_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_ERR_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_ERR_INT_W1S(void)
+{
+	return 0x188;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_gen_cfg
+ *
+ * NPA AF General Configuration Register This register provides NPA
+ * control and status information.
+ */
+union cavm_npa_af_gen_cfg {
+	u64 u;
+	struct cavm_npa_af_gen_cfg_s {
+		u64 reserved_0                       : 1;
+		u64 af_be                            : 1;
+		u64 reserved_2                       : 1;
+		u64 force_cond_clk_en                : 1;
+		u64 force_intf_clk_en                : 1;
+		u64 reserved_5_9                     : 5;
+		u64 ocla_bp                          : 1;
+		u64 reserved_11                      : 1;
+		u64 ratem1                           : 4;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_npa_af_gen_cfg_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_GEN_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_GEN_CFG(void)
+{
+	return 0x30;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_gen_int
+ *
+ * NPA AF General Interrupt Register This register contains general error
+ * interrupt summary bits.
+ */
+union cavm_npa_af_gen_int {
+	u64 u;
+	struct cavm_npa_af_gen_int_s {
+		u64 free_dis                         : 16;
+		u64 alloc_dis                        : 16;
+		u64 unmapped_pf_func                 : 1;
+		u64 reserved_33_63                   : 31;
+	} s;
+	/* struct cavm_npa_af_gen_int_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_GEN_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_GEN_INT(void)
+{
+	return 0x140;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_gen_int_ena_w1c
+ *
+ * NPA AF General Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union cavm_npa_af_gen_int_ena_w1c {
+	u64 u;
+	struct cavm_npa_af_gen_int_ena_w1c_s {
+		u64 free_dis                         : 16;
+		u64 alloc_dis                        : 16;
+		u64 unmapped_pf_func                 : 1;
+		u64 reserved_33_63                   : 31;
+	} s;
+	/* struct cavm_npa_af_gen_int_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_GEN_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_GEN_INT_ENA_W1C(void)
+{
+	return 0x158;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_gen_int_ena_w1s
+ *
+ * NPA AF General Interrupt Enable Set Register This register sets
+ * interrupt enable bits.
+ */
+union cavm_npa_af_gen_int_ena_w1s {
+	u64 u;
+	struct cavm_npa_af_gen_int_ena_w1s_s {
+		u64 free_dis                         : 16;
+		u64 alloc_dis                        : 16;
+		u64 unmapped_pf_func                 : 1;
+		u64 reserved_33_63                   : 31;
+	} s;
+	/* struct cavm_npa_af_gen_int_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_GEN_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_GEN_INT_ENA_W1S(void)
+{
+	return 0x150;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_gen_int_w1s
+ *
+ * NPA AF General Interrupt Set Register This register sets interrupt
+ * bits.
+ */
+union cavm_npa_af_gen_int_w1s {
+	u64 u;
+	struct cavm_npa_af_gen_int_w1s_s {
+		u64 free_dis                         : 16;
+		u64 alloc_dis                        : 16;
+		u64 unmapped_pf_func                 : 1;
+		u64 reserved_33_63                   : 31;
+	} s;
+	/* struct cavm_npa_af_gen_int_w1s_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_GEN_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_GEN_INT_W1S(void)
+{
+	return 0x148;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_inp_ctl
+ *
+ * NPA AF Input Control Register
+ */
+union cavm_npa_af_inp_ctl {
+	u64 u;
+	struct cavm_npa_af_inp_ctl_s {
+		u64 free_dis                         : 16;
+		u64 alloc_dis                        : 16;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cavm_npa_af_inp_ctl_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_INP_CTL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_INP_CTL(void)
+{
+	return 0xd0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_lf#_auras_cfg
+ *
+ * NPA AF Local Function Auras Configuration Registers
+ */
+union cavm_npa_af_lfx_auras_cfg {
+	u64 u;
+	struct cavm_npa_af_lfx_auras_cfg_s {
+		u64 way_mask                         : 16;
+		u64 loc_aura_size                    : 4;
+		u64 loc_aura_offset                  : 14;
+		u64 caching                          : 1;
+		u64 be                               : 1;
+		u64 rmt_aura_size                    : 4;
+		u64 rmt_aura_offset                  : 14;
+		u64 rmt_lf                           : 7;
+		u64 reserved_61_63                   : 3;
+	} s;
+	struct cavm_npa_af_lfx_auras_cfg_cn96xx {
+		u64 way_mask                         : 16;
+		u64 loc_aura_size                    : 4;
+		u64 loc_aura_offset                  : 14;
+		u64 caching                          : 1;
+		u64 reserved_35                      : 1;
+		u64 rmt_aura_size                    : 4;
+		u64 rmt_aura_offset                  : 14;
+		u64 rmt_lf                           : 7;
+		u64 reserved_61_63                   : 3;
+	} cn96xx;
+	/* struct cavm_npa_af_lfx_auras_cfg_s cnf95xx; */
+};
+
+static inline u64 CAVM_NPA_AF_LFX_AURAS_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_LFX_AURAS_CFG(u64 a)
+{
+	return 0x4000 + 0x40000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_lf#_loc_auras_base
+ *
+ * NPA AF Local Function Auras Base Registers
+ */
+union cavm_npa_af_lfx_loc_auras_base {
+	u64 u;
+	struct cavm_npa_af_lfx_loc_auras_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 addr                             : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct cavm_npa_af_lfx_loc_auras_base_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_LFX_LOC_AURAS_BASE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_LFX_LOC_AURAS_BASE(u64 a)
+{
+	return 0x4010 + 0x40000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_lf#_qints_base
+ *
+ * NPA AF Local Function Queue Interrupts Base Registers
+ */
+union cavm_npa_af_lfx_qints_base {
+	u64 u;
+	struct cavm_npa_af_lfx_qints_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 addr                             : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct cavm_npa_af_lfx_qints_base_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_LFX_QINTS_BASE(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_LFX_QINTS_BASE(u64 a)
+{
+	return 0x4110 + 0x40000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_lf#_qints_cfg
+ *
+ * NPA AF Local Function Queue Interrupts Configuration Registers This
+ * register controls access to the LF's queue interrupt context table in
+ * LLC/DRAM. The table consists of NPA_AF_CONST[QINTS] contiguous
+ * NPA_QINT_HW_S structures. The size of each structure is 1 \<\<
+ * NPA_AF_CONST1[QINT_LOG2BYTES] bytes.
+ */
+union cavm_npa_af_lfx_qints_cfg {
+	u64 u;
+	struct cavm_npa_af_lfx_qints_cfg_s {
+		u64 reserved_0_19                    : 20;
+		u64 way_mask                         : 16;
+		u64 caching                          : 2;
+		u64 reserved_38_63                   : 26;
+	} s;
+	/* struct cavm_npa_af_lfx_qints_cfg_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_LFX_QINTS_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_LFX_QINTS_CFG(u64 a)
+{
+	return 0x4100 + 0x40000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_lf_rst
+ *
+ * NPA Admin Function LF Reset Register
+ */
+union cavm_npa_af_lf_rst {
+	u64 u;
+	struct cavm_npa_af_lf_rst_s {
+		u64 lf                               : 8;
+		u64 reserved_8_11                    : 4;
+		u64 exec                             : 1;
+		u64 reserved_13_63                   : 51;
+	} s;
+	/* struct cavm_npa_af_lf_rst_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_LF_RST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_LF_RST(void)
+{
+	return 0x20;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_ndc_cfg
+ *
+ * NDC AF General Configuration Register This register provides NDC
+ * control.
+ */
+union cavm_npa_af_ndc_cfg {
+	u64 u;
+	struct cavm_npa_af_ndc_cfg_s {
+		u64 ndc_bypass                       : 1;
+		u64 ndc_ign_pois                     : 1;
+		u64 byp_aura                         : 1;
+		u64 byp_pool                         : 1;
+		u64 byp_stack                        : 1;
+		u64 byp_qint                         : 1;
+		u64 reserved_6_63                    : 58;
+	} s;
+	/* struct cavm_npa_af_ndc_cfg_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_NDC_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_NDC_CFG(void)
+{
+	return 0x40;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_ndc_sync
+ *
+ * NPA AF NDC Sync Register Used to synchronize the NPA NDC.
+ */
+union cavm_npa_af_ndc_sync {
+	u64 u;
+	struct cavm_npa_af_ndc_sync_s {
+		u64 lf                               : 8;
+		u64 reserved_8_11                    : 4;
+		u64 exec                             : 1;
+		u64 reserved_13_63                   : 51;
+	} s;
+	/* struct cavm_npa_af_ndc_sync_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_NDC_SYNC(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_NDC_SYNC(void)
+{
+	return 0x50;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_ras
+ *
+ * NPA AF RAS Interrupt Register This register is intended for delivery
+ * of RAS events to the SCP, so should be ignored by OS drivers.
+ */
+union cavm_npa_af_ras {
+	u64 u;
+	struct cavm_npa_af_ras_s {
+		u64 reserved_0_31                    : 32;
+		u64 aq_ctx_poison                    : 1;
+		u64 aq_res_poison                    : 1;
+		u64 aq_inst_poison                   : 1;
+		u64 reserved_35_63                   : 29;
+	} s;
+	/* struct cavm_npa_af_ras_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_RAS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_RAS(void)
+{
+	return 0x1a0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_ras_ena_w1c
+ *
+ * NPA AF RAS Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union cavm_npa_af_ras_ena_w1c {
+	u64 u;
+	struct cavm_npa_af_ras_ena_w1c_s {
+		u64 reserved_0_31                    : 32;
+		u64 aq_ctx_poison                    : 1;
+		u64 aq_res_poison                    : 1;
+		u64 aq_inst_poison                   : 1;
+		u64 reserved_35_63                   : 29;
+	} s;
+	/* struct cavm_npa_af_ras_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_RAS_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_RAS_ENA_W1C(void)
+{
+	return 0x1b8;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_ras_ena_w1s
+ *
+ * NPA AF RAS Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
+ */
+union cavm_npa_af_ras_ena_w1s {
+	u64 u;
+	struct cavm_npa_af_ras_ena_w1s_s {
+		u64 reserved_0_31                    : 32;
+		u64 aq_ctx_poison                    : 1;
+		u64 aq_res_poison                    : 1;
+		u64 aq_inst_poison                   : 1;
+		u64 reserved_35_63                   : 29;
+	} s;
+	/* struct cavm_npa_af_ras_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_RAS_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_RAS_ENA_W1S(void)
+{
+	return 0x1b0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_ras_w1s
+ *
+ * NPA AF RAS Interrupt Set Register This register sets interrupt bits.
+ */
+union cavm_npa_af_ras_w1s {
+	u64 u;
+	struct cavm_npa_af_ras_w1s_s {
+		u64 reserved_0_31                    : 32;
+		u64 aq_ctx_poison                    : 1;
+		u64 aq_res_poison                    : 1;
+		u64 aq_inst_poison                   : 1;
+		u64 reserved_35_63                   : 29;
+	} s;
+	/* struct cavm_npa_af_ras_w1s_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_RAS_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_RAS_W1S(void)
+{
+	return 0x1a8;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_rvu_int
+ *
+ * NPA AF RVU Interrupt Register This register contains RVU error
+ * interrupt summary bits.
+ */
+union cavm_npa_af_rvu_int {
+	u64 u;
+	struct cavm_npa_af_rvu_int_s {
+		u64 unmapped_slot                    : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_npa_af_rvu_int_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_RVU_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_RVU_INT(void)
+{
+	return 0x160;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_rvu_int_ena_w1c
+ *
+ * NPA AF RVU Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union cavm_npa_af_rvu_int_ena_w1c {
+	u64 u;
+	struct cavm_npa_af_rvu_int_ena_w1c_s {
+		u64 unmapped_slot                    : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_npa_af_rvu_int_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_RVU_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_RVU_INT_ENA_W1C(void)
+{
+	return 0x178;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_rvu_int_ena_w1s
+ *
+ * NPA AF RVU Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
+ */
+union cavm_npa_af_rvu_int_ena_w1s {
+	u64 u;
+	struct cavm_npa_af_rvu_int_ena_w1s_s {
+		u64 unmapped_slot                    : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_npa_af_rvu_int_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_RVU_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_RVU_INT_ENA_W1S(void)
+{
+	return 0x170;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_rvu_int_w1s
+ *
+ * NPA AF RVU Interrupt Set Register This register sets interrupt bits.
+ */
+union cavm_npa_af_rvu_int_w1s {
+	u64 u;
+	struct cavm_npa_af_rvu_int_w1s_s {
+		u64 unmapped_slot                    : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_npa_af_rvu_int_w1s_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_RVU_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_RVU_INT_W1S(void)
+{
+	return 0x168;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_af_rvu_lf_cfg_debug
+ *
+ * NPA Privileged LF Configuration Debug Register This debug register
+ * allows software to lookup the reverse mapping from VF/PF slot to LF.
+ * The forward mapping is programmed with NPA_PRIV_LF()_CFG.
+ */
+union cavm_npa_af_rvu_lf_cfg_debug {
+	u64 u;
+	struct cavm_npa_af_rvu_lf_cfg_debug_s {
+		u64 lf                               : 12;
+		u64 lf_valid                         : 1;
+		u64 exec                             : 1;
+		u64 reserved_14_15                   : 2;
+		u64 slot                             : 8;
+		u64 pf_func                          : 16;
+		u64 reserved_40_63                   : 24;
+	} s;
+	/* struct cavm_npa_af_rvu_lf_cfg_debug_s cn; */
+};
+
+static inline u64 CAVM_NPA_AF_RVU_LF_CFG_DEBUG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_AF_RVU_LF_CFG_DEBUG(void)
+{
+	return 0x10030;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_aura_op_alloc#
+ *
+ * NPA Aura Allocate Operation Registers These registers are used to
+ * allocate one or two pointers from a given aura's pool. A 64-bit atomic
+ * load-and-add to NPA_LF_AURA_OP_ALLOC(0) allocates a single pointer. A
+ * 128-bit atomic CASP operation to NPA_LF_AURA_OP_ALLOC(0..1) allocates
+ * two pointers. The atomic write data format is NPA_AURA_OP_WDATA_S. For
+ * CASP, the first SWAP word in the write data contains
+ * NPA_AURA_OP_WDATA_S and the remaining write data words are ignored.
+ * All other accesses to this register (e.g. reads and writes) are
+ * RAZ/WI.  RSL accesses to this register are RAZ/WI.
+ */
+union cavm_npa_lf_aura_op_allocx {
+	u64 u;
+	struct cavm_npa_lf_aura_op_allocx_s {
+		u64 addr                             : 64;
+	} s;
+	/* struct cavm_npa_lf_aura_op_allocx_s cn; */
+};
+
+static inline u64 CAVM_NPA_LF_AURA_OP_ALLOCX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_LF_AURA_OP_ALLOCX(u64 a)
+{
+	return 0x10 + 8 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_aura_op_cnt
+ *
+ * NPA LF Aura Count Register A 64-bit atomic load-and-add to this
+ * register returns a given aura's count. A write sets or adds the aura's
+ * count. A read is RAZ.  RSL accesses to this register are RAZ/WI.
+ */
+union cavm_npa_lf_aura_op_cnt {
+	u64 u;
+	struct cavm_npa_lf_aura_op_cnt_s {
+		u64 count                            : 36;
+		u64 reserved_36_41                   : 6;
+		u64 op_err                           : 1;
+		u64 cnt_add                          : 1;
+		u64 aura                             : 20;
+	} s;
+	/* struct cavm_npa_lf_aura_op_cnt_s cn; */
+};
+
+static inline u64 CAVM_NPA_LF_AURA_OP_CNT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_LF_AURA_OP_CNT(void)
+{
+	return 0x30;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_aura_op_free0
+ *
+ * NPA LF Aura Free Operation Register 0 A 128-bit write to
+ * NPA_LF_AURA_OP_FREE0 and NPA_LF_AURA_OP_FREE1 frees a pointer into a
+ * given aura's pool. All other accesses to these registers (e.g. reads
+ * and 64-bit writes) are RAZ/WI.  RSL accesses to this register are
+ * RAZ/WI.
+ */
+union cavm_npa_lf_aura_op_free0 {
+	u64 u;
+	struct cavm_npa_lf_aura_op_free0_s {
+		u64 addr                             : 64;
+	} s;
+	/* struct cavm_npa_lf_aura_op_free0_s cn; */
+};
+
+static inline u64 CAVM_NPA_LF_AURA_OP_FREE0(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_LF_AURA_OP_FREE0(void)
+{
+	return 0x20;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_aura_op_free1
+ *
+ * NPA LF Aura Free Operation Register 1 See NPA_LF_AURA_OP_FREE0.  RSL
+ * accesses to this register are RAZ/WI.
+ */
+union cavm_npa_lf_aura_op_free1 {
+	u64 u;
+	struct cavm_npa_lf_aura_op_free1_s {
+		u64 aura                             : 20;
+		u64 reserved_20_62                   : 43;
+		u64 fabs                             : 1;
+	} s;
+	/* struct cavm_npa_lf_aura_op_free1_s cn; */
+};
+
+static inline u64 CAVM_NPA_LF_AURA_OP_FREE1(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_LF_AURA_OP_FREE1(void)
+{
+	return 0x28;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_aura_op_int
+ *
+ * NPA LF Aura Interrupt Operation Register A 64-bit atomic load-and-add
+ * to this register reads
+ * NPA_AURA_HW_S[ERR_INT,ERR_INT_ENA,THRESH_INT,THRESH_INT_ENA]. A write
+ * optionally sets or clears these fields. A read is RAZ.  RSL accesses
+ * to this register are RAZ/WI.
+ */
+union cavm_npa_lf_aura_op_int {
+	u64 u;
+	struct cavm_npa_lf_aura_op_int_s {
+		u64 err_int                          : 8;
+		u64 err_int_ena                      : 8;
+		u64 thresh_int                       : 1;
+		u64 thresh_int_ena                   : 1;
+		u64 reserved_18_41                   : 24;
+		u64 op_err                           : 1;
+		u64 setop                            : 1;
+		u64 aura                             : 20;
+	} s;
+	/* struct cavm_npa_lf_aura_op_int_s cn; */
+};
+
+static inline u64 CAVM_NPA_LF_AURA_OP_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_LF_AURA_OP_INT(void)
+{
+	return 0x60;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_aura_op_limit
+ *
+ * NPA LF Aura Allocation Limit Register A 64-bit atomic load-and-add to
+ * this register returns a given aura's limit. A write sets the aura's
+ * limit. A read is RAZ.  RSL accesses to this register are RAZ/WI.
+ */
+union cavm_npa_lf_aura_op_limit {
+	u64 u;
+	struct cavm_npa_lf_aura_op_limit_s {
+		u64 limit                            : 36;
+		u64 reserved_36_41                   : 6;
+		u64 op_err                           : 1;
+		u64 reserved_43                      : 1;
+		u64 aura                             : 20;
+	} s;
+	/* struct cavm_npa_lf_aura_op_limit_s cn; */
+};
+
+static inline u64 CAVM_NPA_LF_AURA_OP_LIMIT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_LF_AURA_OP_LIMIT(void)
+{
+	return 0x50;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_aura_op_thresh
+ *
+ * NPA LF Aura Threshold Operation Register A 64-bit atomic load-and-add
+ * to this register reads NPA_AURA_HW_S[THRESH_UP,THRESH]. A write to the
+ * register writes NPA_AURA_HW_S[THRESH_UP,THRESH] and recomputes
+ * NPA_AURA_HW_S[THRESH_INT]. A read is RAZ.  RSL accesses to this
+ * register are RAZ/WI.
+ */
+union cavm_npa_lf_aura_op_thresh {
+	u64 u;
+	struct cavm_npa_lf_aura_op_thresh_s {
+		u64 thresh                           : 36;
+		u64 reserved_36_41                   : 6;
+		u64 op_err                           : 1;
+		u64 thresh_up                        : 1;
+		u64 aura                             : 20;
+	} s;
+	/* struct cavm_npa_lf_aura_op_thresh_s cn; */
+};
+
+static inline u64 CAVM_NPA_LF_AURA_OP_THRESH(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_LF_AURA_OP_THRESH(void)
+{
+	return 0x70;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_err_int
+ *
+ * NPA LF Error Interrupt Register
+ */
+union cavm_npa_lf_err_int {
+	u64 u;
+	struct cavm_npa_lf_err_int_s {
+		u64 aura_dis                         : 1;
+		u64 aura_oor                         : 1;
+		u64 reserved_2                       : 1;
+		u64 rmt_req_oor                      : 1;
+		u64 reserved_4_11                    : 8;
+		u64 aura_fault                       : 1;
+		u64 pool_fault                       : 1;
+		u64 stack_fault                      : 1;
+		u64 qint_fault                       : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_npa_lf_err_int_s cn; */
+};
+
+static inline u64 CAVM_NPA_LF_ERR_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_LF_ERR_INT(void)
+{
+	return 0x200;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_err_int_ena_w1c
+ *
+ * NPA LF Error Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union cavm_npa_lf_err_int_ena_w1c {
+	u64 u;
+	struct cavm_npa_lf_err_int_ena_w1c_s {
+		u64 aura_dis                         : 1;
+		u64 aura_oor                         : 1;
+		u64 reserved_2                       : 1;
+		u64 rmt_req_oor                      : 1;
+		u64 reserved_4_11                    : 8;
+		u64 aura_fault                       : 1;
+		u64 pool_fault                       : 1;
+		u64 stack_fault                      : 1;
+		u64 qint_fault                       : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_npa_lf_err_int_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_NPA_LF_ERR_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_LF_ERR_INT_ENA_W1C(void)
+{
+	return 0x210;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_err_int_ena_w1s
+ *
+ * NPA LF Error Interrupt Enable Set Register This register sets
+ * interrupt enable bits.
+ */
+union cavm_npa_lf_err_int_ena_w1s {
+	u64 u;
+	struct cavm_npa_lf_err_int_ena_w1s_s {
+		u64 aura_dis                         : 1;
+		u64 aura_oor                         : 1;
+		u64 reserved_2                       : 1;
+		u64 rmt_req_oor                      : 1;
+		u64 reserved_4_11                    : 8;
+		u64 aura_fault                       : 1;
+		u64 pool_fault                       : 1;
+		u64 stack_fault                      : 1;
+		u64 qint_fault                       : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_npa_lf_err_int_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_NPA_LF_ERR_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_LF_ERR_INT_ENA_W1S(void)
+{
+	return 0x218;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_err_int_w1s
+ *
+ * NPA LF Error Interrupt Set Register This register sets interrupt bits.
+ */
+union cavm_npa_lf_err_int_w1s {
+	u64 u;
+	struct cavm_npa_lf_err_int_w1s_s {
+		u64 aura_dis                         : 1;
+		u64 aura_oor                         : 1;
+		u64 reserved_2                       : 1;
+		u64 rmt_req_oor                      : 1;
+		u64 reserved_4_11                    : 8;
+		u64 aura_fault                       : 1;
+		u64 pool_fault                       : 1;
+		u64 stack_fault                      : 1;
+		u64 qint_fault                       : 1;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_npa_lf_err_int_w1s_s cn; */
+};
+
+static inline u64 CAVM_NPA_LF_ERR_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_LF_ERR_INT_W1S(void)
+{
+	return 0x208;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_pool_op_available
+ *
+ * NPA LF Pool Available Count Operation Register A 64-bit atomic load-
+ * and-add to this register returns a given pool's free pointer count.
+ * Reads and writes are RAZ/WI.  RSL accesses to this register are
+ * RAZ/WI.
+ */
+union cavm_npa_lf_pool_op_available {
+	u64 u;
+	struct cavm_npa_lf_pool_op_available_s {
+		u64 count                            : 36;
+		u64 reserved_36_41                   : 6;
+		u64 op_err                           : 1;
+		u64 reserved_43                      : 1;
+		u64 aura                             : 20;
+	} s;
+	/* struct cavm_npa_lf_pool_op_available_s cn; */
+};
+
+static inline u64 CAVM_NPA_LF_POOL_OP_AVAILABLE(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_LF_POOL_OP_AVAILABLE(void)
+{
+	return 0x110;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_pool_op_int
+ *
+ * NPA LF Pool Interrupt Operation Register A 64-bit atomic load-and-add
+ * to this register reads
+ * NPA_POOL_S[ERR_INT,ERR_INT_ENA,THRESH_INT,THRESH_INT_ENA]. A write
+ * optionally sets or clears these fields. A read is RAZ.  RSL accesses
+ * to this register are RAZ/WI.
+ */
+union cavm_npa_lf_pool_op_int {
+	u64 u;
+	struct cavm_npa_lf_pool_op_int_s {
+		u64 err_int                          : 8;
+		u64 err_int_ena                      : 8;
+		u64 thresh_int                       : 1;
+		u64 thresh_int_ena                   : 1;
+		u64 reserved_18_41                   : 24;
+		u64 op_err                           : 1;
+		u64 setop                            : 1;
+		u64 aura                             : 20;
+	} s;
+	/* struct cavm_npa_lf_pool_op_int_s cn; */
+};
+
+static inline u64 CAVM_NPA_LF_POOL_OP_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_LF_POOL_OP_INT(void)
+{
+	return 0x160;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_pool_op_pc
+ *
+ * NPA LF Pool Performance Count Register A 64-bit atomic load-and-add to
+ * this register reads NPA_POOL_S[OP_PC] from a given aura's pool. The
+ * aura is selected by the atomic write data, whose format is
+ * NPA_AURA_OP_WDATA_S. Reads and writes are RAZ/WI.  RSL accesses to
+ * this register are RAZ/WI.
+ */
+union cavm_npa_lf_pool_op_pc {
+	u64 u;
+	struct cavm_npa_lf_pool_op_pc_s {
+		u64 op_pc                            : 48;
+		u64 op_err                           : 1;
+		u64 reserved_49_63                   : 15;
+	} s;
+	/* struct cavm_npa_lf_pool_op_pc_s cn; */
+};
+
+static inline u64 CAVM_NPA_LF_POOL_OP_PC(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_LF_POOL_OP_PC(void)
+{
+	return 0x100;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_pool_op_ptr_end0
+ *
+ * NPA LF Pool Pointer End Operation Register 0 A 128-bit write to the
+ * NPA_LF_POOL_OP_PTR_END0 and NPA_LF_POOL_OP_PTR_END1 registers writes
+ * to a given pool's pointer end value. All other accesses to these
+ * registers (e.g. reads and 64-bit writes) are RAZ/WI.  RSL accesses to
+ * this register are RAZ/WI.
+ */
+union cavm_npa_lf_pool_op_ptr_end0 {
+	u64 u;
+	struct cavm_npa_lf_pool_op_ptr_end0_s {
+		u64 ptr_end                          : 64;
+	} s;
+	/* struct cavm_npa_lf_pool_op_ptr_end0_s cn; */
+};
+
+static inline u64 CAVM_NPA_LF_POOL_OP_PTR_END0(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_LF_POOL_OP_PTR_END0(void)
+{
+	return 0x130;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_pool_op_ptr_end1
+ *
+ * NPA LF Pool Pointer End Operation Register 1 See
+ * NPA_LF_POOL_OP_PTR_END0.  RSL accesses to this register are RAZ/WI.
+ */
+union cavm_npa_lf_pool_op_ptr_end1 {
+	u64 u;
+	struct cavm_npa_lf_pool_op_ptr_end1_s {
+		u64 aura                             : 20;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct cavm_npa_lf_pool_op_ptr_end1_s cn; */
+};
+
+static inline u64 CAVM_NPA_LF_POOL_OP_PTR_END1(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_LF_POOL_OP_PTR_END1(void)
+{
+	return 0x138;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_pool_op_ptr_start0
+ *
+ * NPA LF Pool Pointer Start Operation Register 0 A 128-bit write to the
+ * NPA_LF_POOL_OP_PTR_START0 and NPA_LF_POOL_OP_PTR_START1 registers
+ * writes to a given pool's pointer start value. All other accesses to
+ * these registers (e.g. reads and 64-bit writes) are RAZ/WI.  RSL
+ * accesses to this register are RAZ/WI.
+ */
+union cavm_npa_lf_pool_op_ptr_start0 {
+	u64 u;
+	struct cavm_npa_lf_pool_op_ptr_start0_s {
+		u64 ptr_start                        : 64;
+	} s;
+	/* struct cavm_npa_lf_pool_op_ptr_start0_s cn; */
+};
+
+static inline u64 CAVM_NPA_LF_POOL_OP_PTR_START0(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_LF_POOL_OP_PTR_START0(void)
+{
+	return 0x120;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_pool_op_ptr_start1
+ *
+ * NPA LF Pool Pointer Start Operation Register 1 See
+ * NPA_LF_POOL_OP_PTR_START0.  RSL accesses to this register are RAZ/WI.
+ */
+union cavm_npa_lf_pool_op_ptr_start1 {
+	u64 u;
+	struct cavm_npa_lf_pool_op_ptr_start1_s {
+		u64 aura                             : 20;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct cavm_npa_lf_pool_op_ptr_start1_s cn; */
+};
+
+static inline u64 CAVM_NPA_LF_POOL_OP_PTR_START1(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_LF_POOL_OP_PTR_START1(void)
+{
+	return 0x128;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_pool_op_thresh
+ *
+ * NPA LF Pool Threshold Operation Register A 64-bit atomic load-and-add
+ * to this register reads NPA_POOL_S[THRESH_UP,THRESH]. A write to the
+ * register writes NPA_POOL_S[THRESH_UP,THRESH]. A read is RAZ.  RSL
+ * accesses to this register are RAZ/WI.
+ */
+union cavm_npa_lf_pool_op_thresh {
+	u64 u;
+	struct cavm_npa_lf_pool_op_thresh_s {
+		u64 thresh                           : 36;
+		u64 reserved_36_41                   : 6;
+		u64 op_err                           : 1;
+		u64 thresh_up                        : 1;
+		u64 aura                             : 20;
+	} s;
+	/* struct cavm_npa_lf_pool_op_thresh_s cn; */
+};
+
+static inline u64 CAVM_NPA_LF_POOL_OP_THRESH(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_LF_POOL_OP_THRESH(void)
+{
+	return 0x170;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_qint#_cnt
+ *
+ * NPA LF Queue Interrupt Count Registers
+ */
+union cavm_npa_lf_qintx_cnt {
+	u64 u;
+	struct cavm_npa_lf_qintx_cnt_s {
+		u64 count                            : 22;
+		u64 reserved_22_63                   : 42;
+	} s;
+	/* struct cavm_npa_lf_qintx_cnt_s cn; */
+};
+
+static inline u64 CAVM_NPA_LF_QINTX_CNT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_LF_QINTX_CNT(u64 a)
+{
+	return 0x300 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_qint#_ena_w1c
+ *
+ * NPA LF Queue Interrupt Enable Clear Registers This register clears
+ * interrupt enable bits.
+ */
+union cavm_npa_lf_qintx_ena_w1c {
+	u64 u;
+	struct cavm_npa_lf_qintx_ena_w1c_s {
+		u64 intr                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_npa_lf_qintx_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_NPA_LF_QINTX_ENA_W1C(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_LF_QINTX_ENA_W1C(u64 a)
+{
+	return 0x330 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_qint#_ena_w1s
+ *
+ * NPA LF Queue Interrupt Enable Set Registers This register sets
+ * interrupt enable bits.
+ */
+union cavm_npa_lf_qintx_ena_w1s {
+	u64 u;
+	struct cavm_npa_lf_qintx_ena_w1s_s {
+		u64 intr                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_npa_lf_qintx_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_NPA_LF_QINTX_ENA_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_LF_QINTX_ENA_W1S(u64 a)
+{
+	return 0x320 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_qint#_int
+ *
+ * NPA LF Queue Interrupt Registers
+ */
+union cavm_npa_lf_qintx_int {
+	u64 u;
+	struct cavm_npa_lf_qintx_int_s {
+		u64 intr                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_npa_lf_qintx_int_s cn; */
+};
+
+static inline u64 CAVM_NPA_LF_QINTX_INT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_LF_QINTX_INT(u64 a)
+{
+	return 0x310 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_qint#_int_w1s
+ *
+ * INTERNAL: NPA LF Queue Interrupt Set Registers
+ */
+union cavm_npa_lf_qintx_int_w1s {
+	u64 u;
+	struct cavm_npa_lf_qintx_int_w1s_s {
+		u64 intr                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_npa_lf_qintx_int_w1s_s cn; */
+};
+
+static inline u64 CAVM_NPA_LF_QINTX_INT_W1S(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_LF_QINTX_INT_W1S(u64 a)
+{
+	return 0x318 + 0x1000 * a;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_ras
+ *
+ * NPA LF RAS Interrupt Register
+ */
+union cavm_npa_lf_ras {
+	u64 u;
+	struct cavm_npa_lf_ras_s {
+		u64 aura_poison                      : 1;
+		u64 pool_poison                      : 1;
+		u64 stack_poison                     : 1;
+		u64 qint_poison                      : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cavm_npa_lf_ras_s cn; */
+};
+
+static inline u64 CAVM_NPA_LF_RAS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_LF_RAS(void)
+{
+	return 0x220;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_ras_ena_w1c
+ *
+ * NPA LF RAS Interrupt Enable Clear Register This register clears
+ * interrupt enable bits.
+ */
+union cavm_npa_lf_ras_ena_w1c {
+	u64 u;
+	struct cavm_npa_lf_ras_ena_w1c_s {
+		u64 aura_poison                      : 1;
+		u64 pool_poison                      : 1;
+		u64 stack_poison                     : 1;
+		u64 qint_poison                      : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cavm_npa_lf_ras_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_NPA_LF_RAS_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_LF_RAS_ENA_W1C(void)
+{
+	return 0x230;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_ras_ena_w1s
+ *
+ * NPA LF RAS Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
+ */
+union cavm_npa_lf_ras_ena_w1s {
+	u64 u;
+	struct cavm_npa_lf_ras_ena_w1s_s {
+		u64 aura_poison                      : 1;
+		u64 pool_poison                      : 1;
+		u64 stack_poison                     : 1;
+		u64 qint_poison                      : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cavm_npa_lf_ras_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_NPA_LF_RAS_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_LF_RAS_ENA_W1S(void)
+{
+	return 0x238;
+}
+
+/**
+ * Register (RVU_PFVF_BAR2) npa_lf_ras_w1s
+ *
+ * NPA LF RAS Interrupt Set Register This register sets interrupt bits.
+ */
+union cavm_npa_lf_ras_w1s {
+	u64 u;
+	struct cavm_npa_lf_ras_w1s_s {
+		u64 aura_poison                      : 1;
+		u64 pool_poison                      : 1;
+		u64 stack_poison                     : 1;
+		u64 qint_poison                      : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cavm_npa_lf_ras_w1s_s cn; */
+};
+
+static inline u64 CAVM_NPA_LF_RAS_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_LF_RAS_W1S(void)
+{
+	return 0x228;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_priv_af_int_cfg
+ *
+ * NPA Privileged AF Interrupt Configuration Register
+ */
+union cavm_npa_priv_af_int_cfg {
+	u64 u;
+	struct cavm_npa_priv_af_int_cfg_s {
+		u64 msix_offset                      : 11;
+		u64 reserved_11                      : 1;
+		u64 msix_size                        : 8;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct cavm_npa_priv_af_int_cfg_s cn; */
+};
+
+static inline u64 CAVM_NPA_PRIV_AF_INT_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_PRIV_AF_INT_CFG(void)
+{
+	return 0x10000;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_priv_lf#_cfg
+ *
+ * NPA Privileged Local Function Configuration Registers These registers
+ * allow each NPA local function (LF) to be provisioned to a VF/PF slot
+ * for RVU. See also NPA_AF_RVU_LF_CFG_DEBUG.  Software should read this
+ * register after write to ensure that the LF is mapped to [PF_FUNC]
+ * before issuing transactions to the mapped PF and function.  [SLOT]
+ * must be zero.  Internal: Hardware ignores [SLOT] and always assumes
+ * 0x0.
+ */
+union cavm_npa_priv_lfx_cfg {
+	u64 u;
+	struct cavm_npa_priv_lfx_cfg_s {
+		u64 slot                             : 8;
+		u64 pf_func                          : 16;
+		u64 reserved_24_62                   : 39;
+		u64 ena                              : 1;
+	} s;
+	/* struct cavm_npa_priv_lfx_cfg_s cn; */
+};
+
+static inline u64 CAVM_NPA_PRIV_LFX_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_PRIV_LFX_CFG(u64 a)
+{
+	return 0x10010 + 0x100 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npa_priv_lf#_int_cfg
+ *
+ * NPA Privileged LF Interrupt Configuration Registers
+ */
+union cavm_npa_priv_lfx_int_cfg {
+	u64 u;
+	struct cavm_npa_priv_lfx_int_cfg_s {
+		u64 msix_offset                      : 11;
+		u64 reserved_11                      : 1;
+		u64 msix_size                        : 8;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct cavm_npa_priv_lfx_int_cfg_s cn; */
+};
+
+static inline u64 CAVM_NPA_PRIV_LFX_INT_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPA_PRIV_LFX_INT_CFG(u64 a)
+{
+	return 0x10020 + 0x100 * a;
+}
+
+#endif /* __CAVM_CSRS_NPA_H__ */
diff --git a/drivers/net/octeontx2/cavm-csrs-npc.h b/drivers/net/octeontx2/cavm-csrs-npc.h
new file mode 100644
index 0000000..6655a10
--- /dev/null
+++ b/drivers/net/octeontx2/cavm-csrs-npc.h
@@ -0,0 +1,1608 @@
+#ifndef __CAVM_CSRS_NPC_H__
+#define __CAVM_CSRS_NPC_H__
+/* This file is auto-generated.  Do not edit */
+
+/***********************license start***********************************
+* Copyright (C) 2019 Marvell International Ltd.
+* SPDX-License-Identifier: BSD-3-Clause
+* https://spdx.org/licenses
+***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * Configuration and status register (CSR) address and type definitions for
+ * Cavium NPC.
+ *
+ * This file is auto generated.  Do not edit.
+ *
+ */
+
+/**
+ * Enumeration npc_errlev_e
+ *
+ * NPC Error Level Enumeration Enumerates the lowest protocol layer
+ * containing an error.
+ */
+#define CAVM_NPC_ERRLEV_E_LA (1)
+#define CAVM_NPC_ERRLEV_E_LB (2)
+#define CAVM_NPC_ERRLEV_E_LC (3)
+#define CAVM_NPC_ERRLEV_E_LD (4)
+#define CAVM_NPC_ERRLEV_E_LE (5)
+#define CAVM_NPC_ERRLEV_E_LF (6)
+#define CAVM_NPC_ERRLEV_E_LG (7)
+#define CAVM_NPC_ERRLEV_E_LH (8)
+#define CAVM_NPC_ERRLEV_E_NIX (0xf)
+#define CAVM_NPC_ERRLEV_E_RX(a) (0 + (a))
+#define CAVM_NPC_ERRLEV_E_RE (0)
+
+/**
+ * Enumeration npc_intf_e
+ *
+ * NPC Interface Enumeration Enumerates the NPC interfaces.
+ */
+#define CAVM_NPC_INTF_E_NIXX_RX(a) (0 + 2 * (a))
+#define CAVM_NPC_INTF_E_NIXX_TX(a) (1 + 2 * (a))
+
+/**
+ * Enumeration npc_lid_e
+ *
+ * NPC Layer ID Enumeration Enumerates layers parsed by NPC.
+ */
+#define CAVM_NPC_LID_E_LA (0)
+#define CAVM_NPC_LID_E_LB (1)
+#define CAVM_NPC_LID_E_LC (2)
+#define CAVM_NPC_LID_E_LD (3)
+#define CAVM_NPC_LID_E_LE (4)
+#define CAVM_NPC_LID_E_LF (5)
+#define CAVM_NPC_LID_E_LG (6)
+#define CAVM_NPC_LID_E_LH (7)
+
+/**
+ * Enumeration npc_lkupop_e
+ *
+ * NPC Lookup Operation Enumeration Enumerates the lookup operation for
+ * NPC_AF_LKUP_CTL[OP].
+ */
+#define CAVM_NPC_LKUPOP_E_KEY (1)
+#define CAVM_NPC_LKUPOP_E_PKT (0)
+
+/**
+ * Enumeration npc_mcamkeyw_e
+ *
+ * NPC MCAM Search Key Width Enumeration
+ */
+#define CAVM_NPC_MCAMKEYW_E_X1 (0)
+#define CAVM_NPC_MCAMKEYW_E_X2 (1)
+#define CAVM_NPC_MCAMKEYW_E_X4 (2)
+
+/**
+ * Structure npc_layer_info_s
+ *
+ * NPC Layer Parse Information Structure This structure specifies the
+ * format of NPC_RESULT_S[LA,LB,...,LH].
+ */
+union cavm_npc_layer_info_s {
+	u32 u;
+	struct cavm_npc_layer_info_s_s {
+		u32 lptr                             : 8;
+		u32 flags                            : 8;
+		u32 ltype                            : 4;
+		u32 reserved_20_31                   : 12;
+	} s;
+	/* struct cavm_npc_layer_info_s_s cn; */
+};
+
+/**
+ * Structure npc_layer_kex_s
+ *
+ * NPC Layer MCAM Search Key Extract Structure This structure specifies
+ * the format of each of the NPC_PARSE_KEX_S[LA,LB,...,LH] fields. It
+ * contains the subset of NPC_LAYER_INFO_S fields that can be included in
+ * the MCAM search key. See NPC_PARSE_KEX_S and NPC_AF_INTF()_KEX_CFG.
+ */
+union cavm_npc_layer_kex_s {
+	u32 u;
+	struct cavm_npc_layer_kex_s_s {
+		u32 flags                            : 8;
+		u32 ltype                            : 4;
+		u32 reserved_12_31                   : 20;
+	} s;
+	/* struct cavm_npc_layer_kex_s_s cn; */
+};
+
+/**
+ * Structure npc_mcam_key_x1_s
+ *
+ * NPC MCAM Search Key X1 Structure This structure specifies the MCAM
+ * search key format used by an interface when
+ * NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X1.
+ */
+union cavm_npc_mcam_key_x1_s {
+	u64 u[3];
+	struct cavm_npc_mcam_key_x1_s_s {
+		u64 intf                             : 2;
+		u64 reserved_2_63                    : 62;
+		u64 kw0                              : 64;
+		u64 kw1                              : 48;
+		u64 reserved_176_191                 : 16;
+	} s;
+	/* struct cavm_npc_mcam_key_x1_s_s cn; */
+};
+
+/**
+ * Structure npc_mcam_key_x2_s
+ *
+ * NPC MCAM Search Key X2 Structure This structure specifies the MCAM
+ * search key format used by an interface when
+ * NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X2.
+ */
+union cavm_npc_mcam_key_x2_s {
+	u64 u[5];
+	struct cavm_npc_mcam_key_x2_s_s {
+		u64 intf                             : 2;
+		u64 reserved_2_63                    : 62;
+		u64 kw0                              : 64;
+		u64 kw1                              : 64;
+		u64 kw2                              : 64;
+		u64 kw3                              : 32;
+		u64 reserved_288_319                 : 32;
+	} s;
+	/* struct cavm_npc_mcam_key_x2_s_s cn; */
+};
+
+/**
+ * Structure npc_mcam_key_x4_s
+ *
+ * NPC MCAM Search Key X4 Structure This structure specifies the MCAM
+ * search key format used by an interface when
+ * NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X4.
+ */
+union cavm_npc_mcam_key_x4_s {
+	u64 u[8];
+	struct cavm_npc_mcam_key_x4_s_s {
+		u64 intf                             : 2;
+		u64 reserved_2_63                    : 62;
+		u64 kw0                              : 64;
+		u64 kw1                              : 64;
+		u64 kw2                              : 64;
+		u64 kw3                              : 64;
+		u64 kw4                              : 64;
+		u64 kw5                              : 64;
+		u64 kw6                              : 64;
+	} s;
+	/* struct cavm_npc_mcam_key_x4_s_s cn; */
+};
+
+/**
+ * Structure npc_parse_kex_s
+ *
+ * NPC Parse Key Extract Structure This structure contains the subset of
+ * NPC_RESULT_S fields that can be included in the MCAM search key. See
+ * NPC_AF_INTF()_KEX_CFG.
+ */
+union cavm_npc_parse_kex_s {
+	u64 u[2];
+	struct cavm_npc_parse_kex_s_s {
+		u64 chan                             : 12;
+		u64 errlev                           : 4;
+		u64 errcode                          : 8;
+		u64 l2m                              : 1;
+		u64 l2b                              : 1;
+		u64 l3m                              : 1;
+		u64 l3b                              : 1;
+		u64 la                               : 12;
+		u64 lb                               : 12;
+		u64 lc                               : 12;
+		u64 ld                               : 12;
+		u64 le                               : 12;
+		u64 lf                               : 12;
+		u64 lg                               : 12;
+		u64 lh                               : 12;
+		u64 reserved_124_127                 : 4;
+	} s;
+	/* struct cavm_npc_parse_kex_s_s cn; */
+};
+
+/**
+ * Structure npc_result_s
+ *
+ * NPC Result Structure This structure contains a packet's parse and flow
+ * identification information.
+ */
+union cavm_npc_result_s {
+	u64 u[6];
+	struct cavm_npc_result_s_s {
+		u64 intf                             : 2;
+		u64 pkind                            : 6;
+		u64 chan                             : 12;
+		u64 errlev                           : 4;
+		u64 errcode                          : 8;
+		u64 l2m                              : 1;
+		u64 l2b                              : 1;
+		u64 l3m                              : 1;
+		u64 l3b                              : 1;
+		u64 eoh_ptr                          : 8;
+		u64 reserved_44_63                   : 20;
+		u64 action                           : 64;
+		u64 vtag_action                      : 64;
+		u64 la                               : 20;
+		u64 lb                               : 20;
+		u64 lc                               : 20;
+		u64 reserved_252_255                 : 4;
+		u64 ld                               : 20;
+		u64 le                               : 20;
+		u64 lf                               : 20;
+		u64 reserved_316_319                 : 4;
+		u64 lg                               : 20;
+		u64 lh                               : 20;
+		u64 reserved_360_383                 : 24;
+	} s;
+	/* struct cavm_npc_result_s_s cn; */
+};
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_active_pc
+ *
+ * NPC Interrupt-Timer Configuration Register
+ */
+union cavm_npc_af_active_pc {
+	u64 u;
+	struct cavm_npc_af_active_pc_s {
+		u64 active_pc                        : 64;
+	} s;
+	/* struct cavm_npc_af_active_pc_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_ACTIVE_PC(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_ACTIVE_PC(void)
+{
+	return 0x10;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_blk_rst
+ *
+ * NPC AF Block Reset Register
+ */
+union cavm_npc_af_blk_rst {
+	u64 u;
+	struct cavm_npc_af_blk_rst_s {
+		u64 rst                              : 1;
+		u64 reserved_1_62                    : 62;
+		u64 busy                             : 1;
+	} s;
+	/* struct cavm_npc_af_blk_rst_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_BLK_RST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_BLK_RST(void)
+{
+	return 0x40;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_cfg
+ *
+ * NPC AF General Configuration Register
+ */
+union cavm_npc_af_cfg {
+	u64 u;
+	struct cavm_npc_af_cfg_s {
+		u64 reserved_0_1                     : 2;
+		u64 cclk_force                       : 1;
+		u64 force_intf_clk_en                : 1;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cavm_npc_af_cfg_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_CFG(void)
+{
+	return 0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_const
+ *
+ * NPC AF Constants Register This register contains constants for
+ * software discovery.
+ */
+union cavm_npc_af_const {
+	u64 u;
+	struct cavm_npc_af_const_s {
+		u64 intfs                            : 4;
+		u64 lids                             : 4;
+		u64 kpus                             : 5;
+		u64 reserved_13_15                   : 3;
+		u64 mcam_bank_width                  : 10;
+		u64 reserved_26_27                   : 2;
+		u64 mcam_bank_depth                  : 16;
+		u64 mcam_banks                       : 4;
+		u64 match_stats                      : 16;
+	} s;
+	/* struct cavm_npc_af_const_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_CONST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_CONST(void)
+{
+	return 0x20;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_const1
+ *
+ * NPC AF Constants 1 Register This register contains constants for
+ * software discovery.
+ */
+union cavm_npc_af_const1 {
+	u64 u;
+	struct cavm_npc_af_const1_s {
+		u64 kpu_entries                      : 12;
+		u64 pkinds                           : 8;
+		u64 cpi_size                         : 16;
+		u64 reserved_36_63                   : 28;
+	} s;
+	/* struct cavm_npc_af_const1_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_CONST1(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_CONST1(void)
+{
+	return 0x30;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_cpi#_cfg
+ *
+ * NPC AF Channel Parse Index Table Registers
+ */
+union cavm_npc_af_cpix_cfg {
+	u64 u;
+	struct cavm_npc_af_cpix_cfg_s {
+		u64 padd                             : 4;
+		u64 reserved_4_63                    : 60;
+	} s;
+	/* struct cavm_npc_af_cpix_cfg_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_CPIX_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_CPIX_CFG(u64 a)
+{
+	return 0x200000 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_dbg_ctl
+ *
+ * NPC AF Debug Control Register This register controls the capture of
+ * debug information in NPC_AF_KPU()_DBG, NPC_AF_MCAM_DBG,
+ * NPC_AF_DBG_DATA() and NPC_AF_DBG_RESULT().
+ */
+union cavm_npc_af_dbg_ctl {
+	u64 u;
+	struct cavm_npc_af_dbg_ctl_s {
+		u64 continuous                       : 1;
+		u64 lkup_dbg                         : 1;
+		u64 intf_dbg                         : 4;
+		u64 reserved_6_63                    : 58;
+	} s;
+	/* struct cavm_npc_af_dbg_ctl_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_DBG_CTL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_DBG_CTL(void)
+{
+	return 0x3000000;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_dbg_data#
+ *
+ * NPC AF Debug Data Registers These registers contain the packet header
+ * data of the last packet/lookup whose debug information is captured by
+ * NPC_AF_DBG_CTL[INTF_DBG,LKUP_DBG].
+ */
+union cavm_npc_af_dbg_datax {
+	u64 u;
+	struct cavm_npc_af_dbg_datax_s {
+		u64 data                             : 64;
+	} s;
+	/* struct cavm_npc_af_dbg_datax_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_DBG_DATAX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_DBG_DATAX(u64 a)
+{
+	return 0x3001400 + 0x10 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_dbg_result#
+ *
+ * NPC AF Debug Result Registers These registers contain the result data
+ * of the last packet/lookup whose debug information is captured by
+ * NPC_AF_DBG_CTL[INTF_DBG,LKUP_DBG].
+ */
+union cavm_npc_af_dbg_resultx {
+	u64 u;
+	struct cavm_npc_af_dbg_resultx_s {
+		u64 data                             : 64;
+	} s;
+	/* struct cavm_npc_af_dbg_resultx_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_DBG_RESULTX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_DBG_RESULTX(u64 a)
+{
+	return 0x3001800 + 0x10 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_dbg_status
+ *
+ * NPC AF Debug Status Register
+ */
+union cavm_npc_af_dbg_status {
+	u64 u;
+	struct cavm_npc_af_dbg_status_s {
+		u64 done                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_npc_af_dbg_status_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_DBG_STATUS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_DBG_STATUS(void)
+{
+	return 0x3000010;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_dv_fc_scratch
+ *
+ * INTERNAL: NPC AF Scratch Register  Internal: This register is for
+ * internal DV purpose.
+ */
+union cavm_npc_af_dv_fc_scratch {
+	u64 u;
+	struct cavm_npc_af_dv_fc_scratch_s {
+		u64 it                               : 64;
+	} s;
+	/* struct cavm_npc_af_dv_fc_scratch_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_DV_FC_SCRATCH(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_DV_FC_SCRATCH(void)
+{
+	return 0x60;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_eco0
+ *
+ * INTERNAL: ECO 0 Register
+ */
+union cavm_npc_af_eco0 {
+	u64 u;
+	struct cavm_npc_af_eco0_s {
+		u64 eco_rw                           : 32;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cavm_npc_af_eco0_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_ECO0(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_ECO0(void)
+{
+	return 0x200;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_ikpu_err_ctl
+ *
+ * NPC AF Initial KPU Error Control Registers Similar to
+ * NPC_AF_KPU()_ERR_CTL, but specifies values captured in
+ * NPC_RESULT_S[ERRLEV,ERRCODE] for errors detected by the PKIND-based
+ * initial actions from NPC_AF_PKIND()_ACTION0 and
+ * NPC_AF_PKIND()_ACTION1. [DP_OFFSET_ERRCODE] from this register is
+ * never used.
+ */
+union cavm_npc_af_ikpu_err_ctl {
+	u64 u;
+	struct cavm_npc_af_ikpu_err_ctl_s {
+		u64 errlev                           : 4;
+		u64 dp_offset_errcode                : 8;
+		u64 ptr_advance_errcode              : 8;
+		u64 var_len_offset_errcode           : 8;
+		u64 reserved_28_63                   : 36;
+	} s;
+	/* struct cavm_npc_af_ikpu_err_ctl_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_IKPU_ERR_CTL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_IKPU_ERR_CTL(void)
+{
+	return 0x3000080;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_intf#_kex_cfg
+ *
+ * NPC AF Interface Key Extract Configuration Registers
+ */
+union cavm_npc_af_intfx_kex_cfg {
+	u64 u;
+	struct cavm_npc_af_intfx_kex_cfg_s {
+		u64 parse_nibble_ena                 : 31;
+		u64 reserved_31                      : 1;
+		u64 keyw                             : 3;
+		u64 reserved_35_63                   : 29;
+	} s;
+	/* struct cavm_npc_af_intfx_kex_cfg_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_INTFX_KEX_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_INTFX_KEX_CFG(u64 a)
+{
+	return 0x1010 + 0x100 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_intf#_ldata#_flags#_cfg
+ *
+ * NPC AF Interface Layer Data Flags Configuration Registers These
+ * registers control the extraction of layer data (LDATA) into the MCAM
+ * search key for each interface based on the FLAGS\<3:0\> bits of two
+ * layers selected by NPC_AF_KEX_LDATA()_FLAGS_CFG.
+ */
+union cavm_npc_af_intfx_ldatax_flagsx_cfg {
+	u64 u;
+	struct cavm_npc_af_intfx_ldatax_flagsx_cfg_s {
+		u64 key_offset                       : 6;
+		u64 reserved_6                       : 1;
+		u64 ena                              : 1;
+		u64 hdr_offset                       : 8;
+		u64 bytesm1                          : 4;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct cavm_npc_af_intfx_ldatax_flagsx_cfg_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_INTFX_LDATAX_FLAGSX_CFG(u64 a, u64 b, u64 c)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_INTFX_LDATAX_FLAGSX_CFG(u64 a, u64 b, u64 c)
+{
+	return 0x980000 + 0x10000 * a + 0x1000 * b + 8 * c;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_intf#_lid#_lt#_ld#_cfg
+ *
+ * NPC AF Interface Layer Data Extract Configuration Registers These
+ * registers control the extraction of layer data (LDATA) into the MCAM
+ * search key for each interface. Up to two LDATA fields can be extracted
+ * per layer (LID(0..7) indexed by NPC_LID_E), with up to 16 bytes per
+ * LDATA field. For each layer, the corresponding NPC_LAYER_INFO_S[LTYPE]
+ * value in NPC_RESULT_S is used as the LTYPE(0..15) index and select the
+ * associated LDATA(0..1) registers.  NPC_LAYER_INFO_S[LTYPE]=0x0 means
+ * the corresponding layer not parsed (invalid), so software should keep
+ * NPC_AF_INTF()_LID()_LT(0)_LD()_CFG[ENA] clear to disable extraction
+ * when LTYPE is zero.
+ */
+union cavm_npc_af_intfx_lidx_ltx_ldx_cfg {
+	u64 u;
+	struct cavm_npc_af_intfx_lidx_ltx_ldx_cfg_s {
+		u64 key_offset                       : 6;
+		u64 flags_ena                        : 1;
+		u64 ena                              : 1;
+		u64 hdr_offset                       : 8;
+		u64 bytesm1                          : 4;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct cavm_npc_af_intfx_lidx_ltx_ldx_cfg_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_INTFX_LIDX_LTX_LDX_CFG(u64 a, u64 b, u64 c, u64 d)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_INTFX_LIDX_LTX_LDX_CFG(u64 a, u64 b, u64 c, u64 d)
+{
+	return 0x900000 + 0x10000 * a + 0x1000 * b + 0x20 * c + 8 * d;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_intf#_miss_act
+ *
+ * NPC AF Interface MCAM Miss Action Data Registers When a combination of
+ * NPC_AF_MCAME()_BANK()_CAM()_* and NPC_AF_MCAME()_BANK()_CFG[ENA]
+ * yields an MCAM miss for a packet, this register specifies the packet's
+ * match action captured in NPC_RESULT_S[ACTION].
+ */
+union cavm_npc_af_intfx_miss_act {
+	u64 u;
+	struct cavm_npc_af_intfx_miss_act_s {
+		u64 action                           : 64;
+	} s;
+	/* struct cavm_npc_af_intfx_miss_act_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_INTFX_MISS_ACT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_INTFX_MISS_ACT(u64 a)
+{
+	return 0x1a00000 + 0x10 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_intf#_miss_stat_act
+ *
+ * NPC AF Interface MCAM Miss Stat Action Data Registers Used to
+ * optionally increment a NPC_AF_MATCH_STAT() counter when a packet
+ * misses an MCAM entry.
+ */
+union cavm_npc_af_intfx_miss_stat_act {
+	u64 u;
+	struct cavm_npc_af_intfx_miss_stat_act_s {
+		u64 stat_sel                         : 9;
+		u64 ena                              : 1;
+		u64 reserved_10_63                   : 54;
+	} s;
+	/* struct cavm_npc_af_intfx_miss_stat_act_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_INTFX_MISS_STAT_ACT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_INTFX_MISS_STAT_ACT(u64 a)
+{
+	return 0x1880040 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_intf#_miss_tag_act
+ *
+ * NPC AF Interface MCAM Miss VTag Action Data Registers When a
+ * combination of NPC_AF_MCAME()_BANK()_CAM()_* and
+ * NPC_AF_MCAME()_BANK()_CFG[ENA] yields an MCAM miss for a packet, this
+ * register specifies the packet's match Vtag action captured in
+ * NPC_RESULT_S[VTAG_ACTION].
+ */
+union cavm_npc_af_intfx_miss_tag_act {
+	u64 u;
+	struct cavm_npc_af_intfx_miss_tag_act_s {
+		u64 vtag_action                      : 64;
+	} s;
+	/* struct cavm_npc_af_intfx_miss_tag_act_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_INTFX_MISS_TAG_ACT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_INTFX_MISS_TAG_ACT(u64 a)
+{
+	return 0x1b00008 + 0x10 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_intf#_stat
+ *
+ * NPC AF Interface Statistics Registers Statistics per interface. Index
+ * enumerated by NPC_INTF_E.
+ */
+union cavm_npc_af_intfx_stat {
+	u64 u;
+	struct cavm_npc_af_intfx_stat_s {
+		u64 count                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_npc_af_intfx_stat_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_INTFX_STAT(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_INTFX_STAT(u64 a)
+{
+	return 0x2000800 + 0x10 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_kcam_scrub_ctl
+ *
+ * NPC AF KCAM Scrub Control Register
+ */
+union cavm_npc_af_kcam_scrub_ctl {
+	u64 u;
+	struct cavm_npc_af_kcam_scrub_ctl_s {
+		u64 ena                              : 1;
+		u64 reserved_1_7                     : 7;
+		u64 lp_dis                           : 1;
+		u64 reserved_9_15                    : 7;
+		u64 toth                             : 4;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct cavm_npc_af_kcam_scrub_ctl_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_KCAM_SCRUB_CTL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_KCAM_SCRUB_CTL(void)
+{
+	return 0xb0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_kex_ldata#_flags_cfg
+ *
+ * NPC AF Key Extract Layer Data Flags Configuration Register
+ */
+union cavm_npc_af_kex_ldatax_flags_cfg {
+	u64 u;
+	struct cavm_npc_af_kex_ldatax_flags_cfg_s {
+		u64 lid                              : 3;
+		u64 reserved_3_63                    : 61;
+	} s;
+	/* struct cavm_npc_af_kex_ldatax_flags_cfg_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_KEX_LDATAX_FLAGS_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_KEX_LDATAX_FLAGS_CFG(u64 a)
+{
+	return 0x800 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_kpu#_cfg
+ *
+ * NPC AF KPU Configuration Registers
+ */
+union cavm_npc_af_kpux_cfg {
+	u64 u;
+	struct cavm_npc_af_kpux_cfg_s {
+		u64 ena                              : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_npc_af_kpux_cfg_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_KPUX_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_KPUX_CFG(u64 a)
+{
+	return 0x500 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_kpu#_dbg
+ *
+ * NPC AF KPU Debug Registers This register contains information for the
+ * last packet/lookup for which debug is enabled by
+ * NPC_AF_DBG_CTL[INTF_DBG,LKUP_DBG]. The register contents are undefined
+ * and should be ignored for a software key lookup (NPC_AF_LKUP_CTL[OP] =
+ * NPC_LKUPOP_E::KEY)
+ */
+union cavm_npc_af_kpux_dbg {
+	u64 u;
+	struct cavm_npc_af_kpux_dbg_s {
+		u64 hit_entry                        : 8;
+		u64 byp                              : 1;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct cavm_npc_af_kpux_dbg_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_KPUX_DBG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_KPUX_DBG(u64 a)
+{
+	return 0x3000020 + 0x100 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_kpu#_entry#_action0
+ *
+ * NPC AF KPU Entry Action Data 0 Registers When a KPU's search data
+ * matches a KPU CAM entry in NPC_AF_KPU()_ENTRY()_CAM(), the
+ * corresponding entry action in NPC_AF_KPU()_ENTRY()_ACTION0 and
+ * NPC_AF_KPU()_ENTRY()_ACTION1 specifies the next state and operations
+ * to perform before exiting the KPU.
+ */
+union cavm_npc_af_kpux_entryx_action0 {
+	u64 u;
+	struct cavm_npc_af_kpux_entryx_action0_s {
+		u64 var_len_shift                    : 3;
+		u64 var_len_right                    : 1;
+		u64 var_len_mask                     : 8;
+		u64 var_len_offset                   : 8;
+		u64 ptr_advance                      : 8;
+		u64 capture_flags                    : 8;
+		u64 capture_ltype                    : 4;
+		u64 capture_lid                      : 3;
+		u64 reserved_43                      : 1;
+		u64 next_state                       : 8;
+		u64 parse_done                       : 1;
+		u64 capture_ena                      : 1;
+		u64 byp_count                        : 3;
+		u64 reserved_57_63                   : 7;
+	} s;
+	/* struct cavm_npc_af_kpux_entryx_action0_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_KPUX_ENTRYX_ACTION0(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_KPUX_ENTRYX_ACTION0(u64 a, u64 b)
+{
+	return 0x100020 + 0x4000 * a + 0x40 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_kpu#_entry#_action1
+ *
+ * NPC AF KPU Entry Action Data 0 Registers See
+ * NPC_AF_KPU()_ENTRY()_ACTION0.
+ */
+union cavm_npc_af_kpux_entryx_action1 {
+	u64 u;
+	struct cavm_npc_af_kpux_entryx_action1_s {
+		u64 dp0_offset                       : 8;
+		u64 dp1_offset                       : 8;
+		u64 dp2_offset                       : 8;
+		u64 errcode                          : 8;
+		u64 errlev                           : 4;
+		u64 reserved_36_63                   : 28;
+	} s;
+	/* struct cavm_npc_af_kpux_entryx_action1_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_KPUX_ENTRYX_ACTION1(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_KPUX_ENTRYX_ACTION1(u64 a, u64 b)
+{
+	return 0x100028 + 0x4000 * a + 0x40 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_kpu#_entry#_cam#
+ *
+ * NPC AF KPU Entry CAM Registers KPU comparison ternary data. The field
+ * values in NPC_AF_KPU()_ENTRY()_CAM() are ternary, where  each data bit
+ * of the search key matches as follows: _ [CAM(1)]\<n\>=0,
+ * [CAM(0)]\<n\>=0: Always match; search key data\<n\> don't care. _
+ * [CAM(1)]\<n\>=0, [CAM(0)]\<n\>=1: Match when search key data\<n\> ==
+ * 0. _ [CAM(1)]\<n\>=1, [CAM(0)]\<n\>=0: Match when search key data\<n\>
+ * == 1. _ [CAM(1)]\<n\>=1, [CAM(0)]\<n\>=1: Reserved.  The reserved
+ * combination is not allowed. Hardware suppresses any write to CAM(0) or
+ * CAM(1) that would result in the reserved combination for any CAM bit.
+ * The reset value for all non-reserved fields is all zeros for CAM(1)
+ * and all ones for CAM(0), matching a search key of all zeros.  Software
+ * must program a default entry for each KPU, e.g. by programming each
+ * KPU's last entry {b} (NPC_AF_KPU()_ENTRY({b})_CAM()) to always match
+ * all bits.
+ */
+union cavm_npc_af_kpux_entryx_camx {
+	u64 u;
+	struct cavm_npc_af_kpux_entryx_camx_s {
+		u64 dp0_data                         : 16;
+		u64 dp1_data                         : 16;
+		u64 dp2_data                         : 16;
+		u64 state                            : 8;
+		u64 reserved_56_63                   : 8;
+	} s;
+	/* struct cavm_npc_af_kpux_entryx_camx_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_KPUX_ENTRYX_CAMX(u64 a, u64 b, u64 c)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_KPUX_ENTRYX_CAMX(u64 a, u64 b, u64 c)
+{
+	return 0x100000 + 0x4000 * a + 0x40 * b + 8 * c;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_kpu#_entry_dis#
+ *
+ * NPC AF KPU Entry Disable Registers See NPC_AF_KPU()_ENTRY()_ACTION0.
+ */
+union cavm_npc_af_kpux_entry_disx {
+	u64 u;
+	struct cavm_npc_af_kpux_entry_disx_s {
+		u64 dis                              : 64;
+	} s;
+	/* struct cavm_npc_af_kpux_entry_disx_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_KPUX_ENTRY_DISX(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_KPUX_ENTRY_DISX(u64 a, u64 b)
+{
+	return 0x180000 + 0x40 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_kpu#_err_ctl
+ *
+ * NPC AF KPU Error Control Registers This register specifies values
+ * captured in NPC_RESULT_S[ERRLEV,ERRCODE] when errors are detected by a
+ * KPU.
+ */
+union cavm_npc_af_kpux_err_ctl {
+	u64 u;
+	struct cavm_npc_af_kpux_err_ctl_s {
+		u64 errlev                           : 4;
+		u64 dp_offset_errcode                : 8;
+		u64 ptr_advance_errcode              : 8;
+		u64 var_len_offset_errcode           : 8;
+		u64 reserved_28_63                   : 36;
+	} s;
+	/* struct cavm_npc_af_kpux_err_ctl_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_KPUX_ERR_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_KPUX_ERR_CTL(u64 a)
+{
+	return 0x30000a0 + 0x100 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_lkup_ctl
+ *
+ * NPC AF Software Lookup Control Registers
+ */
+union cavm_npc_af_lkup_ctl {
+	u64 u;
+	struct cavm_npc_af_lkup_ctl_s {
+		u64 intf                             : 2;
+		u64 pkind                            : 6;
+		u64 chan                             : 12;
+		u64 hdr_sizem1                       : 8;
+		u64 op                               : 3;
+		u64 exec                             : 1;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cavm_npc_af_lkup_ctl_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_LKUP_CTL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_LKUP_CTL(void)
+{
+	return 0x2000000;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_lkup_data#
+ *
+ * NPC AF Software Lookup Data Registers
+ */
+union cavm_npc_af_lkup_datax {
+	u64 u;
+	struct cavm_npc_af_lkup_datax_s {
+		u64 data                             : 64;
+	} s;
+	/* struct cavm_npc_af_lkup_datax_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_LKUP_DATAX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_LKUP_DATAX(u64 a)
+{
+	return 0x2000200 + 0x10 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_lkup_result#
+ *
+ * NPC AF Software Lookup Result Registers
+ */
+union cavm_npc_af_lkup_resultx {
+	u64 u;
+	struct cavm_npc_af_lkup_resultx_s {
+		u64 data                             : 64;
+	} s;
+	/* struct cavm_npc_af_lkup_resultx_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_LKUP_RESULTX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_LKUP_RESULTX(u64 a)
+{
+	return 0x2000400 + 0x10 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_match_stat#
+ *
+ * NPC AF Match Statistics Registers
+ */
+union cavm_npc_af_match_statx {
+	u64 u;
+	struct cavm_npc_af_match_statx_s {
+		u64 count                            : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_npc_af_match_statx_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_MATCH_STATX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_MATCH_STATX(u64 a)
+{
+	return 0x1880008 + 0x100 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcam_bank#_hit#
+ *
+ * NPC AF MCAM Bank Hit Registers
+ */
+union cavm_npc_af_mcam_bankx_hitx {
+	u64 u;
+	struct cavm_npc_af_mcam_bankx_hitx_s {
+		u64 hit                              : 64;
+	} s;
+	/* struct cavm_npc_af_mcam_bankx_hitx_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_MCAM_BANKX_HITX(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_MCAM_BANKX_HITX(u64 a, u64 b)
+{
+	return 0x1c80000 + 0x100 * a + 0x10 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcam_dbg
+ *
+ * NPC AF MCAM Debug Register This register contains information for the
+ * last packet/lookup for which debug is enabled by
+ * NPC_AF_DBG_CTL[INTF_DBG,LKUP_DBG].
+ */
+union cavm_npc_af_mcam_dbg {
+	u64 u;
+	struct cavm_npc_af_mcam_dbg_s {
+		u64 hit_entry                        : 10;
+		u64 reserved_10_11                   : 2;
+		u64 hit_bank                         : 2;
+		u64 reserved_14_15                   : 2;
+		u64 miss                             : 1;
+		u64 reserved_17_63                   : 47;
+	} s;
+	/* struct cavm_npc_af_mcam_dbg_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_MCAM_DBG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_MCAM_DBG(void)
+{
+	return 0x3001000;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcam_scrub_ctl
+ *
+ * NPC AF MCAM Scrub Control Register
+ */
+union cavm_npc_af_mcam_scrub_ctl {
+	u64 u;
+	struct cavm_npc_af_mcam_scrub_ctl_s {
+		u64 ena                              : 1;
+		u64 reserved_1_7                     : 7;
+		u64 lp_dis                           : 1;
+		u64 reserved_9_15                    : 7;
+		u64 toth                             : 4;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct cavm_npc_af_mcam_scrub_ctl_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_MCAM_SCRUB_CTL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_MCAM_SCRUB_CTL(void)
+{
+	return 0xa0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_action
+ *
+ * NPC AF MCAM Entry Bank Action Data Registers Specifies a packet's
+ * match action captured in NPC_RESULT_S[ACTION].  When an interface is
+ * configured to use the NPC_MCAM_KEY_X2_S search key format
+ * (NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X2), *
+ * NPC_AF_MCAME()_BANK(0)_ACTION/_TAG_ACT/_STAT_ACT are used if the
+ * search key matches NPC_AF_MCAME()_BANK(0..1)_CAM()_W*. *
+ * NPC_AF_MCAME()_BANK(2)_ACTION/_TAG_ACT/_STAT_ACT are used if the
+ * search key matches NPC_AF_MCAME()_BANK(2..3)_CAM()_W*. *
+ * NPC_AF_MCAME()_BANK(1,3)_ACTION/_TAG_ACT/_STAT_ACT are not used.  When
+ * an interface is configured to use the NPC_MCAM_KEY_X4_S search key
+ * format (NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X4): *
+ * NPC_AF_MCAME()_BANK(0)_ACTION/_TAG_ACT/_STAT_ACT are used if the
+ * search key matches NPC_AF_MCAME()_BANK(0..3)_CAM()_W*. *
+ * NPC_AF_MCAME()_BANK(1..3)_ACTION/_TAG_ACT/_STAT_ACT are not used.
+ */
+union cavm_npc_af_mcamex_bankx_action {
+	u64 u;
+	struct cavm_npc_af_mcamex_bankx_action_s {
+		u64 action                           : 64;
+	} s;
+	/* struct cavm_npc_af_mcamex_bankx_action_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_ACTION(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_ACTION(u64 a, u64 b)
+{
+	return 0x1900000 + 0x100 * a + 0x10 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_cam#_intf
+ *
+ * NPC AF MCAM Entry Bank CAM Data Interface Registers MCAM comparison
+ * ternary data interface word. The field values in
+ * NPC_AF_MCAME()_BANK()_CAM()_INTF, NPC_AF_MCAME()_BANK()_CAM()_W0 and
+ * NPC_AF_MCAME()_BANK()_CAM()_W1 are ternary, where  each data bit of
+ * the search key matches as follows: _ [CAM(1)]\<n\>=0, [CAM(0)]\<n\>=0:
+ * Always match; search key data\<n\> don't care. _ [CAM(1)]\<n\>=0,
+ * [CAM(0)]\<n\>=1: Match when search key data\<n\> == 0. _
+ * [CAM(1)]\<n\>=1, [CAM(0)]\<n\>=0: Match when search key data\<n\> ==
+ * 1. _ [CAM(1)]\<n\>=1, [CAM(0)]\<n\>=1: Reserved.  The reserved
+ * combination is not allowed. Hardware suppresses any write to CAM(0) or
+ * CAM(1) that would result in the reserved combination for any CAM bit.
+ * The reset value for all non-reserved fields in
+ * NPC_AF_MCAME()_BANK()_CAM()_INTF, NPC_AF_MCAME()_BANK()_CAM()_W0 and
+ * NPC_AF_MCAME()_BANK()_CAM()_W1 is all zeros for CAM(1) and all ones
+ * for CAM(0), matching a search key of all zeros.  When an interface is
+ * configured to use the NPC_MCAM_KEY_X1_S search key format
+ * (NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X1), the four banks of
+ * every MCAM entry are used as individual entries, each of which is
+ * independently compared with the search key as follows: _
+ * NPC_AF_MCAME()_BANK()_CAM()_INTF[INTF] corresponds to
+ * NPC_MCAM_KEY_X1_S[INTF]. _ NPC_AF_MCAME()_BANK()_CAM()_W0[MD]
+ * corresponds to NPC_MCAM_KEY_X1_S[KW0]. _
+ * NPC_AF_MCAME()_BANK()_CAM()_W1[MD] corresponds to
+ * NPC_MCAM_KEY_X1_S[KW1].  When an interface is configured to use the
+ * NPC_MCAM_KEY_X2_S search key format (NPC_AF_INTF()_KEX_CFG[KEYW] =
+ * NPC_MCAMKEYW_E::X2), banks 0-1 of every MCAM entry are used as one
+ * double-wide entry, banks 2-3 as a second double-wide entry, and each
+ * double-wide entry is independently compared with the search key as
+ * follows: _ NPC_AF_MCAME()_BANK(0,2)_CAM()_INTF[INTF] corresponds to
+ * NPC_MCAM_KEY_X2_S[INTF]. _ NPC_AF_MCAME()_BANK(0,2)_CAM()_W0[MD]
+ * corresponds to NPC_MCAM_KEY_X2_S[KW0]. _
+ * NPC_AF_MCAME()_BANK(0,2)_CAM()_W1[MD] corresponds to
+ * NPC_MCAM_KEY_X2_S[KW1]\<47:0\>. _
+ * NPC_AF_MCAME()_BANK(1,3)_CAM()_INTF[INTF] corresponds to
+ * NPC_MCAM_KEY_X2_S[INTF]. _
+ * NPC_AF_MCAME()_BANK(1,3)_CAM()_W0[MD]\<15:0\> corresponds to
+ * NPC_MCAM_KEY_X2_S[KW1]\<63:48\>. _
+ * NPC_AF_MCAME()_BANK(1,3)_CAM()_W0[MD]\<63:16\> corresponds to
+ * NPC_MCAM_KEY_X2_S[KW2]\<47:0\>. _
+ * NPC_AF_MCAME()_BANK(1,3)_CAM()_W1[MD]\<15:0\> corresponds to
+ * NPC_MCAM_KEY_X2_S[KW2]\<63:48\>. _
+ * NPC_AF_MCAME()_BANK(1,3)_CAM()_W1[MD]\<47:16\> corresponds to
+ * NPC_MCAM_KEY_X2_S[KW3]\<31:0\>.  When an interface is configured to
+ * use the NPC_MCAM_KEY_X4_S search key format
+ * (NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X4), the four banks of
+ * every MCAM entry are used as a single quad-wide entry that is compared
+ * with the search key as follows: _
+ * NPC_AF_MCAME()_BANK(0)_CAM()_INTF[INTF] corresponds to
+ * NPC_MCAM_KEY_X4_S[INTF]. _ NPC_AF_MCAME()_BANK(0)_CAM()_W0[MD]
+ * corresponds to NPC_MCAM_KEY_X4_S[KW0]. _
+ * NPC_AF_MCAME()_BANK(0)_CAM()_W1[MD] corresponds to
+ * NPC_MCAM_KEY_X4_S[KW1]\<47:0\>. _
+ * NPC_AF_MCAME()_BANK(1)_CAM()_INTF[INTF] corresponds to
+ * NPC_MCAM_KEY_X4_S[INTF]. _ NPC_AF_MCAME()_BANK(1)_CAM()_W0[MD]\<15:0\>
+ * corresponds to NPC_MCAM_KEY_X4_S[KW1]\<63:48\>. _
+ * NPC_AF_MCAME()_BANK(1)_CAM()_W0[MD]\<63:16\> corresponds to
+ * NPC_MCAM_KEY_X4_S[KW2]\<47:0\>. _
+ * NPC_AF_MCAME()_BANK(1)_CAM()_W1[MD]\<15:0\> corresponds to
+ * NPC_MCAM_KEY_X4_S[KW2]\<63:48\>. _
+ * NPC_AF_MCAME()_BANK(1)_CAM()_W1[MD]\<47:16\> corresponds to
+ * NPC_MCAM_KEY_X4_S[KW3]\<31:0\>. _
+ * NPC_AF_MCAME()_BANK(2)_CAM()_INTF[INTF] corresponds to
+ * NPC_MCAM_KEY_X4_S[INTF]. _ NPC_AF_MCAME()_BANK(2)_CAM()_W0[MD]\<31:0\>
+ * corresponds to NPC_MCAM_KEY_X4_S[KW3]\<63:32\>. _
+ * NPC_AF_MCAME()_BANK(2)_CAM()_W0[MD]\<63:32\> corresponds to
+ * NPC_MCAM_KEY_X4_S[KW4]\<31:0\>. _
+ * NPC_AF_MCAME()_BANK(2)_CAM()_W1[MD]\<31:0\> corresponds to
+ * NPC_MCAM_KEY_X4_S[KW4]\<63:32\>. _
+ * NPC_AF_MCAME()_BANK(2)_CAM()_W1[MD]\<47:32\> corresponds to
+ * NPC_MCAM_KEY_X4_S[KW5]\<15:0\>. _
+ * NPC_AF_MCAME()_BANK(3)_CAM()_INTF[INTF] corresponds to
+ * NPC_MCAM_KEY_X4_S[INTF]. _ NPC_AF_MCAME()_BANK(3)_CAM()_W0[MD]\<47:0\>
+ * corresponds to NPC_MCAM_KEY_X4_S[KW5]\<63:16\>. _
+ * NPC_AF_MCAME()_BANK(3)_CAM()_W0[MD]\<63:48\> corresponds to
+ * NPC_MCAM_KEY_X4_S[KW6]\<15:0\>. _ NPC_AF_MCAME()_BANK(3)_CAM()_W1[MD]
+ * corresponds to NPC_MCAM_KEY_X4_S[KW6]\<63:16\>.  Note that for the X2
+ * and X4 formats, a wide entry will not match unless the INTF fields
+ * from the associated two or four banks match the INTF value from the
+ * search key.  For the X1 and X2 formats, a match in a lower-numbered
+ * bank takes priority over a match in any higher numbered banks. Within
+ * each bank, the lowest numbered matching entry takes priority over any
+ * higher numbered entry.
+ */
+union cavm_npc_af_mcamex_bankx_camx_intf {
+	u64 u;
+	struct cavm_npc_af_mcamex_bankx_camx_intf_s {
+		u64 intf                             : 2;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cavm_npc_af_mcamex_bankx_camx_intf_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_CAMX_INTF(u64 a, u64 b, u64 c)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_CAMX_INTF(u64 a, u64 b, u64 c)
+{
+	return 0x1000000 + 0x400 * a + 0x40 * b + 8 * c;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_cam#_w0
+ *
+ * NPC AF MCAM Entry Bank CAM Data Word 0 Registers MCAM comparison
+ * ternary data word 0. See NPC_AF_MCAME()_BANK()_CAM()_INTF.
+ */
+union cavm_npc_af_mcamex_bankx_camx_w0 {
+	u64 u;
+	struct cavm_npc_af_mcamex_bankx_camx_w0_s {
+		u64 md                               : 64;
+	} s;
+	/* struct cavm_npc_af_mcamex_bankx_camx_w0_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_CAMX_W0(u64 a, u64 b, u64 c)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_CAMX_W0(u64 a, u64 b, u64 c)
+{
+	return 0x1000010 + 0x400 * a + 0x40 * b + 8 * c;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_cam#_w1
+ *
+ * NPC AF MCAM Entry Bank Data Word 1 Registers MCAM comparison ternary
+ * data word 1. See NPC_AF_MCAME()_BANK()_CAM()_INTF.
+ */
+union cavm_npc_af_mcamex_bankx_camx_w1 {
+	u64 u;
+	struct cavm_npc_af_mcamex_bankx_camx_w1_s {
+		u64 md                               : 48;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_npc_af_mcamex_bankx_camx_w1_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_CAMX_W1(u64 a, u64 b, u64 c)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_CAMX_W1(u64 a, u64 b, u64 c)
+{
+	return 0x1000020 + 0x400 * a + 0x40 * b + 8 * c;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_cfg
+ *
+ * NPC AF MCAM Entry Bank Configuration Registers
+ */
+union cavm_npc_af_mcamex_bankx_cfg {
+	u64 u;
+	struct cavm_npc_af_mcamex_bankx_cfg_s {
+		u64 ena                              : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_npc_af_mcamex_bankx_cfg_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_CFG(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_CFG(u64 a, u64 b)
+{
+	return 0x1800000 + 0x100 * a + 0x10 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_stat_act
+ *
+ * NPC AF MCAM Entry Bank Statistics Action Registers Used to optionally
+ * increment a NPC_AF_MATCH_STAT() counter when a packet matches an MCAM
+ * entry. See also NPC_AF_MCAME()_BANK()_ACTION.
+ */
+union cavm_npc_af_mcamex_bankx_stat_act {
+	u64 u;
+	struct cavm_npc_af_mcamex_bankx_stat_act_s {
+		u64 stat_sel                         : 9;
+		u64 ena                              : 1;
+		u64 reserved_10_63                   : 54;
+	} s;
+	/* struct cavm_npc_af_mcamex_bankx_stat_act_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_STAT_ACT(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_STAT_ACT(u64 a, u64 b)
+{
+	return 0x1880000 + 0x100 * a + 0x10 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_mcame#_bank#_tag_act
+ *
+ * NPC AF MCAM Entry Bank VTag Action Data Registers Specifies a packet's
+ * match Vtag action captured in NPC_RESULT_S[VTAG_ACTION]. See also
+ * NPC_AF_MCAME()_BANK()_ACTION.
+ */
+union cavm_npc_af_mcamex_bankx_tag_act {
+	u64 u;
+	struct cavm_npc_af_mcamex_bankx_tag_act_s {
+		u64 vtag_action                      : 64;
+	} s;
+	/* struct cavm_npc_af_mcamex_bankx_tag_act_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_TAG_ACT(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_MCAMEX_BANKX_TAG_ACT(u64 a, u64 b)
+{
+	return 0x1900008 + 0x100 * a + 0x10 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_pck_cfg
+ *
+ * NPC AF Protocol Check Configuration Register
+ */
+union cavm_npc_af_pck_cfg {
+	u64 u;
+	struct cavm_npc_af_pck_cfg_s {
+		u64 reserved_0                       : 1;
+		u64 iip4_cksum                       : 1;
+		u64 oip4_cksum                       : 1;
+		u64 reserved_3                       : 1;
+		u64 l3b                              : 1;
+		u64 l3m                              : 1;
+		u64 l2b                              : 1;
+		u64 l2m                              : 1;
+		u64 reserved_8_23                    : 16;
+		u64 iip4_cksum_errcode               : 8;
+		u64 oip4_cksum_errcode               : 8;
+		u64 reserved_40_63                   : 24;
+	} s;
+	/* struct cavm_npc_af_pck_cfg_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_PCK_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_PCK_CFG(void)
+{
+	return 0x600;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_pck_def_iip4
+ *
+ * NPC AF Protocol Check Inner IPv4 Definition Register Provides layer
+ * information used by the protocol checker to identify an inner IPv4
+ * header.
+ */
+union cavm_npc_af_pck_def_iip4 {
+	u64 u;
+	struct cavm_npc_af_pck_def_iip4_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct cavm_npc_af_pck_def_iip4_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_PCK_DEF_IIP4(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_PCK_DEF_IIP4(void)
+{
+	return 0x640;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_pck_def_oip4
+ *
+ * NPC AF Protocol Check Outer IPv4 Definition Register Provides layer
+ * information used by the protocol checker to identify an outer IPv4
+ * header.
+ */
+union cavm_npc_af_pck_def_oip4 {
+	u64 u;
+	struct cavm_npc_af_pck_def_oip4_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct cavm_npc_af_pck_def_oip4_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_PCK_DEF_OIP4(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_PCK_DEF_OIP4(void)
+{
+	return 0x620;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_pck_def_oip6
+ *
+ * NPC AF Protocol Check Outer IPv6 Definition Register Provides layer
+ * information used by the protocol checker to identify an outer IPv6
+ * header. [LID] must have the same value as NPC_AF_PCK_DEF_OIP4[LID].
+ */
+union cavm_npc_af_pck_def_oip6 {
+	u64 u;
+	struct cavm_npc_af_pck_def_oip6_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct cavm_npc_af_pck_def_oip6_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_PCK_DEF_OIP6(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_PCK_DEF_OIP6(void)
+{
+	return 0x630;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_pck_def_ol2
+ *
+ * NPC AF Protocol Check Outer L2 Definition Register Provides layer
+ * information used by the protocol checker to identify an outer L2
+ * header.
+ */
+union cavm_npc_af_pck_def_ol2 {
+	u64 u;
+	struct cavm_npc_af_pck_def_ol2_s {
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_11_63                   : 53;
+	} s;
+	/* struct cavm_npc_af_pck_def_ol2_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_PCK_DEF_OL2(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_PCK_DEF_OL2(void)
+{
+	return 0x610;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_pkind#_action0
+ *
+ * NPC AF Port Kind Action Data 0 Registers NPC_AF_PKIND()_ACTION0 and
+ * NPC_AF_PKIND()_ACTION1 specify the initial parse state and operations
+ * to perform before entering KPU 0.
+ */
+union cavm_npc_af_pkindx_action0 {
+	u64 u;
+	struct cavm_npc_af_pkindx_action0_s {
+		u64 var_len_shift                    : 3;
+		u64 var_len_right                    : 1;
+		u64 var_len_mask                     : 8;
+		u64 var_len_offset                   : 8;
+		u64 ptr_advance                      : 8;
+		u64 capture_flags                    : 8;
+		u64 capture_ltype                    : 4;
+		u64 capture_lid                      : 3;
+		u64 reserved_43                      : 1;
+		u64 next_state                       : 8;
+		u64 parse_done                       : 1;
+		u64 capture_ena                      : 1;
+		u64 byp_count                        : 3;
+		u64 reserved_57_63                   : 7;
+	} s;
+	/* struct cavm_npc_af_pkindx_action0_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_PKINDX_ACTION0(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_PKINDX_ACTION0(u64 a)
+{
+	return 0x80000 + 0x40 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_pkind#_action1
+ *
+ * NPC AF Port Kind Action Data 1 Registers NPC_AF_PKIND()_ACTION0 and
+ * NPC_AF_PKIND()_ACTION1 specify the initial parse state and operations
+ * to perform before entering KPU 0.
+ */
+union cavm_npc_af_pkindx_action1 {
+	u64 u;
+	struct cavm_npc_af_pkindx_action1_s {
+		u64 dp0_offset                       : 8;
+		u64 dp1_offset                       : 8;
+		u64 dp2_offset                       : 8;
+		u64 errcode                          : 8;
+		u64 errlev                           : 4;
+		u64 reserved_36_63                   : 28;
+	} s;
+	/* struct cavm_npc_af_pkindx_action1_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_PKINDX_ACTION1(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_PKINDX_ACTION1(u64 a)
+{
+	return 0x80008 + 0x40 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) npc_af_pkind#_cpi_def#
+ *
+ * NPC AF Port Kind Channel Parse Index Definition Registers These
+ * registers specify the layer information and algorithm to compute a
+ * packet's channel parse index (CPI), which provides a port to channel
+ * adder for calculating NPC_RESULT_S[CHAN].  There are two CPI
+ * definitions per port kind, allowing the CPI computation to use two
+ * possible layer definitions in the parsed packet, e.g. DiffServ DSCP
+ * from either IPv4 or IPv6 header.  CPI pseudocode: \<pre\> for (i = 0;
+ * i \< 2; i++) {    cpi_def = NPC_AF_PKIND()_CPI_DEF(i);    LX = LA, LB,
+ * ..., or LH as selected by cpi_def[LID];     if (cpi_def[ENA]        &&
+ * ((cpi_def[LTYPE_MATCH] & cpi_def[LTYPE_MASK])             ==
+ * (NPC_RESULT_S[LX[LTYPE]] & cpi_def[LTYPE_MASK]))        &&
+ * ((cpi_def[FLAGS_MATCH] & cpi_def[FLAGS_MASK])             ==
+ * (NPC_RESULT_S[LX[FLAGS]] & cpi_def[FLAGS_MASK])))    {       // Found
+ * matching layer       nibble_offset = (2*NPC_RESULT_S[LX[LPTR]]) +
+ * cpi_def[ADD_OFFSET];       add_byte = byte at nibble_offset from start
+ * of packet;       cpi_add = (add_byte & cpi_def[ADD_MASK]) \>\>
+ * cpi_def[ADD_SHIFT];       cpi = cpi_def[CPI_BASE] + cpi_add;
+ * NPC_RESULT_S[CHAN] += NPC_AF_CPI(cpi)_CFG[PADD];       break;    } }
+ * \</pre\>
+ */
+union cavm_npc_af_pkindx_cpi_defx {
+	u64 u;
+	struct cavm_npc_af_pkindx_cpi_defx_s {
+		u64 cpi_base                         : 10;
+		u64 reserved_10_11                   : 2;
+		u64 add_shift                        : 3;
+		u64 reserved_15                      : 1;
+		u64 add_mask                         : 8;
+		u64 add_offset                       : 8;
+		u64 flags_mask                       : 8;
+		u64 flags_match                      : 8;
+		u64 ltype_mask                       : 4;
+		u64 ltype_match                      : 4;
+		u64 lid                              : 3;
+		u64 reserved_59_62                   : 4;
+		u64 ena                              : 1;
+	} s;
+	/* struct cavm_npc_af_pkindx_cpi_defx_s cn; */
+};
+
+static inline u64 CAVM_NPC_AF_PKINDX_CPI_DEFX(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_NPC_AF_PKINDX_CPI_DEFX(u64 a, u64 b)
+{
+	return 0x80020 + 0x40 * a + 8 * b;
+}
+
+#endif /* __CAVM_CSRS_NPC_H__ */
diff --git a/drivers/net/octeontx2/cavm-csrs-rvu.h b/drivers/net/octeontx2/cavm-csrs-rvu.h
new file mode 100644
index 0000000..0555e9c
--- /dev/null
+++ b/drivers/net/octeontx2/cavm-csrs-rvu.h
@@ -0,0 +1,2243 @@
+#ifndef __CAVM_CSRS_RVU_H__
+#define __CAVM_CSRS_RVU_H__
+/* This file is auto-generated.  Do not edit */
+
+/***********************license start***********************************
+* Copyright (C) 2019 Marvell International Ltd.
+* SPDX-License-Identifier: BSD-3-Clause
+* https://spdx.org/licenses
+***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * Configuration and status register (CSR) address and type definitions for
+ * Cavium RVU.
+ *
+ * This file is auto generated.  Do not edit.
+ *
+ */
+
+/**
+ * Enumeration rvu_af_int_vec_e
+ *
+ * RVU Admin Function Interrupt Vector Enumeration Enumerates the MSI-X
+ * interrupt vectors. Internal: RVU maintains the state of these vectors
+ * internally, and generates GIB messages for it without accessing the
+ * MSI-X table region in LLC/DRAM.
+ */
+#define CAVM_RVU_AF_INT_VEC_E_GEN (3)
+#define CAVM_RVU_AF_INT_VEC_E_MBOX (4)
+#define CAVM_RVU_AF_INT_VEC_E_PFFLR (1)
+#define CAVM_RVU_AF_INT_VEC_E_PFME (2)
+#define CAVM_RVU_AF_INT_VEC_E_POISON (0)
+
+/**
+ * Enumeration rvu_bar_e
+ *
+ * RVU Base Address Register Enumeration Enumerates the base address
+ * registers. Internal: For documentation only.
+ */
+#define CAVM_RVU_BAR_E_RVU_PFX_BAR0(a) (0x840000000000ll + 0x1000000000ll * (a))
+#define CAVM_RVU_BAR_E_RVU_PFX_BAR0_SIZE 0x10000000ull
+#define CAVM_RVU_BAR_E_RVU_PFX_FUNCX_BAR2(a, b)	\
+	(0x840200000000ll + 0x1000000000ll * (a) + 0x2000000ll * (b))
+#define CAVM_RVU_BAR_E_RVU_PFX_FUNCX_BAR2_SIZE 0x100000ull
+
+/**
+ * Enumeration rvu_block_addr_e
+ *
+ * RVU Block Address Enumeration Enumerates addressing of RVU resource
+ * blocks within each RVU BAR, i.e. values of RVU_FUNC_ADDR_S[BLOCK] and
+ * RVU_AF_ADDR_S[BLOCK].  CNXXXX may not implement all enumerated blocks.
+ * Software can read RVU_PF/RVU_VF_BLOCK_ADDR()_DISC[IMP] to discover
+ * which blocks are implemented and enabled.
+ */
+#define CAVM_RVU_BLOCK_ADDR_E_CPTX(a) (0xa + (a))
+#define CAVM_RVU_BLOCK_ADDR_E_LMT (1)
+#define CAVM_RVU_BLOCK_ADDR_E_NDCX(a) (0xc + (a))
+#define CAVM_RVU_BLOCK_ADDR_E_NIXX(a) (4 + (a))
+#define CAVM_RVU_BLOCK_ADDR_E_NPA (3)
+#define CAVM_RVU_BLOCK_ADDR_E_NPC (6)
+#define CAVM_RVU_BLOCK_ADDR_E_RX(a) (0 + (a))
+#define CAVM_RVU_BLOCK_ADDR_E_REEX(a) (0x14 + (a))
+#define CAVM_RVU_BLOCK_ADDR_E_RVUM (0)
+#define CAVM_RVU_BLOCK_ADDR_E_SSO (7)
+#define CAVM_RVU_BLOCK_ADDR_E_SSOW (8)
+#define CAVM_RVU_BLOCK_ADDR_E_TIM (9)
+
+/**
+ * Enumeration rvu_block_type_e
+ *
+ * RVU Block Type Enumeration Enumerates values of
+ * RVU_PF/RVU_VF_BLOCK_ADDR()_DISC[BTYPE].
+ */
+#define CAVM_RVU_BLOCK_TYPE_E_CPT (9)
+#define CAVM_RVU_BLOCK_TYPE_E_DDF (0xb)
+#define CAVM_RVU_BLOCK_TYPE_E_LMT (2)
+#define CAVM_RVU_BLOCK_TYPE_E_NDC (0xa)
+#define CAVM_RVU_BLOCK_TYPE_E_NIX (3)
+#define CAVM_RVU_BLOCK_TYPE_E_NPA (4)
+#define CAVM_RVU_BLOCK_TYPE_E_NPC (5)
+#define CAVM_RVU_BLOCK_TYPE_E_RAD (0xd)
+#define CAVM_RVU_BLOCK_TYPE_E_REE (0xe)
+#define CAVM_RVU_BLOCK_TYPE_E_RVUM (0)
+#define CAVM_RVU_BLOCK_TYPE_E_SSO (6)
+#define CAVM_RVU_BLOCK_TYPE_E_SSOW (7)
+#define CAVM_RVU_BLOCK_TYPE_E_TIM (8)
+#define CAVM_RVU_BLOCK_TYPE_E_ZIP (0xc)
+
+/**
+ * Enumeration rvu_bus_lf_e
+ *
+ * INTERNAL: RVU Bus LF Range Enumeration  Enumerates the LF range for
+ * the RVU bus. Internal: This is an enum used in csr3 virtual equations.
+ */
+#define CAVM_RVU_BUS_LF_E_RVU_BUS_LFX(a) (0 + 0x2000000 * (a))
+
+/**
+ * Enumeration rvu_bus_lf_slot_e
+ *
+ * INTERNAL: RVU Bus LF Slot Range Enumeration  Enumerates the LF and
+ * Slot range for the RVU bus. Internal: This is an enum used in csr3
+ * virtual equations.
+ */
+#define CAVM_RVU_BUS_LF_SLOT_E_RVU_BUS_LFX_SLOTX(a, b)	\
+	(0 + 0x2000000 * (a) + 0x1000 * (b))
+
+/**
+ * Enumeration rvu_bus_pf_e
+ *
+ * INTERNAL: RVU Bus PF Range Enumeration  Enumerates the PF range for
+ * the RVU bus. Internal: This is an enum used in csr3 virtual equations.
+ */
+#define CAVM_RVU_BUS_PF_E_RVU_BUS_PFX(a) (0ll + 0x1000000000ll * (a))
+
+/**
+ * Enumeration rvu_bus_pfvf_e
+ *
+ * INTERNAL: RVU Bus PFVF Range Enumeration  Enumerates the PF and VF
+ * ranges for the RVU bus. Internal: This is an enum used in csr3 virtual
+ * equations.
+ */
+#define CAVM_RVU_BUS_PFVF_E_RVU_BUS_PFX(a) (0 + 0x2000000 * (a))
+#define CAVM_RVU_BUS_PFVF_E_RVU_BUS_VFX(a) (0 + 0x2000000 * (a))
+
+/**
+ * Enumeration rvu_busbar_e
+ *
+ * INTERNAL: RVU Bus Base Address Region Enumeration  Enumerates the base
+ * address region for the RVU bus. Internal: This is an enum used in csr3
+ * virtual equations.
+ */
+#define CAVM_RVU_BUSBAR_E_RVU_BUSBAR0 (0)
+#define CAVM_RVU_BUSBAR_E_RVU_BUSBAR2 (0x200000000ll)
+
+/**
+ * Enumeration rvu_busdid_e
+ *
+ * INTERNAL: RVU Bus DID Enumeration  Enumerates the DID offset for the
+ * RVU bus. Internal: This is an enum used in csr3 virtual equations.
+ */
+#define CAVM_RVU_BUSDID_E_RVU_BUSDID (0x840000000000ll)
+
+/**
+ * Enumeration rvu_pf_int_vec_e
+ *
+ * RVU PF Interrupt Vector Enumeration Enumerates the MSI-X interrupt
+ * vectors.
+ */
+#define CAVM_RVU_PF_INT_VEC_E_AFPF_MBOX (6)
+#define CAVM_RVU_PF_INT_VEC_E_VFFLRX(a) (0 + (a))
+#define CAVM_RVU_PF_INT_VEC_E_VFMEX(a) (2 + (a))
+#define CAVM_RVU_PF_INT_VEC_E_VFPF_MBOXX(a) (4 + (a))
+
+/**
+ * Enumeration rvu_vf_int_vec_e
+ *
+ * RVU VF Interrupt Vector Enumeration Enumerates the MSI-X interrupt
+ * vectors.
+ */
+#define CAVM_RVU_VF_INT_VEC_E_MBOX (0)
+
+/**
+ * Structure rvu_af_addr_s
+ *
+ * RVU Admin Function Register Address Structure Address format for
+ * accessing shared Admin Function (AF) registers in RVU PF BAR0. These
+ * registers may be accessed by all RVU PFs whose
+ * RVU_PRIV_PF()_CFG[AF_ENA] bit is set.
+ */
+union cavm_rvu_af_addr_s {
+	u64 u;
+	struct cavm_rvu_af_addr_s_s {
+		u64 addr                             : 28;
+		u64 block                            : 5;
+		u64 reserved_33_63                   : 31;
+	} s;
+	/* struct cavm_rvu_af_addr_s_s cn; */
+};
+
+/**
+ * Structure rvu_func_addr_s
+ *
+ * RVU Function-unique Address Structure Address format for accessing
+ * function-unique registers in RVU PF/FUNC BAR2.
+ */
+union cavm_rvu_func_addr_s {
+	u32 u;
+	struct cavm_rvu_func_addr_s_s {
+		u32 addr                             : 12;
+		u32 lf_slot                          : 8;
+		u32 block                            : 5;
+		u32 reserved_25_31                   : 7;
+	} s;
+	/* struct cavm_rvu_func_addr_s_s cn; */
+};
+
+/**
+ * Structure rvu_msix_vec_s
+ *
+ * RVU MSI-X Vector Structure Format of entries in the RVU MSI-X table
+ * region in LLC/DRAM. See RVU_PRIV_PF()_MSIX_CFG.
+ */
+union cavm_rvu_msix_vec_s {
+	u64 u[2];
+	struct cavm_rvu_msix_vec_s_s {
+		u64 addr                             : 64;
+		u64 data                             : 32;
+		u64 mask                             : 1;
+		u64 pend                             : 1;
+		u64 reserved_98_127                  : 30;
+	} s;
+	/* struct cavm_rvu_msix_vec_s_s cn; */
+};
+
+/**
+ * Structure rvu_pf_func_s
+ *
+ * RVU PF Function Identification Structure Identifies an RVU PF/VF, and
+ * format of *_PRIV_LF()_CFG[PF_FUNC] in RVU resource blocks, e.g.
+ * NPA_PRIV_LF()_CFG[PF_FUNC].  Internal: Also used for PF/VF
+ * identification on inter-coprocessor hardware interfaces (NPA, SSO,
+ * CPT, ...).
+ */
+union cavm_rvu_pf_func_s {
+	u32 u;
+	struct cavm_rvu_pf_func_s_s {
+		u32 func                             : 10;
+		u32 pf                               : 6;
+		u32 reserved_16_31                   : 16;
+	} s;
+	/* struct cavm_rvu_pf_func_s_s cn; */
+};
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_afpf#_mbox#
+ *
+ * RVU Admin Function AF/PF Mailbox Registers
+ */
+union cavm_rvu_af_afpfx_mboxx {
+	u64 u;
+	struct cavm_rvu_af_afpfx_mboxx_s {
+		u64 data                             : 64;
+	} s;
+	/* struct cavm_rvu_af_afpfx_mboxx_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_AFPFX_MBOXX(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_AFPFX_MBOXX(u64 a, u64 b)
+{
+	return 0x2000 + 0x10 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_bar2_alias#
+ *
+ * INTERNAL: RVU Admin Function  BAR2 Alias Registers  These registers
+ * alias to the RVU BAR2 registers for the PF and function selected by
+ * RVU_AF_BAR2_SEL[PF_FUNC].  Internal: Not implemented. Placeholder for
+ * bug33464.
+ */
+union cavm_rvu_af_bar2_aliasx {
+	u64 u;
+	struct cavm_rvu_af_bar2_aliasx_s {
+		u64 data                             : 64;
+	} s;
+	/* struct cavm_rvu_af_bar2_aliasx_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_BAR2_ALIASX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_BAR2_ALIASX(u64 a)
+{
+	return 0x9100000 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_bar2_sel
+ *
+ * INTERNAL: RVU Admin Function BAR2 Select Register  This register
+ * configures BAR2 accesses from the RVU_AF_BAR2_ALIAS() registers in
+ * BAR0. Internal: Not implemented. Placeholder for bug33464.
+ */
+union cavm_rvu_af_bar2_sel {
+	u64 u;
+	struct cavm_rvu_af_bar2_sel_s {
+		u64 alias_pf_func                    : 16;
+		u64 alias_ena                        : 1;
+		u64 reserved_17_63                   : 47;
+	} s;
+	/* struct cavm_rvu_af_bar2_sel_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_BAR2_SEL(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_BAR2_SEL(void)
+{
+	return 0x9000000;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_blk_rst
+ *
+ * RVU Master Admin Function Block Reset Register
+ */
+union cavm_rvu_af_blk_rst {
+	u64 u;
+	struct cavm_rvu_af_blk_rst_s {
+		u64 rst                              : 1;
+		u64 reserved_1_62                    : 62;
+		u64 busy                             : 1;
+	} s;
+	/* struct cavm_rvu_af_blk_rst_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_BLK_RST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_BLK_RST(void)
+{
+	return 0x30;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_bp_test
+ *
+ * INTERNAL: RVUM Backpressure Test Registers
+ */
+union cavm_rvu_af_bp_test {
+	u64 u;
+	struct cavm_rvu_af_bp_test_s {
+		u64 lfsr_freq                        : 12;
+		u64 reserved_12_15                   : 4;
+		u64 bp_cfg                           : 16;
+		u64 enable                           : 8;
+		u64 reserved_40_63                   : 24;
+	} s;
+	/* struct cavm_rvu_af_bp_test_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_BP_TEST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_BP_TEST(void)
+{
+	return 0x4000;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_eco
+ *
+ * INTERNAL: RVU Admin Function ECO Register
+ */
+union cavm_rvu_af_eco {
+	u64 u;
+	struct cavm_rvu_af_eco_s {
+		u64 eco_rw                           : 32;
+		u64 reserved_32_63                   : 32;
+	} s;
+	/* struct cavm_rvu_af_eco_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_ECO(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_ECO(void)
+{
+	return 0x20;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_gen_int
+ *
+ * RVU Admin Function General Interrupt Register This register contains
+ * General interrupt summary bits.
+ */
+union cavm_rvu_af_gen_int {
+	u64 u;
+	struct cavm_rvu_af_gen_int_s {
+		u64 unmapped                         : 1;
+		u64 msix_fault                       : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cavm_rvu_af_gen_int_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_GEN_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_GEN_INT(void)
+{
+	return 0x120;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_gen_int_ena_w1c
+ *
+ * RVU Admin Function General Interrupt Enable Clear Register This
+ * register clears interrupt enable bits.
+ */
+union cavm_rvu_af_gen_int_ena_w1c {
+	u64 u;
+	struct cavm_rvu_af_gen_int_ena_w1c_s {
+		u64 unmapped                         : 1;
+		u64 msix_fault                       : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cavm_rvu_af_gen_int_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_GEN_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_GEN_INT_ENA_W1C(void)
+{
+	return 0x138;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_gen_int_ena_w1s
+ *
+ * RVU Admin Function General Interrupt Enable Set Register This register
+ * sets interrupt enable bits.
+ */
+union cavm_rvu_af_gen_int_ena_w1s {
+	u64 u;
+	struct cavm_rvu_af_gen_int_ena_w1s_s {
+		u64 unmapped                         : 1;
+		u64 msix_fault                       : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cavm_rvu_af_gen_int_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_GEN_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_GEN_INT_ENA_W1S(void)
+{
+	return 0x130;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_gen_int_w1s
+ *
+ * RVU Admin Function General Interrupt Set Register This register sets
+ * interrupt bits.
+ */
+union cavm_rvu_af_gen_int_w1s {
+	u64 u;
+	struct cavm_rvu_af_gen_int_w1s_s {
+		u64 unmapped                         : 1;
+		u64 msix_fault                       : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cavm_rvu_af_gen_int_w1s_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_GEN_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_GEN_INT_W1S(void)
+{
+	return 0x128;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_hwvf_rst
+ *
+ * RVU Admin Function Hardware VF Reset Register
+ */
+union cavm_rvu_af_hwvf_rst {
+	u64 u;
+	struct cavm_rvu_af_hwvf_rst_s {
+		u64 hwvf                             : 8;
+		u64 reserved_8_11                    : 4;
+		u64 exec                             : 1;
+		u64 reserved_13_63                   : 51;
+	} s;
+	/* struct cavm_rvu_af_hwvf_rst_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_HWVF_RST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_HWVF_RST(void)
+{
+	return 0x2850;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_msixtr_base
+ *
+ * RVU Admin Function MSI-X Table Region Base-Address Register
+ */
+union cavm_rvu_af_msixtr_base {
+	u64 u;
+	struct cavm_rvu_af_msixtr_base_s {
+		u64 reserved_0_6                     : 7;
+		u64 addr                             : 46;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct cavm_rvu_af_msixtr_base_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_MSIXTR_BASE(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_MSIXTR_BASE(void)
+{
+	return 0x10;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pf_bar4_addr
+ *
+ * RVU Admin Function PF BAR4 Address Registers
+ */
+union cavm_rvu_af_pf_bar4_addr {
+	u64 u;
+	struct cavm_rvu_af_pf_bar4_addr_s {
+		u64 reserved_0_15                    : 16;
+		u64 addr                             : 48;
+	} s;
+	/* struct cavm_rvu_af_pf_bar4_addr_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_PF_BAR4_ADDR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_PF_BAR4_ADDR(void)
+{
+	return 0x40;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pf_rst
+ *
+ * RVU Admin Function PF Reset Register
+ */
+union cavm_rvu_af_pf_rst {
+	u64 u;
+	struct cavm_rvu_af_pf_rst_s {
+		u64 pf                               : 4;
+		u64 reserved_4_11                    : 8;
+		u64 exec                             : 1;
+		u64 reserved_13_63                   : 51;
+	} s;
+	/* struct cavm_rvu_af_pf_rst_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_PF_RST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_PF_RST(void)
+{
+	return 0x2840;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pfaf_mbox_int
+ *
+ * RVU Admin Function PF to AF Mailbox Interrupt Registers
+ */
+union cavm_rvu_af_pfaf_mbox_int {
+	u64 u;
+	struct cavm_rvu_af_pfaf_mbox_int_s {
+		u64 mbox                             : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_rvu_af_pfaf_mbox_int_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_PFAF_MBOX_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_PFAF_MBOX_INT(void)
+{
+	return 0x2880;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pfaf_mbox_int_ena_w1c
+ *
+ * RVU Admin Function PF to AF Mailbox Interrupt Enable Clear Registers
+ * This register clears interrupt enable bits.
+ */
+union cavm_rvu_af_pfaf_mbox_int_ena_w1c {
+	u64 u;
+	struct cavm_rvu_af_pfaf_mbox_int_ena_w1c_s {
+		u64 mbox                             : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_rvu_af_pfaf_mbox_int_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_PFAF_MBOX_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_PFAF_MBOX_INT_ENA_W1C(void)
+{
+	return 0x2898;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pfaf_mbox_int_ena_w1s
+ *
+ * RVU Admin Function PF to AF Mailbox Interrupt Enable Set Registers
+ * This register sets interrupt enable bits.
+ */
+union cavm_rvu_af_pfaf_mbox_int_ena_w1s {
+	u64 u;
+	struct cavm_rvu_af_pfaf_mbox_int_ena_w1s_s {
+		u64 mbox                             : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_rvu_af_pfaf_mbox_int_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_PFAF_MBOX_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_PFAF_MBOX_INT_ENA_W1S(void)
+{
+	return 0x2890;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pfaf_mbox_int_w1s
+ *
+ * RVU Admin Function PF to AF Mailbox Interrupt Set Registers This
+ * register sets interrupt bits.
+ */
+union cavm_rvu_af_pfaf_mbox_int_w1s {
+	u64 u;
+	struct cavm_rvu_af_pfaf_mbox_int_w1s_s {
+		u64 mbox                             : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_rvu_af_pfaf_mbox_int_w1s_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_PFAF_MBOX_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_PFAF_MBOX_INT_W1S(void)
+{
+	return 0x2888;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pfflr_int
+ *
+ * RVU Admin Function PF Function Level Reset Interrupt Registers
+ */
+union cavm_rvu_af_pfflr_int {
+	u64 u;
+	struct cavm_rvu_af_pfflr_int_s {
+		u64 flr                              : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_rvu_af_pfflr_int_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_PFFLR_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_PFFLR_INT(void)
+{
+	return 0x28a0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pfflr_int_ena_w1c
+ *
+ * RVU Admin Function PF Function Level Reset Interrupt Enable Clear
+ * Registers This register clears interrupt enable bits.
+ */
+union cavm_rvu_af_pfflr_int_ena_w1c {
+	u64 u;
+	struct cavm_rvu_af_pfflr_int_ena_w1c_s {
+		u64 flr                              : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_rvu_af_pfflr_int_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_PFFLR_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_PFFLR_INT_ENA_W1C(void)
+{
+	return 0x28b8;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pfflr_int_ena_w1s
+ *
+ * RVU Admin Function PF Function Level Reset Interrupt Enable Set
+ * Registers This register sets interrupt enable bits.
+ */
+union cavm_rvu_af_pfflr_int_ena_w1s {
+	u64 u;
+	struct cavm_rvu_af_pfflr_int_ena_w1s_s {
+		u64 flr                              : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_rvu_af_pfflr_int_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_PFFLR_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_PFFLR_INT_ENA_W1S(void)
+{
+	return 0x28b0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pfflr_int_w1s
+ *
+ * RVU Admin Function PF Function Level Reset Interrupt Set Registers
+ * This register sets interrupt bits.
+ */
+union cavm_rvu_af_pfflr_int_w1s {
+	u64 u;
+	struct cavm_rvu_af_pfflr_int_w1s_s {
+		u64 flr                              : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_rvu_af_pfflr_int_w1s_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_PFFLR_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_PFFLR_INT_W1S(void)
+{
+	return 0x28a8;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pfme_int
+ *
+ * RVU Admin Function PF Bus Master Enable Interrupt Registers
+ */
+union cavm_rvu_af_pfme_int {
+	u64 u;
+	struct cavm_rvu_af_pfme_int_s {
+		u64 me                               : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_rvu_af_pfme_int_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_PFME_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_PFME_INT(void)
+{
+	return 0x28c0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pfme_int_ena_w1c
+ *
+ * RVU Admin Function PF Bus Master Enable Interrupt Enable Clear
+ * Registers This register clears interrupt enable bits.
+ */
+union cavm_rvu_af_pfme_int_ena_w1c {
+	u64 u;
+	struct cavm_rvu_af_pfme_int_ena_w1c_s {
+		u64 me                               : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_rvu_af_pfme_int_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_PFME_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_PFME_INT_ENA_W1C(void)
+{
+	return 0x28d8;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pfme_int_ena_w1s
+ *
+ * RVU Admin Function PF Bus Master Enable Interrupt Enable Set Registers
+ * This register sets interrupt enable bits.
+ */
+union cavm_rvu_af_pfme_int_ena_w1s {
+	u64 u;
+	struct cavm_rvu_af_pfme_int_ena_w1s_s {
+		u64 me                               : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_rvu_af_pfme_int_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_PFME_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_PFME_INT_ENA_W1S(void)
+{
+	return 0x28d0;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pfme_int_w1s
+ *
+ * RVU Admin Function PF Bus Master Enable Interrupt Set Registers This
+ * register sets interrupt bits.
+ */
+union cavm_rvu_af_pfme_int_w1s {
+	u64 u;
+	struct cavm_rvu_af_pfme_int_w1s_s {
+		u64 me                               : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_rvu_af_pfme_int_w1s_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_PFME_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_PFME_INT_W1S(void)
+{
+	return 0x28c8;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pfme_status
+ *
+ * RVU Admin Function PF Bus Master Enable Status Registers
+ */
+union cavm_rvu_af_pfme_status {
+	u64 u;
+	struct cavm_rvu_af_pfme_status_s {
+		u64 me                               : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_rvu_af_pfme_status_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_PFME_STATUS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_PFME_STATUS(void)
+{
+	return 0x2800;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pftrpend
+ *
+ * RVU Admin Function PF Transaction Pending Registers
+ */
+union cavm_rvu_af_pftrpend {
+	u64 u;
+	struct cavm_rvu_af_pftrpend_s {
+		u64 trpend                           : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_rvu_af_pftrpend_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_PFTRPEND(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_PFTRPEND(void)
+{
+	return 0x2810;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_pftrpend_w1s
+ *
+ * RVU Admin Function PF Transaction Pending Set Registers This register
+ * reads or sets bits.
+ */
+union cavm_rvu_af_pftrpend_w1s {
+	u64 u;
+	struct cavm_rvu_af_pftrpend_w1s_s {
+		u64 trpend                           : 16;
+		u64 reserved_16_63                   : 48;
+	} s;
+	/* struct cavm_rvu_af_pftrpend_w1s_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_PFTRPEND_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_PFTRPEND_W1S(void)
+{
+	return 0x2820;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_ras
+ *
+ * RVU Admin Function RAS Interrupt Register This register is intended
+ * for delivery of RAS events to the SCP, so should be ignored by OS
+ * drivers.
+ */
+union cavm_rvu_af_ras {
+	u64 u;
+	struct cavm_rvu_af_ras_s {
+		u64 msix_poison                      : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_rvu_af_ras_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_RAS(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_RAS(void)
+{
+	return 0x100;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_ras_ena_w1c
+ *
+ * RVU Admin Function RAS Interrupt Enable Clear Register This register
+ * clears interrupt enable bits.
+ */
+union cavm_rvu_af_ras_ena_w1c {
+	u64 u;
+	struct cavm_rvu_af_ras_ena_w1c_s {
+		u64 msix_poison                      : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_rvu_af_ras_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_RAS_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_RAS_ENA_W1C(void)
+{
+	return 0x118;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_ras_ena_w1s
+ *
+ * RVU Admin Function RAS Interrupt Enable Set Register This register
+ * sets interrupt enable bits.
+ */
+union cavm_rvu_af_ras_ena_w1s {
+	u64 u;
+	struct cavm_rvu_af_ras_ena_w1s_s {
+		u64 msix_poison                      : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_rvu_af_ras_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_RAS_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_RAS_ENA_W1S(void)
+{
+	return 0x110;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_af_ras_w1s
+ *
+ * RVU Admin Function RAS Interrupt Set Register This register sets
+ * interrupt bits.
+ */
+union cavm_rvu_af_ras_w1s {
+	u64 u;
+	struct cavm_rvu_af_ras_w1s_s {
+		u64 msix_poison                      : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_rvu_af_ras_w1s_s cn; */
+};
+
+static inline u64 CAVM_RVU_AF_RAS_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_AF_RAS_W1S(void)
+{
+	return 0x108;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_block_addr#_disc
+ *
+ * RVU PF Block Address Discovery Registers These registers allow each PF
+ * driver to discover block resources that are provisioned to its PF. The
+ * register's BLOCK_ADDR index is enumerated by RVU_BLOCK_ADDR_E.
+ */
+union cavm_rvu_pf_block_addrx_disc {
+	u64 u;
+	struct cavm_rvu_pf_block_addrx_disc_s {
+		u64 num_lfs                          : 9;
+		u64 reserved_9_10                    : 2;
+		u64 imp                              : 1;
+		u64 rid                              : 8;
+		u64 btype                            : 8;
+		u64 reserved_28_63                   : 36;
+	} s;
+	/* struct cavm_rvu_pf_block_addrx_disc_s cn; */
+};
+
+static inline u64 CAVM_RVU_PF_BLOCK_ADDRX_DISC(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PF_BLOCK_ADDRX_DISC(u64 a)
+{
+	return 0x200 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_int
+ *
+ * RVU PF Interrupt Registers
+ */
+union cavm_rvu_pf_int {
+	u64 u;
+	struct cavm_rvu_pf_int_s {
+		u64 mbox                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_rvu_pf_int_s cn; */
+};
+
+static inline u64 CAVM_RVU_PF_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PF_INT(void)
+{
+	return 0xc20;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_int_ena_w1c
+ *
+ * RVU PF Interrupt Enable Clear Register This register clears interrupt
+ * enable bits.
+ */
+union cavm_rvu_pf_int_ena_w1c {
+	u64 u;
+	struct cavm_rvu_pf_int_ena_w1c_s {
+		u64 mbox                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_rvu_pf_int_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_RVU_PF_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PF_INT_ENA_W1C(void)
+{
+	return 0xc38;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_int_ena_w1s
+ *
+ * RVU PF Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
+ */
+union cavm_rvu_pf_int_ena_w1s {
+	u64 u;
+	struct cavm_rvu_pf_int_ena_w1s_s {
+		u64 mbox                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_rvu_pf_int_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_RVU_PF_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PF_INT_ENA_W1S(void)
+{
+	return 0xc30;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_int_w1s
+ *
+ * RVU PF Interrupt Set Register This register sets interrupt bits.
+ */
+union cavm_rvu_pf_int_w1s {
+	u64 u;
+	struct cavm_rvu_pf_int_w1s_s {
+		u64 mbox                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_rvu_pf_int_w1s_s cn; */
+};
+
+static inline u64 CAVM_RVU_PF_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PF_INT_W1S(void)
+{
+	return 0xc28;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_msix_pba#
+ *
+ * RVU PF MSI-X Pending-Bit-Array Registers This register is the MSI-X PF
+ * PBA table.
+ */
+union cavm_rvu_pf_msix_pbax {
+	u64 u;
+	struct cavm_rvu_pf_msix_pbax_s {
+		u64 pend                             : 64;
+	} s;
+	/* struct cavm_rvu_pf_msix_pbax_s cn; */
+};
+
+static inline u64 CAVM_RVU_PF_MSIX_PBAX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PF_MSIX_PBAX(u64 a)
+{
+	return 0xf0000 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_msix_vec#_addr
+ *
+ * RVU PF MSI-X Vector-Table Address Registers These registers and
+ * RVU_PF_MSIX_VEC()_CTL form the PF MSI-X vector table. The number of
+ * MSI-X vectors for a given PF is specified by
+ * RVU_PRIV_PF()_MSIX_CFG[PF_MSIXT_SIZEM1] (plus 1).  Software must do a
+ * read after any writes to the MSI-X vector table to ensure that the
+ * writes have completed before interrupts are generated to the modified
+ * vectors.
+ */
+union cavm_rvu_pf_msix_vecx_addr {
+	u64 u;
+	struct cavm_rvu_pf_msix_vecx_addr_s {
+		u64 secvec                           : 1;
+		u64 reserved_1                       : 1;
+		u64 addr                             : 51;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct cavm_rvu_pf_msix_vecx_addr_s cn; */
+};
+
+static inline u64 CAVM_RVU_PF_MSIX_VECX_ADDR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PF_MSIX_VECX_ADDR(u64 a)
+{
+	return 0x80000 + 0x10 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_msix_vec#_ctl
+ *
+ * RVU PF MSI-X Vector-Table Control and Data Registers These registers
+ * and RVU_PF_MSIX_VEC()_ADDR form the PF MSI-X vector table.
+ */
+union cavm_rvu_pf_msix_vecx_ctl {
+	u64 u;
+	struct cavm_rvu_pf_msix_vecx_ctl_s {
+		u64 data                             : 32;
+		u64 mask                             : 1;
+		u64 reserved_33_63                   : 31;
+	} s;
+	/* struct cavm_rvu_pf_msix_vecx_ctl_s cn; */
+};
+
+static inline u64 CAVM_RVU_PF_MSIX_VECX_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PF_MSIX_VECX_CTL(u64 a)
+{
+	return 0x80008 + 0x10 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_pfaf_mbox#
+ *
+ * RVU PF/AF Mailbox Registers
+ */
+union cavm_rvu_pf_pfaf_mboxx {
+	u64 u;
+	struct cavm_rvu_pf_pfaf_mboxx_s {
+		u64 data                             : 64;
+	} s;
+	/* struct cavm_rvu_pf_pfaf_mboxx_s cn; */
+};
+
+static inline u64 CAVM_RVU_PF_PFAF_MBOXX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PF_PFAF_MBOXX(u64 a)
+{
+	return 0xc00 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vf#_pfvf_mbox#
+ *
+ * RVU PF/VF Mailbox Registers
+ */
+union cavm_rvu_pf_vfx_pfvf_mboxx {
+	u64 u;
+	struct cavm_rvu_pf_vfx_pfvf_mboxx_s {
+		u64 data                             : 64;
+	} s;
+	/* struct cavm_rvu_pf_vfx_pfvf_mboxx_s cn; */
+};
+
+static inline u64 CAVM_RVU_PF_VFX_PFVF_MBOXX(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PF_VFX_PFVF_MBOXX(u64 a, u64 b)
+{
+	return 0 + 0x1000 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vf_bar4_addr
+ *
+ * RVU PF VF BAR4 Address Registers
+ */
+union cavm_rvu_pf_vf_bar4_addr {
+	u64 u;
+	struct cavm_rvu_pf_vf_bar4_addr_s {
+		u64 reserved_0_15                    : 16;
+		u64 addr                             : 48;
+	} s;
+	/* struct cavm_rvu_pf_vf_bar4_addr_s cn; */
+};
+
+static inline u64 CAVM_RVU_PF_VF_BAR4_ADDR(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PF_VF_BAR4_ADDR(void)
+{
+	return 0x10;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vfflr_int#
+ *
+ * RVU PF VF Function Level Reset Interrupt Registers
+ */
+union cavm_rvu_pf_vfflr_intx {
+	u64 u;
+	struct cavm_rvu_pf_vfflr_intx_s {
+		u64 flr                              : 64;
+	} s;
+	/* struct cavm_rvu_pf_vfflr_intx_s cn; */
+};
+
+static inline u64 CAVM_RVU_PF_VFFLR_INTX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PF_VFFLR_INTX(u64 a)
+{
+	return 0x900 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vfflr_int_ena_w1c#
+ *
+ * RVU PF VF Function Level Reset Interrupt Enable Clear Registers This
+ * register clears interrupt enable bits.
+ */
+union cavm_rvu_pf_vfflr_int_ena_w1cx {
+	u64 u;
+	struct cavm_rvu_pf_vfflr_int_ena_w1cx_s {
+		u64 flr                              : 64;
+	} s;
+	/* struct cavm_rvu_pf_vfflr_int_ena_w1cx_s cn; */
+};
+
+static inline u64 CAVM_RVU_PF_VFFLR_INT_ENA_W1CX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PF_VFFLR_INT_ENA_W1CX(u64 a)
+{
+	return 0x960 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vfflr_int_ena_w1s#
+ *
+ * RVU PF VF Function Level Reset Interrupt Enable Set Registers This
+ * register sets interrupt enable bits.
+ */
+union cavm_rvu_pf_vfflr_int_ena_w1sx {
+	u64 u;
+	struct cavm_rvu_pf_vfflr_int_ena_w1sx_s {
+		u64 flr                              : 64;
+	} s;
+	/* struct cavm_rvu_pf_vfflr_int_ena_w1sx_s cn; */
+};
+
+static inline u64 CAVM_RVU_PF_VFFLR_INT_ENA_W1SX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PF_VFFLR_INT_ENA_W1SX(u64 a)
+{
+	return 0x940 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vfflr_int_w1s#
+ *
+ * RVU PF VF Function Level Reset Interrupt Set Registers This register
+ * sets interrupt bits.
+ */
+union cavm_rvu_pf_vfflr_int_w1sx {
+	u64 u;
+	struct cavm_rvu_pf_vfflr_int_w1sx_s {
+		u64 flr                              : 64;
+	} s;
+	/* struct cavm_rvu_pf_vfflr_int_w1sx_s cn; */
+};
+
+static inline u64 CAVM_RVU_PF_VFFLR_INT_W1SX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PF_VFFLR_INT_W1SX(u64 a)
+{
+	return 0x920 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vfme_int#
+ *
+ * RVU PF VF Bus Master Enable Interrupt Registers
+ */
+union cavm_rvu_pf_vfme_intx {
+	u64 u;
+	struct cavm_rvu_pf_vfme_intx_s {
+		u64 me                               : 64;
+	} s;
+	/* struct cavm_rvu_pf_vfme_intx_s cn; */
+};
+
+static inline u64 CAVM_RVU_PF_VFME_INTX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PF_VFME_INTX(u64 a)
+{
+	return 0x980 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vfme_int_ena_w1c#
+ *
+ * RVU PF VF Bus Master Enable Interrupt Enable Clear Registers This
+ * register clears interrupt enable bits.
+ */
+union cavm_rvu_pf_vfme_int_ena_w1cx {
+	u64 u;
+	struct cavm_rvu_pf_vfme_int_ena_w1cx_s {
+		u64 me                               : 64;
+	} s;
+	/* struct cavm_rvu_pf_vfme_int_ena_w1cx_s cn; */
+};
+
+static inline u64 CAVM_RVU_PF_VFME_INT_ENA_W1CX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PF_VFME_INT_ENA_W1CX(u64 a)
+{
+	return 0x9e0 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vfme_int_ena_w1s#
+ *
+ * RVU PF VF Bus Master Enable Interrupt Enable Set Registers This
+ * register sets interrupt enable bits.
+ */
+union cavm_rvu_pf_vfme_int_ena_w1sx {
+	u64 u;
+	struct cavm_rvu_pf_vfme_int_ena_w1sx_s {
+		u64 me                               : 64;
+	} s;
+	/* struct cavm_rvu_pf_vfme_int_ena_w1sx_s cn; */
+};
+
+static inline u64 CAVM_RVU_PF_VFME_INT_ENA_W1SX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PF_VFME_INT_ENA_W1SX(u64 a)
+{
+	return 0x9c0 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vfme_int_w1s#
+ *
+ * RVU PF VF Bus Master Enable Interrupt Set Registers This register sets
+ * interrupt bits.
+ */
+union cavm_rvu_pf_vfme_int_w1sx {
+	u64 u;
+	struct cavm_rvu_pf_vfme_int_w1sx_s {
+		u64 me                               : 64;
+	} s;
+	/* struct cavm_rvu_pf_vfme_int_w1sx_s cn; */
+};
+
+static inline u64 CAVM_RVU_PF_VFME_INT_W1SX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PF_VFME_INT_W1SX(u64 a)
+{
+	return 0x9a0 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vfme_status#
+ *
+ * RVU PF VF Bus Master Enable Status Registers
+ */
+union cavm_rvu_pf_vfme_statusx {
+	u64 u;
+	struct cavm_rvu_pf_vfme_statusx_s {
+		u64 me                               : 64;
+	} s;
+	/* struct cavm_rvu_pf_vfme_statusx_s cn; */
+};
+
+static inline u64 CAVM_RVU_PF_VFME_STATUSX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PF_VFME_STATUSX(u64 a)
+{
+	return 0x800 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vfpf_mbox_int#
+ *
+ * RVU VF to PF Mailbox Interrupt Registers
+ */
+union cavm_rvu_pf_vfpf_mbox_intx {
+	u64 u;
+	struct cavm_rvu_pf_vfpf_mbox_intx_s {
+		u64 mbox                             : 64;
+	} s;
+	/* struct cavm_rvu_pf_vfpf_mbox_intx_s cn; */
+};
+
+static inline u64 CAVM_RVU_PF_VFPF_MBOX_INTX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PF_VFPF_MBOX_INTX(u64 a)
+{
+	return 0x880 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vfpf_mbox_int_ena_w1c#
+ *
+ * RVU VF to PF Mailbox Interrupt Enable Clear Registers This register
+ * clears interrupt enable bits.
+ */
+union cavm_rvu_pf_vfpf_mbox_int_ena_w1cx {
+	u64 u;
+	struct cavm_rvu_pf_vfpf_mbox_int_ena_w1cx_s {
+		u64 mbox                             : 64;
+	} s;
+	/* struct cavm_rvu_pf_vfpf_mbox_int_ena_w1cx_s cn; */
+};
+
+static inline u64 CAVM_RVU_PF_VFPF_MBOX_INT_ENA_W1CX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PF_VFPF_MBOX_INT_ENA_W1CX(u64 a)
+{
+	return 0x8e0 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vfpf_mbox_int_ena_w1s#
+ *
+ * RVU VF to PF Mailbox Interrupt Enable Set Registers This register sets
+ * interrupt enable bits.
+ */
+union cavm_rvu_pf_vfpf_mbox_int_ena_w1sx {
+	u64 u;
+	struct cavm_rvu_pf_vfpf_mbox_int_ena_w1sx_s {
+		u64 mbox                             : 64;
+	} s;
+	/* struct cavm_rvu_pf_vfpf_mbox_int_ena_w1sx_s cn; */
+};
+
+static inline u64 CAVM_RVU_PF_VFPF_MBOX_INT_ENA_W1SX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PF_VFPF_MBOX_INT_ENA_W1SX(u64 a)
+{
+	return 0x8c0 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vfpf_mbox_int_w1s#
+ *
+ * RVU VF to PF Mailbox Interrupt Set Registers This register sets
+ * interrupt bits.
+ */
+union cavm_rvu_pf_vfpf_mbox_int_w1sx {
+	u64 u;
+	struct cavm_rvu_pf_vfpf_mbox_int_w1sx_s {
+		u64 mbox                             : 64;
+	} s;
+	/* struct cavm_rvu_pf_vfpf_mbox_int_w1sx_s cn; */
+};
+
+static inline u64 CAVM_RVU_PF_VFPF_MBOX_INT_W1SX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PF_VFPF_MBOX_INT_W1SX(u64 a)
+{
+	return 0x8a0 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vftrpend#
+ *
+ * RVU PF VF Transaction Pending Registers
+ */
+union cavm_rvu_pf_vftrpendx {
+	u64 u;
+	struct cavm_rvu_pf_vftrpendx_s {
+		u64 trpend                           : 64;
+	} s;
+	/* struct cavm_rvu_pf_vftrpendx_s cn; */
+};
+
+static inline u64 CAVM_RVU_PF_VFTRPENDX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PF_VFTRPENDX(u64 a)
+{
+	return 0x820 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR2) rvu_pf_vftrpend_w1s#
+ *
+ * RVU PF VF Transaction Pending Set Registers This register reads or
+ * sets bits.
+ */
+union cavm_rvu_pf_vftrpend_w1sx {
+	u64 u;
+	struct cavm_rvu_pf_vftrpend_w1sx_s {
+		u64 trpend                           : 64;
+	} s;
+	/* struct cavm_rvu_pf_vftrpend_w1sx_s cn; */
+};
+
+static inline u64 CAVM_RVU_PF_VFTRPEND_W1SX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PF_VFTRPEND_W1SX(u64 a)
+{
+	return 0x840 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_active_pc
+ *
+ * RVU Active Program Counter Register
+ */
+union cavm_rvu_priv_active_pc {
+	u64 u;
+	struct cavm_rvu_priv_active_pc_s {
+		u64 active_pc                        : 64;
+	} s;
+	/* struct cavm_rvu_priv_active_pc_s cn; */
+};
+
+static inline u64 CAVM_RVU_PRIV_ACTIVE_PC(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PRIV_ACTIVE_PC(void)
+{
+	return 0x8000030;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_block_type#_rev
+ *
+ * RVU Privileged Block Type Revision Registers These registers are used
+ * by configuration software to specify the revision ID of each block
+ * type enumerated by RVU_BLOCK_TYPE_E, to assist VF/PF software
+ * discovery.
+ */
+union cavm_rvu_priv_block_typex_rev {
+	u64 u;
+	struct cavm_rvu_priv_block_typex_rev_s {
+		u64 rid                              : 8;
+		u64 reserved_8_63                    : 56;
+	} s;
+	/* struct cavm_rvu_priv_block_typex_rev_s cn; */
+};
+
+static inline u64 CAVM_RVU_PRIV_BLOCK_TYPEX_REV(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PRIV_BLOCK_TYPEX_REV(u64 a)
+{
+	return 0x8000400 + 8 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_clk_cfg
+ *
+ * RVU Privileged General Configuration Register
+ */
+union cavm_rvu_priv_clk_cfg {
+	u64 u;
+	struct cavm_rvu_priv_clk_cfg_s {
+		u64 blk_clken                        : 1;
+		u64 ncbi_clken                       : 1;
+		u64 reserved_2_63                    : 62;
+	} s;
+	/* struct cavm_rvu_priv_clk_cfg_s cn; */
+};
+
+static inline u64 CAVM_RVU_PRIV_CLK_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PRIV_CLK_CFG(void)
+{
+	return 0x8000020;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_const
+ *
+ * RVU Privileged Constants Register This register contains constants for
+ * software discovery.
+ */
+union cavm_rvu_priv_const {
+	u64 u;
+	struct cavm_rvu_priv_const_s {
+		u64 max_msix                         : 20;
+		u64 hwvfs                            : 12;
+		u64 pfs                              : 8;
+		u64 max_vfs_per_pf                   : 8;
+		u64 reserved_48_63                   : 16;
+	} s;
+	/* struct cavm_rvu_priv_const_s cn; */
+};
+
+static inline u64 CAVM_RVU_PRIV_CONST(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PRIV_CONST(void)
+{
+	return 0x8000000;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_gen_cfg
+ *
+ * RVU Privileged General Configuration Register
+ */
+union cavm_rvu_priv_gen_cfg {
+	u64 u;
+	struct cavm_rvu_priv_gen_cfg_s {
+		u64 lock                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_rvu_priv_gen_cfg_s cn; */
+};
+
+static inline u64 CAVM_RVU_PRIV_GEN_CFG(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PRIV_GEN_CFG(void)
+{
+	return 0x8000010;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_hwvf#_cpt#_cfg
+ *
+ * RVU Privileged Hardware VF CPT Configuration Registers Similar to
+ * RVU_PRIV_HWVF()_NIX()_CFG, but for CPT({a}) block.
+ */
+union cavm_rvu_priv_hwvfx_cptx_cfg {
+	u64 u;
+	struct cavm_rvu_priv_hwvfx_cptx_cfg_s {
+		u64 num_lfs                          : 9;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct cavm_rvu_priv_hwvfx_cptx_cfg_s cn; */
+};
+
+static inline u64 CAVM_RVU_PRIV_HWVFX_CPTX_CFG(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PRIV_HWVFX_CPTX_CFG(u64 a, u64 b)
+{
+	return 0x8001350 + 0x10000 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_hwvf#_int_cfg
+ *
+ * RVU Privileged Hardware VF Interrupt Configuration Registers
+ */
+union cavm_rvu_priv_hwvfx_int_cfg {
+	u64 u;
+	struct cavm_rvu_priv_hwvfx_int_cfg_s {
+		u64 msix_offset                      : 11;
+		u64 reserved_11                      : 1;
+		u64 msix_size                        : 8;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct cavm_rvu_priv_hwvfx_int_cfg_s cn; */
+};
+
+static inline u64 CAVM_RVU_PRIV_HWVFX_INT_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PRIV_HWVFX_INT_CFG(u64 a)
+{
+	return 0x8001280 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_hwvf#_nix#_cfg
+ *
+ * RVU Privileged Hardware VF NIX Configuration Registers These registers
+ * are used to assist VF software discovery. For each HWVF, if the HWVF
+ * is mapped to a VF by RVU_PRIV_PF()_CFG[FIRST_HWVF,NVF], software
+ * writes NIX block's resource configuration for the VF in this register.
+ * The VF driver can read RVU_VF_BLOCK_ADDR()_DISC to discover the
+ * configuration.
+ */
+union cavm_rvu_priv_hwvfx_nixx_cfg {
+	u64 u;
+	struct cavm_rvu_priv_hwvfx_nixx_cfg_s {
+		u64 has_lf                           : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_rvu_priv_hwvfx_nixx_cfg_s cn; */
+};
+
+static inline u64 CAVM_RVU_PRIV_HWVFX_NIXX_CFG(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PRIV_HWVFX_NIXX_CFG(u64 a, u64 b)
+{
+	return 0x8001300 + 0x10000 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_hwvf#_npa_cfg
+ *
+ * RVU Privileged Hardware VF NPA Configuration Registers Similar to
+ * RVU_PRIV_HWVF()_NIX()_CFG, but for NPA block.
+ */
+union cavm_rvu_priv_hwvfx_npa_cfg {
+	u64 u;
+	struct cavm_rvu_priv_hwvfx_npa_cfg_s {
+		u64 has_lf                           : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_rvu_priv_hwvfx_npa_cfg_s cn; */
+};
+
+static inline u64 CAVM_RVU_PRIV_HWVFX_NPA_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PRIV_HWVFX_NPA_CFG(u64 a)
+{
+	return 0x8001310 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_hwvf#_sso_cfg
+ *
+ * RVU Privileged Hardware VF SSO Configuration Registers Similar to
+ * RVU_PRIV_HWVF()_NIX()_CFG, but for SSO block.
+ */
+union cavm_rvu_priv_hwvfx_sso_cfg {
+	u64 u;
+	struct cavm_rvu_priv_hwvfx_sso_cfg_s {
+		u64 num_lfs                          : 9;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct cavm_rvu_priv_hwvfx_sso_cfg_s cn; */
+};
+
+static inline u64 CAVM_RVU_PRIV_HWVFX_SSO_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PRIV_HWVFX_SSO_CFG(u64 a)
+{
+	return 0x8001320 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_hwvf#_ssow_cfg
+ *
+ * RVU Privileged Hardware VF SSO Work Slot Configuration Registers
+ * Similar to RVU_PRIV_HWVF()_NIX()_CFG, but for SSOW block.
+ */
+union cavm_rvu_priv_hwvfx_ssow_cfg {
+	u64 u;
+	struct cavm_rvu_priv_hwvfx_ssow_cfg_s {
+		u64 num_lfs                          : 9;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct cavm_rvu_priv_hwvfx_ssow_cfg_s cn; */
+};
+
+static inline u64 CAVM_RVU_PRIV_HWVFX_SSOW_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PRIV_HWVFX_SSOW_CFG(u64 a)
+{
+	return 0x8001330 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_hwvf#_tim_cfg
+ *
+ * RVU Privileged Hardware VF SSO Work Slot Configuration Registers
+ * Similar to RVU_PRIV_HWVF()_NIX()_CFG, but for TIM block.
+ */
+union cavm_rvu_priv_hwvfx_tim_cfg {
+	u64 u;
+	struct cavm_rvu_priv_hwvfx_tim_cfg_s {
+		u64 num_lfs                          : 9;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct cavm_rvu_priv_hwvfx_tim_cfg_s cn; */
+};
+
+static inline u64 CAVM_RVU_PRIV_HWVFX_TIM_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PRIV_HWVFX_TIM_CFG(u64 a)
+{
+	return 0x8001340 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_pf#_cfg
+ *
+ * RVU Privileged PF Configuration Registers
+ */
+union cavm_rvu_priv_pfx_cfg {
+	u64 u;
+	struct cavm_rvu_priv_pfx_cfg_s {
+		u64 first_hwvf                       : 12;
+		u64 nvf                              : 8;
+		u64 ena                              : 1;
+		u64 af_ena                           : 1;
+		u64 me_flr_ena                       : 1;
+		u64 reserved_23_63                   : 41;
+	} s;
+	/* struct cavm_rvu_priv_pfx_cfg_s cn; */
+};
+
+static inline u64 CAVM_RVU_PRIV_PFX_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PRIV_PFX_CFG(u64 a)
+{
+	return 0x8000100 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_pf#_cpt#_cfg
+ *
+ * RVU Privileged PF CPT Configuration Registers Similar to
+ * RVU_PRIV_PF()_NIX()_CFG, but for CPT({a}) block.
+ */
+union cavm_rvu_priv_pfx_cptx_cfg {
+	u64 u;
+	struct cavm_rvu_priv_pfx_cptx_cfg_s {
+		u64 num_lfs                          : 9;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct cavm_rvu_priv_pfx_cptx_cfg_s cn; */
+};
+
+static inline u64 CAVM_RVU_PRIV_PFX_CPTX_CFG(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PRIV_PFX_CPTX_CFG(u64 a, u64 b)
+{
+	return 0x8000350 + 0x10000 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_pf#_id_cfg
+ *
+ * RVU Privileged PF ID Configuration Registers
+ */
+union cavm_rvu_priv_pfx_id_cfg {
+	u64 u;
+	struct cavm_rvu_priv_pfx_id_cfg_s {
+		u64 pf_devid                         : 8;
+		u64 vf_devid                         : 8;
+		u64 class_code                       : 24;
+		u64 reserved_40_63                   : 24;
+	} s;
+	/* struct cavm_rvu_priv_pfx_id_cfg_s cn; */
+};
+
+static inline u64 CAVM_RVU_PRIV_PFX_ID_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PRIV_PFX_ID_CFG(u64 a)
+{
+	return 0x8000120 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_pf#_int_cfg
+ *
+ * RVU Privileged PF Interrupt Configuration Registers
+ */
+union cavm_rvu_priv_pfx_int_cfg {
+	u64 u;
+	struct cavm_rvu_priv_pfx_int_cfg_s {
+		u64 msix_offset                      : 11;
+		u64 reserved_11                      : 1;
+		u64 msix_size                        : 8;
+		u64 reserved_20_63                   : 44;
+	} s;
+	/* struct cavm_rvu_priv_pfx_int_cfg_s cn; */
+};
+
+static inline u64 CAVM_RVU_PRIV_PFX_INT_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PRIV_PFX_INT_CFG(u64 a)
+{
+	return 0x8000200 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_pf#_msix_cfg
+ *
+ * RVU Privileged PF MSI-X Configuration Registers These registers
+ * specify MSI-X table sizes and locations for RVU PFs and associated
+ * VFs. Hardware maintains all RVU MSI-X tables in a contiguous memory
+ * region in LLC/DRAM called the MSI-X table region. The table region's
+ * base AF IOVA is specified by RVU_AF_MSIXTR_BASE, and its size as a
+ * multiple of 16-byte RVU_MSIX_VEC_S structures must be less than or
+ * equal to RVU_PRIV_CONST[MAX_MSIX].  A PF's MSI-X table consists of the
+ * following range of RVU_MSIX_VEC_S structures in the table region: *
+ * First index: [PF_MSIXT_OFFSET]. * Last index: [PF_MSIXT_OFFSET] +
+ * [PF_MSIXT_SIZEM1].  If a PF has enabled VFs (associated
+ * RVU_PRIV_PF()_CFG[NVF] is nonzero), then each VF's MSI-X table
+ * consumes the following range of RVU_MSIX_VEC_S structures: * First
+ * index: [VF_MSIXT_OFFSET] + N*([VF_MSIXT_SIZEM1] + 1). * Last index:
+ * [VF_MSIXT_OFFSET] + N*([VF_MSIXT_SIZEM1] + 1) + [VF_MSIXT_SIZEM1].
+ * N=0 for the first VF, N=1 for the second VF, etc.  Different PFs and
+ * VFs must have non-overlapping vector ranges, and the last index of any
+ * range must be less than RVU_PRIV_CONST[MAX_MSIX].
+ */
+union cavm_rvu_priv_pfx_msix_cfg {
+	u64 u;
+	struct cavm_rvu_priv_pfx_msix_cfg_s {
+		u64 vf_msixt_sizem1                  : 12;
+		u64 vf_msixt_offset                  : 20;
+		u64 pf_msixt_sizem1                  : 12;
+		u64 pf_msixt_offset                  : 20;
+	} s;
+	/* struct cavm_rvu_priv_pfx_msix_cfg_s cn; */
+};
+
+static inline u64 CAVM_RVU_PRIV_PFX_MSIX_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PRIV_PFX_MSIX_CFG(u64 a)
+{
+	return 0x8000110 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_pf#_nix#_cfg
+ *
+ * RVU Privileged PF NIX Configuration Registers These registers are used
+ * to assist PF software discovery. For each enabled RVU PF, software
+ * writes the block's resource configuration for the PF in this register.
+ * The PF driver can read RVU_PF_BLOCK_ADDR()_DISC to discover the
+ * configuration.
+ */
+union cavm_rvu_priv_pfx_nixx_cfg {
+	u64 u;
+	struct cavm_rvu_priv_pfx_nixx_cfg_s {
+		u64 has_lf                           : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_rvu_priv_pfx_nixx_cfg_s cn; */
+};
+
+static inline u64 CAVM_RVU_PRIV_PFX_NIXX_CFG(u64 a, u64 b)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PRIV_PFX_NIXX_CFG(u64 a, u64 b)
+{
+	return 0x8000300 + 0x10000 * a + 8 * b;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_pf#_npa_cfg
+ *
+ * RVU Privileged PF NPA Configuration Registers Similar to
+ * RVU_PRIV_PF()_NIX()_CFG, but for NPA block.
+ */
+union cavm_rvu_priv_pfx_npa_cfg {
+	u64 u;
+	struct cavm_rvu_priv_pfx_npa_cfg_s {
+		u64 has_lf                           : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_rvu_priv_pfx_npa_cfg_s cn; */
+};
+
+static inline u64 CAVM_RVU_PRIV_PFX_NPA_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PRIV_PFX_NPA_CFG(u64 a)
+{
+	return 0x8000310 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_pf#_sso_cfg
+ *
+ * RVU Privileged PF SSO Configuration Registers Similar to
+ * RVU_PRIV_PF()_NIX()_CFG, but for SSO block.
+ */
+union cavm_rvu_priv_pfx_sso_cfg {
+	u64 u;
+	struct cavm_rvu_priv_pfx_sso_cfg_s {
+		u64 num_lfs                          : 9;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct cavm_rvu_priv_pfx_sso_cfg_s cn; */
+};
+
+static inline u64 CAVM_RVU_PRIV_PFX_SSO_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PRIV_PFX_SSO_CFG(u64 a)
+{
+	return 0x8000320 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_pf#_ssow_cfg
+ *
+ * RVU Privileged PF SSO Work Slot Configuration Registers Similar to
+ * RVU_PRIV_PF()_NIX()_CFG, but for SSOW block.
+ */
+union cavm_rvu_priv_pfx_ssow_cfg {
+	u64 u;
+	struct cavm_rvu_priv_pfx_ssow_cfg_s {
+		u64 num_lfs                          : 9;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct cavm_rvu_priv_pfx_ssow_cfg_s cn; */
+};
+
+static inline u64 CAVM_RVU_PRIV_PFX_SSOW_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PRIV_PFX_SSOW_CFG(u64 a)
+{
+	return 0x8000330 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_PF_BAR0) rvu_priv_pf#_tim_cfg
+ *
+ * RVU Privileged PF SSO Work Slot Configuration Registers Similar to
+ * RVU_PRIV_PF()_NIX()_CFG, but for TIM block.
+ */
+union cavm_rvu_priv_pfx_tim_cfg {
+	u64 u;
+	struct cavm_rvu_priv_pfx_tim_cfg_s {
+		u64 num_lfs                          : 9;
+		u64 reserved_9_63                    : 55;
+	} s;
+	/* struct cavm_rvu_priv_pfx_tim_cfg_s cn; */
+};
+
+static inline u64 CAVM_RVU_PRIV_PFX_TIM_CFG(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_PRIV_PFX_TIM_CFG(u64 a)
+{
+	return 0x8000340 + 0x10000 * a;
+}
+
+/**
+ * Register (RVU_VF_BAR2) rvu_vf_block_addr#_disc
+ *
+ * RVU VF Block Address Discovery Registers These registers allow each VF
+ * driver to discover block resources that are provisioned to its VF. The
+ * register's BLOCK_ADDR index is enumerated by RVU_BLOCK_ADDR_E.
+ */
+union cavm_rvu_vf_block_addrx_disc {
+	u64 u;
+	struct cavm_rvu_vf_block_addrx_disc_s {
+		u64 num_lfs                          : 9;
+		u64 reserved_9_10                    : 2;
+		u64 imp                              : 1;
+		u64 rid                              : 8;
+		u64 btype                            : 8;
+		u64 reserved_28_63                   : 36;
+	} s;
+	/* struct cavm_rvu_vf_block_addrx_disc_s cn; */
+};
+
+static inline u64 CAVM_RVU_VF_BLOCK_ADDRX_DISC(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_VF_BLOCK_ADDRX_DISC(u64 a)
+{
+	return 0x200 + 8 * a;
+}
+
+/**
+ * Register (RVU_VF_BAR2) rvu_vf_int
+ *
+ * RVU VF Interrupt Registers
+ */
+union cavm_rvu_vf_int {
+	u64 u;
+	struct cavm_rvu_vf_int_s {
+		u64 mbox                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_rvu_vf_int_s cn; */
+};
+
+static inline u64 CAVM_RVU_VF_INT(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_VF_INT(void)
+{
+	return 0x20;
+}
+
+/**
+ * Register (RVU_VF_BAR2) rvu_vf_int_ena_w1c
+ *
+ * RVU VF Interrupt Enable Clear Register This register clears interrupt
+ * enable bits.
+ */
+union cavm_rvu_vf_int_ena_w1c {
+	u64 u;
+	struct cavm_rvu_vf_int_ena_w1c_s {
+		u64 mbox                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_rvu_vf_int_ena_w1c_s cn; */
+};
+
+static inline u64 CAVM_RVU_VF_INT_ENA_W1C(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_VF_INT_ENA_W1C(void)
+{
+	return 0x38;
+}
+
+/**
+ * Register (RVU_VF_BAR2) rvu_vf_int_ena_w1s
+ *
+ * RVU VF Interrupt Enable Set Register This register sets interrupt
+ * enable bits.
+ */
+union cavm_rvu_vf_int_ena_w1s {
+	u64 u;
+	struct cavm_rvu_vf_int_ena_w1s_s {
+		u64 mbox                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_rvu_vf_int_ena_w1s_s cn; */
+};
+
+static inline u64 CAVM_RVU_VF_INT_ENA_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_VF_INT_ENA_W1S(void)
+{
+	return 0x30;
+}
+
+/**
+ * Register (RVU_VF_BAR2) rvu_vf_int_w1s
+ *
+ * RVU VF Interrupt Set Register This register sets interrupt bits.
+ */
+union cavm_rvu_vf_int_w1s {
+	u64 u;
+	struct cavm_rvu_vf_int_w1s_s {
+		u64 mbox                             : 1;
+		u64 reserved_1_63                    : 63;
+	} s;
+	/* struct cavm_rvu_vf_int_w1s_s cn; */
+};
+
+static inline u64 CAVM_RVU_VF_INT_W1S(void)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_VF_INT_W1S(void)
+{
+	return 0x28;
+}
+
+/**
+ * Register (RVU_VF_BAR2) rvu_vf_msix_pba#
+ *
+ * RVU VF MSI-X Pending-Bit-Array Registers This register is the MSI-X VF
+ * PBA table.
+ */
+union cavm_rvu_vf_msix_pbax {
+	u64 u;
+	struct cavm_rvu_vf_msix_pbax_s {
+		u64 pend                             : 64;
+	} s;
+	/* struct cavm_rvu_vf_msix_pbax_s cn; */
+};
+
+static inline u64 CAVM_RVU_VF_MSIX_PBAX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_VF_MSIX_PBAX(u64 a)
+{
+	return 0xf0000 + 8 * a;
+}
+
+/**
+ * Register (RVU_VF_BAR2) rvu_vf_msix_vec#_addr
+ *
+ * RVU VF MSI-X Vector-Table Address Registers These registers and
+ * RVU_VF_MSIX_VEC()_CTL form the VF MSI-X vector table. The number of
+ * MSI-X vectors for a given VF is specified by
+ * RVU_PRIV_PF()_MSIX_CFG[VF_MSIXT_SIZEM1] (plus 1).  Software must do a
+ * read after any writes to the MSI-X vector table to ensure that the
+ * writes have completed before interrupts are generated to the modified
+ * vectors.
+ */
+union cavm_rvu_vf_msix_vecx_addr {
+	u64 u;
+	struct cavm_rvu_vf_msix_vecx_addr_s {
+		u64 secvec                           : 1;
+		u64 reserved_1                       : 1;
+		u64 addr                             : 51;
+		u64 reserved_53_63                   : 11;
+	} s;
+	/* struct cavm_rvu_vf_msix_vecx_addr_s cn; */
+};
+
+static inline u64 CAVM_RVU_VF_MSIX_VECX_ADDR(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_VF_MSIX_VECX_ADDR(u64 a)
+{
+	return 0x80000 + 0x10 * a;
+}
+
+/**
+ * Register (RVU_VF_BAR2) rvu_vf_msix_vec#_ctl
+ *
+ * RVU VF MSI-X Vector-Table Control and Data Registers These registers
+ * and RVU_VF_MSIX_VEC()_ADDR form the VF MSI-X vector table.
+ */
+union cavm_rvu_vf_msix_vecx_ctl {
+	u64 u;
+	struct cavm_rvu_vf_msix_vecx_ctl_s {
+		u64 data                             : 32;
+		u64 mask                             : 1;
+		u64 reserved_33_63                   : 31;
+	} s;
+	/* struct cavm_rvu_vf_msix_vecx_ctl_s cn; */
+};
+
+static inline u64 CAVM_RVU_VF_MSIX_VECX_CTL(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_VF_MSIX_VECX_CTL(u64 a)
+{
+	return 0x80008 + 0x10 * a;
+}
+
+/**
+ * Register (RVU_VF_BAR2) rvu_vf_vfpf_mbox#
+ *
+ * RVU VF/PF Mailbox Registers
+ */
+union cavm_rvu_vf_vfpf_mboxx {
+	u64 u;
+	struct cavm_rvu_vf_vfpf_mboxx_s {
+		u64 data                             : 64;
+	} s;
+	/* struct cavm_rvu_vf_vfpf_mboxx_s cn; */
+};
+
+static inline u64 CAVM_RVU_VF_VFPF_MBOXX(u64 a)
+	__attribute__ ((pure, always_inline));
+static inline u64 CAVM_RVU_VF_VFPF_MBOXX(u64 a)
+{
+	return 0 + 8 * a;
+}
+
+#endif /* __CAVM_CSRS_RVU_H__ */
diff --git a/drivers/net/octeontx2/cgx.c b/drivers/net/octeontx2/cgx.c
new file mode 100644
index 0000000..3aa00d1
--- /dev/null
+++ b/drivers/net/octeontx2/cgx.c
@@ -0,0 +1,335 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#include <common.h>
+#include <net.h>
+#include <malloc.h>
+#include <dm.h>
+#include <misc.h>
+#include <asm/io.h>
+#include <errno.h>
+#include <linux/list.h>
+#include <asm/arch/octeontx2.h>
+#include "cavm-csrs-cgx.h"
+#include "cgx.h"
+
+char lmac_type_to_str[][8] = {
+	"SGMII",
+	"XAUI",
+	"RXAUI",
+	"10G_R",
+	"40G_R",
+	"RGMII",
+	"QSGMII",
+	"25G_R",
+	"50G_R",
+	"100G_R",
+	"USXGMII",
+};
+
+char lmac_speed_to_str[][8] = {
+	"0",
+	"10M",
+	"100M",
+	"1G",
+	"2.5G",
+	"5G",
+	"10G",
+	"20G",
+	"25G",
+	"40G",
+	"50G",
+	"80G",
+	"100G",
+};
+
+/**
+ * Given an LMAC/PF instance number, return the lmac
+ * Per design, each PF has only one LMAC mapped.
+ *
+ * @param instance	instance to find
+ *
+ * @return	pointer to lmac data structure or NULL if not found
+ */
+struct lmac *nix_get_cgx_lmac(int lmac_instance)
+{
+	struct cgx *cgx;
+	struct udevice *dev;
+	int i, idx, err;
+
+	for (i = 0; i < CGX_PER_NODE; i++) {
+		err = dm_pci_find_device(PCI_VENDOR_ID_CAVIUM,
+					 PCI_DEVICE_ID_OCTEONTX2_CGX, i,
+					 &dev);
+		if (err)
+			continue;
+
+		cgx = dev_get_priv(dev);
+		debug("%s udev %p cgx %p instance %d\n", __func__, dev, cgx,
+			lmac_instance);
+		for (idx = 0; idx < cgx->lmac_count; idx++) {
+			if (cgx->lmac[idx]->instance == lmac_instance)
+				return cgx->lmac[idx];
+		}
+	}
+	return NULL;
+}
+
+void cgx_lmac_mac_filter_clear(struct lmac *lmac)
+{
+	union cavm_cgxx_cmrx_rx_dmac_ctl0 dmac_ctl0;
+	union cavm_cgxx_cmr_rx_dmacx_cam0 dmac_cam0;
+	void *reg_addr;
+
+	dmac_cam0.u = 0x0;
+	reg_addr = lmac->cgx->reg_base +
+			CAVM_CGXX_CMR_RX_DMACX_CAM0(lmac->lmac_id * 8);
+	writeq(dmac_cam0.u, reg_addr);
+	debug("%s: reg %p dmac_cam0 %llx\n", __func__, reg_addr, dmac_cam0.u);
+
+	dmac_ctl0.u = 0x0;
+	dmac_ctl0.s.bcst_accept = 1;
+	dmac_ctl0.s.mcst_mode = 1;
+	dmac_ctl0.s.cam_accept = 0;
+	reg_addr = lmac->cgx->reg_base +
+			CAVM_CGXX_CMRX_RX_DMAC_CTL0(lmac->lmac_id);
+	writeq(dmac_ctl0.u, reg_addr);
+	debug("%s: reg %p dmac_ctl0 %llx\n", __func__, reg_addr, dmac_ctl0.u);
+}
+
+void cgx_lmac_mac_filter_setup(struct lmac *lmac)
+{
+	union cavm_cgxx_cmrx_rx_dmac_ctl0 dmac_ctl0;
+	union cavm_cgxx_cmr_rx_dmacx_cam0 dmac_cam0;
+#if 0
+	union cavm_cgxx_cmr_rx_steering0x steering0;
+	union cavm_cgxx_cmr_rx_steering_default0 steering_default0;
+	static int str_idx = 1;
+#endif
+	u64 mac, tmp;
+	void *reg_addr;
+
+	memcpy((void *)&tmp, lmac->mac_addr, 6);
+	debug("%s: tmp %llx\n", __func__, tmp);
+	debug("%s: swab tmp %llx\n", __func__, swab64(tmp));
+	mac = swab64(tmp) >> 16;
+	debug("%s: mac %llx\n", __func__, mac);
+	dmac_cam0.u = 0x0;
+	dmac_cam0.s.id = lmac->lmac_id;
+	dmac_cam0.s.adr = mac;
+	dmac_cam0.s.en = 1;
+	reg_addr = lmac->cgx->reg_base + 
+			CAVM_CGXX_CMR_RX_DMACX_CAM0(lmac->lmac_id * 8);
+	writeq(dmac_cam0.u, reg_addr);
+	debug("%s: reg %p dmac_cam0 %llx\n", __func__, reg_addr, dmac_cam0.u);
+	dmac_ctl0.u = 0x0;
+	dmac_ctl0.s.bcst_accept = 0;
+	dmac_ctl0.s.mcst_mode = 0;
+	dmac_ctl0.s.cam_accept = 1;
+	reg_addr = lmac->cgx->reg_base +
+			CAVM_CGXX_CMRX_RX_DMAC_CTL0(lmac->lmac_id);
+	writeq(dmac_ctl0.u, reg_addr);
+	debug("%s: reg %p dmac_ctl0 %llx\n", __func__, reg_addr, dmac_ctl0.u);
+
+#if 0
+	steering_default0.u = 0x0;
+	steering_default0.s.pass = 0;
+	reg_addr = lmac->cgx->reg_base + CAVM_CGXX_CMR_RX_STEERING_DEFAULT0();
+	writeq(steering_default0.u, reg_addr);
+	debug("%s: reg %p str_def0 %llx\n", __func__, reg_addr,
+			 steering_default0.u);
+
+	steering0.u = 0x0;
+	steering0.s.pass = 1;
+	steering0.s.mcst_en = 0;
+	steering0.s.dmac_en = 1;
+	steering0.s.dmac = mac;
+	reg_addr = lmac->cgx->reg_base + CAVM_CGXX_CMR_RX_STEERING0X(0);
+	writeq(steering0.u, reg_addr);
+	debug("%s: reg %p steering00 %llx\n", __func__, reg_addr,
+			 steering0.u);
+
+	mac = 0x0000FFFFFFFFFFFF;	/* broadcast addr */
+	steering0.u = 0x0;
+	steering0.s.pass = 1;
+	steering0.s.mcst_en = 0;
+	steering0.s.dmac_en = 1;
+	steering0.s.dmac = mac;
+	reg_addr = lmac->cgx->reg_base + CAVM_CGXX_CMR_RX_STEERING0X(1);
+	writeq(steering0.u, reg_addr);
+	debug("%s: reg %p steering01 %llx\n", __func__, reg_addr,
+			 steering0.u);
+#endif
+}
+
+
+int cgx_lmac_set_pkind(struct lmac *lmac, u8 lmac_id, int pkind)
+{
+	cgx_write(lmac->cgx, lmac_id, CAVM_CGXX_CMRX_RX_ID_MAP(0),
+		  (pkind & 0x3f));
+	return 0;
+}
+
+
+int cgx_lmac_link_status(struct lmac *lmac, int lmac_id, u64 *status)
+{
+	int ret = 0;
+
+	ret = cgx_intf_get_link_sts(lmac->cgx->cgx_id, lmac_id, status);
+	if (ret) {
+		debug("%s request failed for cgx%d lmac%d\n",
+		      __func__, lmac->cgx->cgx_id, lmac->lmac_id);
+		ret = -1;
+	}
+	return ret;
+}
+
+int cgx_lmac_rx_tx_enable(struct lmac *lmac, int lmac_id, bool enable)
+{
+	struct cgx *cgx = lmac->cgx;
+	union cavm_cgxx_cmrx_config cmrx_config;
+
+	if (!cgx || lmac_id >= cgx->lmac_count)
+		return -ENODEV;
+
+	cmrx_config.u = cgx_read(cgx, lmac_id, CAVM_CGXX_CMRX_CONFIG(0));
+	cmrx_config.s.data_pkt_rx_en =
+	cmrx_config.s.data_pkt_tx_en = enable ? 1 : 0;
+	cgx_write(cgx, lmac_id, CAVM_CGXX_CMRX_CONFIG(0), cmrx_config.u);
+	return 0;
+}
+
+int cgx_lmac_link_enable(struct lmac *lmac, int lmac_id, bool enable,
+			 u64 *status)
+{
+	int ret = 0;
+
+	ret = cgx_intf_link_up_dwn(lmac->cgx->cgx_id, lmac_id, enable,
+				   status);
+	if (ret) {
+		debug("%s request failed for cgx%d lmac%d\n",
+		      __func__, lmac->cgx->cgx_id, lmac->lmac_id);
+		ret = -1;
+	}
+	return ret;
+}
+
+int cgx_lmac_internal_loopback(struct lmac *lmac, int lmac_id, bool enable)
+{
+	struct cgx *cgx = lmac->cgx;
+	union cavm_cgxx_cmrx_config cmrx_cfg;
+	union cavm_cgxx_gmp_pcs_mrx_control mrx_control;
+	union cavm_cgxx_spux_control1 spux_control1;
+	enum lmac_type lmac_type;
+
+	if (!cgx || lmac_id >= cgx->lmac_count)
+		return -ENODEV;
+
+	cmrx_cfg.u = cgx_read(cgx, lmac_id, CAVM_CGXX_CMRX_CONFIG(0));
+	lmac_type = cmrx_cfg.s.lmac_type;
+	if (lmac_type == LMAC_MODE_SGMII || lmac_type == LMAC_MODE_QSGMII) {
+		mrx_control.u = cgx_read(cgx, lmac_id,
+					 CAVM_CGXX_GMP_PCS_MRX_CONTROL(0));
+		mrx_control.s.loopbck1 = enable ? 1 : 0;
+		cgx_write(cgx, lmac_id, CAVM_CGXX_GMP_PCS_MRX_CONTROL(0),
+			  mrx_control.u);
+	} else {
+		spux_control1.u = cgx_read(cgx, lmac_id,
+					   CAVM_CGXX_SPUX_CONTROL1(0));
+		spux_control1.s.loopbck = enable ? 1 : 0;
+		cgx_write(cgx, lmac_id, CAVM_CGXX_SPUX_CONTROL1(0),
+			  spux_control1.u);
+	}
+	return 0;
+}
+
+static int cgx_lmac_init(struct cgx *cgx)
+{
+	struct lmac *lmac;
+	union cavm_cgxx_cmrx_config cmrx_cfg;
+	static int instance = 1;
+	int i;
+
+	cgx->lmac_count = cgx_read(cgx, 0, CAVM_CGXX_CMR_RX_LMACS());
+	debug("%s: Found %d lmacs for cgx %d@%p\n", __func__, cgx->lmac_count,
+	      cgx->cgx_id, cgx->reg_base);
+
+	for (i = 0; i < cgx->lmac_count; i++) {
+		lmac = calloc(1, sizeof(*lmac));
+		if (!lmac)
+			return -ENOMEM;
+		lmac->instance = instance++;
+		snprintf(lmac->name, sizeof(lmac->name), "cgx_fwi_%d_%d",
+			 cgx->cgx_id, i);
+		/* Get LMAC type */
+		cmrx_cfg.u = cgx_read(cgx, i, CAVM_CGXX_CMRX_CONFIG(0));
+		lmac->lmac_type = cmrx_cfg.s.lmac_type;
+
+		lmac->lmac_id = i;
+		lmac->cgx = cgx;
+		cgx->lmac[i] = lmac;
+		debug("%s: mapping id %d to lmac %p (%s), lmac type: %d"
+			" lmac instance %d\n", __func__, i, lmac, lmac->name,
+			 lmac->lmac_type, lmac->instance);
+		lmac->init_pend = 1;
+		printf("CGX%d LMAC%d [%s]\n", lmac->cgx->cgx_id,
+		       lmac->lmac_id, lmac_type_to_str[lmac->lmac_type]);
+		octeontx2_board_get_mac_addr((lmac->instance - 1),
+					     lmac->mac_addr);
+		debug("%s: MAC %pM\n", __func__, lmac->mac_addr);
+		cgx_lmac_mac_filter_setup(lmac);
+	}
+	return 0;
+}
+
+int cgx_probe(struct udevice *dev)
+{
+	struct cgx *cgx = dev_get_priv(dev);
+	size_t size;
+	int err;
+
+	cgx->reg_base = dm_pci_map_bar(dev, 0, &size, PCI_REGION_MEM);
+	cgx->dev = dev;
+	cgx->cgx_id = ((u64)(cgx->reg_base) >> 24) & 0x7;
+
+	debug("%s CGX BAR %p, id: %d\n", __func__,
+		 cgx->reg_base, cgx->cgx_id);
+	debug("%s CGX %p, udev: %p\n", __func__, cgx, dev);
+
+	err = cgx_lmac_init(cgx);
+
+	return err;
+}
+
+int cgx_remove(struct udevice *dev)
+{
+	struct cgx *cgx = dev_get_priv(dev);
+	int i;
+
+	debug("%s: cgx remove reg_base %p cgx_id %d",
+		__func__, cgx->reg_base, cgx->cgx_id);
+	for (i = 0; i < cgx->lmac_count; i++)
+		cgx_lmac_mac_filter_clear(cgx->lmac[i]);
+
+	return 0;
+}
+
+U_BOOT_DRIVER(cgx) = {
+        .name   = "cgx",
+        .id     = UCLASS_MISC,
+        .probe  = cgx_probe,
+        .remove  = cgx_remove,
+        .priv_auto_alloc_size = sizeof(struct cgx),
+};
+
+static struct pci_device_id cgx_supported[] = {
+        { PCI_VDEVICE(CAVIUM, PCI_DEVICE_ID_OCTEONTX2_CGX) },
+        {}
+};
+
+U_BOOT_PCI_DEVICE(cgx, cgx_supported);
diff --git a/drivers/net/octeontx2/cgx.h b/drivers/net/octeontx2/cgx.h
new file mode 100644
index 0000000..35aca56
--- /dev/null
+++ b/drivers/net/octeontx2/cgx.h
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#ifndef __CGX_H__
+#define __CGX_H__
+
+#include "cgx_intf.h"
+
+#define PCI_DEVICE_ID_OCTEONTX2_CGX	0xA059
+
+#define MAX_LMAC_PER_CGX		4
+#define CGX_PER_NODE 			3
+
+enum lmac_type {
+	LMAC_MODE_SGMII		= 0,
+	LMAC_MODE_XAUI		= 1,
+	LMAC_MODE_RXAUI		= 2,
+	LMAC_MODE_10G_R		= 3,
+	LMAC_MODE_40G_R		= 4,
+	LMAC_MODE_QSGMII	= 6,
+	LMAC_MODE_25G_R		= 7,
+	LMAC_MODE_50G_R		= 8,
+	LMAC_MODE_100G_R	= 9,
+	LMAC_MODE_USXGMII	= 10,
+};
+
+extern char lmac_type_to_str[][8];
+
+extern char lmac_speed_to_str[][8];
+
+struct lmac_priv {
+	u8 enable:1;
+	u8 full_duplex:1;
+	u8 speed:4;
+	u8 mode:1;
+	u8 rsvd:1;
+	u8 mac_addr[6];
+};
+
+struct cgx;
+struct nix;
+struct nix_af;
+
+struct lmac {
+	struct cgx	*cgx;
+	struct nix	*nix;
+	char		name[16];
+	enum lmac_type	lmac_type;
+	bool		init_pend;
+	u8		instance;
+	u8		lmac_id;
+	u8		pknd;
+	u8		link_num;
+	u32		chan_num;
+	u8		mac_addr[6];
+};
+
+struct cgx {
+	struct nix_af		*nix_af;
+	void __iomem		*reg_base;
+	struct udevice		*dev;
+	struct lmac		*lmac[MAX_LMAC_PER_CGX];
+	u8			cgx_id;
+	u8			lmac_count;
+};
+
+static inline void cgx_write(struct cgx *cgx, u8 lmac, u64 offset, u64 val)
+{
+	writeq(val, cgx->reg_base + CMR_SHIFT(lmac) + offset);
+}
+
+static inline u64 cgx_read(struct cgx *cgx, u8 lmac, u64 offset)
+{
+	return readq(cgx->reg_base + CMR_SHIFT(lmac) + offset);
+}
+
+/**
+ * Given an LMAC/PF instance number, return the lmac
+ * Per design, each PF has only one LMAC mapped.
+ *
+ * @param instance	instance to find
+ *
+ * @return	pointer to lmac data structure or NULL if not found
+ */
+struct lmac *nix_get_cgx_lmac(int lmac_instance);
+
+int cgx_lmac_set_pkind(struct lmac *lmac, u8 lmac_id, int pkind);
+int cgx_lmac_internal_loopback(struct lmac *lmac, int lmac_id, bool enable);
+int cgx_lmac_rx_tx_enable(struct lmac *lmac, int lmac_id, bool enable);
+int cgx_lmac_link_enable(struct lmac *lmac, int lmac_id, bool enable,
+			 u64 *status);
+int cgx_lmac_link_status(struct lmac *lmac, int lmac_id, u64 *status);
+void cgx_lmac_mac_filter_setup(struct lmac *lmac);
+
+int cgx_intf_get_link_sts(u8 cgx, u8 lmac, u64 *lnk_sts);
+int cgx_intf_link_up_dwn(u8 cgx, u8 lmac, u8 up_dwn, u64 *lnk_sts);
+int cgx_intf_get_mac_addr(u8 cgx, u8 lmac, u8 *mac);
+
+#endif /* __CGX_H__ */
diff --git a/drivers/net/octeontx2/cgx_intf.c b/drivers/net/octeontx2/cgx_intf.c
new file mode 100644
index 0000000..c87d7c7
--- /dev/null
+++ b/drivers/net/octeontx2/cgx_intf.c
@@ -0,0 +1,358 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#include <common.h>
+#include <net.h>
+#include <malloc.h>
+#include <dm.h>
+#include <misc.h>
+#include <asm/io.h>
+#include <errno.h>
+#include <linux/list.h>
+#include <asm/arch/octeontx2.h>
+
+#include "cgx_intf.h"
+#include "cgx.h"
+#include "nix.h"
+
+static u64 cgx_rd_scrx(u8 cgx, u8 lmac, u8 index)
+{
+	u64 addr;
+
+	addr = (index == 1) ? CGX_CMR_SCRATCH1 : CGX_CMR_SCRATCH0;
+	addr += CGX_SHIFT(cgx) + CMR_SHIFT(lmac);
+	return readq(addr);
+}
+
+static void cgx_wr_scrx(u8 cgx, u8 lmac, u8 index, u64 val)
+{
+	u64 addr;
+
+	addr = (index == 1) ? CGX_CMR_SCRATCH1 : CGX_CMR_SCRATCH0;
+	addr += CGX_SHIFT(cgx) + CMR_SHIFT(lmac);
+	writeq(val, addr);
+}
+
+static u64 cgx_rd_scr0(u8 cgx, u8 lmac)
+{
+	return cgx_rd_scrx(cgx, lmac, 0);
+}
+
+static u64 cgx_rd_scr1(u8 cgx, u8 lmac)
+{
+	return cgx_rd_scrx(cgx, lmac, 1);
+}
+
+static void cgx_wr_scr0(u8 cgx, u8 lmac, u64 val)
+{
+	return cgx_wr_scrx(cgx, lmac, 0, val);
+}
+
+static void cgx_wr_scr1(u8 cgx, u8 lmac, u64 val)
+{
+	return cgx_wr_scrx(cgx, lmac, 1, val);
+}
+
+static inline void set_ownership(u8 cgx, u8 lmac, u8 val)
+{
+	union cgx_scratchx1 scr1;
+	scr1.u = cgx_rd_scr1(cgx, lmac);
+	scr1.s.own_status = val;
+	cgx_wr_scr1(cgx, lmac, scr1.u);
+}
+
+static int wait_for_ownership(u8 cgx, u8 lmac)
+{
+	union cgx_scratchx1 scr1;
+	union cgx_scratchx0 scr0;
+	u64 cmrx_int;
+	int timeout = 5000;
+
+	do {
+	
+		scr1.u = cgx_rd_scr1(cgx, lmac);
+		scr0.u = cgx_rd_scr0(cgx, lmac);
+		/* clear async events if any */
+		if ((scr0.s.evt_sts.evt_type == CGX_EVT_ASYNC) &&
+			scr0.s.evt_sts.ack) {
+			/* clear interrupt */
+			cmrx_int = readq(CGX_CMR_INT +
+					 CGX_SHIFT(cgx) + CMR_SHIFT(lmac));
+			cmrx_int |= 0x2; // Overflw bit
+			writeq(cmrx_int, CGX_CMR_INT +
+					 CGX_SHIFT(cgx) + CMR_SHIFT(lmac));
+
+			/* clear ack */
+			scr0.s.evt_sts.ack = 0;
+			cgx_wr_scr0(cgx, lmac, scr0.u);
+		}
+
+		if (timeout-- < 0) {
+			debug("timeout waiting for ownership\n");
+			return -ETIMEDOUT;
+		}
+		mdelay(1);
+	} while ((scr1.s.own_status == CGX_OWN_FIRMWARE) &&
+		  scr0.s.evt_sts.ack);
+
+	return 0;
+}
+
+int cgx_intf_req(u8 cgx, u8 lmac, u8 cmd, u8 type, u64 *rsp)
+{
+	union cgx_scratchx1 scr1;
+	union cgx_scratchx0 scr0;
+	u64 cmrx_int;
+	int timeout = 500;
+	int err = 0;
+
+	if (wait_for_ownership(cgx, lmac)) {
+		err = -ETIMEDOUT;
+		goto error;
+	}
+
+	/* send command */
+	scr1.u = cgx_rd_scr1(cgx, lmac);
+	scr1.s.cmd.id = cmd;
+	if (cmd == CGX_CMD_SET_PHY_MOD_TYPE)
+		scr1.s.phy_mod_args.mod = type;
+	if (cmd == CGX_CMD_SET_FEC)
+		scr1.s.fec_args.fec = type;
+	cgx_wr_scr1(cgx, lmac, scr1.u);
+
+	set_ownership(cgx, lmac, CGX_OWN_FIRMWARE);
+
+	/* wait for response and ownership */
+	do {
+		scr0.u = cgx_rd_scr0(cgx, lmac);
+		scr1.u = cgx_rd_scr1(cgx, lmac);
+		mdelay(10);
+	} while (timeout-- && ( !scr0.s.evt_sts.ack) &&
+		 (scr1.s.own_status == CGX_OWN_FIRMWARE));
+	if (timeout < 0) {
+		debug("%s timeout waiting for ack\n",__func__);
+		err = -ETIMEDOUT;
+		goto error;
+	}
+
+	if (cmd == CGX_CMD_INTF_SHUTDOWN)
+		goto error;
+
+	if (scr0.s.evt_sts.evt_type != CGX_EVT_CMD_RESP) {
+		debug("%s received async event instead of cmd resp event\n",
+		      __func__);
+		err = -1;
+		goto error;
+	}
+	if (scr0.s.evt_sts.id != cmd) {
+		debug("%s received resp for cmd %d expected cmd %d\n",
+		      __func__, scr0.s.evt_sts.id, cmd);
+		err = -1;
+		goto error;
+	}
+	if (scr0.s.evt_sts.stat != CGX_STAT_SUCCESS) {
+		debug("%s cmd%d failed on cgx%u lmac%u with errcode %d\n",
+		      __func__, cmd, cgx, lmac, scr0.s.link_sts.err_type);
+		err = -1;
+	}
+
+error:
+	/* clear interrupt */
+	cmrx_int = readq(CGX_CMR_INT + CGX_SHIFT(cgx) + CMR_SHIFT(lmac));
+	cmrx_int |= 0x2; // Overflw bit
+	writeq(cmrx_int, CGX_CMR_INT + CGX_SHIFT(cgx) + CMR_SHIFT(lmac));
+
+	/* clear ownership and ack */
+	scr0.s.evt_sts.ack = 0;
+	cgx_wr_scr0(cgx, lmac, scr0.u);
+
+	*rsp = err ? 0 : scr0.u;
+
+	return err;
+}
+
+
+int cgx_intf_get_mac_addr(u8 cgx, u8 lmac, u8 *mac)
+{
+	union cgx_scratchx0 scr0;
+	int ret;
+
+	ret = cgx_intf_req(cgx, lmac,
+				CGX_CMD_GET_MAC_ADDR, 0, &scr0.u);
+	if (ret)
+		return -1;
+
+	scr0.u >>= 9;
+	memcpy(mac, &scr0.u, 6);
+
+	return 0;
+}
+
+int cgx_intf_get_ver(u8 cgx, u8 lmac, u8 *ver)
+{
+	union cgx_scratchx0 scr0;
+	int ret;
+
+	ret = cgx_intf_req(cgx, lmac,
+				CGX_CMD_GET_FW_VER, 0, &scr0.u);
+	if (ret)
+		return -1;
+
+	scr0.u >>= 9;
+	*ver = scr0.u & 0xFFFF;
+
+	return 0;
+}
+
+int cgx_intf_get_link_sts(u8 cgx, u8 lmac, u64 *lnk_sts)
+{
+	union cgx_scratchx0 scr0;
+	int ret;
+
+	ret = cgx_intf_req(cgx, lmac,
+				CGX_CMD_GET_LINK_STS, 0, &scr0.u);
+	if (ret)
+		return -1;
+
+	scr0.u >>= 9;
+	/* pass the same format as cgx_lnk_sts_s
+	 * err_type:10, speed:4, full_duplex:1, link_up:1
+	 */
+	*lnk_sts = scr0.u & 0xFFFF;
+	return 0;
+}
+
+int cgx_intf_link_up_dwn(u8 cgx, u8 lmac, u8 up_dwn, u64 *lnk_sts)
+{
+	union cgx_scratchx0 scr0;
+	int ret;
+	u8 cmd;
+
+	cmd = up_dwn ? CGX_CMD_LINK_BRING_UP : CGX_CMD_LINK_BRING_DOWN;
+
+	ret = cgx_intf_req(cgx, lmac, cmd, 0, &scr0.u);
+	if (ret)
+		return -1;
+
+	scr0.u >>= 9;
+	/* pass the same format as cgx_lnk_sts_s
+	 * err_type:10, speed:4, full_duplex:1, link_up:1
+	 */
+	*lnk_sts = scr0.u & 0xFFFF;
+	return 0;
+}
+
+void cgx_intf_shutdown(void)
+{
+	union cgx_scratchx0 scr0;
+
+	cgx_intf_req(0, 0, CGX_CMD_INTF_SHUTDOWN, 0, &scr0.u);
+}
+
+int cgx_intf_get_fec(struct udevice *ethdev)
+{
+	struct rvu_pf *rvu = dev_get_priv(ethdev);
+	struct nix *nix = rvu->nix;
+	union cgx_scratchx0 scr0;
+	int ret;
+
+	ret = cgx_intf_req(nix->lmac->cgx->cgx_id, nix->lmac->lmac_id,
+			   CGX_CMD_GET_SUPPORTED_FEC, 0, &scr0.u);
+	if (ret) {
+		printf("Get supported FEC failed for %s\n", ethdev->name);
+		return -1;
+	}
+
+	printf("Supported FEC type: ");
+	switch (scr0.s.supported_fec.fec) {
+	case 0:
+		printf("FEC_NONE\n");
+		break;
+	case 1:
+		printf("FEC_BASE_R\n");
+		break;
+	case 2:
+		printf("FEC_RS\n");
+		break;
+	case 3:
+		printf("FEC_BASE_R FEC_RS\n");
+		break;
+	}
+	ret = cgx_intf_req(nix->lmac->cgx->cgx_id, nix->lmac->lmac_id,
+			   CGX_CMD_GET_LINK_STS, 0, &scr0.u);
+	if (ret) {
+		printf("Get active fec failed for %s\n", ethdev->name);
+		return -1;
+	}
+	printf("Active FEC type: ");
+	switch (scr0.s.link_sts.fec) {
+	case 0:
+		printf("FEC_NONE\n");
+		break;
+	case 1:
+		printf("FEC_BASE_R\n");
+		break;
+	case 2:
+		printf("FEC_RS\n");
+		break;
+	}
+	return 0;
+}
+
+int cgx_intf_set_fec(struct udevice *ethdev, int type)
+{
+	struct rvu_pf *rvu = dev_get_priv(ethdev);
+	struct nix *nix = rvu->nix;
+	union cgx_scratchx0 scr0;
+	int ret;
+
+	ret = cgx_intf_req(nix->lmac->cgx->cgx_id, nix->lmac->lmac_id,
+			   CGX_CMD_SET_FEC, type, &scr0.u);
+	if (ret) {
+		printf("Set FEC type %d failed for %s\n", type, ethdev->name);
+		return -1;
+	}
+	return 0;
+}
+
+int cgx_intf_get_phy_mod_type(struct udevice *ethdev)
+{
+	struct rvu_pf *rvu = dev_get_priv(ethdev);
+	struct nix *nix = rvu->nix;
+	union cgx_scratchx0 scr0;
+	int ret;
+
+	ret = cgx_intf_req(nix->lmac->cgx->cgx_id, nix->lmac->lmac_id,
+			   CGX_CMD_GET_PHY_MOD_TYPE, 0, &scr0.u);
+	if (ret) {
+		printf("Get PHYMOD type failed for %s\n", ethdev->name);
+		return -1;
+	}
+	printf("Current phy mod type %s\n",
+	       scr0.s.phy_mod_type.mod ? "PAM4" : "NRZ");
+	return 0;
+}
+
+int cgx_intf_set_phy_mod_type(struct udevice *ethdev, int type)
+{
+	struct rvu_pf *rvu = dev_get_priv(ethdev);
+	struct nix *nix = rvu->nix;
+	union cgx_scratchx0 scr0;
+	int ret;
+
+	ret = cgx_intf_req(nix->lmac->cgx->cgx_id, nix->lmac->lmac_id,
+			   CGX_CMD_SET_PHY_MOD_TYPE, type, &scr0.u);
+	if (ret) {
+		printf("Set PHYMOD type %d failed for %s\n", type,
+		       ethdev->name);
+		return -1;
+	}
+
+	return 0;
+}
+
diff --git a/drivers/net/octeontx2/cgx_intf.h b/drivers/net/octeontx2/cgx_intf.h
new file mode 100644
index 0000000..ac02fe8
--- /dev/null
+++ b/drivers/net/octeontx2/cgx_intf.h
@@ -0,0 +1,352 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#ifndef __CGX_INTF_H__
+#define __CGX_INTF_H__
+
+#define CGX_FIRMWARE_MAJOR_VER		1
+#define CGX_FIRMWARE_MINOR_VER		0
+
+/* Register offsets */
+#define CGX_CMR_INT		0x87e0e0000040
+#define CGX_CMR_SCRATCH0	0x87e0e0001050
+#define CGX_CMR_SCRATCH1	0x87e0e0001058
+
+#define CGX_SHIFT(x)		(0x1000000 * (x & 0x3))
+#define CMR_SHIFT(x)		(0x40000 * (x & 0x3))
+
+/* CGX error types. set for cmd response status as CGX_STAT_FAIL */
+enum cgx_error_type {
+	CGX_ERR_NONE,
+	CGX_ERR_LMAC_NOT_ENABLED,
+	CGX_ERR_LMAC_MODE_INVALID,
+	CGX_ERR_REQUEST_ID_INVALID,
+	CGX_ERR_PREV_ACK_NOT_CLEAR,
+	CGX_ERR_PHY_LINK_DOWN,
+	CGX_ERR_PCS_RESET_FAIL,
+	CGX_ERR_AN_CPT_FAIL,
+	CGX_ERR_TX_NOT_IDLE,
+	CGX_ERR_RX_NOT_IDLE,
+	CGX_ERR_SPUX_BR_BLKLOCK_FAIL,
+	CGX_ERR_SPUX_RX_ALIGN_FAIL,
+	CGX_ERR_SPUX_TX_FAULT,
+	CGX_ERR_SPUX_RX_FAULT,
+	CGX_ERR_SPUX_RESET_FAIL,
+	CGX_ERR_SPUX_AN_RESET_FAIL,
+	CGX_ERR_SPUX_USX_AN_RESET_FAIL,
+	CGX_ERR_SMUX_RX_LINK_NOT_OK,
+	CGX_ERR_PCS_LINK_FAIL,
+	CGX_ERR_TRAINING_FAIL,
+	CGX_ERR_RX_EQU_FAIL,
+	CGX_ERR_SPUX_BER_FAIL,
+	CGX_ERR_SPUX_RSFEC_ALGN_FAIL,
+	CGX_ERR_SPUX_MARKER_LOCK_FAIL,
+	CGX_ERR_SET_FEC_INVALID,
+	CGX_ERR_SET_FEC_FAIL,
+	CGX_ERR_MODULE_INVALID,
+	CGX_ERR_MODULE_NOT_PRESENT,	/* = 27 */
+	/* FIXME : add more error types when adding support for new modes */
+};
+
+/* LINK speed types */
+enum cgx_link_speed {
+	CGX_LINK_NONE,
+	CGX_LINK_10M,
+	CGX_LINK_100M,
+	CGX_LINK_1G,
+	CGX_LINK_2HG,	/* 2.5 Gbps */
+	CGX_LINK_5G,
+	CGX_LINK_10G,
+	CGX_LINK_20G,
+	CGX_LINK_25G,
+	CGX_LINK_40G,
+	CGX_LINK_50G,
+	CGX_LINK_80G,
+	CGX_LINK_100G,
+	CGX_LINK_MAX,
+};
+
+/* REQUEST ID types. Input to firmware */
+enum cgx_cmd_id {
+	CGX_CMD_NONE,
+	CGX_CMD_GET_FW_VER,
+	CGX_CMD_GET_MAC_ADDR,
+	CGX_CMD_SET_MTU,
+	CGX_CMD_GET_LINK_STS,		/* optional to user */
+	CGX_CMD_LINK_BRING_UP,
+	CGX_CMD_LINK_BRING_DOWN,
+	CGX_CMD_INTERNAL_LBK,
+	CGX_CMD_EXTERNAL_LBK,
+	CGX_CMD_HIGIG,
+	CGX_CMD_LINK_STAT_CHANGE,
+	CGX_CMD_MODE_CHANGE,		/* hot plug support */
+	CGX_CMD_INTF_SHUTDOWN,
+	CGX_CMD_GET_MKEX_SIZE,
+	CGX_CMD_GET_MKEX_PROFILE,
+	CGX_CMD_GET_FWD_BASE,		/* get base address of shared FW data */
+	CGX_CMD_GET_LINK_MODES,		/* Supported Link Modes */
+	CGX_CMD_SET_LINK_MODE,
+	CGX_CMD_GET_SUPPORTED_FEC,
+	CGX_CMD_SET_FEC,
+	CGX_CMD_GET_AN,
+	CGX_CMD_SET_AN,
+	CGX_CMD_GET_ADV_LINK_MODES,
+	CGX_CMD_GET_ADV_FEC,
+	CGX_CMD_GET_PHY_MOD_TYPE, /* line-side modulation type: NRZ or PAM4 */
+	CGX_CMD_SET_PHY_MOD_TYPE,
+};
+
+/* async event ids */
+enum cgx_evt_id {
+	CGX_EVT_NONE,
+	CGX_EVT_LINK_CHANGE,
+};
+
+/* event types - cause of interrupt */
+enum cgx_evt_type {
+	CGX_EVT_ASYNC,
+	CGX_EVT_CMD_RESP
+};
+
+enum cgx_stat {
+	CGX_STAT_SUCCESS,
+	CGX_STAT_FAIL
+};
+
+enum cgx_cmd_own {
+	/* default ownership with kernel/uefi/u-boot */
+	CGX_OWN_NON_SECURE_SW,
+	/* set by kernel/uefi/u-boot after posting a new request to ATF */
+	CGX_OWN_FIRMWARE,
+};
+
+/* scratchx(0) CSR used for ATF->non-secure SW communication.
+ * This acts as the status register
+ * Provides details on command ack/status, link status, error details
+ */
+
+/* CAUTION : below structures are placed in order based on the bit positions
+ * For any updates/new bitfields, corresponding structures needs to be updated
+ */
+struct cgx_evt_sts_s {			/* start from bit 0 */
+	uint64_t ack:1;
+	uint64_t evt_type:1;		/* cgx_evt_type */
+	uint64_t stat:1;		/* cgx_stat */
+	uint64_t id:6;			/* cgx_evt_id/cgx_cmd_id */
+	uint64_t reserved:55;
+};
+
+/* all the below structures are in the same memory location of SCRATCHX(0)
+ * value can be read/written based on command ID
+ */
+
+/* Resp to command IDs with command status as CGX_STAT_FAIL
+ * Not applicable for commands :
+ *	CGX_CMD_LINK_BRING_UP/DOWN/CGX_EVT_LINK_CHANGE
+ *	check struct cgx_lnk_sts_s comments
+ */
+struct cgx_err_sts_s {			/* start from bit 9 */
+	uint64_t reserved1:9;
+	uint64_t type:10;		/* cgx_error_type */
+	uint64_t reserved2:35;
+};
+
+/* Resp to cmd ID as CGX_CMD_GET_FW_VER with cmd status as CGX_STAT_SUCCESS */
+struct cgx_ver_s {			/* start from bit 9 */
+	uint64_t reserved1:9;
+	uint64_t major_ver:4;
+	uint64_t minor_ver:4;
+	uint64_t reserved2:47;
+};
+
+/* Resp to cmd ID as CGX_CMD_GET_MAC_ADDR with cmd status as CGX_STAT_SUCCESS
+ * Returns each byte of MAC address in a separate bit field
+ */
+struct cgx_mac_addr_s {			/* start from bit 9 */
+	uint64_t reserved1:9;
+	uint64_t addr_0:8;
+	uint64_t addr_1:8;
+	uint64_t addr_2:8;
+	uint64_t addr_3:8;
+	uint64_t addr_4:8;
+	uint64_t addr_5:8;
+	uint64_t reserved2:7;
+};
+
+/* Resp to cmd ID - CGX_CMD_LINK_BRING_UP/DOWN, event ID CGX_EVT_LINK_CHANGE
+ * status can be either CGX_STAT_FAIL or CGX_STAT_SUCCESS
+ * In case of CGX_STAT_FAIL, it indicates CGX configuration failed when
+ * processing link up/down/change command. Both err_type and current link status
+ * will be updated
+ * In case of CGX_STAT_SUCCESS, err_type will be CGX_ERR_NONE and current
+ * link status will be updated
+ */
+struct cgx_lnk_sts_s {
+	uint64_t reserved1:9;
+	uint64_t link_up:1;
+	uint64_t full_duplex:1;
+	uint64_t speed:4;	/* cgx_link_speed */
+	uint64_t err_type:10;
+	uint64_t an:1;		/* Current AN state : enabled/disabled */
+	uint64_t fec:2;		/* Current FEC type if enabled, if not 0 */
+	uint64_t port:8;	/* Share the current port info if required */
+	uint64_t reserved2:28;
+};
+
+struct sh_fwd_base_s {
+	uint64_t reserved1:9;
+	uint64_t addr:55;
+};
+
+struct cgx_link_modes_s {
+	uint64_t reserved1:9;
+	uint64_t modes:55;
+};
+
+/* Resp to cmd ID - CGX_CMD_GET_ADV_FEC/CGX_CMD_GET_SUPPORTED_FEC
+ * fec : 2 bits
+ * typedef enum cgx_fec_type {
+ *     CGX_FEC_NONE,
+ *     CGX_FEC_BASE_R,
+ *     CGX_FEC_RS
+ * } fec_type_t;
+ */
+struct cgx_fec_types_s {
+	uint64_t reserved1:9;
+	uint64_t fec:2;
+	uint64_t reserved2:53;
+};
+
+/* Resp to cmd ID - CGX_CMD_GET_AN */
+struct cgx_get_an_s {
+	uint64_t reserved1:9;
+	uint64_t an:1;
+	uint64_t reserved2:54;
+};
+
+/* Resp to cmd ID - CGX_CMD_GET_PHY_MOD_TYPE */
+struct cgx_get_phy_mod_type_s {
+	uint64_t reserved1:9;
+	uint64_t mod:1;		/* 0=NRZ, 1=PAM4 */
+	uint64_t reserved2:54;
+};
+
+union cgx_rsp_sts {
+	/* Fixed, applicable for all commands/events */
+	struct cgx_evt_sts_s evt_sts;
+	/* response to CGX_CMD_LINK_BRINGUP/DOWN/LINK_CHANGE */
+	struct cgx_lnk_sts_s link_sts;
+	/* response to CGX_CMD_GET_FW_VER */
+	struct cgx_ver_s ver;
+	/* response to CGX_CMD_GET_MAC_ADDR */
+	struct cgx_mac_addr_s mac_s;
+	/* response to CGX_CMD_GET_FWD_BASE */
+	struct sh_fwd_base_s fwd_base_s;
+	/* response if evt_status = CMD_FAIL */
+	struct cgx_err_sts_s err;
+	/* response to CGX_CMD_GET_SUPPORTED_FEC */
+	struct cgx_fec_types_s supported_fec;
+	/* response to CGX_CMD_GET_LINK_MODES */
+	struct cgx_link_modes_s supported_modes;
+	/* response to CGX_CMD_GET_ADV_LINK_MODES */
+	struct cgx_link_modes_s adv_modes;
+	/* response to CGX_CMD_GET_ADV_FEC */
+	struct cgx_fec_types_s adv_fec;
+	/* response to CGX_CMD_GET_AN */
+	struct cgx_get_an_s an;
+	/* response to CGX_CMD_GET_PHY_MOD_TYPE */
+	struct cgx_get_phy_mod_type_s phy_mod_type;
+#ifdef NT_FW_CONFIG
+	/* response to CGX_CMD_GET_MKEX_SIZE */
+	struct cgx_mcam_profile_sz_s prfl_sz;
+	/* response to CGX_CMD_GET_MKEX_PROFILE */
+	struct cgx_mcam_profile_addr_s prfl_addr;
+#endif
+};
+
+union cgx_scratchx0 {
+	uint64_t u;
+	union cgx_rsp_sts s;
+};
+
+/* scratchx(1) CSR used for non-secure SW->ATF communication
+ * This CSR acts as a command register
+ */
+struct cgx_cmd {			/* start from bit 2 */
+	uint64_t reserved1:2;
+	uint64_t id:6;			/* cgx_request_id */
+	uint64_t reserved2:56;
+};
+
+/* all the below structures are in the same memory location of SCRATCHX(1)
+ * corresponding arguments for command Id needs to be updated
+ */
+
+/* Any command using enable/disable as an argument need
+ * to pass the option via this structure.
+ * Ex: Loopback, HiGig...
+ */
+struct cgx_ctl_args {			/* start from bit 8 */
+	uint64_t reserved1:8;
+	uint64_t enable:1;
+	uint64_t reserved2:55;
+};
+
+/* command argument to be passed for cmd ID - CGX_CMD_SET_MTU */
+struct cgx_mtu_args {
+	uint64_t reserved1:8;
+	uint64_t size:16;
+	uint64_t reserved2:40;
+};
+
+/* command argument to be passed for cmd ID - CGX_CMD_LINK_CHANGE */
+struct cgx_link_change_args {		/* start from bit 8 */
+	uint64_t reserved1:8;
+	uint64_t link_up:1;
+	uint64_t full_duplex:1;
+	uint64_t speed:4;		/* cgx_link_speed */
+	uint64_t reserved2:50;
+};
+
+/* command argument to be passed for cmd ID - CGX_CMD_SET_LINK_MODE */
+struct cgx_set_mode_args {
+	uint64_t reserved1:8;
+	uint64_t mode:56;
+};
+
+/* command argument to be passed for cmd ID - CGX_CMD_SET_FEC */
+struct cgx_set_fec_args {
+	uint64_t reserved1:8;
+	uint64_t fec:2;
+	uint64_t reserved2:54;
+};
+
+/* command argument to be passed for cmd ID - CGX_CMD_SET_PHY_MOD_TYPE */
+struct cgx_set_phy_mod_args {
+	uint64_t reserved1:8;
+	uint64_t mod:1;		/* 0=NRZ, 1=PAM4 */
+	uint64_t reserved2:55;
+};
+
+union cgx_cmd_s {
+	uint64_t own_status:2;			/* cgx_cmd_own */
+	struct cgx_cmd cmd;
+	struct cgx_ctl_args cmd_args;
+	struct cgx_mtu_args mtu_size;
+	struct cgx_link_change_args lnk_args;	/* Input to CGX_CMD_LINK_CHANGE */
+	struct cgx_set_mode_args mode_args;
+	struct cgx_set_fec_args fec_args;
+	struct cgx_set_phy_mod_args phy_mod_args;
+	/* any other arg for command id * like : mtu, dmac filtering control */
+};
+
+union cgx_scratchx1 {
+	uint64_t u;
+	union cgx_cmd_s s;
+};
+
+#endif /* __CGX_INTF_H__ */
diff --git a/drivers/net/octeontx2/lmt.h b/drivers/net/octeontx2/lmt.h
new file mode 100644
index 0000000..0108a05
--- /dev/null
+++ b/drivers/net/octeontx2/lmt.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+/**
+ * Atomically adds a signed value to a 64 bit (aligned) memory location,
+ * and returns previous value.
+ *
+ * This version does not perform 'sync' operations to enforce memory
+ * operations.  This should only be used when there are no memory operation
+ * ordering constraints.  (This should NOT be used for reference counting -
+ * use the standard version instead.)
+ *
+ * @param ptr    address in memory to add incr to
+ * @param incr   amount to increment memory location by (signed)
+ *
+ * @return Value of memory location before increment
+ */
+static inline s64 cavm_atomic_fetch_and_add64_nosync(s64 *ptr, s64 incr)
+{
+	s64 result;
+	/* Atomic add with no ordering */
+	asm volatile("ldadd %x[i], %x[r], [%[b]]"
+		     : [r] "=r" (result), "+m" (*ptr)
+		     : [i] "r" (incr), [b] "r" (ptr)
+		     : "memory");
+	return result;
+}
+
+static inline void cavm_lmt_cancel(const struct nix *nix)
+{
+	writeq(0, nix->lmt_base + CAVM_LMT_LF_LMTCANCEL());
+}
+
+static inline volatile u64 *cavm_lmt_store_ptr(struct nix *nix)
+{
+	return (volatile u64 *)((u8 *)(nix->lmt_base) +
+				       CAVM_LMT_LF_LMTLINEX(0));
+}
+
+static inline s64 cavm_lmt_submit(u64 io_address)
+{
+	s64 result = 0;
+
+	asm volatile("ldeor xzr, %x[rf],[%[rs]]"
+			: [rf] "=r"(result) : [rs] "r"(io_address));
+	return result;
+}
diff --git a/drivers/net/octeontx2/nix.c b/drivers/net/octeontx2/nix.c
new file mode 100644
index 0000000..e1e86e8
--- /dev/null
+++ b/drivers/net/octeontx2/nix.c
@@ -0,0 +1,852 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#include <common.h>
+#include <net.h>
+#include <malloc.h>
+#include <dm.h>
+#include <misc.h>
+#include <pci.h>
+#include <memalign.h>
+#include <watchdog.h>
+#include <asm/types.h>
+#include <asm/io.h>
+#include <linux/types.h>
+#include <linux/log2.h>
+#include <asm/arch/octeontx2.h>
+#include "cavm-csrs-lmt.h"
+#include "nix.h"
+#include "lmt.h"
+#include "cgx.h"
+
+/**
+ * NIX needs a lot of memory areas. Rather than handle all the failure cases,
+ * we'll use a wrapper around alloc that prints an error if a memory
+ * allocation fails.
+ *
+ * @param num_elements
+ *                  Number of elements to allocate
+ * @param elem_size Size of each element
+ * @param msg       Text string to show when allocation fails
+ *
+ * @return A valid memory location or NULL on failure
+ */
+static void *nix_memalloc(int num_elements, size_t elem_size, const char *msg)
+{
+	size_t alloc_size = num_elements * elem_size;
+	void *base = memalign(CONFIG_SYS_CACHELINE_SIZE, alloc_size);
+
+	if (!base)
+		printf("NIX: Memory alloc failed for %s (%d * %zu = %zu bytes)\n",
+		       msg ? msg : __func__, num_elements, elem_size,
+		       alloc_size);
+	else
+		memset(base, 0, alloc_size);
+
+	debug("NIX: Memory alloc for %s (%d * %zu = %zu bytes) at %p\n",
+	       msg ? msg : __func__, num_elements, elem_size,
+	       alloc_size, base);
+	return base;
+}
+
+int npc_lf_setup(struct nix *nix)
+{
+	int err;
+
+	err = npc_lf_admin_setup(nix);
+	if (err) {
+		printf("%s: Error setting up npc lf admin\n", __func__);
+		return err;
+	}
+
+	return 0;
+}
+
+static int npa_setup_pool(struct npa *npa, u32 pool_id,
+			  size_t buffer_size, u32 queue_length, void *buffers[])
+{
+	struct {
+		union cavm_npa_lf_aura_op_free0 f0;
+		union cavm_npa_lf_aura_op_free1 f1;
+	} aura_descr;
+	int index;
+
+	for (index = 0; index < queue_length; index++) {
+		buffers[index] = memalign(CONFIG_SYS_CACHELINE_SIZE,
+					  buffer_size);
+		if (!buffers[index]) {
+			printf("%s: Out of memory allocating buffer %d, size: %zu\n",
+			       __func__, index, buffer_size);
+			return -ENOMEM;
+		}
+		debug("%s: allocating buffer %d, addr %p size: %zu\n",
+		       __func__, index, buffers[index], buffer_size);
+
+		/* Add the newly obtained pointer to the pool.  128 bit
+		 * writes only.
+		 */
+		aura_descr.f0.s.addr = (u64)buffers[index];
+		aura_descr.f1.u = 0;
+		aura_descr.f1.s.fabs = 1;
+		aura_descr.f1.s.aura = pool_id;
+		cavm_st128(npa->npa_base + CAVM_NPA_LF_AURA_OP_FREE0(),
+			   aura_descr.f0.u, aura_descr.f1.u);
+	}
+
+	return 0;
+}
+
+int npa_lf_setup(struct nix *nix)
+{
+	struct rvu_pf *rvu = dev_get_priv(nix->dev);
+	struct nix_af *nix_af = nix->nix_af;
+	struct npa *npa; 
+	union cavm_npa_af_const npa_af_const;
+	union cavm_npa_aura_s *aura;
+	union cavm_npa_pool_s *pool;
+	union cavm_rvu_func_addr_s block_addr;
+	int idx;
+	int stack_page_pointers;
+	int stack_page_bytes;
+	int err;
+
+	npa = (struct npa *)calloc(1, sizeof(struct npa));
+	if (!npa) {
+		printf("%s: out of memory for npa instance\n", __func__);
+		return -ENOMEM;
+	}
+	block_addr.u = 0;
+	block_addr.s.block = CAVM_RVU_BLOCK_ADDR_E_NPA;
+	npa->npa_base = rvu->pf_base + block_addr.u;
+	npa->npa_af = nix_af->npa_af;
+	nix->npa = npa;
+
+	npa_af_const.u = npa_af_reg_read(npa->npa_af, CAVM_NPA_AF_CONST());
+	stack_page_pointers = npa_af_const.s.stack_page_ptrs;
+	stack_page_bytes = npa_af_const.s.stack_page_bytes;
+
+	npa->stack_pages[NPA_POOL_RX] = (RQ_QLEN + stack_page_pointers - 1) /
+							stack_page_pointers;
+	npa->stack_pages[NPA_POOL_TX] = (SQ_QLEN + stack_page_pointers - 1) /
+							stack_page_pointers;
+	npa->pool_stack_pointers = stack_page_pointers;
+
+	npa->q_len[NPA_POOL_RX] = RQ_QLEN;
+	npa->q_len[NPA_POOL_TX] = SQ_QLEN;
+
+	npa->buf_size[NPA_POOL_RX] = MAX_MTU + CONFIG_SYS_CACHELINE_SIZE;
+	npa->buf_size[NPA_POOL_TX] = nix_af->sqb_size;
+
+	npa->rx_pool_stack_pages = npa->stack_pages[NPA_POOL_RX];
+	npa->tx_pool_stack_pages = npa->stack_pages[NPA_POOL_TX];
+
+	npa->aura_ctx = nix_memalloc(NPA_POOL_COUNT, sizeof(union cavm_npa_aura_s),
+					"aura context");
+	if (!npa->aura_ctx) {
+		printf("%s: Out of memory for aura context\n", __func__);
+		return -ENOMEM;
+	}
+
+	for (idx = 0; idx < NPA_POOL_COUNT; idx++) {
+		npa->pool_ctx[idx] = nix_memalloc(1, sizeof(union cavm_npa_pool_s),
+							"pool context");
+		if (!npa->pool_ctx[idx]) {
+			printf("%s: Out of memory for pool context\n",
+			       __func__);
+			return -ENOMEM;
+		}
+		npa->pool_stack[idx] = nix_memalloc(npa->stack_pages[idx],
+							 stack_page_bytes,
+							 "pool stack");
+		if (!npa->pool_stack[idx]){
+			printf("%s: Out of memory for pool stack\n", __func__);
+			return -ENOMEM;
+		}
+	}
+
+	err = npa_lf_admin_setup(npa, nix->lf, (dma_addr_t) npa->aura_ctx);
+	if (err) {
+		printf("%s: Error setting up NPA LF admin for lf %d\n",
+		       __func__, nix->lf);
+		return err;
+	}
+
+	/* Set up the auras */
+	for (idx = 0; idx < NPA_POOL_COUNT; idx++) {
+		aura = npa->aura_ctx + (idx * sizeof(union cavm_npa_aura_s));
+		pool = npa->pool_ctx[idx];
+		debug("%s aura %p pool %p\n",__func__,aura,pool);
+		memset(aura, 0, sizeof(union cavm_npa_aura_s));
+		aura->s.fc_ena = 0;
+		aura->s.pool_addr = (u64)npa->pool_ctx[idx];
+		debug("%s aura.s.pool_addr %llx pool_addr %p\n",__func__,
+			aura->s.pool_addr,npa->pool_ctx[idx]);
+		aura->s.shift = 64 - __builtin_clzll(npa->q_len[idx]) - 8;
+		aura->s.count = npa->q_len[idx];
+		aura->s.limit = npa->q_len[idx];
+		aura->s.ena = 1;
+		err = npa_attach_aura(nix_af, nix->lf, aura, idx);
+		if (err)
+			return err;
+
+		memset(pool, 0, sizeof(*pool));
+		pool->s.fc_ena = 0;
+		pool->s.nat_align = 1;
+		pool->s.stack_base = (u64)(npa->pool_stack[idx]);
+		debug("%s pool.s.stack_base %llx stack_base %p\n",__func__,
+			pool->s.stack_base,npa->pool_stack[idx]);
+		pool->s.buf_size = 
+			npa->buf_size[idx]/CONFIG_SYS_CACHELINE_SIZE;
+		pool->s.stack_max_pages = npa->stack_pages[idx];
+		pool->s.shift =
+			64 - __builtin_clzll(npa->pool_stack_pointers) - 8;
+		pool->s.ptr_start = 0;
+		pool->s.ptr_end = (1ULL << 40) -  1;
+		pool->s.ena = 1;
+		err = npa_attach_pool(nix_af, nix->lf, pool, idx);
+		if (err)
+			return err;
+	}
+
+	npa->rx_buffers = nix_memalloc(npa->q_len[NPA_POOL_RX], sizeof(void *),
+					"rx_buffers");
+	if (!npa->rx_buffers) {
+		printf("%s: Out of memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	npa->tx_buffers = nix_memalloc(npa->q_len[NPA_POOL_TX], sizeof(void *),
+					"tx_buffers");
+	if (!npa->tx_buffers) {
+		printf("%s: Out of memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	for (idx = 0; idx < NPA_POOL_COUNT; idx++) {
+		err = npa_setup_pool(npa, idx, npa->buf_size[idx],
+				     npa->q_len[idx], idx == NPA_POOL_RX ?
+				     npa->rx_buffers : npa->tx_buffers);
+		if (err) {
+			printf("%s: Error setting up pool %d\n",
+			       __func__, idx);
+			return err;
+		}
+	}
+	return 0;
+}
+
+int npa_lf_shutdown(struct nix *nix)
+{
+	struct npa *npa = nix->npa;
+	int err;
+	int pool;
+
+	err = npa_lf_admin_shutdown(nix->nix_af, nix->lf, NPA_POOL_COUNT);
+	if (err) {
+		printf("%s: Error %d shutting down NPA LF admin\n",
+		       __func__, err);
+		return err;
+	}
+	free(npa->aura_ctx);
+	npa->aura_ctx = NULL;
+
+	for (pool = 0; pool < NPA_POOL_COUNT; pool++) {
+		free(npa->pool_ctx[pool]);
+		npa->pool_ctx[pool] = NULL;
+		free(npa->pool_stack[pool]);
+		npa->pool_stack[pool] = NULL;
+	}
+
+	free(npa->rx_buffers);
+	npa->rx_buffers = NULL;
+	free(npa->tx_buffers);
+	npa->tx_buffers = NULL;
+
+	return 0;
+}
+
+int nix_lf_setup(struct nix *nix)
+{
+	struct nix_af *nix_af = nix->nix_af;
+	int idx;
+	int err = -1;
+
+	/* Alloc NIX RQ HW context memory */
+	nix->rq_ctx_base = nix_memalloc(nix->rq_cnt, nix_af->rq_ctx_sz,
+					"RQ CTX");
+	if (!nix->rq_ctx_base)
+		goto error;
+	memset(nix->rq_ctx_base, 0, nix_af->rq_ctx_sz);
+
+	/* Alloc NIX SQ HW context memory */
+	nix->sq_ctx_base = nix_memalloc(nix->sq_cnt, nix_af->sq_ctx_sz,
+					"SQ CTX");
+	if (!nix->sq_ctx_base)
+		goto error;
+	memset(nix->sq_ctx_base, 0, nix_af->sq_ctx_sz);
+
+	/* Alloc NIX CQ HW context memory */
+	nix->cq_ctx_base = nix_memalloc(nix->cq_cnt, nix_af->cq_ctx_sz,
+					"CQ CTX");
+	if (!nix->cq_ctx_base)
+		goto error;
+	memset(nix->cq_ctx_base, 0, nix_af->cq_ctx_sz * NIX_CQ_COUNT);
+	/* Alloc NIX CQ Ring memory */
+	for (idx = 0; idx < NIX_CQ_COUNT; idx++) {
+		err = qmem_alloc(&(nix->cq[idx]), CQ_ENTRIES, CQ_ENTRY_SIZE);
+		if (err)
+			goto error;
+	}
+
+	/* Alloc memory for Qints HW contexts */
+	nix->qint_base = nix_memalloc(nix_af->qints, nix_af->qint_ctx_sz,
+					"Qint CTX");
+	if (!nix->qint_base)
+		goto error;
+	/* Alloc memory for CQints HW contexts */
+	nix->cint_base = nix_memalloc(nix_af->cints, nix_af->cint_ctx_sz,
+					"Cint CTX");
+	if (!nix->cint_base)
+		goto error;
+	/* Alloc NIX RSS HW context memory and config the base */
+	nix->rss_base = nix_memalloc(nix->rss_grps, nix_af->rsse_ctx_sz,
+					"RSS CTX");
+	if (!nix->rss_base)
+		goto error;
+
+	err = nix_lf_admin_setup(nix);
+	if (err) {
+		printf("%s: Error setting up LF\n", __func__);
+		goto error;
+	}
+
+	return 0;
+
+error:
+	if (nix->rq_ctx_base)
+		free(nix->rq_ctx_base);
+	nix->rq_ctx_base = NULL;
+	if (nix->rq_ctx_base)
+		free(nix->rq_ctx_base);
+	nix->rq_ctx_base = NULL;
+	if (nix->sq_ctx_base)
+		free(nix->sq_ctx_base);
+	nix->sq_ctx_base = NULL;
+	if (nix->cq_ctx_base)
+		free(nix->cq_ctx_base);
+	nix->cq_ctx_base = NULL;
+
+	for (idx = 0; idx < NIX_CQ_COUNT; idx++)
+		qmem_free(&nix->cq[idx]);
+
+	return err;
+}
+
+int nix_lf_shutdown(struct nix *nix)
+{
+	struct nix_af *nix_af = nix->nix_af;
+	int index;
+	int err;
+
+	err = nix_lf_admin_shutdown(nix_af, nix->lf, nix->cq_cnt,
+					nix->rq_cnt, nix->sq_cnt);
+	if (err) {
+		printf("%s: Error shutting down LF admin\n", __func__);
+		return err;
+	}
+
+	if (nix->rq_ctx_base)
+		free(nix->rq_ctx_base);
+	nix->rq_ctx_base = NULL;
+	if (nix->rq_ctx_base)
+		free(nix->rq_ctx_base);
+	nix->rq_ctx_base = NULL;
+	if (nix->sq_ctx_base)
+		free(nix->sq_ctx_base);
+	nix->sq_ctx_base = NULL;
+	if (nix->cq_ctx_base)
+		free(nix->cq_ctx_base);
+	nix->cq_ctx_base = NULL;
+
+	for (index = 0; index < NIX_CQ_COUNT; index++)
+		qmem_free(&nix->cq[index]);
+
+	debug("%s: nix lf %d reset -- \n", __func__, nix->lf);
+	return 0;
+}
+
+
+struct nix *nix_lf_alloc(struct udevice *dev)
+{
+	union cavm_rvu_func_addr_s block_addr;
+	struct nix *nix;
+	struct rvu_pf *rvu = dev_get_priv(dev);
+	struct rvu_af *rvu_af = dev_get_priv(rvu->afdev);
+	union cavm_rvu_pf_func_s pf_func;
+	int err;
+
+	debug("%s(%s )\n", __func__, dev->name);
+
+	nix = (struct nix *)calloc(1, sizeof(*nix));
+	if (!nix) {
+		printf("%s: Out of memory for nix instance\n", __func__);
+		return NULL;
+	}
+	nix->nix_af = rvu_af->nix_af;
+
+	block_addr.u = 0;
+	block_addr.s.block = CAVM_RVU_BLOCK_ADDR_E_NIXX(0);
+	nix->nix_base = rvu->pf_base + block_addr.u;
+	block_addr.u = 0;
+	block_addr.s.block = CAVM_RVU_BLOCK_ADDR_E_NPC;
+	nix->npc_base = rvu->pf_base + block_addr.u;
+	block_addr.u = 0;
+	block_addr.s.block = CAVM_RVU_BLOCK_ADDR_E_LMT;
+	nix->lmt_base = rvu->pf_base + block_addr.u;
+
+	pf_func.u = 0;
+	pf_func.s.pf = rvu->pfid;
+	nix->pf_func = pf_func.u;
+	nix->lf = rvu->nix_lfid;
+	nix->pf = rvu->pfid;
+	nix->dev = dev;
+	nix->sq_cnt = nix->rq_cnt = nix->rss_grps = 1;
+	nix->cq_cnt = 2;
+	nix->xqe_sz = NIX_CQE_SIZE_W16; 
+
+	nix->lmac = nix_get_cgx_lmac(nix->pf);
+	if (!nix->lmac) {
+		printf("%s: Error: could not find lmac for pf %d\n",
+		       __func__, nix->pf);
+		free(nix);
+		return NULL;
+	}
+	nix->lmac->link_num =
+		CAVM_NIX_LINK_E_CGXX_LMACX(nix->lmac->cgx->cgx_id,
+					   nix->lmac->lmac_id);
+	nix->lmac->chan_num =
+		CAVM_NIX_CHAN_E_CGXX_LMACX_CHX(nix->lmac->cgx->cgx_id,
+						nix->lmac->lmac_id, 0);
+	/* This is rx pkind in 1:1 mapping to NIX_LINK_E */
+	nix->lmac->pknd = nix->lmac->link_num;
+
+	cgx_lmac_set_pkind(nix->lmac, nix->lmac->lmac_id, nix->lmac->pknd);
+	debug("%s(%s CGX%x LMAC%x)\n", __func__, dev->name,
+			nix->lmac->cgx->cgx_id, nix->lmac->lmac_id);
+	debug("%s(%s Link %x Chan %x Pknd %x)\n", __func__, dev->name,
+			nix->lmac->link_num, nix->lmac->chan_num,
+			nix->lmac->pknd);
+
+	err = npa_lf_setup(nix);
+	if (err)
+		return NULL;
+	
+	err = npc_lf_setup(nix);
+	if (err)
+		return NULL;
+
+	err = nix_lf_setup(nix);
+	if (err)
+		return NULL;
+
+	return nix;
+}
+
+u64 nix_cq_op_status(struct nix *nix, u64 cq_id)
+{
+	union cavm_nixx_lf_cq_op_status op_status;
+
+	op_status.u = cavm_atomic_fetch_and_add64_nosync(
+			nix->nix_base + CAVM_NIXX_LF_CQ_OP_STATUS(),
+			(u64)cq_id << 32);
+	return op_status.u;
+}
+
+/* TX */
+int nix_alloc_tx_dr(struct nix *nix)
+{
+	int i;
+
+	for (i = 0; i < (SQ_QLEN*2); i++) {
+		if (nix->tx_desc[i].in_use == 0) {
+	debug("%s i%d tx_desc %p  in_use %llx\n", __func__,
+		 i, &nix->tx_desc[i], nix->tx_desc[i].in_use);
+			return i;
+		}
+	}
+	return -1;
+}
+
+void nix_free_tx_dr(struct nix *nix, int sqe_id)
+{
+	debug("%s sqe_id %d\n", __func__, sqe_id);
+	nix->tx_desc[sqe_id].in_use = 0;
+}
+
+static inline void nix_write_lmt(struct nix *nix, void *buffer,
+				 int num_words)
+{
+	int i;
+	volatile u64 *lmt_ptr = cavm_lmt_store_ptr(nix);
+	u64 *ptr = buffer;
+
+	debug("%s lmt_ptr %p %p\n", __func__, nix->lmt_base, lmt_ptr);
+	for (i = 0; i < num_words; i++) {
+		debug("%s data %llx lmt_ptr %p\n", __func__, ptr[i],
+			 lmt_ptr+i);
+		lmt_ptr[i] = ptr[i];
+	}
+}
+
+void nix_cqe_tx_pkt_handler(struct nix *nix, void *cqe)
+{
+	union cavm_nix_cqe_hdr_s *txcqe = (union cavm_nix_cqe_hdr_s *)cqe;
+	union cavm_nix_send_comp_s *send_comp;
+
+	debug("%s: txcqe: %p\n", __func__, txcqe);
+
+	if (txcqe->s.cqe_type != CAVM_NIX_XQE_TYPE_E_SEND) {
+		printf("%s: Error: Unsupported CQ header type %d\n",
+		       __func__, txcqe->s.cqe_type);
+		return;
+	}
+
+	send_comp = (union cavm_nix_send_comp_s *)(txcqe + 1);
+
+	debug("%s: tx descriptor id: %d\n", __func__, send_comp->s.sqe_id);
+
+	nix_free_tx_dr(nix, send_comp->s.sqe_id);
+
+	nix_pf_reg_write(nix, CAVM_NIXX_LF_CQ_OP_DOOR(),
+			 (NIX_CQ_TX << 32) | 1);
+}
+
+int nix_lf_xmit(struct udevice *dev, void *pkt, int pkt_len)
+{
+	struct rvu_pf *rvu = dev_get_priv(dev);
+	struct nix *nix = rvu->nix;
+	struct nix_tx_dr *tx_dr;
+	int dr_sz = (sizeof(struct nix_tx_dr) + 15) / 16 - 1;
+	s64 result;
+	int sqe_id;
+
+	sqe_id = nix_alloc_tx_dr(nix);
+	if (sqe_id < 0) {
+		printf("%s: Error: out of tx descriptors\n", __func__);
+		return -1;
+	}
+	tx_dr = &nix->tx_desc[sqe_id];
+	debug("%s sqe_id %d tx_dr %p\n", __func__, sqe_id, tx_dr);
+	memset((void *)tx_dr, 0, sizeof(struct nix_tx_dr));
+
+	tx_dr->hdr.s.aura = 0xa5a5;
+	tx_dr->hdr.s.df = 1;
+	tx_dr->hdr.s.pnc = 1;
+	tx_dr->hdr.s.sq = 0;
+	tx_dr->hdr.s.sqe_id = sqe_id;
+	tx_dr->hdr.s.total = pkt_len;
+	tx_dr->hdr.s.sizem1 = dr_sz - 2; /* FIXME - for now hdr+sg+sg1addr */
+	debug("%s dr_sz %d \n", __func__, dr_sz);
+
+	tx_dr->tx_sg.s.segs = 1;
+	tx_dr->tx_sg.s.subdc = CAVM_NIX_SUBDC_E_SG;
+	tx_dr->tx_sg.s.seg1_size = pkt_len;
+	tx_dr->tx_sg.s.ld_type = CAVM_NIX_SENDLDTYPE_E_LDT;
+
+	tx_dr->sg1_addr = (dma_addr_t)pkt;
+	tx_dr->in_use = 0x1;
+
+#define DEBUG_PKT
+#ifdef DEBUG_PKT
+	debug("TX PKT Data\n");
+	for (int i = 0; i < pkt_len; i++) {
+		if (i && (i%8 == 0))
+			debug("\n");
+		debug("%02x ", *((u8 *)pkt + i));
+	}
+	debug("\n");
+#endif
+	do {
+		nix_write_lmt(nix, tx_dr, (dr_sz - 1) * 2);
+		__iowmb();
+		result = cavm_lmt_submit((u64)(nix->nix_base +
+					       CAVM_NIXX_LF_OP_SENDX(0)));
+		WATCHDOG_RESET();
+	} while (result == 0);
+	
+	return 0;
+}
+
+/* RX */
+void nix_lf_flush_rx(struct udevice *dev)
+{
+	struct rvu_pf *rvu = dev_get_priv(dev);
+	struct nix *nix = rvu->nix;
+	union cavm_nixx_lf_cq_op_status op_status;
+	void *cq_rx_base = nix->cq[NIX_CQ_RX].base;
+	struct nix_rx_dr *rx_dr;
+	union cavm_nix_rx_parse_s *rxparse;
+	u32 head, tail;
+	u32 rx_cqe_sz = nix->cq[NIX_CQ_RX].entry_sz;
+	u64 *seg;
+
+	/* flush rx cqe entries */
+	op_status.u = nix_cq_op_status(nix, NIX_CQ_RX);
+	head = op_status.s.head;
+	tail = op_status.s.tail;
+	head &= (nix->cq[NIX_CQ_RX].qsize - 1);
+	tail &= (nix->cq[NIX_CQ_RX].qsize - 1);
+
+	debug("%s cq rx head %d tail %d\n", __func__, head, tail);
+	while (head != tail) {
+		rx_dr = (struct nix_rx_dr *)cq_rx_base + head * rx_cqe_sz;
+		rxparse = &(rx_dr->rx_parse);
+
+		debug("%s: rx parse: %p\n", __func__, rxparse);
+		debug("%s: rx parse: desc_sizem1 %x pkt_lenm1 %x \n",
+		 __func__, rxparse->s.desc_sizem1, rxparse->s.pkt_lenm1);
+
+		seg = (dma_addr_t *)(&rx_dr->rx_sg + 1);
+
+		cavm_st128(nix->npa->npa_base + CAVM_NPA_LF_AURA_OP_FREE0(),
+			   seg[0], (1ULL << 63) | NPA_POOL_RX);
+
+		debug("%s return %llx to NPA \n", __func__, seg[0]);
+		nix_pf_reg_write(nix, CAVM_NIXX_LF_CQ_OP_DOOR(),
+				 (NIX_CQ_RX << 32) | 1);
+
+		op_status.u = nix_cq_op_status(nix, NIX_CQ_RX);
+		head = op_status.s.head;
+		tail = op_status.s.tail;
+		head &= (nix->cq[NIX_CQ_RX].qsize - 1);
+		tail &= (nix->cq[NIX_CQ_RX].qsize - 1);
+		debug("%s cq rx head %d tail %d\n", __func__, head, tail);
+	}
+}
+
+int nix_lf_free_pkt(struct udevice *dev, uchar *pkt, int pkt_len)
+{
+	struct rvu_pf *rvu = dev_get_priv(dev);
+	struct nix *nix = rvu->nix;
+	union cavm_nixx_lf_cq_op_status op_status;
+	u32 head, tail;
+	void *cq_tx_base = nix->cq[NIX_CQ_TX].base;
+	union cavm_nix_cqe_hdr_s *cqe;
+
+	/* Return rx packet to NPA */
+	debug("%s return %p to NPA \n", __func__, pkt);
+	cavm_st128(nix->npa->npa_base + CAVM_NPA_LF_AURA_OP_FREE0(),
+		   (u64)pkt, (1ULL << 63) | NPA_POOL_RX);
+	nix_pf_reg_write(nix, CAVM_NIXX_LF_CQ_OP_DOOR(),
+			 (NIX_CQ_RX << 32) | 1);
+
+	/* ack tx cqe entries */
+	op_status.u = nix_cq_op_status(nix, NIX_CQ_TX);
+	head = op_status.s.head;
+	tail = op_status.s.tail;
+	head &= (nix->cq[NIX_CQ_TX].qsize - 1);
+	tail &= (nix->cq[NIX_CQ_TX].qsize - 1);
+
+	debug("%s cq tx head %d tail %d\n", __func__, head, tail);
+	while (head != tail) {
+		cqe = cq_tx_base + head * nix->cq[NIX_CQ_TX].entry_sz;
+		nix_cqe_tx_pkt_handler(nix, cqe);
+
+		op_status.u = nix_cq_op_status(nix, NIX_CQ_TX);
+		head = op_status.s.head;
+		tail = op_status.s.tail;
+		head &= (nix->cq[NIX_CQ_TX].qsize - 1);
+		tail &= (nix->cq[NIX_CQ_TX].qsize - 1);
+		debug("%s cq tx head %d tail %d\n", __func__, head, tail);
+	}
+
+	return 0;
+}
+
+int nix_lf_recv(struct udevice *dev, int flags, uchar **packetp)
+{
+	struct rvu_pf *rvu = dev_get_priv(dev);
+	struct nix *nix = rvu->nix;
+	union cavm_nixx_lf_cq_op_status op_status;
+	void *cq_rx_base = nix->cq[NIX_CQ_RX].base;
+	struct nix_rx_dr *rx_dr;
+	union cavm_nix_rx_parse_s *rxparse;
+	void *pkt, *cqe;
+	int pkt_len = 0;
+	u64 *addr;
+	u32 head, tail;
+
+	/* fetch rx cqe entries */
+	op_status.u = nix_cq_op_status(nix, NIX_CQ_RX);
+	head = op_status.s.head;
+	tail = op_status.s.tail;
+	head &= (nix->cq[NIX_CQ_RX].qsize - 1);
+	tail &= (nix->cq[NIX_CQ_RX].qsize - 1);
+	debug("%s cq rx head %d tail %d\n", __func__, head, tail);
+	if (head == tail)
+		return -EAGAIN;
+
+	debug("%s: rx_base %p head %d sz %d \n", __func__, cq_rx_base, head, nix->cq[NIX_CQ_RX].entry_sz);
+	cqe = cq_rx_base + head * nix->cq[NIX_CQ_RX].entry_sz;
+	rx_dr = (struct nix_rx_dr *)cqe;
+	rxparse = &(rx_dr->rx_parse);
+
+	debug("%s: rx completion: %p\n", __func__, cqe);
+	debug("%s: rx dr: %p\n", __func__, rx_dr);
+	debug("%s: rx parse: %p\n", __func__, rxparse);
+	debug("%s: rx parse: desc_sizem1 %x pkt_lenm1 %x \n",
+		 __func__, rxparse->s.desc_sizem1, rxparse->s.pkt_lenm1);
+	debug("%s: rx parse: pkind %x chan %x \n",
+		 __func__, rxparse->s.pkind, rxparse->s.chan);
+
+	if (rx_dr->hdr.s.cqe_type != CAVM_NIX_XQE_TYPE_E_RX) {
+		printf("%s: Error: Unsupported CQ header type in Rx %d\n",
+		       __func__, rx_dr->hdr.s.cqe_type);
+		return -1;
+	}
+
+	pkt_len = rxparse->s.pkt_lenm1 + 1;
+	addr = (dma_addr_t *)(&rx_dr->rx_sg + 1);
+	pkt = (void *)addr[0];
+
+	debug("%s: segs: %d (%d@0x%llx, %d@0x%llx, %d@0x%llx)\n", __func__,
+	      rx_dr->rx_sg.s.segs, rx_dr->rx_sg.s.seg1_size, addr[0],
+	      rx_dr->rx_sg.s.seg2_size, addr[1],
+	      rx_dr->rx_sg.s.seg3_size, addr[2]);
+	if (pkt_len < rx_dr->rx_sg.s.seg1_size + rx_dr->rx_sg.s.seg2_size +
+			rx_dr->rx_sg.s.seg3_size) {
+		debug("%s: Error: rx buffer size too small\n", __func__);
+		return -1;
+	}
+
+	__iowmb();
+#define DEBUG_PKT
+#ifdef DEBUG_PKT
+	debug("RX PKT Data\n");
+	for (int i = 0; i < pkt_len; i++) {
+		if (i && (i%8 == 0))
+			debug("\n");
+		debug("%02x ", *((u8 *)pkt + i));
+	}
+	debug("\n");
+#endif
+
+	*packetp = (uchar *)pkt;
+
+	return pkt_len;
+}
+
+int nix_lf_setup_mac(struct udevice *dev)
+{
+	struct rvu_pf *rvu = dev_get_priv(dev);
+	struct nix *nix = rvu->nix;
+	struct eth_pdata *pdata = dev_get_platdata(dev);
+
+	/* If lower level firmware fails to set proper MAC
+	 * u-boot framework updates MAC to random address.
+	 * Use this hook to update mac address in cgx lmac
+	 * and call mac filter setup to update new address.
+	 */
+	if (memcmp(nix->lmac->mac_addr, pdata->enetaddr, ARP_HLEN)) {
+		memcpy(nix->lmac->mac_addr, pdata->enetaddr, 6);
+		eth_env_set_enetaddr_by_index("eth", rvu->dev->seq,
+					      pdata->enetaddr);
+		cgx_lmac_mac_filter_setup(nix->lmac);
+		debug("%s: lMAC %pM\n", __func__, nix->lmac->mac_addr);
+		debug("%s: pMAC %pM\n", __func__, pdata->enetaddr);
+	}
+	debug("%s: setupMAC %pM\n", __func__, pdata->enetaddr);
+	return 0;
+}
+
+int nix_lf_read_rom_mac(struct udevice *dev)
+{
+	return -ENOSYS;
+}
+
+void nix_lf_halt(struct udevice *dev)
+{
+	struct rvu_pf *rvu = dev_get_priv(dev);
+	struct nix *nix = rvu->nix;
+
+	cgx_lmac_rx_tx_enable(nix->lmac, nix->lmac->lmac_id, false);
+
+	mdelay(1);
+
+	/* Flush tx and rx descriptors */
+	nix_lf_flush_rx(dev);
+	for (int i = 0; i < (SQ_QLEN * 2); i++)
+		if (nix->tx_desc[i].in_use)
+			nix_free_tx_dr(nix, i);
+}
+
+int nix_lf_init(struct udevice *dev)
+{
+	struct rvu_pf *rvu = dev_get_priv(dev);
+	struct nix *nix = rvu->nix;
+	struct lmac *lmac = nix->lmac;
+	int ret;
+	u64 link_sts;
+	u8 link, speed;
+	u16 errcode;
+
+	printf("Waiting for CGX%d LMAC%d [%s] link status...",
+	       lmac->cgx->cgx_id, lmac->lmac_id,
+	       lmac_type_to_str[lmac->lmac_type]);
+
+	if (lmac->init_pend) {
+		/* Bring up LMAC */
+		ret = cgx_lmac_link_enable(lmac, lmac->lmac_id,
+					   true, &link_sts);
+		lmac->init_pend = 0;
+	} else {
+		ret = cgx_lmac_link_status(lmac, lmac->lmac_id, &link_sts);
+	}
+
+	if (ret) {
+		printf(" [Down]\n");
+		return -1;
+	}
+
+	link = link_sts & 0x1;
+	speed = (link_sts >> 2) & 0xf;
+	errcode = (link_sts >> 6) & 0x2ff;
+	debug("%s: link %x speed %x errcode %x\n",
+	      __func__, link, speed, errcode);
+
+	/* Print link status */
+	printf(" [%s]\n", link ? lmac_speed_to_str[speed] : "Down");
+	if (!link)
+		return -1;
+
+	if (!lmac->init_pend)
+		cgx_lmac_rx_tx_enable(lmac, lmac->lmac_id, true);
+
+	return 0;
+}
+
+void nix_get_cgx_lmac_id(struct udevice *dev, int *cgxid, int *lmacid)
+{
+	struct rvu_pf *rvu = dev_get_priv(dev);
+	struct nix *nix = rvu->nix;
+	struct lmac *lmac = nix->lmac;
+
+	*cgxid = lmac->cgx->cgx_id;
+	*lmacid = lmac->lmac_id;
+}
+
+void nix_print_mac_info(struct udevice *dev)
+{
+	struct rvu_pf *rvu = dev_get_priv(dev);
+	struct nix *nix = rvu->nix;
+	struct lmac *lmac = nix->lmac;
+
+	printf(" CGX%d LMAC%d [%s]", lmac->cgx->cgx_id, lmac->lmac_id,
+	       lmac_type_to_str[lmac->lmac_type]);
+}
+
diff --git a/drivers/net/octeontx2/nix.h b/drivers/net/octeontx2/nix.h
new file mode 100644
index 0000000..6f7e286
--- /dev/null
+++ b/drivers/net/octeontx2/nix.h
@@ -0,0 +1,334 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#ifndef __NIX_H__
+#define	__NIX_H__
+
+#include "cavm-csrs-npa.h"
+#include "cavm-csrs-nix.h"
+#include "rvu.h"
+
+/** Maximum number of LMACs supported */
+#define MAX_LMAC			12
+
+/* NIX RX action operation*/
+#define NIX_RX_ACTIONOP_DROP		(0x0ull)
+#define NIX_RX_ACTIONOP_UCAST		(0x1ull)
+#define NIX_RX_ACTIONOP_UCAST_IPSEC	(0x2ull)
+#define NIX_RX_ACTIONOP_MCAST		(0x3ull)
+#define NIX_RX_ACTIONOP_RSS		(0x4ull)
+
+/* NIX TX action operation*/
+#define NIX_TX_ACTIONOP_DROP		(0x0ull)
+#define NIX_TX_ACTIONOP_UCAST_DEFAULT	(0x1ull)
+#define NIX_TX_ACTIONOP_UCAST_CHAN	(0x2ull)
+#define NIX_TX_ACTIONOP_MCAST		(0x3ull)
+#define NIX_TX_ACTIONOP_DROP_VIOL	(0x5ull)
+
+#define NIX_INTF_RX			0
+#define NIX_INTF_TX			1
+
+#define NIX_INTF_TYPE_CGX		0
+#define NIX_INTF_TYPE_LBK		1
+#define NIX_MAX_HW_MTU			9212
+#define NIX_MIN_HW_MTU			40
+#define MAX_MTU				1536
+
+#define NPA_POOL_COUNT			2
+#define NPA_AURA_COUNT(x)		(1ULL << ((x) + 6))
+#define NPA_POOL_RX			0ULL
+#define NPA_POOL_TX			1ULL
+#define RQ_QLEN				Q_COUNT(Q_SIZE_1K)
+#define SQ_QLEN				Q_COUNT(Q_SIZE_16)
+
+#define NIX_CQ_RX			0ULL
+#define NIX_CQ_TX			1ULL
+#define NIX_CQ_COUNT			2ULL
+#define NIX_CQE_SIZE_W16		(16 * sizeof(u64))
+#define NIX_CQE_SIZE_W64		(64 * sizeof(u64))
+
+/** Size of aura hardware context */
+#define NPA_AURA_HW_CTX_SIZE		48
+/** Size of pool hardware context */
+#define NPA_POOL_HW_CTX_SIZE		64
+
+#define NPA_DEFAULT_PF_FUNC		0xffff
+
+#define NIX_CHAN_CGX_LMAC_CHX(a, b, c)	(0x800 + 0x100 * (a) + 0x10 * (b) + (c))
+#define NIX_LINK_CGX_LMAC(a, b)		(0 + 4 * (a) + (b))
+#define NIX_LINK_LBK(a)			(12 + (a))
+#define NIX_CHAN_LBK_CHX(a, b)		(0 + 0x100 * (a) + (b))
+#define MAX_LMAC_PKIND			12
+
+/** Number of Admin queue entries */
+#define AQ_RING_SIZE 			Q_COUNT(Q_SIZE_16)
+
+/** Each completion queue contains 256 entries, see NIC_CQ_CTX_S[qsize] */
+#define CQS_QSIZE			Q_SIZE_256
+#define CQ_ENTRIES			Q_COUNT(CQS_QSIZE)
+/**
+ * Each completion queue entry contains 128 bytes, see
+ * NIXX_AF_LFX_CFG[xqe_size]
+ */
+#define CQ_ENTRY_SIZE			NIX_CQE_SIZE_W16
+
+enum npa_aura_size {
+	NPA_AURA_SZ_0,
+	NPA_AURA_SZ_128,
+	NPA_AURA_SZ_256,
+	NPA_AURA_SZ_512,
+	NPA_AURA_SZ_1K,
+	NPA_AURA_SZ_2K,
+	NPA_AURA_SZ_4K,
+	NPA_AURA_SZ_8K,
+	NPA_AURA_SZ_16K,
+	NPA_AURA_SZ_32K,
+	NPA_AURA_SZ_64K,
+	NPA_AURA_SZ_128K,
+	NPA_AURA_SZ_256K,
+	NPA_AURA_SZ_512K,
+	NPA_AURA_SZ_1M,
+	NPA_AURA_SZ_MAX,
+};
+#define NPA_AURA_SIZE_DEFAULT		NPA_AURA_SZ_128
+
+/* NIX Transmit schedulers */
+enum nix_scheduler {
+	NIX_TXSCH_LVL_SMQ = 0x0,
+	NIX_TXSCH_LVL_MDQ = 0x0,
+	NIX_TXSCH_LVL_TL4 = 0x1,
+	NIX_TXSCH_LVL_TL3 = 0x2,
+	NIX_TXSCH_LVL_TL2 = 0x3,
+	NIX_TXSCH_LVL_TL1 = 0x4,
+	NIX_TXSCH_LVL_CNT = 0x5,
+};
+
+struct cgx;
+
+struct nix_stats {
+	u64	num_packets;
+	u64	num_bytes;
+};
+
+struct nix;
+struct lmac;
+
+struct npa_af {
+	void __iomem		*npa_af_base;
+	struct admin_queue	aq;
+	u32			aura;
+};
+
+struct npa {
+	struct npa_af		*npa_af;
+	void __iomem		*npa_base;
+	void __iomem		*npc_base;
+	void __iomem		*lmt_base;
+	/** Hardware aura context */
+	void			*aura_ctx;
+	/** Hardware pool context */
+	void			*pool_ctx[NPA_POOL_COUNT];
+	void			*pool_stack[NPA_POOL_COUNT];
+	void			**rx_buffers;
+	void			**tx_buffers;
+	u32			rx_pool_stack_pages;
+	u32			tx_pool_stack_pages;
+	u32			pool_stack_pointers;
+	u32			q_len[NPA_POOL_COUNT];
+	u32			buf_size[NPA_POOL_COUNT];
+	u32			stack_pages[NPA_POOL_COUNT];
+};
+
+struct nix_af {
+	struct udevice			*dev;
+	struct nix			*lmacs[MAX_LMAC];
+	struct npa_af			*npa_af;
+	void __iomem			*nix_af_base;
+	void __iomem			*npc_af_base;
+	struct admin_queue		aq;
+	u8				num_lmacs;
+	s8				index;
+	u8				xqe_size;
+	u32				sqb_size;
+	u32				qints;
+	u32				cints;
+	u32				sq_ctx_sz;
+	u32				rq_ctx_sz;
+	u32				cq_ctx_sz;
+	u32				rsse_ctx_sz;
+	u32				cint_ctx_sz;
+	u32				qint_ctx_sz;
+};
+
+struct nix_tx_dr {
+	union cavm_nix_send_hdr_s	hdr;
+	union cavm_nix_send_sg_s	tx_sg;
+	dma_addr_t			sg1_addr;
+	dma_addr_t			sg2_addr;
+	dma_addr_t			sg3_addr;
+	u64				in_use;
+};
+
+struct nix_rx_dr {
+	union cavm_nix_cqe_hdr_s hdr;
+	union cavm_nix_rx_parse_s rx_parse;
+	union cavm_nix_rx_sg_s rx_sg;
+};
+
+struct nix {
+	struct udevice			*dev;
+	struct eth_device		*netdev;
+	struct nix_af			*nix_af;
+	struct npa			*npa;
+	struct lmac			*lmac;
+	union cavm_nix_cint_hw_s	*cint_base;
+	union cavm_nix_cq_ctx_s		*cq_ctx_base;
+	union cavm_nix_qint_hw_s	*qint_base;
+	union cavm_nix_rq_ctx_s		*rq_ctx_base;
+	union cavm_nix_rsse_s		*rss_base;
+	union cavm_nix_sq_ctx_s		*sq_ctx_base;
+	void				*cqe_base;
+	struct qmem			sq;
+	struct qmem			cq[NIX_CQ_COUNT];
+	struct qmem			rq;
+	struct qmem			rss;
+	struct qmem			cq_ints;
+	struct qmem			qints;
+	char				name[16];
+	void __iomem			*nix_base;	/** PF reg base */
+	void __iomem			*npc_base;
+	void __iomem			*lmt_base;
+	struct nix_tx_dr		tx_desc[SQ_QLEN*2];
+	struct nix_stats		tx_stats;
+	struct nix_stats		rx_stats;
+	u32				aura;
+	int				pknd;
+	int				lf;
+	int				pf;
+	u16				pf_func;
+	u32				rq_cnt;		/** Number of receive queues */
+	u32				sq_cnt;		/** Number of send squeues */
+	u32				cq_cnt;		/** Number of completion queues */
+	u16				rss_sz;
+	u16				sqb_size;
+	u8				rss_grps;
+	u8				xqe_sz;
+};
+
+struct nix_aq_cq_request {
+	union cavm_nix_aq_res_s	resp	ALIGNED;
+	union cavm_nix_cq_ctx_s	cq	ALIGNED;
+};
+
+struct nix_aq_rq_request {
+	union cavm_nix_aq_res_s	resp	ALIGNED;
+	union cavm_nix_rq_ctx_s	rq	ALIGNED;
+};
+
+struct nix_aq_sq_request {
+	union cavm_nix_aq_res_s	resp	ALIGNED;
+	union cavm_nix_sq_ctx_s	sq	ALIGNED;
+};
+
+static inline u64 nix_af_reg_read(struct nix_af *nix_af, u64 offset)
+{
+	u64 val = readq(nix_af->nix_af_base + offset);
+	debug("%s reg %p val %llx\n", __func__, nix_af->nix_af_base + offset,
+		val);
+	return val;
+}
+
+static inline void nix_af_reg_write(struct nix_af *nix_af, u64 offset,
+				    u64 val)
+{
+	debug("%s reg %p val %llx\n", __func__, nix_af->nix_af_base + offset,
+		val);
+	writeq(val, nix_af->nix_af_base + offset);
+}
+
+static inline u64 nix_pf_reg_read(struct nix *nix, u64 offset)
+{
+	u64 val = readq(nix->nix_base + offset);
+	debug("%s reg %p val %llx\n", __func__, nix->nix_base + offset,
+		val);
+	return val;
+}
+
+static inline void nix_pf_reg_write(struct nix *nix, u64 offset,
+				    u64 val)
+{
+	debug("%s reg %p val %llx\n", __func__, nix->nix_base + offset,
+		val);
+	writeq(val, nix->nix_base + offset);
+}
+
+static inline u64 npa_af_reg_read(struct npa_af *npa_af, u64 offset)
+{
+	u64 val = readq(npa_af->npa_af_base + offset);
+	debug("%s reg %p val %llx\n", __func__, npa_af->npa_af_base + offset,
+		val);
+	return val;
+}
+
+static inline void npa_af_reg_write(struct npa_af *npa_af, u64 offset,
+				    u64 val)
+{
+	debug("%s reg %p val %llx\n", __func__, npa_af->npa_af_base + offset,
+		val);
+	writeq(val, npa_af->npa_af_base + offset);
+}
+
+static inline u64 npc_af_reg_read(struct nix_af *nix_af, u64 offset)
+{
+	u64 val = readq(nix_af->npc_af_base + offset);
+	debug("%s reg %p val %llx\n", __func__, nix_af->npc_af_base + offset,
+		val);
+	return val;
+}
+
+static inline void npc_af_reg_write(struct nix_af *nix_af, u64 offset,
+				    u64 val)
+{
+	debug("%s reg %p val %llx\n", __func__, nix_af->npc_af_base + offset,
+		val);
+	writeq(val, nix_af->npc_af_base + offset);
+}
+
+int npa_attach_aura(struct nix_af *nix_af, int lf,
+			const union cavm_npa_aura_s *desc, u32 aura_id);
+int npa_attach_pool(struct nix_af *nix_af, int lf,
+			const union cavm_npa_pool_s *desc, u32 pool_id);
+int npa_af_setup(struct npa_af *npa_af);
+int npa_af_shutdown(struct npa_af *npa_af);
+int npa_lf_setup(struct nix *nix);
+int npa_lf_shutdown(struct nix *nix);
+int npa_lf_admin_setup(struct npa *npa, int lf, dma_addr_t aura_base);
+int npa_lf_admin_shutdown(struct nix_af *nix_af, int lf, u32 pool_count);
+
+int npc_lf_admin_setup(struct nix *nix);
+int npc_af_shutdown(struct nix_af *nix_af);
+
+int nix_af_setup(struct nix_af *nix_af);
+int nix_af_shutdown(struct nix_af *nix_af);
+int nix_lf_setup(struct nix *nix);
+int nix_lf_shutdown(struct nix *nix);
+struct nix *nix_lf_alloc(struct udevice *dev);
+int nix_lf_admin_setup(struct nix *nix);
+int nix_lf_admin_shutdown(struct nix_af *nix_af, int lf,
+			  u32 cq_count, u32 rq_count, u32 sq_count);
+struct rvu_af *get_af(void);
+
+int nix_lf_setup_mac(struct udevice *dev);
+int nix_lf_read_rom_mac(struct udevice *dev);
+void nix_lf_halt(struct udevice *dev);
+int nix_lf_free_pkt(struct udevice *dev, uchar *pkt, int pkt_len);
+int nix_lf_recv(struct udevice *dev, int flags, uchar **packetp);
+int nix_lf_init(struct udevice *dev);
+int nix_lf_xmit(struct udevice *dev, void *pkt, int pkt_len);
+
+#endif /* __NIX_H__ */
diff --git a/drivers/net/octeontx2/nix_af.c b/drivers/net/octeontx2/nix_af.c
new file mode 100644
index 0000000..87cb3c4
--- /dev/null
+++ b/drivers/net/octeontx2/nix_af.c
@@ -0,0 +1,1114 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#include <common.h>
+#include <net.h>
+#include <malloc.h>
+#include <dm.h>
+#include <misc.h>
+#include <pci.h>
+#include <memalign.h>
+#include <watchdog.h>
+#include <asm/io.h>
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/log2.h>
+#include <asm/arch/octeontx2.h>
+#include "cavm-csrs-npc.h"
+#include "cavm-csrs-lmt.h"
+#include "nix.h"
+#include "lmt.h"
+#include "cgx.h"
+
+/***************
+ * NPA API 
+ ***************/
+int npa_attach_aura(struct nix_af *nix_af, int lf,
+			   const union cavm_npa_aura_s *desc, u32 aura_id)
+{
+	struct npa_af *npa = nix_af->npa_af;
+	union cavm_npa_aq_inst_s *inst;
+	volatile union cavm_npa_aq_res_s *res;
+	union cavm_npa_af_aq_status aq_stat;
+	union cavm_npa_aura_s *context;
+	u64 head;
+	ulong start;
+
+	debug("%s(%p, %d, %p, %u)\n", __func__, nix_af, lf, desc, aura_id);
+	aq_stat.u = npa_af_reg_read(npa, CAVM_NPA_AF_AQ_STATUS());
+	head = aq_stat.s.head_ptr;
+	inst = (union cavm_npa_aq_inst_s *)(npa->aq.inst.base) + head;
+	res = (volatile union cavm_npa_aq_res_s *)(npa->aq.res.base);
+
+	memset(inst, 0, sizeof(*inst));
+	inst->s.lf = lf;
+	inst->s.doneint = 0;
+	inst->s.ctype = CAVM_NPA_AQ_CTYPE_E_AURA;
+	inst->s.op = CAVM_NPA_AQ_INSTOP_E_INIT;
+	inst->s.res_addr = npa->aq.res.iova;
+	inst->s.cindex = aura_id;
+
+	context = (union cavm_npa_aura_s *)(npa->aq.res.base +
+						CONFIG_SYS_CACHELINE_SIZE);
+	memset(npa->aq.res.base, 0, npa->aq.res.entry_sz);
+	memcpy(context, desc, sizeof(union cavm_npa_aura_s));
+	__iowmb();
+	npa_af_reg_write(npa, CAVM_NPA_AF_AQ_DOOR(), 1);
+
+	start = get_timer(0);
+	while ((res->s.compcode == CAVM_NPA_AQ_COMP_E_NOTDONE) &&
+	       (get_timer(start) < 1000))
+		WATCHDOG_RESET();
+	if (res->s.compcode != CAVM_NPA_AQ_COMP_E_GOOD) {
+		printf("%s: Error: result 0x%x not good\n",
+		       __func__, res->s.compcode);
+		return -1;
+	}
+
+	return 0;
+}
+
+int npa_attach_pool(struct nix_af *nix_af, int lf,
+			   const union cavm_npa_pool_s *desc, u32 pool_id)
+{
+	union cavm_npa_aq_inst_s *inst;
+	volatile union cavm_npa_aq_res_s *res;
+	union cavm_npa_af_aq_status aq_stat;
+	struct npa_af *npa = nix_af->npa_af;
+	union cavm_npa_aura_s *context;
+	u64 head;
+	ulong start;
+
+	debug("%s(%p, %d, %p, %u)\n", __func__, nix_af, lf, desc, pool_id);
+	aq_stat.u = npa_af_reg_read(npa, CAVM_NPA_AF_AQ_STATUS());
+	head = aq_stat.s.head_ptr;
+
+	inst = (union cavm_npa_aq_inst_s *)(npa->aq.inst.base) + head;
+	res = (union cavm_npa_aq_res_s *)(npa->aq.res.base);
+
+	memset(inst, 0, sizeof(*inst));
+	inst->s.cindex = pool_id;
+	inst->s.lf = lf;
+	inst->s.doneint = 0;
+	inst->s.ctype = CAVM_NPA_AQ_CTYPE_E_POOL;
+	inst->s.op = CAVM_NPA_AQ_INSTOP_E_INIT;
+	inst->s.res_addr = npa->aq.res.iova;
+
+	context = (union cavm_npa_aura_s *)(npa->aq.res.base +
+						CONFIG_SYS_CACHELINE_SIZE);
+	memset(npa->aq.res.base, 0, npa->aq.res.entry_sz);
+	memcpy(context, desc, sizeof(union cavm_npa_aura_s));
+	__iowmb();
+	npa_af_reg_write(npa, CAVM_NPA_AF_AQ_DOOR(), 1);
+
+	start = get_timer(0);
+	while ((res->s.compcode == CAVM_NPA_AQ_COMP_E_NOTDONE) &&
+	       (get_timer(start) < 1000))
+		WATCHDOG_RESET();
+
+	if (res->s.compcode != CAVM_NPA_AQ_COMP_E_GOOD) {
+		printf("%s: Error: result 0x%x not good\n",
+		       __func__, res->s.compcode);
+		return -1;
+	}
+
+	return 0;
+}
+
+
+int npa_lf_admin_setup(struct npa *npa, int lf, dma_addr_t aura_base)
+{
+	union cavm_npa_af_lf_rst lf_rst;
+	union cavm_npa_af_lfx_auras_cfg auras_cfg;
+	struct npa_af *npa_af = npa->npa_af;
+
+	debug("%s(%p, %d, 0x%llx)\n", __func__, npa_af, lf, aura_base);
+	lf_rst.u = 0;
+	lf_rst.s.exec = 1;
+	lf_rst.s.lf = lf;
+	npa_af_reg_write(npa_af, CAVM_NPA_AF_LF_RST(), lf_rst.u);
+
+	do {
+		lf_rst.u = npa_af_reg_read(npa_af, CAVM_NPA_AF_LF_RST());
+		WATCHDOG_RESET();
+	} while (lf_rst.s.exec);
+
+	/* Set Aura size and enable caching of contexts */
+	auras_cfg.u = npa_af_reg_read(npa_af, CAVM_NPA_AF_LFX_AURAS_CFG(lf));
+	auras_cfg.s.loc_aura_size = NPA_AURA_SIZE_DEFAULT; //FIXME aura_size;
+	auras_cfg.s.caching = 1;
+	auras_cfg.s.rmt_aura_size = 0;
+	auras_cfg.s.rmt_aura_offset = 0;
+	auras_cfg.s.rmt_lf = 0;
+	npa_af_reg_write(npa_af, CAVM_NPA_AF_LFX_AURAS_CFG(lf), auras_cfg.u);
+	/* Configure aura HW context base */
+	npa_af_reg_write(npa_af, CAVM_NPA_AF_LFX_LOC_AURAS_BASE(lf),
+			 aura_base);
+
+	return 0;
+}
+
+int npa_lf_admin_shutdown(struct nix_af *nix_af, int lf, u32 pool_count)
+{
+	int pool_id;
+	u32 head;
+	union cavm_npa_aq_inst_s *inst;
+	volatile union cavm_npa_aq_res_s *res;
+	struct npa_aq_pool_request {
+		union cavm_npa_aq_res_s	resp	ALIGNED;
+		union cavm_npa_pool_s	p0	ALIGNED;
+		union cavm_npa_pool_s	p1	ALIGNED;
+	} pool_req ALIGNED;
+	struct npa_aq_aura_request {
+		union cavm_npa_aq_res_s	resp	ALIGNED;
+		union cavm_npa_aura_s	a0	ALIGNED;
+		union cavm_npa_aura_s	a1	ALIGNED;
+	} aura_req ALIGNED;
+	union cavm_npa_af_aq_status aq_stat;
+	union cavm_npa_af_lf_rst lf_rst;
+	struct npa_af *npa = nix_af->npa_af;
+	ulong start;
+
+	for (pool_id = 0; pool_id < pool_count; pool_id++) {
+		aq_stat.u = npa_af_reg_read(npa, CAVM_NPA_AF_AQ_STATUS());
+		head = aq_stat.s.head_ptr;
+		inst = (union cavm_npa_aq_inst_s *)(npa->aq.inst.base) + head;
+		res = &pool_req.resp;
+
+		memset(inst, 0, sizeof(*inst));
+		inst->s.cindex = pool_id;
+		inst->s.lf = lf;
+		inst->s.doneint = 0;
+		inst->s.ctype = CAVM_NPA_AQ_CTYPE_E_POOL;
+		inst->s.op = CAVM_NPA_AQ_INSTOP_E_WRITE;
+		inst->s.res_addr = (u64)&pool_req.resp;
+
+		memset((void *)&pool_req, 0, sizeof(pool_req));
+		pool_req.p0.s.ena = 0;
+		pool_req.p1.s.ena = 1;	/* Write mask */
+		__iowmb();
+
+		npa_af_reg_write(npa, CAVM_NPA_AF_AQ_DOOR(), 1);
+
+		start = get_timer(0);
+		while ((res->s.compcode == CAVM_NPA_AQ_COMP_E_NOTDONE) &&
+		       (get_timer(start) < 1000))
+			WATCHDOG_RESET();
+
+		if (res->s.compcode != CAVM_NPA_AQ_COMP_E_GOOD) {
+			printf("%s: Error: result 0x%x not good for lf %d \n"
+			       " aura id %d", __func__, res->s.compcode, lf,
+				pool_id);
+			return -1;
+		}
+		debug("%s(LF %d, pool id %d) disabled\n", __func__, lf,
+			 pool_id);
+	}
+
+	for (pool_id = 0; pool_id < pool_count; pool_id++) {
+		aq_stat.u = npa_af_reg_read(npa, CAVM_NPA_AF_AQ_STATUS());
+		head = aq_stat.s.head_ptr;
+		inst = (union cavm_npa_aq_inst_s *)(npa->aq.inst.base) + head;
+		res = &aura_req.resp;
+
+		memset(inst, 0, sizeof(*inst));
+		inst->s.cindex = pool_id;
+		inst->s.lf = lf;
+		inst->s.doneint = 0;
+		inst->s.ctype = CAVM_NPA_AQ_CTYPE_E_AURA;
+		inst->s.op = CAVM_NPA_AQ_INSTOP_E_WRITE;
+		inst->s.res_addr = (u64)&aura_req.resp;
+
+		memset((void *)&aura_req, 0, sizeof(aura_req));
+		aura_req.a0.s.ena = 0;
+		aura_req.a1.s.ena = 1;	/* Write mask */
+		__iowmb();
+
+		npa_af_reg_write(npa, CAVM_NPA_AF_AQ_DOOR(), 1);
+
+		start = get_timer(0);
+		while ((res->s.compcode == CAVM_NPA_AQ_COMP_E_NOTDONE) &&
+		       (get_timer(start) < 1000))
+			WATCHDOG_RESET();
+
+		if (res->s.compcode != CAVM_NPA_AQ_COMP_E_GOOD) {
+			printf("%s: Error: result 0x%x not good for lf %d \n"
+			       " aura id %d", __func__, res->s.compcode, lf,
+				pool_id);
+			return -1;
+		}
+		debug("%s(LF %d, aura id %d) disabled\n", __func__, lf,
+			 pool_id);
+	}
+
+	/* Reset the LF */
+	lf_rst.u = 0;
+	lf_rst.s.exec = 1;
+	lf_rst.s.lf = lf;
+	npa_af_reg_write(npa, CAVM_NPA_AF_LF_RST(), lf_rst.u);
+
+	do {
+		lf_rst.u = npa_af_reg_read(npa, CAVM_NPA_AF_LF_RST());
+		WATCHDOG_RESET();
+	} while (lf_rst.s.exec);
+
+	return 0;
+}
+
+int npa_af_setup(struct npa_af *npa_af)
+{
+	int err;
+	union cavm_npa_af_gen_cfg npa_cfg;
+	union cavm_npa_af_ndc_cfg ndc_cfg;
+	union cavm_npa_af_aq_cfg aq_cfg;
+	union cavm_npa_af_blk_rst blk_rst;
+
+	err = rvu_aq_alloc(&npa_af->aq, Q_COUNT(AQ_SIZE),
+				sizeof(union cavm_npa_aq_inst_s),
+				sizeof(union cavm_npa_aq_res_s));
+	if (err) {
+		printf("%s: Error %d allocating admin queue\n", __func__, err);
+		return err;
+	}
+	debug("%s: NPA admin queue allocated at %p %llx\n", __func__,
+	      npa_af->aq.inst.base, npa_af->aq.inst.iova);
+
+	blk_rst.u = 0;
+	blk_rst.s.rst = 1;
+	npa_af_reg_write(npa_af, CAVM_NPA_AF_BLK_RST(), blk_rst.u);
+
+	/* Wait for reset to complete */
+	do {
+		blk_rst.u = npa_af_reg_read(npa_af, CAVM_NPA_AF_BLK_RST());
+		WATCHDOG_RESET();
+	} while (blk_rst.s.busy);
+
+	/* Set little Endian */
+	npa_cfg.u = npa_af_reg_read(npa_af, CAVM_NPA_AF_GEN_CFG());
+	npa_cfg.s.af_be = 0;
+	npa_af_reg_write(npa_af, CAVM_NPA_AF_GEN_CFG(), npa_cfg.u);
+	/* Enable NDC cache */
+	ndc_cfg.u = npa_af_reg_read(npa_af, CAVM_NPA_AF_NDC_CFG());
+	ndc_cfg.s.ndc_bypass = 0;
+	npa_af_reg_write(npa_af, CAVM_NPA_AF_NDC_CFG(), ndc_cfg.u);
+	/* Set up queue size */
+	aq_cfg.u = npa_af_reg_read(npa_af, CAVM_NPA_AF_AQ_CFG());
+	aq_cfg.s.qsize = AQ_SIZE;
+	npa_af_reg_write(npa_af, CAVM_NPA_AF_AQ_CFG(), aq_cfg.u);
+	/* Set up queue base address */
+	npa_af_reg_write(npa_af, CAVM_NPA_AF_AQ_BASE(), npa_af->aq.inst.iova);
+
+	return 0;
+}
+
+int npa_af_shutdown(struct npa_af *npa_af)
+{
+	union cavm_npa_af_blk_rst blk_rst;
+
+	blk_rst.u = 0;
+	blk_rst.s.rst = 1;
+	npa_af_reg_write(npa_af, CAVM_NPA_AF_BLK_RST(), blk_rst.u);
+
+	/* Wait for reset to complete */
+	do {
+		blk_rst.u = npa_af_reg_read(npa_af, CAVM_NPA_AF_BLK_RST());
+		WATCHDOG_RESET();
+	} while (blk_rst.s.busy);
+
+	rvu_aq_free(&npa_af->aq);
+
+	debug("%s: npa af reset -- \n", __func__);
+
+	return 0;
+}
+
+/***************
+ * NIX API 
+ ***************/
+/**
+ * Setup SMQ -> TL4 -> TL3 -> TL2 -> TL1 -> MAC mapping
+ *
+ * @param nix     Handle to setup
+ *
+ * @return 0, or negative on failure
+ */
+static int nix_af_setup_sq(struct nix *nix)
+{
+	union cavm_nixx_af_tl1x_schedule tl1_sched;
+	union cavm_nixx_af_tl2x_parent tl2_parent;
+	union cavm_nixx_af_tl3x_parent tl3_parent;
+	union cavm_nixx_af_tl3_tl2x_cfg tl3_tl2_cfg;
+	union cavm_nixx_af_tl3_tl2x_linkx_cfg tl3_tl2_link_cfg;
+	union cavm_nixx_af_tl4x_parent tl4_parent;
+	union cavm_nixx_af_tl4x_sdp_link_cfg tl4_sdp_link_cfg;
+	union cavm_nixx_af_smqx_cfg smq_cfg;
+	union cavm_nixx_af_mdqx_schedule mdq_sched;
+	union cavm_nixx_af_mdqx_parent mdq_parent;
+	union cavm_nixx_af_rx_linkx_cfg link_cfg;
+	int tl1_index = nix->lmac->link_num; /* NIX_LINK_E enum */
+	int tl2_index = tl1_index;
+	int tl3_index = tl2_index;
+	int tl4_index = tl3_index;
+	int smq_index = tl4_index;
+	struct nix_af *nix_af = nix->nix_af;
+
+	tl1_sched.u = nix_af_reg_read(nix_af,
+					CAVM_NIXX_AF_TL1X_SCHEDULE(tl1_index));
+	tl1_sched.s.rr_quantum = MAX_MTU;
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_TL1X_SCHEDULE(tl1_index),
+				      tl1_sched.u);
+
+	tl2_parent.u = nix_af_reg_read(nix_af,
+					CAVM_NIXX_AF_TL2X_PARENT(tl2_index));
+	tl2_parent.s.parent = tl1_index;
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_TL2X_PARENT(tl2_index),
+				      tl2_parent.u);
+
+	tl3_parent.u = nix_af_reg_read(nix_af,
+					CAVM_NIXX_AF_TL3X_PARENT(tl3_index));
+	tl3_parent.s.parent = tl2_index;
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_TL3X_PARENT(tl3_index),
+				      tl3_parent.u);
+	tl3_tl2_cfg.u = nix_af_reg_read(nix_af,
+					CAVM_NIXX_AF_TL3_TL2X_CFG(tl3_index));
+	tl3_tl2_cfg.s.express = 0;
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_TL3_TL2X_CFG(tl3_index),
+				      tl3_tl2_cfg.u);
+
+	tl3_tl2_link_cfg.u = nix_af_reg_read(nix_af,
+				CAVM_NIXX_AF_TL3_TL2X_LINKX_CFG(tl3_index,
+				nix->lmac->link_num));
+	tl3_tl2_link_cfg.s.bp_ena = 1;
+	tl3_tl2_link_cfg.s.ena = 1;
+	tl3_tl2_link_cfg.s.relchan = 0;
+	nix_af_reg_write(nix_af,
+				CAVM_NIXX_AF_TL3_TL2X_LINKX_CFG(tl3_index,
+				nix->lmac->link_num), tl3_tl2_link_cfg.u);
+
+	tl4_parent.u = nix_af_reg_read(nix_af,
+				CAVM_NIXX_AF_TL4X_PARENT(tl4_index));
+	tl4_parent.s.parent = tl3_index;
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_TL4X_PARENT(tl4_index),
+				tl4_parent.u);
+	tl4_sdp_link_cfg.u = nix_af_reg_read(nix_af,
+				CAVM_NIXX_AF_TL4X_SDP_LINK_CFG(tl4_index));
+	tl4_sdp_link_cfg.s.bp_ena = 0;
+	tl4_sdp_link_cfg.s.ena = 0;
+	tl4_sdp_link_cfg.s.relchan = 0;
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_TL4X_SDP_LINK_CFG(tl4_index),
+				tl4_sdp_link_cfg.u);
+
+	smq_cfg.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_SMQX_CFG(smq_index));
+	smq_cfg.s.express = 0;
+	smq_cfg.s.lf = nix->lf;
+	smq_cfg.s.desc_shp_ctl_dis = 1;
+	smq_cfg.s.maxlen = MAX_MTU;
+	smq_cfg.s.minlen = NIX_MIN_HW_MTU;
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_SMQX_CFG(smq_index), smq_cfg.u);
+
+	mdq_sched.u = nix_af_reg_read(nix_af,
+				CAVM_NIXX_AF_MDQX_SCHEDULE(smq_index));
+	mdq_sched.s.rr_quantum = MAX_MTU;
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_MDQX_SCHEDULE(smq_index),
+		      mdq_sched.u);
+	mdq_parent.u = nix_af_reg_read(nix_af,
+				CAVM_NIXX_AF_MDQX_PARENT(smq_index));
+	mdq_parent.s.parent = tl4_index;
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_MDQX_PARENT(smq_index),
+		      mdq_parent.u);
+
+	link_cfg.u = 0;
+	link_cfg.s.maxlen = NIX_MAX_HW_MTU;
+	link_cfg.s.minlen = NIX_MIN_HW_MTU;
+	nix_af_reg_write(nix->nix_af,
+			 CAVM_NIXX_AF_RX_LINKX_CFG(nix->lmac->link_num),
+			 link_cfg.u);
+
+	return 0;
+}
+
+/**
+ * Issue a command to the NIX AF Admin Queue
+ *
+ * @param nix    nix handle
+ * @param lf     Logical function number for command
+ * @param op     Operation
+ * @param ctype  Context type
+ * @param cindex Context index
+ * @param resp   Result pointer
+ *
+ * @return	0 for success, -EBUSY on failure
+ */
+static int nix_aq_issue_command(struct nix_af *nix_af,
+				int lf,
+				int op,
+				int ctype,
+				int cindex, union cavm_nix_aq_res_s *resp)
+{
+	union cavm_nixx_af_aq_status aq_status;
+	union cavm_nix_aq_inst_s *aq_inst;
+	volatile union cavm_nix_aq_res_s *result = resp;
+	ulong start;
+
+	debug("%s(%p, 0x%x, 0x%x, 0x%x, 0x%x, %p)\n", __func__, nix_af, lf,
+	      op, ctype, cindex, resp);
+	aq_status.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_AQ_STATUS());
+	aq_inst = (union cavm_nix_aq_inst_s *)(nix_af->aq.inst.base) +
+						aq_status.s.head_ptr;
+	aq_inst->u[0] = 0;
+	aq_inst->u[1] = 0;
+	aq_inst->s.op = op;
+	aq_inst->s.ctype = ctype;
+	aq_inst->s.lf = lf;
+	aq_inst->s.cindex = cindex;
+	aq_inst->s.doneint = 0;
+	aq_inst->s.res_addr = (u64)resp;
+	debug("%s: inst@%p: 0x%llx 0x%llx\n", __func__, aq_inst,
+	      aq_inst->u[0], aq_inst->u[1]);
+	__iowmb();
+
+	/* Ring doorbell and wait for result */
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_AQ_DOOR(), 1);
+
+	start = get_timer(0);
+	/* Wait for completion */
+	do {
+		WATCHDOG_RESET();
+		dsb();
+	} while (result->s.compcode == 0 && get_timer(start) < 2);
+
+	if (result->s.compcode != CAVM_NIX_AQ_COMP_E_GOOD) {
+		printf("NIX: Admin Queue failed or timed out with code %d after %ld ms\n",
+		       result->s.compcode, get_timer(start));
+		return -EBUSY;
+	}
+	return 0;
+}
+
+static int nix_attach_receive_queue(struct nix_af *nix_af, int lf)
+{
+	struct nix_aq_rq_request rq_req ALIGNED;
+	int err;
+
+	debug("%s(%p, %d)\n", __func__, nix_af, lf);
+
+	memset(&rq_req, 0, sizeof(struct nix_aq_rq_request));
+	
+	rq_req.rq.s.ena = 1;
+	rq_req.rq.s.spb_ena = 1;
+	rq_req.rq.s.ipsech_ena = 0;
+	rq_req.rq.s.ena_wqwd = 0;
+	rq_req.rq.s.cq = NIX_CQ_RX;
+	rq_req.rq.s.substream = 0;	/* FIXME: Substream IDs? */
+	rq_req.rq.s.wqe_aura = -1;	/* No WQE aura */
+	rq_req.rq.s.spb_aura = NPA_POOL_RX;
+	rq_req.rq.s.lpb_aura = NPA_POOL_RX;
+	/* U-Boot doesn't use WQE group for anything */
+	rq_req.rq.s.pb_caching = 1;
+	rq_req.rq.s.xqe_drop_ena = 0;	/* Disable RED dropping */
+	rq_req.rq.s.spb_drop_ena = 0;
+	rq_req.rq.s.lpb_drop_ena = 0;
+	rq_req.rq.s.spb_sizem1 = (MAX_MTU / (3 * 8)) - 1; /* 512 bytes */
+	rq_req.rq.s.lpb_sizem1 = (MAX_MTU / 8) - 1;
+	rq_req.rq.s.first_skip = 0;
+	rq_req.rq.s.later_skip = 0;
+	rq_req.rq.s.xqe_imm_copy = 0;
+	rq_req.rq.s.xqe_hdr_split = 0;
+	rq_req.rq.s.xqe_drop = 0;
+	rq_req.rq.s.xqe_pass = 0;
+	rq_req.rq.s.wqe_pool_drop = 0;	/* No WQE pool */
+	rq_req.rq.s.wqe_pool_pass = 0;	/* No WQE pool */
+	rq_req.rq.s.spb_aura_drop = 255;
+	rq_req.rq.s.spb_aura_pass = 255;
+	rq_req.rq.s.spb_pool_drop = 0;
+	rq_req.rq.s.spb_pool_pass = 0;
+	rq_req.rq.s.lpb_aura_drop = 255;
+	rq_req.rq.s.lpb_aura_pass = 255;
+	rq_req.rq.s.lpb_pool_drop = 0;
+	rq_req.rq.s.lpb_pool_pass = 0;
+	rq_req.rq.s.qint_idx = 0;
+
+	err = nix_aq_issue_command(nix_af, lf,
+				   CAVM_NIX_AQ_INSTOP_E_INIT,
+				   CAVM_NIX_AQ_CTYPE_E_RQ,
+				   0, &rq_req.resp);
+	if (err) { 
+		printf("%s: Error requesting send queue\n", __func__);
+		return err;
+	}
+
+	return 0;
+}
+
+static int nix_attach_send_queue(struct nix *nix)
+{
+	struct nix_af *nix_af = nix->nix_af;
+	struct nix_aq_sq_request sq_req ALIGNED;
+	int err;
+
+	debug("%s(%p)\n", __func__, nix_af);
+	err = nix_af_setup_sq(nix); 
+
+	memset(&sq_req, 0, sizeof(sq_req));
+
+	sq_req.sq.s.ena = 1;
+	sq_req.sq.s.cq_ena = 1;
+	sq_req.sq.s.max_sqe_size = CAVM_NIX_MAXSQESZ_E_W16;
+	sq_req.sq.s.substream = 0; // FIXME: Substream IDs?
+	sq_req.sq.s.sdp_mcast = 0;
+	sq_req.sq.s.cq = NIX_CQ_TX;
+	sq_req.sq.s.cq_limit = 0;
+	sq_req.sq.s.smq = nix->lmac->link_num; // scheduling index
+	sq_req.sq.s.sso_ena = 0;
+	sq_req.sq.s.smq_rr_quantum = MAX_MTU / 4;
+	sq_req.sq.s.default_chan = nix->lmac->chan_num;
+	sq_req.sq.s.sqe_stype = CAVM_NIX_STYPE_E_STP;
+	sq_req.sq.s.qint_idx = 0;
+	sq_req.sq.s.sqb_aura = NPA_POOL_TX;
+
+	err = nix_aq_issue_command(nix_af, nix->lf,
+				   CAVM_NIX_AQ_INSTOP_E_INIT,
+				   CAVM_NIX_AQ_CTYPE_E_SQ,
+				   0, &sq_req.resp);
+	if (err) { 
+		printf("%s: Error requesting send queue\n", __func__);
+		return err;
+	}
+
+	return 0;
+}
+
+static int nix_attach_completion_queue(struct nix *nix, int cq_idx)
+{
+	struct nix_af *nix_af = nix->nix_af;
+	struct nix_aq_cq_request cq_req ALIGNED;
+	int err;
+
+	debug("%s(%p)\n", __func__, nix_af);
+	memset(&cq_req, 0, sizeof(cq_req));
+	cq_req.cq.s.ena = 1;
+	cq_req.cq.s.bpid = nix->lmac->pknd;
+	cq_req.cq.s.substream = 0;	/* FIXME: Substream IDs? */
+	cq_req.cq.s.drop_ena = 0;
+	cq_req.cq.s.caching = 1;
+	cq_req.cq.s.qsize = CQS_QSIZE;
+	cq_req.cq.s.drop = 255 * 7 / 8;
+	cq_req.cq.s.qint_idx = 0;
+	cq_req.cq.s.cint_idx = 0;
+	cq_req.cq.s.base = nix->cq[cq_idx].iova;
+	debug("%s: CQ(%d)  base %p \n", __func__, cq_idx,
+	      nix->cq[cq_idx].base);
+
+	err = nix_aq_issue_command(nix_af, nix->lf,
+				   CAVM_NIX_AQ_INSTOP_E_INIT,
+				   CAVM_NIX_AQ_CTYPE_E_CQ,
+				   cq_idx, &cq_req.resp);
+	if (err) {
+		printf("%s: Error requesting completion queue\n", __func__);
+		return err;
+	}
+	debug("%s: CQ(%d) allocated, base %p\n", __func__, cq_idx,
+	      nix->cq[cq_idx].base);
+
+	return 0;
+}
+
+int nix_lf_admin_setup(struct nix *nix)
+{
+	union cavm_nixx_af_lfx_rqs_cfg rqs_cfg;
+	union cavm_nixx_af_lfx_sqs_cfg sqs_cfg;
+	union cavm_nixx_af_lfx_cqs_cfg cqs_cfg;
+	union cavm_nixx_af_lfx_rss_cfg rss_cfg;
+	union cavm_nixx_af_lfx_cints_cfg cints_cfg;
+	union cavm_nixx_af_lfx_qints_cfg qints_cfg;
+	union cavm_nixx_af_lfx_rss_grpx rss_grp;
+	union cavm_nixx_af_lfx_tx_cfg2 tx_cfg2;
+	union cavm_nixx_af_lfx_cfg lfx_cfg;
+	union cavm_nixx_af_lf_rst lf_rst;
+	u32 index;
+	struct nix_af *nix_af = nix->nix_af;
+	int err;
+
+	/* Reset the LF */
+	lf_rst.u = 0;
+	lf_rst.s.lf = nix->lf;
+	lf_rst.s.exec = 1;
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LF_RST(), lf_rst.u);
+
+	do {
+		lf_rst.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_LF_RST());
+		WATCHDOG_RESET();
+	} while (lf_rst.s.exec);
+
+	/* Config NIX RQ HW context and base*/
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LFX_RQS_BASE(nix->lf),
+			 (u64)nix->rq_ctx_base);
+	/* Set caching and queue count in HW */
+	rqs_cfg.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_LFX_RQS_CFG(nix->lf));
+	rqs_cfg.s.caching = 1;
+	rqs_cfg.s.max_queuesm1 = nix->rq_cnt - 1;
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LFX_RQS_CFG(nix->lf), rqs_cfg.u);
+
+	/* Config NIX SQ HW context and base*/
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LFX_SQS_BASE(nix->lf),
+			 (u64)nix->sq_ctx_base);
+	sqs_cfg.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_LFX_SQS_CFG(nix->lf));
+	sqs_cfg.s.caching = 1;
+	sqs_cfg.s.max_queuesm1 = nix->sq_cnt - 1;
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LFX_SQS_CFG(nix->lf), sqs_cfg.u);
+
+	/* Config NIX CQ HW context and base*/
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LFX_CQS_BASE(nix->lf),
+			 (u64)nix->cq_ctx_base);
+	cqs_cfg.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_LFX_CQS_CFG(nix->lf));
+	cqs_cfg.s.caching = 1;
+	cqs_cfg.s.max_queuesm1 = nix->cq_cnt - 1;
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LFX_CQS_CFG(nix->lf), cqs_cfg.u);
+
+	/* Config NIX RSS HW context and base */
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LFX_RSS_BASE(nix->lf),
+			 (u64)nix->rss_base);
+	rss_cfg.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_LFX_RSS_CFG(nix->lf));
+	rss_cfg.s.ena = 1;
+	rss_cfg.s.size = ilog2(nix->rss_sz) / 256;
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LFX_RSS_CFG(nix->lf), rss_cfg.u);
+
+	for (index = 0; index < nix->rss_grps; index++) {
+		rss_grp.u = 0;
+		rss_grp.s.sizem1 = 0x7;
+		rss_grp.s.offset = nix->rss_sz * index;
+		nix_af_reg_write(nix_af,
+				 CAVM_NIXX_AF_LFX_RSS_GRPX(nix->lf, index),
+				 rss_grp.u);
+	}
+
+	/* Config CQints HW contexts and base */
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LFX_CINTS_BASE(nix->lf),
+			 (u64)nix->cint_base);
+	cints_cfg.u = nix_af_reg_read(nix_af,
+				      CAVM_NIXX_AF_LFX_CINTS_CFG(nix->lf));
+	cints_cfg.s.caching = 1;
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LFX_CINTS_CFG(nix->lf),
+			 cints_cfg.u);
+
+	/* Config Qints HW context and base */
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LFX_QINTS_BASE(nix->lf),
+			 (u64)nix->qint_base);
+	qints_cfg.u = nix_af_reg_read(nix_af,
+				      CAVM_NIXX_AF_LFX_QINTS_CFG(nix->lf));
+	qints_cfg.s.caching = 1;
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LFX_QINTS_CFG(nix->lf),
+			 qints_cfg.u);
+
+	debug("%s(%p, %d, %d)\n", __func__, nix_af, nix->lf, nix->pf);
+
+	/* Enable LMTST for this NIX LF */
+	tx_cfg2.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_LFX_TX_CFG2(nix->lf));
+	tx_cfg2.s.lmt_ena = 1;
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LFX_TX_CFG2(nix->lf), tx_cfg2.u);
+
+	/* Use 16-word XQEs, write the npa pf_func number only */
+	lfx_cfg.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_LFX_CFG(nix->lf));
+	lfx_cfg.s.xqe_size = CAVM_NIX_XQESZ_E_W16;
+	lfx_cfg.s.npa_pf_func = nix->pf_func;
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LFX_CFG(nix->lf), lfx_cfg.u);
+
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LFX_RX_CFG(nix->lf), 0);
+
+	for (index = 0; index < nix->cq_cnt; index++) {
+		err = nix_attach_completion_queue(nix, index);
+		if (err) {
+			printf("%s: Error attaching completion queue %d\n",
+			       __func__, index);
+			return err;
+		}
+	}
+
+	for (index = 0; index < nix->rq_cnt; index++) {
+		err = nix_attach_receive_queue(nix_af, nix->lf);
+		if (err) {
+			printf("%s: Error attaching receive queue %d\n",
+			       __func__, index);
+			return err;
+		}
+	}
+
+	for (index = 0; index < nix->sq_cnt; index++) {
+		err = nix_attach_send_queue(nix);
+		if (err) {
+			printf("%s: Error attaching send queue %d\n",
+			       __func__, index);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+int nix_lf_admin_shutdown(struct nix_af *nix_af, int lf,
+			  u32 cq_count, u32 rq_count, u32 sq_count)
+{
+	union cavm_nixx_af_rx_sw_sync sw_sync;
+	struct nix_aq_cq_request {
+		union cavm_nix_aq_res_s	resp	ALIGNED;
+		union cavm_nix_cq_ctx_s	cq0	ALIGNED;
+		union cavm_nix_cq_ctx_s	cq1	ALIGNED;
+	} cq_req ALIGNED;
+	struct nix_aq_rq_request {
+		union cavm_nix_aq_res_s	resp	ALIGNED;
+		union cavm_nix_rq_ctx_s	rq0	ALIGNED;
+		union cavm_nix_rq_ctx_s	rq1	ALIGNED;
+	} rq_req ALIGNED;
+	struct nix_aq_sq_request {
+		union cavm_nix_aq_res_s	resp	ALIGNED;
+		union cavm_nix_sq_ctx_s	sq0	ALIGNED;
+		union cavm_nix_sq_ctx_s	sq1	ALIGNED;
+	} sq_req ALIGNED;
+	union cavm_nixx_af_lf_rst lf_rst;
+	int index, err;
+
+	/* Flush all tx packets */
+	sw_sync.u = 0;
+	sw_sync.s.ena = 1;
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_RX_SW_SYNC(), sw_sync.u);
+
+	do {
+		sw_sync.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_RX_SW_SYNC());
+		WATCHDOG_RESET();
+	} while (sw_sync.s.ena);
+
+	for (index = 0; index < rq_count; index++) {
+		memset((void *)&rq_req, 0, sizeof(rq_req));
+		rq_req.rq0.s.ena = 0;	/* Context */
+		rq_req.rq1.s.ena = 1;	/* Mask */
+		__iowmb();
+
+		err = nix_aq_issue_command(nix_af, lf,
+					   CAVM_NIX_AQ_INSTOP_E_WRITE,
+					   CAVM_NIX_AQ_CTYPE_E_RQ,
+					   index, &rq_req.resp);
+		if (err) {
+			printf("%s: Error disabling LF %d RQ(%d)\n",
+				 __func__, lf, index);
+			return err;
+		}
+		debug("%s: LF %d RQ(%d) disabled\n", __func__, lf, index);
+	}
+
+	for (index = 0; index < sq_count; index++) {
+		memset((void *)&sq_req, 0, sizeof(sq_req));
+		sq_req.sq0.s.ena = 0;	/* Context */
+		sq_req.sq1.s.ena = 1;	/* Mask */
+		__iowmb();
+
+		err = nix_aq_issue_command(nix_af, lf,
+					   CAVM_NIX_AQ_INSTOP_E_WRITE,
+					   CAVM_NIX_AQ_CTYPE_E_SQ,
+					   index, &sq_req.resp);
+		if (err) {
+			printf("%s: Error disabling LF %d SQ(%d)\n",
+				 __func__, lf, index);
+			return err;
+		}
+		debug("%s: LF %d SQ(%d) disabled\n", __func__, lf, index);
+	}
+
+	for (index = 0; index < cq_count; index++) {
+		memset((void *)&cq_req, 0, sizeof(cq_req));
+		cq_req.cq0.s.ena = 0;	/* Context */
+		cq_req.cq1.s.ena = 1;	/* Mask */
+		__iowmb();
+
+		err = nix_aq_issue_command(nix_af, lf,
+					   CAVM_NIX_AQ_INSTOP_E_WRITE,
+					   CAVM_NIX_AQ_CTYPE_E_CQ,
+					   index, &cq_req.resp);
+		if (err) {
+			printf("%s: Error disabling LF %d CQ(%d)\n",
+				 __func__, lf, index);
+			return err;
+		}
+		debug("%s: LF %d CQ(%d) disabled\n", __func__, lf, index);
+	}
+
+	/* Reset the LF */
+	lf_rst.u = 0;
+	lf_rst.s.lf = lf;
+	lf_rst.s.exec = 1;
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_LF_RST(), lf_rst.u);
+
+	do {
+		lf_rst.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_LF_RST());
+		WATCHDOG_RESET();
+	} while (lf_rst.s.exec);
+
+	return 0;
+}
+
+int npc_lf_admin_setup(struct nix *nix)
+{
+	union cavm_npc_af_const af_const;
+	union cavm_npc_af_pkindx_action0 action0;
+	union cavm_npc_af_pkindx_action1 action1;
+	union cavm_npc_af_intfx_kex_cfg kex_cfg;
+	union cavm_npc_af_intfx_miss_stat_act intfx_stat_act;
+	union cavm_npc_af_mcamex_bankx_camx_intf camx_intf;
+	union cavm_npc_af_mcamex_bankx_camx_w0 camx_w0;
+	union cavm_npc_af_mcamex_bankx_cfg bankx_cfg;
+	union cavm_npc_af_mcamex_bankx_stat_act mcamex_stat_act;
+
+	union cavm_nix_rx_action_s rx_action;
+	union cavm_nix_tx_action_s tx_action;
+
+	struct nix_af *nix_af = nix->nix_af;
+	u32 kpus;
+	int pkind = nix->lmac->link_num;
+	int index;
+
+	debug("%s(%p, pkind 0x%x)\n", __func__, nix_af, pkind);
+	af_const.u = npc_af_reg_read(nix_af, CAVM_NPC_AF_CONST());
+	kpus = af_const.s.kpus;
+
+	action0.u = 0;
+	action0.s.parse_done = 1;
+	npc_af_reg_write(nix_af, CAVM_NPC_AF_PKINDX_ACTION0(pkind), action0.u);
+
+	action1.u = 0;
+	npc_af_reg_write(nix_af, CAVM_NPC_AF_PKINDX_ACTION1(pkind), action1.u);
+
+	kex_cfg.u = 0;
+	kex_cfg.s.keyw = CAVM_NPC_MCAMKEYW_E_X1;
+	kex_cfg.s.parse_nibble_ena = 0x7;
+	npc_af_reg_write(nix_af,
+			 CAVM_NPC_AF_INTFX_KEX_CFG(CAVM_NPC_INTF_E_NIXX_RX(0)),
+			 kex_cfg.u);
+
+	/* Errata #35786 */
+	kex_cfg.u = 0;
+	kex_cfg.s.parse_nibble_ena = 0x7;
+	npc_af_reg_write(nix_af,
+			 CAVM_NPC_AF_INTFX_KEX_CFG(CAVM_NPC_INTF_E_NIXX_TX(0)),
+			 kex_cfg.u);
+
+	camx_intf.u = 0;
+	camx_intf.s.intf = ~CAVM_NPC_INTF_E_NIXX_RX(0);
+	npc_af_reg_write(nix_af,
+			 CAVM_NPC_AF_MCAMEX_BANKX_CAMX_INTF(pkind, 0, 0),
+			 camx_intf.u);
+
+	camx_intf.u = 0;
+	camx_intf.s.intf = CAVM_NPC_INTF_E_NIXX_RX(0);
+	npc_af_reg_write(nix_af,
+			 CAVM_NPC_AF_MCAMEX_BANKX_CAMX_INTF(pkind, 0, 1),
+			 camx_intf.u);
+
+	camx_w0.u = 0;
+	camx_w0.s.md = ~(nix->lmac->chan_num) & (~((~0x0ull) << 12));
+	debug("NPC LF ADMIN camx_w0.u %llx\n", camx_w0.u);
+	npc_af_reg_write(nix_af,
+			 CAVM_NPC_AF_MCAMEX_BANKX_CAMX_W0(pkind, 0, 0),
+			 camx_w0.u);
+
+	camx_w0.u = 0;
+	camx_w0.s.md = nix->lmac->chan_num;
+	npc_af_reg_write(nix_af,
+			 CAVM_NPC_AF_MCAMEX_BANKX_CAMX_W0(pkind, 0, 1),
+			 camx_w0.u);
+
+	npc_af_reg_write(nix_af, CAVM_NPC_AF_MCAMEX_BANKX_CAMX_W1(pkind, 0, 0),
+			 0);
+
+	npc_af_reg_write(nix_af, CAVM_NPC_AF_MCAMEX_BANKX_CAMX_W1(pkind, 0, 1),
+			 0);
+
+	/* Enable stats for NPC INTF RX */
+	mcamex_stat_act.u = 0;
+	mcamex_stat_act.s.ena = 1;
+	mcamex_stat_act.s.stat_sel = pkind;
+	npc_af_reg_write(nix_af,
+			 CAVM_NPC_AF_MCAMEX_BANKX_STAT_ACT(pkind, 0),
+			 mcamex_stat_act.u);
+	intfx_stat_act.u = 0;
+	intfx_stat_act.s.ena = 1;
+	intfx_stat_act.s.stat_sel = 16;
+	npc_af_reg_write(nix_af,
+			 CAVM_NPC_AF_INTFX_MISS_STAT_ACT(CAVM_NPC_INTF_E_NIXX_RX(0)),
+			 intfx_stat_act.u);
+	rx_action.u = 0;
+	rx_action.s.pf_func = nix->pf_func;
+	rx_action.s.op = CAVM_NIX_RX_ACTIONOP_E_UCAST;
+	npc_af_reg_write(nix_af, CAVM_NPC_AF_MCAMEX_BANKX_ACTION(pkind, 0),
+			 rx_action.u);
+
+	for (index = 0; index < kpus; index++)
+		npc_af_reg_write(nix_af, CAVM_NPC_AF_KPUX_CFG(index), 0);
+
+	rx_action.u = 0;
+	rx_action.s.pf_func = nix->pf_func;
+	rx_action.s.op = CAVM_NIX_RX_ACTIONOP_E_DROP;
+	npc_af_reg_write(nix_af,
+			 CAVM_NPC_AF_INTFX_MISS_ACT(CAVM_NPC_INTF_E_NIXX_RX(0)),
+			 rx_action.u);
+	bankx_cfg.u = 0;
+	bankx_cfg.s.ena = 1;
+	npc_af_reg_write(nix_af, CAVM_NPC_AF_MCAMEX_BANKX_CFG(pkind, 0),
+			 bankx_cfg.u);
+
+	tx_action.u = 0;
+	tx_action.s.op = CAVM_NIX_TX_ACTIONOP_E_UCAST_DEFAULT;
+	npc_af_reg_write(nix_af,
+			 CAVM_NPC_AF_INTFX_MISS_ACT(CAVM_NPC_INTF_E_NIXX_TX(0)),
+			 tx_action.u);
+
+#ifdef DEBUG
+	/* Enable debug capture on RX intf */
+	npc_af_reg_write(nix_af, CAVM_NPC_AF_DBG_CTL(), 0x4);
+#endif
+
+	return 0;
+}
+
+int npc_af_shutdown(struct nix_af *nix_af)
+{
+	union cavm_npc_af_blk_rst blk_rst;
+
+	blk_rst.u = 0;
+	blk_rst.s.rst = 1;
+	npc_af_reg_write(nix_af, CAVM_NPC_AF_BLK_RST(), blk_rst.u);
+
+	/* Wait for reset to complete */
+	do {
+		blk_rst.u = npc_af_reg_read(nix_af, CAVM_NPC_AF_BLK_RST());
+		WATCHDOG_RESET();
+	} while (blk_rst.s.busy);
+
+	debug("%s: npc af reset -- \n", __func__);
+
+	return 0;
+}
+
+int nix_af_setup(struct nix_af *nix_af)
+{
+	int err;
+	union cavm_nixx_af_const2 af_const2;
+	union cavm_nixx_af_const3 af_const3;
+	union cavm_nixx_af_sq_const sq_const;
+	union cavm_nixx_af_cfg af_cfg;
+	union cavm_nixx_af_status af_status;
+	union cavm_nixx_af_ndc_cfg ndc_cfg;
+	union cavm_nixx_af_aq_cfg aq_cfg;
+	union cavm_nixx_af_blk_rst blk_rst;
+
+	debug("%s(%p)\n", __func__, nix_af);
+	err = rvu_aq_alloc(&nix_af->aq, Q_COUNT(AQ_SIZE),
+				sizeof(union cavm_nix_aq_inst_s),
+				sizeof(union cavm_nix_aq_res_s));
+	if (err) {
+		printf("%s: Error allocating nix admin queue\n", __func__);
+		return err;
+	}
+
+	blk_rst.u = 0;
+	blk_rst.s.rst = 1;
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_BLK_RST(), blk_rst.u);
+
+	/* Wait for reset to complete */
+	do {
+		blk_rst.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_BLK_RST());
+		WATCHDOG_RESET();
+	} while (blk_rst.s.busy);
+
+	/* Put in LE mode */
+	af_cfg.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_CFG());
+	if (af_cfg.s.force_cond_clk_en ||
+	    af_cfg.s.calibrate_x2p || af_cfg.s.force_intf_clk_en) {
+		    printf("%s: Error: Invalid NIX_AF_CFG value 0x%llx\n",
+			   __func__, af_cfg.u);
+		    return -1;
+	}
+	af_cfg.s.af_be = 0;
+	af_cfg.u |= 0x5E;	/* Errata 35057 */
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_CFG(), af_cfg.u);
+
+	/* Perform Calibration */
+	af_cfg.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_CFG());
+	af_cfg.s.calibrate_x2p = 1;
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_CFG(), af_cfg.u);
+
+	/* Wait for calibration to complete */
+	do {
+		af_status.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_STATUS());
+		WATCHDOG_RESET();
+	} while (af_status.s.calibrate_done == 0);
+
+	af_cfg.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_CFG());
+	af_cfg.s.calibrate_x2p = 0;
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_CFG(), af_cfg.u);
+
+	/* Enable NDC cache */
+	ndc_cfg.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_NDC_CFG());
+	ndc_cfg.s.ndc_ign_pois = 0;
+	ndc_cfg.s.byp_sq = 0;
+	ndc_cfg.s.byp_sqb = 0;
+	ndc_cfg.s.byp_cqs = 0;
+	ndc_cfg.s.byp_cints = 0;
+	ndc_cfg.s.byp_dyno = 0;
+	ndc_cfg.s.byp_mce = 0;
+	ndc_cfg.s.byp_rqc = 0;
+	ndc_cfg.s.byp_rsse = 0;
+	ndc_cfg.s.byp_mc_data = 0;
+	ndc_cfg.s.byp_mc_wqe = 0;
+	ndc_cfg.s.byp_mr_data = 0;
+	ndc_cfg.s.byp_mr_wqe = 0;
+	ndc_cfg.s.byp_qints = 0;
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_NDC_CFG(), ndc_cfg.u);
+
+	/* Set up queue size */
+	aq_cfg.u = 0;
+	aq_cfg.s.qsize = AQ_SIZE;
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_AQ_CFG(), aq_cfg.u);
+
+	/* Set up queue base address */
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_AQ_BASE(), nix_af->aq.inst.iova);
+
+	af_const3.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_CONST3());
+	af_const2.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_CONST2());
+	sq_const.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_SQ_CONST());
+	nix_af->rq_ctx_sz = 1ULL << af_const3.s.rq_ctx_log2bytes;
+	nix_af->sq_ctx_sz = 1ULL << af_const3.s.sq_ctx_log2bytes;
+	nix_af->cq_ctx_sz = 1ULL << af_const3.s.cq_ctx_log2bytes;
+	nix_af->rsse_ctx_sz = 1ULL << af_const3.s.rsse_log2bytes;
+	nix_af->qints = af_const2.s.qints;
+	nix_af->cints = af_const2.s.cints;
+	nix_af->cint_ctx_sz = 1ULL << af_const3.s.cint_log2bytes;
+	nix_af->qint_ctx_sz = 1ULL << af_const3.s.qint_log2bytes;
+	nix_af->sqb_size = sq_const.s.sqb_size;
+
+	return 0;
+}
+
+int nix_af_shutdown(struct nix_af *nix_af)
+{
+	union cavm_nixx_af_blk_rst blk_rst;
+
+	blk_rst.u = 0;
+	blk_rst.s.rst = 1;
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_BLK_RST(), blk_rst.u);
+
+	/* Wait for reset to complete */
+	do {
+		blk_rst.u = nix_af_reg_read(nix_af, CAVM_NIXX_AF_BLK_RST());
+		WATCHDOG_RESET();
+	} while (blk_rst.s.busy);
+
+	rvu_aq_free(&nix_af->aq);
+
+	debug("%s: nix af reset -- \n", __func__);
+
+	return 0;
+}
diff --git a/drivers/net/octeontx2/npc.c b/drivers/net/octeontx2/npc.c
new file mode 100644
index 0000000..5eec279
--- /dev/null
+++ b/drivers/net/octeontx2/npc.c
@@ -0,0 +1,400 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#include <common.h>
+#include <net.h>
+#include <netdev.h>
+#include <malloc.h>
+#include <dm.h>
+#include <misc.h>
+#include <pci.h>
+#include <memalign.h>
+#include <watchdog.h>
+#include <asm/io.h>
+#include <linux/types.h>
+#include <linux/bitops.h>
+#include <asm/arch/octeontx2.h>
+#include "cavm-csrs-npc.h"
+#include "cavm-csrs-nix.h"
+#include "npc_profile.h"
+#include "nix_af.h"
+#include "nix.h"
+#include "npc.h"
+
+#define RSVD_MCAM_ENTRIES_PER_PF	2 /** Ucast & Bcast */
+#define RSVD_MCAM_ENTRIES_PER_NIXLF	1 /** Ucast for VFs */
+#if 0
+static u64 npc_af_reg_read(struct npc_af *npc, u64 offset)
+{
+	return readq(npc->npc_af_base + offset);
+}
+
+static void npc_af_reg_write(struct npc_af *npc, u64 offset, u64 val)
+{
+	writeq(va, npc->npc_af_base + offset);
+}
+#endif
+static inline u64 enable_mask(int count)
+{
+	return ((count < 64) ? ~(BIT_ULL(count) - 1) : (0x00ULL));
+}
+
+
+#define LDATA_EXTRACT_CONFIG(intf, lid, ltype, ld, cfg) \
+	npc_af_reg_write(npc,			\
+		CAVM_NPC_AF_INTFX_LIDX_LTX_LDX_CFG(intf, lid, ltype, ld), cfg)
+
+#define LDATA_FLAGS_CONFIG(intf, ld, flags, cfg)	\
+	npc_af_reg_write(npc,			\
+		CAVM_NPC_AF_INTFX_LDATAX_FLAGSX_CFG(intf, ld, flags), cfg)
+
+static void npc_af_config_layer_info(struct npc_af *npc)
+{
+	union cavm_npc_af_const af_const;
+	union cavm_npc_af_intfx_lidx_ltx_ldx_cfg cfg;
+	int lid_count;
+	int lid, ltype;
+	struct npc_mcam *mcam = &npc->mcam;
+
+	af_const.u = npc_af_reg_read(npc, CAVM_NPC_AF_CONST());
+	lid_count = af_const.s.lids;
+
+	/* First clear any existing config i.e
+	 * disable LDATA and FLAGS extraction.
+	 */
+	for (lid = 0; lid < lid_count; lid++) {
+		for (ltype = 0; ltype < 16; ltype++) {
+			LDATA_EXTRACT_CONFIG(NIX_INTF_RX, lid, ltype, 0, 0ULL);
+			LDATA_EXTRACT_CONFIG(NIX_INTF_RX, lid, ltype, 1, 0ULL);
+			LDATA_EXTRACT_CONFIG(NIX_INTF_TX, lid, ltype, 0, 0ULL);
+			LDATA_EXTRACT_CONFIG(NIX_INTF_TX, lid, ltype, 1, 0ULL);
+
+			LDATA_FLAGS_CONFIG(NIX_INTF_RX, 0, ltype, 0ULL);
+			LDATA_FLAGS_CONFIG(NIX_INTF_RX, 1, ltype, 0ULL);
+			LDATA_FLAGS_CONFIG(NIX_INTF_TX, 0, ltype, 0ULL);
+			LDATA_FLAGS_CONFIG(NIX_INTF_TX, 1, ltype, 0ULL);
+		}
+	}
+
+	/* If we plan to extract Outer IPv4 tuple for TCP/UDP pkts
+	 * then 112bit key is not sufficient
+	 */
+	if (mcam->keysize != NPC_MCAM_KEY_X2)
+		return;
+
+	/* Start placing extracted data/flags from 64bit onwards, for now */
+	/* Extract DMAC from the packet */
+	cfg.u = 0;
+	cfg.s.bytesm1 = 0x05;
+	cfg.s.ena = 1;
+	cfg.s.key_offset = 0x8;
+	LDATA_EXTRACT_CONFIG(NIX_INTF_RX, CAVM_NPC_LID_E_LA, NPC_LT_LA_ETHER, 0, cfg.u);
+}
+
+static void npc_af_config_kpuaction(struct npc_af *npc,
+				    struct npc_kpu_profile_action *kpuaction,
+				    int kpu, int entry, bool pkind)
+{
+	u64 reg;
+	union cavm_npc_af_pkindx_action0 action0;
+	union cavm_npc_af_pkindx_action1 action1;
+
+	action0.u = 0;
+	action1.u = 0;
+	action1.s.errlev = kpuaction->errlev;
+	action1.s.errcode = kpuaction->errcode;
+	action1.s.dp0_offset = kpuaction->dp0_offset;
+	action1.s.dp1_offset = kpuaction->dp1_offset;
+	action1.s.dp2_offset = kpuaction->dp2_offset;
+
+	reg = pkind ? CAVM_NPC_AF_PKINDX_ACTION1(entry) :
+		      CAVM_NPC_AF_KPUX_ENTRYX_ACTION1(kpu, entry);
+	npc_af_reg_write(npc, reg, action1.u);
+
+	action0.s.byp_count = kpuaction->bypass_count;
+	action0.s.capture_ena = kpuaction->cap_ena;
+	action0.s.parse_done = kpuaction->parse_done;
+	action0.s.next_state = kpuaction->next_state;
+	action0.s.capture_lid = kpuaction->lid;
+	action0.s.capture_ltype = kpuaction->ltype;
+	action0.s.capture_flags = kpuaction->flags;
+	action0.s.ptr_advance = kpuaction->ptr_advance;
+	action0.s.var_len_offset = kpuaction->offset;
+	action0.s.var_len_mask = kpuaction->mask;
+	action0.s.var_len_right = kpuaction->right;
+	action0.s.var_len_shift = kpuaction->shift;
+
+	reg = pkind ? CAVM_NPC_AF_PKINDX_ACTION0(entry) :
+		      CAVM_NPC_AF_KPUX_ENTRYX_ACTION0(kpu, entry);
+	npc_af_reg_write(npc, reg, action0.u);
+}
+
+static void npc_af_config_kpucam(struct npc_af *npc,
+				 struct npc_kpu_profile_cam *kpucam,
+				 int kpu, int entry)
+{
+	union cavm_npc_af_kpux_entryx_camx cam0, cam1;
+
+	cam0.u = 0;
+	cam1.u = 0;
+	cam1.s.state = kpucam->state & kpucam->state_mask;
+	cam1.s.dp0_data = kpucam->dp0 & kpucam->dp0_mask;
+	cam1.s.dp1_data = kpucam->dp1 & kpucam->dp1_mask;
+	cam1.s.dp2_data = kpucam->dp2 & kpucam->dp2_mask;
+
+	cam0.s.state = ~kpucam->state & kpucam->state_mask;
+	cam0.s.dp0_data = ~kpucam->dp0 & kpucam->dp0_mask;
+	cam0.s.dp1_data = ~kpucam->dp1 & kpucam->dp1_mask;
+	cam0.s.dp2_data = ~kpucam->dp2 & kpucam->dp2_mask;
+
+	npc_af_reg_write(npc, CAVM_NPC_AF_KPUX_ENTRYX_CAMX(kpu, entry, 0),
+			 cam0.u);
+	npc_af_reg_write(npc, CAVM_NPC_AF_KPUX_ENTRYX_CAMX(kpu, entry, 1),
+			 cam1.u);
+}
+
+static void npc_af_program_kpu_profile(struct npc_af *npc, int kpu,
+				       struct npc_kpu_profile *profile)
+{
+	int entry, num_entries, max_entries;
+	union cavm_npc_af_const1 af_const1;
+	union cavm_npc_af_kpux_cfg kpu_cfg;
+
+	if (profile->cam_entries != profile->action_entries) {
+		printf("%s: KPU%d: CAM and action entries [%d != %d] not equal\n",
+		       __func__, kpu, profile->cam_entries,
+		       profile->action_entries);
+		return;
+	}
+
+	af_const1.u = npc_af_reg_read(npc, CAVM_NPC_AF_CONST1());
+	max_entries = af_const1.s.kpu_entries;
+
+	/* Program CAM match entries for previous KPU extracted data */
+	num_entries = min_t(int, profile->cam_entries, max_entries);
+	for (entry = 0; entry < num_entries; entry++)
+		npc_af_config_kpucam(npc, &profile->cam[entry], kpu, entry);
+
+	/* Program this KPU's actions */
+	num_entries = min_t(int, profile->action_entries, max_entries);
+	npc_af_reg_write(npc, CAVM_NPC_AF_KPUX_ENTRY_DISX(kpu, 0),
+			 enable_mask(num_entries));
+	if (num_entries > 64)
+		npc_af_reg_write(npc, CAVM_NPC_AF_KPUX_ENTRY_DISX(kpu, 1),
+				 enable_mask(num_entries - 64));
+
+	/* Enable this KPU */
+	kpu_cfg.u = npc_af_reg_read(CAVM_NPC_AF_KPUX_CFG(kpu));
+	kpu_cfg.s.ena = 1;
+	npc_af_reg_write(npc, CAVM_NPC_AF_KPUX_CFG(kpu), kpu_cfg.u);
+}
+
+static void npc_parser_profile_init(struct npc_af *npc)
+{
+	int num_pkinds, num_kpus, idx;
+	struct npc_pkind *pkind = &npc->pkind;
+	union cavm_npc_af_const af_const;
+
+	af_const.u = npc_af_reg_read(npc, CAVM_NPC_AF_CONST());
+	npc->npc_kpus = af_const.s.kpus;
+
+	/* Disable all KPUs and their entries */
+	for (idx = 0; idx < npc->npc_kpus; idx++) {
+		npc_af_reg_write(npc, CAVM_NPC_AF_KPUX_ENTRY_DISX(idx, 0),
+				 ~0ULL);
+		npc_af_reg_write(npc, CAVM_NPC_AF_KPUX_ENTRY_DISX(idx, 1),
+				 ~0ULL);
+		npc_af_reg_write(npc, CAVM_NPC_AF_KPUX_CFG(idx), 0);
+	}
+
+	/* First program IKPU profile (i.e. PKIND configs).
+	 * Check HW max count to avoid configuring junk or writing to
+	 * unsupported CSR addresses.
+	 */
+
+	num_pkinds = ARRAY_SIZE(ikpu_action_entries);
+	num_pkinds = min_t(int, pkind->rsrc.max, num_pkinds);
+
+	for (idx = 0; idx < num_pkinds; idx++)
+		npc_af_config_kpuaction(npc, &ikpu_action_entries[idx],
+					0, idx, true);
+	/* Program KPU CAM and Action profiles */
+	num_kpus = ARRAY_SIZE(npc_kpu_profiles);
+	num_kpus = min_t(int, npc->npc_kpus, num_kpus);
+
+	for (idx = 0; idx < num_kpus; idx++)
+		npc_af_program_kpu_profile(npc, idx, &npc_kpu_profiles[idx]);
+
+	npc_af_config_layer_info(npc);
+}
+
+static int npc_af_mcam_rsrcs_init(struct npc_af *npc)
+{
+	int err, rsvd;
+	struct npc_mcam *mcam = &npc->mcam;
+	union cavm_npc_af_const af_const;
+	union cavm_npc_af_intfx_kex_cfg kex_cfg;
+	struct nix_af_handle *nix = npc->nix_af;
+
+	/* Get HW limits */
+	af_const.u = npc_af_reg_read(npc, CAVM_NPC_AF_CONST());
+	mcam->banks = af_const.s.mcam_banks;
+	mcam->banksize = af_const.s.mcam_bank_depth;
+	mcam->counters = af_const.s.match_stats;
+
+	/* Actual number of MCAM entries vary by entry size */
+	kex_cfg.u = npc_af_reg_read(npc, CAVM_NPC_AF_INTFX_KEX_CFG(0));
+	mcam->total_entries = (mcam->banks / kex_cfg.s.keyw) * mcam->banksize;
+	mcam->keysize = kex_cfg.s.keyw;
+
+	/* Number of banks combined per MCAM entry */
+	switch (kex_cfg.s.keyw) {
+	case CAVM_NPC_MCAMKEYW_E_X4:
+		mcam->banks_per_entry = 4;
+		break;
+	case CAVM_NPC_MCAMKEYW_E_X2:
+		mcam->banks_per_entry = 2;
+		break;
+	default:
+		mcam->banks_per_entry = 1;
+		break;
+	}
+
+	/* Reserve one MCAM entry for each of the NIX LFs to guarantee space
+	 * to install default matching DMAC rule.  Also reserve 2 MCAM entries
+	 * for each PF for default channel based matchingor 'ucast & bcast'
+	 * matching to support UCAST and PROMISC modes of operation for PFs.
+	 * PF0 is excluded.
+	 */
+	rsvd = (npc->block.rsrc.max * RSVD_MCAM_ENTRIES_PER_NIXLF) +
+		((npc->hw->total_pfs - 1) * RSVD_MCAM_ENTRIES_PER_PF);
+	if (mcam->total_entries <= rsvd) {
+		printf("%s: Insufficient NPC MCAM size %d for pkt I/O, exiting\n",
+		       __func__);
+		return -ENOMEM;
+	}
+	mcam->entries = mcam->total_entries - rsvd;
+	mcam->nixlf_offset = mcam->entries;
+	mcam->pf_offset = mcam->nixlf_offset + nix->rsrc.max;
+
+	/* Allocate bitmap for this resource and memory for MCAM entry to
+	 * RVU PFFUNC allocation mapping info.
+	 */
+	mcam->rsrc.max = mcam->entries;
+	err = rvu_alloc_bitmap(&mcam->rsrc);
+	if (err)
+		return err;
+	mcam->pfvf_map = calloc(mcam->rsrc.max, sizeof(u16));
+	if (!mcam->pfvf_map)
+		return -ENOMEM;
+
+	return 0;
+}
+
+int npc_af_init(struct npc_af *npc)
+{
+	int err;
+	u64 keyz = NPC_MCAM_KEY_X2;
+	struct npc_pkind *pkind = &npc->pkind;
+	union cavm_npc_af_const1 af_const1;
+	union cavm_npc_af_pck_def_ol2 pck_ol2;
+	union cavm_nixx_af_rx_def_ol2 rx_def_ol2;
+	union cavm_nixx_af_rx_def_oudp rx_oudp;
+	union cavm_nixx_af_rx_def_otcp rx_otcp;
+	union cavm_nixx_af_rx_def_oip4 rx_oip4;
+	union cavm_npc_af_pck_def_oip4 pck_oip4;
+	union cavm_npc_af_pck_cfg pck_cfg;
+	union cavm_npc_af_intfx_kex_cfg key_cfg;
+
+	af_const1.u = npc_af_reg_read(npc, CAVM_NPC_AF_CONST1());
+	pkind->rsrc.max = af_const1.s.pkinds;
+
+	err = rvu_alloc_bitmap(&pkind->rsrc);
+	if (err)
+		return err;
+
+	pkind->pfchan_map = calloc(pkind->rsrc.max, sizeof(u32));
+	if (!pkind->pfchan_map)
+		return -ENOMEM;
+
+	/* Configure KPU profile */
+	npc_parser_profile_init(npc);
+
+	/* Config outer L2, IP, TCP and UDP's NPC layer info */
+	pck_ol2.u = 0;
+	pck_ol2.s.lid = CAVM_NPC_LID_E_LA;
+	pck_ol2.s.ltype_match = NPC_LT_LA_ETHER;
+	pck_ol2.s.ltype_mask = 0x0f;
+	npc_af_reg_write(npc, CAVM_NPC_AF_PCK_DEF_OL2(), pck_ol2.u);
+	rx_def_ol2.u = 0;
+	rx_def_ol2.s.lid = CAVM_NPC_LID_E_LA;
+	rx_def_ol2.s.ltype_match = NPC_LT_LA_ETHER;
+	rx_def_ol2.s.ltype_mask = 0x0f;
+	nix_af_reg_write(npc->nix_af, CAVM_NIXX_AF_RX_DEF_OL2(), rx_def_ol2.u);
+	rx_oudp.u = 0;
+	rx_oudp.s.lid = CAVM_NPC_LID_E_LD;
+	rx_oudp.s.ltype_match = NPC_LT_LD_UDP;
+	rx_oudp.s.ltype_mask = 0x0f;
+	nix_af_reg_write(npc->nix_af, CAVM_NIXX_AF_RX_DEF_OUDP(), rx_oudp.u);
+	rx_otcp.s.lid = CAVM_NPC_LID_E_LD;
+	rx_otcp.s.ltype_match = NPC_LT_LD_TCP;
+	rx_otcp.s.ltype_mask = 0x0f;
+	nix_af_reg_write(npc->nix_af, CAVM_NIXX_AF_RX_DEF_OTCP(), rx_otcp.u);
+	rx_oip4.u = 0;
+	rx_oip4.s.lid = CAVM_NPC_LID_E_LC;
+	rx_oip4.s.ltype_match = NPC_LT_LC_IP;
+	rx_oip4.s.ltype_mask = 0x0f;
+	nix_af_reg_write(npc->nix_af, CAVM_NIXX_AF_RX_DEF_OIP4(), rx_oip4.u);
+	pck_oip4.u = 0;
+	pck_oip4.s.lid = CAVM_NPC_LID_E_LC;
+	pck_oip4.s.ltype_match = NPC_LT_LC_IP;
+	pck_oip4.s.ltype_mask = 0x0f;
+	npc_af_reg_write(npc, CAVM_NPC_AF_PCK_DEF_OIP4(), pck_oip4.u);
+
+	/* Enable below for Rx packets
+	 * - IPv4 header checksum validation
+	 * - Detect outer L2 broadcast addresses/
+	 */
+	pck_cfg.u = npc_af_reg_read(npc, CAVM_NPC_AF_PCK_CFG());
+	pck_cfg.s.oip4_cksum = 1;
+	pck_cfg.s.l2b = 1;
+	npc_af_reg_write(npc, CAVM_NPC_AF_PCK_CFG(), pck_cfg.u)
+
+	/* Set RX and TX side MCAM search key size.
+	 * Also enable parse key extract nibles such that execpt layer E to H,
+	 * rest of the key is included for MCAM search.
+	 * Layer E-H is excluded since all KPUs are not yet in use.
+	 */
+	key_cfg.u = 0;
+	key_cfg.s.keyw = keyz & 0x3;
+	key_cfg.s.parse_nibble_ena = (1 << 20) - 1;
+	npc_af_reg_write(npc,
+		      CAVM_NPC_AF_INTFX_KEY_CFG(CAVM_NPC_INTF_E_NIXX_RX(0)), key_cfg.u);
+	key_cfg.u = 0;
+	key_cfg.s.keyw = keyz & 0x3;
+	key_cfg.s.parse_nibble_ena = (1 << 20) - 1;
+	npc_af_reg_write(npc,
+		      CAVM_NPC_AF_INTFX_KEY_CFG(CAVM_NPC_INTF_E_NIXX_TX(0)),
+		      key_cfg.u);
+
+	/* Set TX miss action to UCAST_DEFAULT, i.e. transmit the packet on
+	 * NIX LF SQ's default channel
+	 */
+	npc_af_reg_write(npc,
+		      CAVM_NPC_AF_INTFX_MISS_ACT(CAVM_NPC_INTF_E_NIXX_TX(0)),
+		      CAVM_NIX_TX_ACTIONOP_E_UCAST_DEFAULT);
+
+	/* If MCAM lookup doesn't result in a match, drop the received packet */
+	npc_af_reg_write(npc,
+		      CAVM_NPC_AF_INTFX_MISS_ACT(CAVM_NPC_INTF_E_NIXX_RX(0)),
+		      CAVM_NIX_RX_ACTIONOP_E_DROP);
+
+	err = npc_mcam_rsrcs_init(npc);
+
+	return err;
+}
diff --git a/drivers/net/octeontx2/npc.h b/drivers/net/octeontx2/npc.h
new file mode 100644
index 0000000..112ef03
--- /dev/null
+++ b/drivers/net/octeontx2/npc.h
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#ifndef __NPC_H__
+#define __NPC_H__
+
+#define RSVD_MCAM_ENTRIES_PER_PF	2	/** Ucast and Bcast */
+#define RSVD_MCAM_ENTRIES_PER_NIXLF	1	/** Ucast for VFs */
+
+struct npc_kpu_profile_cam {
+	u8 state;
+	u8 state_mask;
+	u16 dp0;
+	u16 dp0_mask;
+	u16 dp1;
+	u16 dp1_mask;
+	u16 dp2;
+	u16 dp2_mask;
+};
+
+struct npc_kpu_profile_action {
+	u8 errlev;
+	u8 errcode;
+	u8 dp0_offset;
+	u8 dp1_offset;
+	u8 dp2_offset;
+	u8 bypass_count;
+	u8 parse_done;
+	u8 next_state;
+	u8 ptr_advance;
+	u8 cap_ena;
+	u8 lid;
+	u8 ltype;
+	u8 flags;
+	u8 offset;
+	u8 mask;
+	u8 right;
+	u8 shift;
+};
+
+struct npc_kpu_profile {
+	int cam_entries;
+	int action_entries;
+	struct npc_kpu_profile_cam *cam;
+	struct npc_kpu_profile_action *action;
+};
+
+struct npc_pkind {
+	struct rsrc_bmap rsrc;
+	u32	*pfchan_map;
+};
+
+struct npc_mcam {
+	struct rsrc_bmap rsrc;
+	u16	*pfvf_map;
+	u16	total_entries; /* Total number of MCAM entries */
+	u16	entries;  /* Total - reserved for NIX LFs */
+	u8	banks_per_entry;  /* Number of keywords in key */
+	u8	keysize;
+	u8	banks;    /* Number of MCAM banks */
+	u16	banksize; /* Number of MCAM entries in each bank */
+	u16	counters; /* Number of match counters */
+	u16	nixlf_offset;
+	u16	pf_offset;
+};
+
+struct nix_af_handle;
+struct nix_handle;
+struct rvu_hwinfo;
+
+struct npc_af {
+	struct nix_af_handle	*nix_af;
+	struct npc_pkind	pkind;
+	void __iomem		*npc_af_base;
+	u8			npc_kpus;	/** Number of parser units */
+	struct npc_mcam		mcam;
+	struct rvu_block	block;
+	struct rvu_hwinfo	*hw;
+};
+
+struct npc {
+	struct npc_af		*npc_af;
+	void __iomem		*npc_base;
+	struct nix_handle	*nix;
+}
+
+#endif /* __NPC_H__ */
+
diff --git a/drivers/net/octeontx2/npc_profile.h b/drivers/net/octeontx2/npc_profile.h
new file mode 100644
index 0000000..4f521fb
--- /dev/null
+++ b/drivers/net/octeontx2/npc_profile.h
@@ -0,0 +1,3354 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#ifndef NPC_PROFILE_H
+#define NPC_PROFILE_H
+
+#define NPC_ETYPE_IP		0x0800
+#define NPC_ETYPE_IP6		0x86dd
+#define NPC_ETYPE_ARP		0x0806
+#define NPC_ETYPE_RARP		0x8035
+#define NPC_ETYPE_MPLSU		0x8847
+#define NPC_ETYPE_MPLSM		0x8848
+#define NPC_ETYPE_ETAG		0x893f
+#define NPC_ETYPE_CTAG		0x8100
+#define NPC_ETYPE_SBTAG		0x88a8
+#define NPC_ETYPE_ITAG		0X88e7
+#define NPC_ETYPE_QINQ		0x9100
+#define NPC_ETYPE_TRANS_ETH_BR	0x6558
+#define NPC_ETYPE_PPP		0x880b
+
+#define NPC_IPNH_HOP		0
+#define NPC_IPNH_ICMP		1
+#define NPC_IPNH_IGMP		2
+#define NPC_IPNH_IP		4
+#define NPC_IPNH_TCP		6
+#define NPC_IPNH_UDP		17
+#define NPC_IPNH_IP6		41
+#define NPC_IPNH_ROUT		43
+#define NPC_IPNH_FRAG		44
+#define NPC_IPNH_GRE		47
+#define NPC_IPNH_ESP		50
+#define NPC_IPNH_AH		51
+#define NPC_IPNH_ICMP6		58
+#define NPC_IPNH_NONH		59
+#define NPC_IPNH_DEST		60
+#define NPC_IPNH_SCTP		132
+
+#define NPC_UDP_PORT_GTPC	2123
+#define NPC_UDP_PORT_GTPU	2152
+#define NPC_UDP_PORT_VXLAN	4789
+#define NPC_UDP_PORT_GENEVE	6081
+
+#define NPC_TCP_PORT_HTTP	80
+#define NPC_TCP_PORT_HTTPS	443
+
+#define NPC_IP_VER_4		0x4000
+#define NPC_IP_VER_6		0x6000
+#define NPC_IP_VER_MASK		0xf000
+#define NPC_IP_HDR_LEN_5	0x0500
+#define NPC_IP_HDR_LEN_MASK	0x0f00
+
+#define NPC_GRE_F_CSUM		(0x1 << 15)
+#define NPC_GRE_F_ROUTE		(0x1 << 14)
+#define NPC_GRE_F_KEY		(0x1 << 13)
+#define NPC_GRE_F_SEQ		(0x1 << 12)
+#define NPC_GRE_F_ACK		(0x1 << 7)
+#define NPC_GRE_FLAG_MASK	(NPC_GRE_F_CSUM | NPC_GRE_F_ROUTE | \
+				 NPC_GRE_F_KEYNPC_GRE_F_SEQNPC_GRE_F_ACK)
+#define NPC_GRE_VER_MASK	0x0003
+#define NPC_GRE_VER_1		0x0001
+
+#define NPC_VXLAN_I		0x0800
+
+#define NPC_GENEVE_F_OAM	(0x1 << 7)
+#define NPC_GENEVE_F_CRI_OPT	(0x1 << 6)
+#define NPC_GTP_PT_GTP		(0x1 << 12)
+#define NPC_GTP_PT_MASK		(0x1 << 12)
+#define NPC_GTP_VER1		(0x1 << 13)
+#define NPC_GTP_VER_MASK	(0x7 << 13)
+#define NPC_GTP_MT_G_PDU	0xff
+#define NPC_GTP_MT_MASK		0xff
+
+#define NPC_TCP_DATA_OFFSET_5		0x5000
+#define NPC_TCP_DATA_OFFSET_MASK	0xf000
+
+enum NPC_ERRLEV_E {
+	NPC_ERRLEV_RE = 0,
+	NPC_ERRLEV_LA = 1,
+	NPC_ERRLEV_LB = 2,
+	NPC_ERRLEV_LC = 3,
+	NPC_ERRLEV_LD = 4,
+	NPC_ERRLEV_LE = 5,
+	NPC_ERRLEV_LF = 6,
+	NPC_ERRLEV_LG = 7,
+	NPC_ERRLEV_LH = 8,
+	NPC_ERRLEV_NIX = 15,
+	NPC_ERRLEV_ENUM_LAST = 16,
+};
+
+enum npc_kpu_err_code {
+	NPC_EC_NOERR = 0, /* has to be zero */
+	NPC_EC_UNK,
+	NPC_EC_L2_K1,
+	NPC_EC_L2_K2,
+	NPC_EC_L2_K3,
+	NPC_EC_L2_K3_ETYPE_UNK,
+	NPC_EC_IP_VER,
+	NPC_EC_IP6_VER,
+	NPC_EC_VXLAN,
+	NPC_EC_NVGRE,
+	NPC_EC_GRE,
+	NPC_EC_GRE_VER1,
+	NPC_EC_L4,
+	NPC_EC_LAST /* has to be the last item */
+};
+
+enum npc_kpu_parser_state {
+	NPC_S_NA = 0,
+	NPC_S_KPU1_ETHER,
+	NPC_S_KPU1_PKI,
+	NPC_S_KPU2_CTAG,
+	NPC_S_KPU2_SBTAG,
+	NPC_S_KPU2_QINQ,
+	NPC_S_KPU2_ETAG,
+	NPC_S_KPU3_CTAG,
+	NPC_S_KPU3_STAG,
+	NPC_S_KPU3_QINQ,
+	NPC_S_KPU4_MPLS,
+	NPC_S_KPU5_IP,
+	NPC_S_KPU5_IP6,
+	NPC_S_KPU5_ARP,
+	NPC_S_KPU5_RARP,
+	NPC_S_KPU6_IP6_EXT,
+	NPC_S_KPU7_IP6_EXT,
+	NPC_S_KPU8_TCP,
+	NPC_S_KPU8_UDP,
+	NPC_S_KPU8_SCTP,
+	NPC_S_KPU8_ICMP,
+	NPC_S_KPU8_IGMP,
+	NPC_S_KPU8_ICMP6,
+	NPC_S_KPU8_GRE,
+	NPC_S_KPU8_ESP,
+	NPC_S_KPU8_AH,
+	NPC_S_KPU9_TU_ETHER,
+	NPC_S_KPU9_TU_PPP,
+	NPC_S_KPU11_TU_IP,
+	NPC_S_KPU11_TU_IP6,
+	NPC_S_KPU11_TU_ARP,
+	NPC_S_KPU12_TU_IP6_EXT,
+	NPC_S_KPU13_TU_IP6_EXT,
+	NPC_S_KPU14_TU_TCP,
+	NPC_S_KPU14_TU_UDP,
+	NPC_S_KPU14_TU_SCTP,
+	NPC_S_KPU14_TU_ICMP,
+	NPC_S_KPU14_TU_IGMP,
+	NPC_S_KPU14_TU_ICMP6,
+	NPC_S_KPU14_TU_ESP,
+	NPC_S_KPU14_TU_AH,
+	NPC_S_KPU15_HTTP_DATA,
+	NPC_S_KPU15_HTTPS_DATA,
+	NPC_S_KPU15_TCP_DATA,
+	NPC_S_KPU15_UDP_DATA,
+	NPC_S_LAST /* has to be the last item */
+};
+
+enum npc_kpu_parser_flag {
+	NPC_F_NA = 0,
+	NPC_F_HAS_PKI,
+	NPC_F_HAS_PKI_HAS_VLAN,
+	NPC_F_HAS_PKI_HAS_ETAG,
+	NPC_F_HAS_PKI_HAS_MPLS,
+	NPC_F_ETYPE_UNK,
+	NPC_F_ETHER_HAS_VLAN,
+	NPC_F_ETHER_HAS_ETAG,
+	NPC_F_ETHER_HAS_MPLS,
+	NPC_F_VLAN_2_TAGS,
+	NPC_F_VLAN_2_TAGS_ETYPE_UNK,
+	NPC_F_VLAN_3_TAGS,
+	NPC_F_VLAN_4_TAGS,
+	NPC_F_QINQ_DBL,
+	NPC_F_BTAG_HAS_CTAG,
+	NPC_F_IP_HAS_OPTIONS,
+	NPC_F_IP_IN_IP,
+	NPC_F_IP_6TO4,
+	NPC_F_IP_UNK_PROTO,
+	NPC_F_IP_IN_IP_HAS_OPTIONS,
+	NPC_F_IP_6TO4_HAS_OPTIONS,
+	NPC_F_IP_UNK_PROTO_HAS_OPTIONS,
+	NPC_F_IP6_HAS_EXT,
+	NPC_F_IP6_TUN_IP6,
+	NPC_F_TCP_HAS_OPTIONS,
+	NPC_F_TCP_HTTP,
+	NPC_F_TCP_HTTPS,
+	NPC_F_TCP_UNK_PORT,
+	NPC_F_TCP_HTTP_HAS_OPTIONS,
+	NPC_F_TCP_HTTPS_HAS_OPTIONS,
+	NPC_F_TCP_UNK_PORT_HAS_OPTIONS,
+	NPC_F_UDP_VXLAN_NOVNI,
+	NPC_F_UDP_GTPU_G_PDU,
+	NPC_F_UDP_GTPU_UNK,
+	NPC_F_UDP_UNK_PORT,
+	NPC_F_UDP_GENEVE_OAM,
+	NPC_F_UDP_GENEVE_CRI_OPT,
+	NPC_F_UDP_GENEVE_OAM_CRI_OPT,
+	NPC_F_GRE_HAS_SRE,
+	NPC_F_GRE_HAS_CSUM,
+	NPC_F_GRE_HAS_KEY,
+	NPC_F_GRE_HAS_SEQ,
+	NPC_F_GRE_HAS_CSUM_KEY,
+	NPC_F_GRE_HAS_CSUM_SEQ,
+	NPC_F_GRE_HAS_KEY_SEQ,
+	NPC_F_GRE_HAS_CSUM_KEY_SEQ,
+	NPC_F_GRE_HAS_ROUTE,
+	NPC_F_GRE_UNK_PROTO,
+	NPC_F_GRE_VER1,
+	NPC_F_GRE_VER1_HAS_SEQ,
+	NPC_F_GRE_VER1_HAS_ACK,
+	NPC_F_GRE_VER1_HAS_SEQ_ACK,
+	NPC_F_GRE_VER1_UNK_PROTO,
+	NPC_F_TU_ETHER_ETYPE_UNK,
+	NPC_F_TU_ETHER_HAS_CTAG,
+	NPC_F_TU_ETHER_HAS_CTAG_ETYPE_UNK,
+	NPC_F_TU_ETHER_HAS_STAG_CTAG,
+	NPC_F_TU_ETHER_HAS_STAG_CTAG_ETYPE_UNK,
+	NPC_F_TU_ETHER_HAS_STAG_ETYPE_UNK,
+	NPC_F_TU_ETHER_HAS_QINQ_CTAG,
+	NPC_F_TU_ETHER_HAS_QINQ_CTAG_ETYPE_UNK,
+	NPC_F_TU_ETHER_HAS_QINQ_ETYPE_UNK,
+	NPC_F_LAST /* has to be the last item */
+};
+
+struct npc_kpu_profile_action ikpu_action_entries[] = {
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 14, 16,
+		0, 0, NPC_S_KPU1_ETHER, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 1, 0xff,
+		0, 0,
+	},
+};
+
+struct npc_kpu_profile_cam kpu1_cam_entries[] = {
+	{
+		NPC_S_KPU1_ETHER, 0xff, NPC_ETYPE_IP, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU1_ETHER, 0xff, NPC_ETYPE_IP6, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU1_ETHER, 0xff, NPC_ETYPE_ARP, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU1_ETHER, 0xff, NPC_ETYPE_RARP, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU1_ETHER, 0xff, NPC_ETYPE_CTAG, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU1_ETHER, 0xff, NPC_ETYPE_SBTAG, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU1_ETHER, 0xff, NPC_ETYPE_QINQ, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU1_ETHER, 0xff, NPC_ETYPE_ETAG, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU1_ETHER, 0xff, NPC_ETYPE_MPLSU, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU1_ETHER, 0xff, NPC_ETYPE_MPLSM, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU1_ETHER, 0xff, 0x0000, 0xfc00, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU1_ETHER, 0xff, 0x0400, 0xfe00, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU1_ETHER, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU1_PKI, 0xff, NPC_ETYPE_IP, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU1_PKI, 0xff, NPC_ETYPE_IP6, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU1_PKI, 0xff, NPC_ETYPE_ARP, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU1_PKI, 0xff, NPC_ETYPE_RARP, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU1_PKI, 0xff, NPC_ETYPE_CTAG, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU1_PKI, 0xff, NPC_ETYPE_SBTAG, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU1_PKI, 0xff, NPC_ETYPE_QINQ, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU1_PKI, 0xff, NPC_ETYPE_ETAG, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU1_PKI, 0xff, NPC_ETYPE_MPLSU, 0xffff, 0x0010,
+		0x0010, 0x0000, 0xffff,
+	},
+	{
+		NPC_S_KPU1_PKI, 0xff, NPC_ETYPE_MPLSM, 0xffff, 0x0010,
+		0x0010, 0x0000, 0xffff,
+	},
+	{
+		NPC_S_KPU1_PKI, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_NA, 0X00, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+};
+
+struct npc_kpu_profile_cam kpu2_cam_entries[] = {
+	{
+		NPC_S_KPU2_CTAG, 0xff, NPC_ETYPE_IP, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_CTAG, 0xff, NPC_ETYPE_IP6, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_CTAG, 0xff, NPC_ETYPE_ARP, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_CTAG, 0xff, NPC_ETYPE_RARP, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_CTAG, 0xff, NPC_ETYPE_MPLSU, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_CTAG, 0xff, NPC_ETYPE_MPLSM, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_CTAG, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_SBTAG, 0xff, NPC_ETYPE_CTAG, 0xffff, NPC_ETYPE_IP,
+		0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_SBTAG, 0xff, NPC_ETYPE_CTAG, 0xffff, NPC_ETYPE_IP6,
+		0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_SBTAG, 0xff, NPC_ETYPE_CTAG, 0xffff, NPC_ETYPE_ARP,
+		0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_SBTAG, 0xff, NPC_ETYPE_CTAG, 0xffff, NPC_ETYPE_RARP,
+		0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_SBTAG, 0xff, NPC_ETYPE_CTAG, 0xffff, NPC_ETYPE_MPLSU,
+		0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_SBTAG, 0xff, NPC_ETYPE_CTAG, 0xffff, NPC_ETYPE_MPLSM,
+		0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_SBTAG, 0xff, NPC_ETYPE_CTAG, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_SBTAG, 0xff, NPC_ETYPE_SBTAG, 0xffff,
+		NPC_ETYPE_CTAG, 0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_SBTAG, 0xff, NPC_ETYPE_SBTAG, 0xffff,
+		NPC_ETYPE_SBTAG, 0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_SBTAG, 0xff, NPC_ETYPE_ITAG, 0xffff,
+		0x0000, 0x0000, NPC_ETYPE_IP, 0xffff,
+	},
+	{
+		NPC_S_KPU2_SBTAG, 0xff, NPC_ETYPE_ITAG, 0xffff,
+		0x0000, 0x0000, NPC_ETYPE_IP6, 0xffff,
+	},
+	{
+		NPC_S_KPU2_SBTAG, 0xff, NPC_ETYPE_ITAG, 0xffff,
+		0x0000, 0x0000, NPC_ETYPE_ARP, 0xffff,
+	},
+	{
+		NPC_S_KPU2_SBTAG, 0xff, NPC_ETYPE_ITAG, 0xffff,
+		0x0000, 0x0000, NPC_ETYPE_RARP, 0xffff,
+	},
+	{
+		NPC_S_KPU2_SBTAG, 0xff, NPC_ETYPE_ITAG, 0xffff,
+		0x0000, 0x0000, NPC_ETYPE_CTAG, 0xffff,
+	},
+	{
+		NPC_S_KPU2_SBTAG, 0xff, NPC_ETYPE_ITAG, 0xffff,
+		0x0000, 0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_SBTAG, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_QINQ, 0xff, NPC_ETYPE_CTAG, 0xffff,
+		NPC_ETYPE_IP, 0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_QINQ, 0xff, NPC_ETYPE_CTAG, 0xffff,
+		NPC_ETYPE_IP6, 0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_QINQ, 0xff, NPC_ETYPE_CTAG, 0xffff,
+		NPC_ETYPE_ARP, 0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_QINQ, 0xff, NPC_ETYPE_CTAG, 0xffff,
+		NPC_ETYPE_RARP, 0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_QINQ, 0xff, NPC_ETYPE_CTAG, 0xffff,
+		NPC_ETYPE_MPLSU, 0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_QINQ, 0xff, NPC_ETYPE_CTAG, 0xffff,
+		NPC_ETYPE_MPLSM, 0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_QINQ, 0xff, NPC_ETYPE_CTAG, 0xffff,
+		0x0000, 0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_QINQ, 0xff, NPC_ETYPE_QINQ, 0xffff,
+		NPC_ETYPE_CTAG, 0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_QINQ, 0xff, NPC_ETYPE_QINQ, 0xffff,
+		NPC_ETYPE_QINQ, 0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_ETAG, 0xff, NPC_ETYPE_IP, 0xffff,
+		0x0000, 0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_ETAG, 0xff, NPC_ETYPE_IP6, 0xffff,
+		0x0000, 0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_ETAG, 0xff, NPC_ETYPE_ARP, 0xffff,
+		0x0000, 0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_ETAG, 0xff, NPC_ETYPE_RARP, 0xffff,
+		0x0000, 0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_ETAG, 0xff, NPC_ETYPE_CTAG, 0xffff,
+		0x0000, 0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_ETAG, 0xff, NPC_ETYPE_SBTAG, 0xffff,
+		0x0000, 0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_ETAG, 0xff, NPC_ETYPE_QINQ, 0xffff,
+		0x0000, 0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU2_ETAG, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_NA, 0X00, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+};
+
+struct npc_kpu_profile_cam kpu3_cam_entries[] = {
+	{
+		NPC_S_KPU3_CTAG, 0xff, NPC_ETYPE_IP, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU3_CTAG, 0xff, NPC_ETYPE_IP6, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU3_CTAG, 0xff, NPC_ETYPE_ARP, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU3_CTAG, 0xff, NPC_ETYPE_RARP, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU3_CTAG, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU3_STAG, 0xff, NPC_ETYPE_CTAG, 0xffff, NPC_ETYPE_IP,
+		0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU3_STAG, 0xff, NPC_ETYPE_CTAG, 0xffff, NPC_ETYPE_IP6,
+		0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU3_STAG, 0xff, NPC_ETYPE_CTAG, 0xffff, NPC_ETYPE_ARP,
+		0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU3_STAG, 0xff, NPC_ETYPE_CTAG, 0xffff, NPC_ETYPE_RARP,
+		0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU3_STAG, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU3_QINQ, 0xff, NPC_ETYPE_CTAG, 0xffff, NPC_ETYPE_IP,
+		0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU3_QINQ, 0xff, NPC_ETYPE_CTAG, 0xffff, NPC_ETYPE_IP6,
+		0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU3_QINQ, 0xff, NPC_ETYPE_CTAG, 0xffff, NPC_ETYPE_ARP,
+		0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU3_QINQ, 0xff, NPC_ETYPE_CTAG, 0xffff, NPC_ETYPE_RARP,
+		0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU3_QINQ, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_NA, 0X00, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+};
+
+struct npc_kpu_profile_cam kpu4_cam_entries[] = {
+	{
+		NPC_S_KPU4_MPLS, 0xff, NPC_ETYPE_IP, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+};
+
+struct npc_kpu_profile_cam kpu5_cam_entries[] = {
+	{
+		NPC_S_KPU5_IP, 0xff, NPC_IPNH_TCP, 0x00ff,
+		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
+		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP, 0xff, NPC_IPNH_UDP, 0x00ff,
+		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
+		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP, 0xff, NPC_IPNH_SCTP, 0x00ff,
+		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
+		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP, 0xff, NPC_IPNH_ICMP, 0x00ff,
+		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
+		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP, 0xff, NPC_IPNH_IGMP, 0x00ff,
+		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
+		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP, 0xff, NPC_IPNH_ESP, 0x00ff,
+		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
+		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP, 0xff, NPC_IPNH_AH, 0x00ff,
+		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
+		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP, 0xff, NPC_IPNH_GRE, 0x00ff,
+		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
+		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP, 0xff, NPC_IPNH_IP, 0x00ff,
+		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
+		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP, 0xff, NPC_IPNH_IP6, 0x00ff,
+		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
+		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP, 0xff, 0x0000, 0x0000,
+		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
+		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP, 0xff, NPC_IPNH_TCP, 0x00ff, NPC_IP_VER_4,
+		NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP, 0xff, NPC_IPNH_UDP, 0x00ff, NPC_IP_VER_4,
+		NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP, 0xff, NPC_IPNH_SCTP, 0x00ff, NPC_IP_VER_4,
+		NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP, 0xff, NPC_IPNH_ICMP, 0x00ff, NPC_IP_VER_4,
+		NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP, 0xff, NPC_IPNH_IGMP, 0x00ff, NPC_IP_VER_4,
+		NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP, 0xff, NPC_IPNH_ESP, 0x00ff, NPC_IP_VER_4,
+		NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP, 0xff, NPC_IPNH_AH, 0x00ff, NPC_IP_VER_4,
+		NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP, 0xff, NPC_IPNH_GRE, 0x00ff, NPC_IP_VER_4,
+		NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP, 0xff, NPC_IPNH_IP, 0x00ff, NPC_IP_VER_4,
+		NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP, 0xff, NPC_IPNH_IP6, 0x00ff, NPC_IP_VER_4,
+		NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP, 0xff, 0x0000, 0x0000, NPC_IP_VER_4,
+		NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_ARP, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_RARP, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP6, 0xff, NPC_IPNH_TCP << 8, 0xff00, NPC_IP_VER_6,
+		NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP6, 0xff, NPC_IPNH_UDP << 8, 0xff00, NPC_IP_VER_6,
+		NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP6, 0xff, NPC_IPNH_SCTP << 8, 0xff00, NPC_IP_VER_6,
+		NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP6, 0xff, NPC_IPNH_ICMP << 8, 0xff00, NPC_IP_VER_6,
+		NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP6, 0xff, NPC_IPNH_ICMP6 << 8, 0xff00, NPC_IP_VER_6,
+		NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP6, 0xff, NPC_IPNH_ESP << 8, 0xff00, NPC_IP_VER_6,
+		NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP6, 0xff, NPC_IPNH_AH << 8, 0xff00, NPC_IP_VER_6,
+		NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP6, 0xff, NPC_IPNH_GRE << 8, 0xff00, NPC_IP_VER_6,
+		NPC_IP_VER_MASK, 0x0000, 0x0000
+	},
+	{
+		NPC_S_KPU5_IP6, 0xff, NPC_IPNH_IP6 << 8, 0xff00, NPC_IP_VER_6,
+		NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP6, 0xff, 0x0000, 0x0000, NPC_IP_VER_6,
+		NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU5_IP6, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_NA, 0X00, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+};
+
+struct npc_kpu_profile_cam kpu6_cam_entries[] = {
+	{
+		NPC_S_KPU6_IP6_EXT, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+};
+
+struct npc_kpu_profile_cam kpu7_cam_entries[] = {
+	{
+		NPC_S_KPU7_IP6_EXT, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+};
+
+struct npc_kpu_profile_cam kpu8_cam_entries[] = {
+	{
+		NPC_S_KPU8_TCP, 0xff, NPC_TCP_PORT_HTTP,
+		0xffff, NPC_TCP_DATA_OFFSET_5,
+		NPC_TCP_DATA_OFFSET_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_TCP, 0xff, NPC_TCP_PORT_HTTPS,
+		0xffff, NPC_TCP_DATA_OFFSET_5,
+		NPC_TCP_DATA_OFFSET_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_TCP, 0xff, 0x0000, 0x0000, NPC_TCP_DATA_OFFSET_5,
+		NPC_TCP_DATA_OFFSET_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_TCP, 0xff, NPC_TCP_PORT_HTTP, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_TCP, 0xff, NPC_TCP_PORT_HTTPS, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_TCP, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_VXLAN, 0xffff, NPC_VXLAN_I,
+		NPC_VXLAN_I, 0x0000, 0xffff,
+	},
+	{
+		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_VXLAN, 0xffff, 0x0000,
+		0xffff, 0x0000, 0xffff,
+	},
+	{
+		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_VXLAN, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_GENEVE, 0xffff,
+		0x0000, NPC_GENEVE_F_OAM | NPC_GENEVE_F_CRI_OPT,
+		NPC_ETYPE_TRANS_ETH_BR, 0xffff,
+	},
+	{
+		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_GENEVE, 0xffff,
+		NPC_GENEVE_F_OAM, NPC_GENEVE_F_OAM | NPC_GENEVE_F_CRI_OPT,
+		NPC_ETYPE_TRANS_ETH_BR, 0xffff,
+	},
+	{
+		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_GENEVE, 0xffff,
+		NPC_GENEVE_F_CRI_OPT, NPC_GENEVE_F_OAM | NPC_GENEVE_F_CRI_OPT,
+		NPC_ETYPE_TRANS_ETH_BR, 0xffff,
+	},
+	{
+		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_GENEVE, 0xffff,
+		NPC_GENEVE_F_OAM | NPC_GENEVE_F_CRI_OPT,
+		NPC_GENEVE_F_OAM | NPC_GENEVE_F_CRI_OPT,
+		NPC_ETYPE_TRANS_ETH_BR, 0xffff,
+	},
+	{
+		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_GENEVE, 0xffff,
+		0x0000, NPC_GENEVE_F_OAM | NPC_GENEVE_F_CRI_OPT,
+		NPC_ETYPE_IP, 0xffff,
+	},
+	{
+		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_GENEVE, 0xffff,
+		NPC_GENEVE_F_OAM, NPC_GENEVE_F_OAM | NPC_GENEVE_F_CRI_OPT,
+		NPC_ETYPE_IP, 0xffff,
+	},
+	{
+		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_GENEVE, 0xffff,
+		NPC_GENEVE_F_CRI_OPT, NPC_GENEVE_F_OAM | NPC_GENEVE_F_CRI_OPT,
+		NPC_ETYPE_IP, 0xffff,
+	},
+	{
+		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_GENEVE, 0xffff,
+		NPC_GENEVE_F_OAM | NPC_GENEVE_F_CRI_OPT,
+		NPC_GENEVE_F_OAM | NPC_GENEVE_F_CRI_OPT, NPC_ETYPE_IP, 0xffff,
+	},
+	{
+		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_GENEVE, 0xffff, 0x0000,
+		NPC_GENEVE_F_OAM | NPC_GENEVE_F_CRI_OPT, NPC_ETYPE_IP6, 0xffff,
+	},
+	{
+		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_GENEVE, 0xffff,
+		NPC_GENEVE_F_OAM, NPC_GENEVE_F_OAM | NPC_GENEVE_F_CRI_OPT,
+		NPC_ETYPE_IP6, 0xffff,
+	},
+	{
+		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_GENEVE, 0xffff,
+		NPC_GENEVE_F_CRI_OPT, NPC_GENEVE_F_OAM | NPC_GENEVE_F_CRI_OPT,
+		NPC_ETYPE_IP6, 0xffff,
+	},
+	{
+		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_GENEVE, 0xffff,
+		NPC_GENEVE_F_OAM | NPC_GENEVE_F_CRI_OPT,
+		NPC_GENEVE_F_OAM | NPC_GENEVE_F_CRI_OPT, NPC_ETYPE_IP6, 0xffff,
+	},
+	{
+		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_GTPC, 0xffff,
+		0x0000, 0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_GTPU, 0xffff,
+		NPC_GTP_PT_GTP | NPC_GTP_VER1 | NPC_GTP_MT_G_PDU,
+		NPC_GTP_PT_MASK | NPC_GTP_VER_MASK | NPC_GTP_MT_MASK,
+		0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_UDP, 0xff, NPC_UDP_PORT_GTPU, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_UDP, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_SCTP, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_ICMP, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_IGMP, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_ICMP6, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_ESP, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_AH, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_TRANS_ETH_BR, 0xffff,
+		NPC_GRE_F_KEY, 0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_TRANS_ETH_BR, 0xffff,
+		0x0000, 0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP, 0xffff,
+		0x0000, 0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP, 0xffff,
+		NPC_GRE_F_CSUM, 0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP, 0xffff,
+		NPC_GRE_F_KEY, 0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP, 0xffff,
+		NPC_GRE_F_SEQ, 0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP, 0xffff,
+		NPC_GRE_F_CSUM | NPC_GRE_F_KEY, 0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP, 0xffff,
+		NPC_GRE_F_CSUM | NPC_GRE_F_SEQ, 0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP, 0xffff,
+		NPC_GRE_F_KEY | NPC_GRE_F_SEQ, 0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP, 0xffff,
+		NPC_GRE_F_CSUM | NPC_GRE_F_KEY | NPC_GRE_F_SEQ,
+		0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP6, 0xffff,
+		0x0000, 0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP6, 0xffff,
+		NPC_GRE_F_CSUM, 0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP6, 0xffff,
+		NPC_GRE_F_KEY, 0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP6, 0xffff,
+		NPC_GRE_F_SEQ, 0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP6, 0xffff,
+		NPC_GRE_F_CSUM | NPC_GRE_F_KEY, 0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP6, 0xffff,
+		NPC_GRE_F_CSUM | NPC_GRE_F_SEQ, 0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP6, 0xffff,
+		NPC_GRE_F_KEY | NPC_GRE_F_SEQ, 0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_IP6, 0xffff,
+		NPC_GRE_F_CSUM | NPC_GRE_F_KEY | NPC_GRE_F_SEQ,
+		0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_GRE, 0xff, 0x0000, 0xffff, NPC_GRE_F_ROUTE,
+		0x4fff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_GRE, 0xff, 0x0000, 0xffff, 0x0000,
+		0x4fff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_GRE, 0xff, 0x0000, 0xffff, 0x0000,
+		0x0003, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_PPP, 0xffff,
+		NPC_GRE_F_KEY | NPC_GRE_VER_1, 0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_PPP, 0xffff,
+		NPC_GRE_F_KEY | NPC_GRE_F_SEQ | NPC_GRE_VER_1,
+		0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_PPP, 0xffff,
+		NPC_GRE_F_KEY | NPC_GRE_F_ACK | NPC_GRE_VER_1,
+		0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_GRE, 0xff, NPC_ETYPE_PPP, 0xffff,
+		NPC_GRE_F_KEY | NPC_GRE_F_SEQ | NPC_GRE_F_ACK | NPC_GRE_VER_1,
+		0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_GRE, 0xff, 0x0000, 0xffff, 0x2001,
+		0xef7f, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU8_GRE, 0xff, 0x0000, 0xffff, 0x0001,
+		0x0003, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_NA, 0X00, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+};
+
+struct npc_kpu_profile_cam kpu9_cam_entries[] = {
+	{
+		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_IP,
+		0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_IP6,
+		0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_ARP,
+		0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_CTAG,
+		0xffff, NPC_ETYPE_IP,
+		0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_CTAG,
+		0xffff, NPC_ETYPE_IP6,
+		0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_CTAG,
+		0xffff, NPC_ETYPE_ARP,
+		0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_CTAG,
+		0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_SBTAG,
+		0xffff, NPC_ETYPE_CTAG,
+		0xffff, NPC_ETYPE_IP, 0xffff,
+	},
+	{
+		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_SBTAG,
+		0xffff, NPC_ETYPE_CTAG,
+		0xffff, NPC_ETYPE_IP6, 0xffff,
+	},
+	{
+		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_SBTAG,
+		0xffff, NPC_ETYPE_CTAG,
+		0xffff, NPC_ETYPE_ARP, 0xffff,
+	},
+	{
+		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_SBTAG,
+		0xffff, NPC_ETYPE_CTAG,
+		0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_SBTAG,
+		0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_QINQ,
+		0xffff, NPC_ETYPE_CTAG,
+		0xffff, NPC_ETYPE_IP, 0xffff,
+	},
+	{
+		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_QINQ,
+		0xffff, NPC_ETYPE_CTAG,
+		0xffff, NPC_ETYPE_IP6, 0xffff,
+	},
+	{
+		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_QINQ,
+		0xffff, NPC_ETYPE_CTAG,
+		0xffff, NPC_ETYPE_ARP, 0xffff,
+	},
+	{
+		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_QINQ,
+		0xffff, NPC_ETYPE_CTAG,
+		0xffff, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU9_TU_ETHER, 0xff, NPC_ETYPE_QINQ,
+		0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU9_TU_ETHER, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU9_TU_PPP, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_NA, 0X00, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+};
+
+struct npc_kpu_profile_cam kpu10_cam_entries[] = {
+	{
+		NPC_S_NA, 0X00, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+};
+
+struct npc_kpu_profile_cam kpu11_cam_entries[] = {
+	{
+		NPC_S_KPU11_TU_IP, 0xff, NPC_IPNH_TCP, 0x00ff,
+		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
+		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU11_TU_IP, 0xff, NPC_IPNH_UDP, 0x00ff,
+		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
+		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU11_TU_IP, 0xff, NPC_IPNH_SCTP, 0x00ff,
+		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
+		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU11_TU_IP, 0xff, NPC_IPNH_ICMP, 0x00ff,
+		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
+		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU11_TU_IP, 0xff, NPC_IPNH_IGMP, 0x00ff,
+		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
+		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU11_TU_IP, 0xff, NPC_IPNH_ESP, 0x00ff,
+		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
+		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU11_TU_IP, 0xff, NPC_IPNH_AH, 0x00ff,
+		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
+		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU11_TU_IP, 0xff, 0x0000, 0x0000,
+		NPC_IP_VER_4 | NPC_IP_HDR_LEN_5,
+		NPC_IP_VER_MASK | NPC_IP_HDR_LEN_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU11_TU_IP, 0xff, NPC_IPNH_TCP, 0x00ff, NPC_IP_VER_4,
+		NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU11_TU_IP, 0xff, NPC_IPNH_UDP, 0x00ff, NPC_IP_VER_4,
+		NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU11_TU_IP, 0xff, NPC_IPNH_SCTP, 0x00ff, NPC_IP_VER_4,
+		NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU11_TU_IP, 0xff, NPC_IPNH_ICMP, 0x00ff, NPC_IP_VER_4,
+		NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU11_TU_IP, 0xff, NPC_IPNH_IGMP, 0x00ff, NPC_IP_VER_4,
+		NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU11_TU_IP, 0xff, NPC_IPNH_ESP, 0x00ff, NPC_IP_VER_4,
+		NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU11_TU_IP, 0xff, NPC_IPNH_AH, 0x00ff, NPC_IP_VER_4,
+		NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU11_TU_IP, 0xff, 0x0000, 0x0000, NPC_IP_VER_4,
+		NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU11_TU_IP, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU11_TU_ARP, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU11_TU_IP6, 0xff, NPC_IPNH_TCP << 8, 0xff00,
+		NPC_IP_VER_6, NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU11_TU_IP6, 0xff, NPC_IPNH_UDP << 8, 0xff00,
+		NPC_IP_VER_6, NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU11_TU_IP6, 0xff, NPC_IPNH_SCTP << 8, 0xff00,
+		NPC_IP_VER_6, NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU11_TU_IP6, 0xff, NPC_IPNH_ICMP << 8, 0xff00,
+		NPC_IP_VER_6, NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU11_TU_IP6, 0xff, NPC_IPNH_ICMP6 << 8, 0xff00,
+		NPC_IP_VER_6, NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU11_TU_IP6, 0xff, NPC_IPNH_ESP << 8, 0xff00,
+		NPC_IP_VER_6, NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU11_TU_IP6, 0xff, NPC_IPNH_AH << 8, 0xff00,
+		NPC_IP_VER_6, NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU11_TU_IP6, 0xff, 0x0000, 0x0000,
+		NPC_IP_VER_6, NPC_IP_VER_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU11_TU_IP6, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_NA, 0X00, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+};
+
+struct npc_kpu_profile_cam kpu12_cam_entries[] = {
+	{
+		NPC_S_KPU12_TU_IP6_EXT, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+};
+
+struct npc_kpu_profile_cam kpu13_cam_entries[] = {
+	{
+		NPC_S_KPU13_TU_IP6_EXT, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+};
+
+struct npc_kpu_profile_cam kpu14_cam_entries[] = {
+	{
+		NPC_S_KPU14_TU_TCP, 0xff, NPC_TCP_PORT_HTTP, 0xffff,
+		NPC_TCP_DATA_OFFSET_5, NPC_TCP_DATA_OFFSET_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU14_TU_TCP, 0xff, NPC_TCP_PORT_HTTPS, 0xffff,
+		NPC_TCP_DATA_OFFSET_5, NPC_TCP_DATA_OFFSET_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU14_TU_TCP, 0xff, 0x0000, 0x0000,
+		NPC_TCP_DATA_OFFSET_5, NPC_TCP_DATA_OFFSET_MASK, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU14_TU_TCP, 0xff, NPC_TCP_PORT_HTTP, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU14_TU_TCP, 0xff, NPC_TCP_PORT_HTTPS, 0xffff, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU14_TU_TCP, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU14_TU_UDP, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU14_TU_SCTP, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU14_TU_ICMP, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU14_TU_IGMP, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU14_TU_ICMP6, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU14_TU_ESP, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU14_TU_AH, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_NA, 0X00, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+};
+
+struct npc_kpu_profile_cam kpu15_cam_entries[] = {
+	{
+		NPC_S_KPU15_TCP_DATA, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU15_HTTP_DATA, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU15_HTTPS_DATA, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+	{
+		NPC_S_KPU15_UDP_DATA, 0xff, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000,
+	},
+};
+
+struct npc_kpu_profile_action kpu1_action_entries[] = {
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		3, 0, NPC_S_KPU5_IP, 14, 1,
+		NPC_LID_LA, NPC_LT_LA_ETHER, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
+		3, 0, NPC_S_KPU5_IP6, 14, 1,
+		NPC_LID_LA, NPC_LT_LA_ETHER, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		3, 0, NPC_S_KPU5_ARP, 14, 1,
+		NPC_LID_LA, NPC_LT_LA_ETHER, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		3, 0, NPC_S_KPU5_RARP, 14, 1,
+		NPC_LID_LA, NPC_LT_LA_ETHER, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 6, 0,
+		0, 0, NPC_S_KPU2_CTAG, 14, 1,
+		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_ETHER_HAS_VLAN, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 6, 20,
+		0, 0, NPC_S_KPU2_SBTAG, 14, 1,
+		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_ETHER_HAS_VLAN, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 6, 0,
+		0, 0, NPC_S_KPU2_QINQ, 14, 1,
+		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_ETHER_HAS_VLAN, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
+		0, 0, NPC_S_KPU2_ETAG, 14, 1,
+		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_ETHER_HAS_ETAG, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 0, 0,
+		0, 0, NPC_S_KPU4_MPLS, 14, 1,
+		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_ETHER_HAS_MPLS, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 0, 0,
+		0, 0, NPC_S_KPU4_MPLS, 14, 1,
+		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_ETHER_HAS_MPLS, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LA, NPC_LT_LA_8023, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LA, NPC_LT_LA_8023, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_ETYPE_UNK, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		3, 0, NPC_S_KPU5_IP, 14, 1,
+		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_HAS_PKI, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
+		3, 0, NPC_S_KPU5_IP6, 14, 1,
+		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_HAS_PKI, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		3, 0, NPC_S_KPU5_ARP, 14, 1,
+		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_HAS_PKI, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		3, 0, NPC_S_KPU5_RARP, 14, 1,
+		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_HAS_PKI, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 6, 0,
+		0, 0, NPC_S_KPU2_CTAG, 14, 1,
+		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_HAS_PKI_HAS_VLAN, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 6, 20,
+		0, 0, NPC_S_KPU2_SBTAG, 14, 1,
+		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_HAS_PKI_HAS_VLAN, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 6, 0,
+		0, 0, NPC_S_KPU2_QINQ, 14, 1,
+		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_HAS_PKI_HAS_VLAN, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
+		0, 0, NPC_S_KPU2_ETAG, 14, 1,
+		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_HAS_PKI_HAS_ETAG, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 0, 0,
+		0, 0, NPC_S_KPU4_MPLS, 14, 1,
+		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_HAS_PKI_HAS_MPLS, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 0, 0,
+		0, 0, NPC_S_KPU4_MPLS, 14, 1,
+		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_HAS_PKI_HAS_MPLS, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LA, NPC_LT_LA_ETHER, NPC_F_ETYPE_UNK, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_LA, NPC_EC_L2_K1, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+};
+
+struct npc_kpu_profile_action kpu2_action_entries[] = {
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		2, 0, NPC_S_KPU5_IP, 4, 1,
+		NPC_LID_LB, NPC_LT_LB_CTAG, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
+		2, 0, NPC_S_KPU5_IP6, 4, 1,
+		NPC_LID_LB, NPC_LT_LB_CTAG, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU5_ARP, 4, 1,
+		NPC_LID_LB, NPC_LT_LB_CTAG, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU5_RARP, 4, 1,
+		NPC_LID_LB, NPC_LT_LB_CTAG, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 0, NPC_S_KPU4_MPLS, 4, 1,
+		NPC_LID_LB, NPC_LT_LB_VLAN_MPLS, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 0, NPC_S_KPU4_MPLS, 4, 1,
+		NPC_LID_LB, NPC_LT_LB_VLAN_MPLS, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LB, NPC_LT_LB_CTAG, NPC_F_ETYPE_UNK, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		2, 0, NPC_S_KPU5_IP, 8, 1,
+		NPC_LID_LB, NPC_LT_LB_STAG, NPC_F_VLAN_2_TAGS, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
+		2, 0, NPC_S_KPU5_IP6, 8, 1,
+		NPC_LID_LB, NPC_LT_LB_STAG, NPC_F_VLAN_2_TAGS, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU5_ARP, 8, 1,
+		NPC_LID_LB, NPC_LT_LB_STAG, NPC_F_VLAN_2_TAGS, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU5_RARP, 8, 1,
+		NPC_LID_LB, NPC_LT_LB_STAG, NPC_F_VLAN_2_TAGS, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 0, NPC_S_KPU4_MPLS, 4, 1,
+		NPC_LID_LB, NPC_LT_LB_VLAN_MPLS, NPC_F_VLAN_2_TAGS, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 0, NPC_S_KPU4_MPLS, 4, 1,
+		NPC_LID_LB, NPC_LT_LB_VLAN_MPLS, NPC_F_VLAN_2_TAGS, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LB, NPC_LT_LB_STAG, NPC_F_VLAN_2_TAGS_ETYPE_UNK, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 6, 0,
+		0, 0, NPC_S_KPU3_CTAG, 8, 1,
+		NPC_LID_LB, NPC_LT_LB_STAG, NPC_F_VLAN_3_TAGS, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 6, 0,
+		0, 0, NPC_S_KPU3_STAG, 8, 1,
+		NPC_LID_LB, NPC_LT_LB_STAG, NPC_F_VLAN_4_TAGS, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		2, 0, NPC_S_KPU5_IP, 22, 1,
+		NPC_LID_LB, NPC_LT_LB_BTAG, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
+		2, 0, NPC_S_KPU5_IP6, 22, 1,
+		NPC_LID_LB, NPC_LT_LB_BTAG, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU5_ARP, 22, 1,
+		NPC_LID_LB, NPC_LT_LB_BTAG, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU5_RARP, 22, 1,
+		NPC_LID_LB, NPC_LT_LB_BTAG, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 0, 0,
+		0, 0, NPC_S_KPU3_CTAG, 22, 1,
+		NPC_LID_LB, NPC_LT_LB_BTAG, NPC_F_BTAG_HAS_CTAG, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LB, NPC_LT_LB_BTAG, NPC_F_ETYPE_UNK, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LB, NPC_LT_LB_BTAG, NPC_F_ETYPE_UNK, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		2, 0, NPC_S_KPU5_IP, 8, 1,
+		NPC_LID_LB, NPC_LT_LB_QINQ, NPC_F_VLAN_2_TAGS, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
+		2, 0, NPC_S_KPU5_IP6, 8, 1,
+		NPC_LID_LB, NPC_LT_LB_QINQ, NPC_F_VLAN_2_TAGS, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU5_ARP, 8, 1,
+		NPC_LID_LB, NPC_LT_LB_QINQ, NPC_F_VLAN_2_TAGS, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU5_RARP, 8, 1,
+		NPC_LID_LB, NPC_LT_LB_QINQ, NPC_F_VLAN_2_TAGS, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 0, NPC_S_KPU4_MPLS, 4, 1,
+		NPC_LID_LB, NPC_LT_LB_VLAN_MPLS, NPC_F_VLAN_2_TAGS, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 0, NPC_S_KPU4_MPLS, 4, 1,
+		NPC_LID_LB, NPC_LT_LB_VLAN_MPLS, NPC_F_VLAN_2_TAGS, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LB, NPC_LT_LB_QINQ, NPC_F_VLAN_2_TAGS_ETYPE_UNK, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 6, 0,
+		0, 0, NPC_S_KPU3_CTAG, 8, 1,
+		NPC_LID_LB, NPC_LT_LB_STAG, NPC_F_VLAN_3_TAGS, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 6, 0,
+		0, 0, NPC_S_KPU3_QINQ, 8, 1,
+		NPC_LID_LB, NPC_LT_LB_STAG, NPC_F_VLAN_4_TAGS, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		2, 0, NPC_S_KPU5_IP, 8, 1,
+		NPC_LID_LB, NPC_LT_LB_ETAG, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
+		2, 0, NPC_S_KPU5_IP6, 8, 1,
+		NPC_LID_LB, NPC_LT_LB_ETAG, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU5_ARP, 8, 1,
+		NPC_LID_LB, NPC_LT_LB_ETAG, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU5_RARP, 8, 1,
+		NPC_LID_LB, NPC_LT_LB_ETAG, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 6, 0,
+		0, 0, NPC_S_KPU3_CTAG, 8, 1,
+		NPC_LID_LB, NPC_LT_LB_ETAG_CTAG, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 6, 0,
+		0, 0, NPC_S_KPU3_STAG, 8, 1,
+		NPC_LID_LB, NPC_LT_LB_ETAG_STAG, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 6, 0,
+		0, 0, NPC_S_KPU3_QINQ, 8, 1,
+		NPC_LID_LB, NPC_LT_LB_ETAG_QINQ, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LB, NPC_LT_LB_ETAG, NPC_F_ETYPE_UNK, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_LB, NPC_EC_L2_K2, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 0,
+		NPC_LID_LA, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+};
+
+struct npc_kpu_profile_action kpu3_action_entries[] = {
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		1, 0, NPC_S_KPU5_IP, 4, 0,
+		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
+		1, 0, NPC_S_KPU5_IP6, 4, 0,
+		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		1, 0, NPC_S_KPU5_ARP, 4, 0,
+		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		1, 0, NPC_S_KPU5_RARP, 4, 0,
+		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_LB, NPC_EC_L2_K3_ETYPE_UNK, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 0,
+		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		1, 0, NPC_S_KPU5_IP, 8, 0,
+		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
+		1, 0, NPC_S_KPU5_IP6, 8, 0,
+		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		1, 0, NPC_S_KPU5_ARP, 8, 0,
+		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		1, 0, NPC_S_KPU5_RARP, 8, 0,
+		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_LB, NPC_EC_L2_K3_ETYPE_UNK, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 0,
+		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		1, 0, NPC_S_KPU5_IP, 8, 0,
+		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
+		1, 0, NPC_S_KPU5_IP6, 8, 0,
+		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		1, 0, NPC_S_KPU5_ARP, 8, 0,
+		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		1, 0, NPC_S_KPU5_RARP, 8, 0,
+		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_LB, NPC_EC_L2_K3_ETYPE_UNK, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 0,
+		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_LB, NPC_EC_L2_K3, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 0,
+		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+};
+
+struct npc_kpu_profile_action kpu4_action_entries[] = {
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		0, 0, NPC_S_KPU5_IP, 4, 0,
+		NPC_LID_LB, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+};
+
+struct npc_kpu_profile_action kpu5_action_entries[] = {
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 12, 0,
+		2, 0, NPC_S_KPU8_TCP, 20, 1,
+		NPC_LID_LC, NPC_LT_LC_IP, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 8, 10,
+		2, 0, NPC_S_KPU8_UDP, 20, 1,
+		NPC_LID_LC, NPC_LT_LC_IP, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU8_SCTP, 20, 1,
+		NPC_LID_LC, NPC_LT_LC_IP, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU8_ICMP, 20, 1,
+		NPC_LID_LC, NPC_LT_LC_IP, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU8_IGMP, 20, 1,
+		NPC_LID_LC, NPC_LT_LC_IP, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 0, NPC_S_KPU8_ESP, 20, 1,
+		NPC_LID_LC, NPC_LT_LC_IP, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 0, NPC_S_KPU8_AH, 20, 1,
+		NPC_LID_LC, NPC_LT_LC_IP, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 0, 0,
+		2, 0, NPC_S_KPU8_GRE, 20, 1,
+		NPC_LID_LC, NPC_LT_LC_IP, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		5, 0, NPC_S_KPU11_TU_IP, 20, 1,
+		NPC_LID_LC, NPC_LT_LC_IP, NPC_F_IP_IN_IP, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
+		5, 0, NPC_S_KPU11_TU_IP6, 20, 1,
+		NPC_LID_LC, NPC_LT_LC_IP, NPC_F_IP_6TO4, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LC, NPC_LT_LC_IP, NPC_F_IP_UNK_PROTO, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 12, 0,
+		2, 0, NPC_S_KPU8_TCP, 0, 1,
+		NPC_LID_LC, NPC_LT_LC_IP, NPC_F_IP_HAS_OPTIONS, 0, 0xf,
+		0, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 8, 10,
+		2, 0, NPC_S_KPU8_UDP, 0, 1,
+		NPC_LID_LC, NPC_LT_LC_IP, NPC_F_IP_HAS_OPTIONS, 0, 0xf,
+		0, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU8_SCTP, 0, 1,
+		NPC_LID_LC, NPC_LT_LC_IP, NPC_F_IP_HAS_OPTIONS, 0, 0xf,
+		0, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU8_ICMP, 0, 1,
+		NPC_LID_LC, NPC_LT_LC_IP, NPC_F_IP_HAS_OPTIONS, 0, 0xf,
+		0, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU8_IGMP, 0, 1,
+		NPC_LID_LC, NPC_LT_LC_IP, NPC_F_IP_HAS_OPTIONS, 0, 0xf,
+		0, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 0, NPC_S_KPU8_ESP, 0, 1,
+		NPC_LID_LC, NPC_LT_LC_IP, NPC_F_IP_HAS_OPTIONS, 0, 0xf,
+		0, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 0, NPC_S_KPU8_AH, 0, 1,
+		NPC_LID_LC, NPC_LT_LC_IP, NPC_F_IP_HAS_OPTIONS, 0, 0xf,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 0, 0,
+		2, 0, NPC_S_KPU8_GRE, 0, 1,
+		NPC_LID_LC, NPC_LT_LC_IP, NPC_F_IP_HAS_OPTIONS, 0, 0xf,
+		0, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		5, 0, NPC_S_KPU11_TU_IP, 0, 1,
+		NPC_LID_LC, NPC_LT_LC_IP, NPC_F_IP_IN_IP_HAS_OPTIONS, 0, 0xf,
+		0, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
+		5, 0, NPC_S_KPU11_TU_IP6, 0, 1,
+		NPC_LID_LC, NPC_LT_LC_IP, NPC_F_IP_6TO4_HAS_OPTIONS, 0, 0xf,
+		0, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LC, NPC_LT_LC_IP, NPC_F_IP_UNK_PROTO_HAS_OPTIONS, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_LC, NPC_EC_IP_VER, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LC, NPC_LT_LC_IP, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LC, NPC_LT_LC_ARP, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LC, NPC_LT_LC_RARP, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 12, 0,
+		2, 0, NPC_S_KPU8_TCP, 40, 1,
+		NPC_LID_LC, NPC_LT_LC_IP6, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 8, 10,
+		2, 0, NPC_S_KPU8_UDP, 40, 1,
+		NPC_LID_LC, NPC_LT_LC_IP6, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU8_SCTP, 40, 1,
+		NPC_LID_LC, NPC_LT_LC_IP6, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU8_ICMP, 40, 1,
+		NPC_LID_LC, NPC_LT_LC_IP6, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU8_ICMP6, 40, 1,
+		NPC_LID_LC, NPC_LT_LC_IP6, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU8_ESP, 40, 1,
+		NPC_LID_LC, NPC_LT_LC_IP6, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU8_AH, 40, 1,
+		NPC_LID_LC, NPC_LT_LC_IP6, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU8_GRE, 40, 1,
+		NPC_LID_LC, NPC_LT_LC_IP6, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
+		5, 0, NPC_S_KPU11_TU_IP6, 40, 1,
+		NPC_LID_LC, NPC_LT_LC_IP6, NPC_F_IP6_TUN_IP6, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 0, 0,
+		0, 0, NPC_S_KPU6_IP6_EXT, 0, 1,
+		NPC_LID_LC, NPC_LT_LC_IP6, NPC_F_IP6_HAS_EXT, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_LC, NPC_EC_IP6_VER, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LC, NPC_LT_LC_IP6, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_LC, NPC_EC_UNK, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 0,
+		NPC_LID_LC, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+};
+
+struct npc_kpu_profile_action kpu6_action_entries[] = {
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 0,
+		NPC_LID_LC, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+};
+
+struct npc_kpu_profile_action kpu7_action_entries[] = {
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 0,
+		NPC_LID_LC, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+};
+
+struct npc_kpu_profile_action kpu8_action_entries[] = {
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		6, 0, NPC_S_KPU15_HTTP_DATA, 20, 1,
+		NPC_LID_LD, NPC_LT_LD_TCP, NPC_F_TCP_HTTP, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		6, 0, NPC_S_KPU15_HTTPS_DATA, 20, 1,
+		NPC_LID_LD, NPC_LT_LD_TCP, NPC_F_TCP_HTTPS, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		6, 0, NPC_S_KPU15_TCP_DATA, 20, 1,
+		NPC_LID_LD, NPC_LT_LD_TCP, NPC_F_TCP_UNK_PORT, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		6, 0, NPC_S_KPU15_HTTP_DATA, 0, 1,
+		NPC_LID_LD, NPC_LT_LD_TCP, NPC_F_TCP_HTTP_HAS_OPTIONS,
+		12, 0xf0, 1, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		6, 0, NPC_S_KPU15_HTTPS_DATA, 0, 1,
+		NPC_LID_LD, NPC_LT_LD_TCP, NPC_F_TCP_HTTPS_HAS_OPTIONS,
+		12, 0xf0, 1, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		6, 0, NPC_S_KPU15_TCP_DATA, 0, 1,
+		NPC_LID_LD, NPC_LT_LD_TCP, NPC_F_TCP_UNK_PORT_HAS_OPTIONS,
+		12, 0xf0, 1, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 16, 20,
+		0, 0, NPC_S_KPU9_TU_ETHER, 16, 1,
+		NPC_LID_LD, NPC_LT_LD_UDP_VXLAN, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 16, 20,
+		0, 0, NPC_S_KPU9_TU_ETHER, 16, 1,
+		NPC_LID_LD, NPC_LT_LD_UDP_VXLAN, NPC_F_UDP_VXLAN_NOVNI,
+		0, 0, 0, 0,
+	},
+	{
+		NPC_ERRLEV_LD, NPC_EC_VXLAN, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 0,
+		NPC_LID_LD, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 16, 20,
+		0, 0, NPC_S_KPU9_TU_ETHER, 16, 1,
+		NPC_LID_LD, NPC_LT_LD_UDP_GENEVE, 0, 8, 0x3f,
+		0, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 16, 20,
+		0, 0, NPC_S_KPU9_TU_ETHER, 16, 1,
+		NPC_LID_LD, NPC_LT_LD_UDP_GENEVE, NPC_F_UDP_GENEVE_OAM,
+		8, 0x3f, 0, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 16, 20,
+		0, 0, NPC_S_KPU9_TU_ETHER, 16, 1,
+		NPC_LID_LD, NPC_LT_LD_UDP_GENEVE, NPC_F_UDP_GENEVE_CRI_OPT,
+		8, 0x3f, 0, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 16, 20,
+		0, 0, NPC_S_KPU9_TU_ETHER, 16, 1,
+		NPC_LID_LD, NPC_LT_LD_UDP_GENEVE, NPC_F_UDP_GENEVE_OAM_CRI_OPT,
+		8, 0x3f, 0, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		2, 0, NPC_S_KPU11_TU_IP, 16, 1,
+		NPC_LID_LD, NPC_LT_LD_UDP_GENEVE, 0, 8, 0x3f,
+		0, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		2, 0, NPC_S_KPU11_TU_IP, 16, 1,
+		NPC_LID_LD, NPC_LT_LD_UDP_GENEVE, NPC_F_UDP_GENEVE_OAM,
+		8, 0x3f, 0, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		2, 0, NPC_S_KPU11_TU_IP, 16, 1,
+		NPC_LID_LD, NPC_LT_LD_UDP_GENEVE, NPC_F_UDP_GENEVE_CRI_OPT,
+		8, 0x3f, 0, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		2, 0, NPC_S_KPU11_TU_IP, 16, 1,
+		NPC_LID_LD, NPC_LT_LD_UDP_GENEVE, NPC_F_UDP_GENEVE_OAM_CRI_OPT,
+		8, 0x3f, 0, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		2, 0, NPC_S_KPU11_TU_IP6, 16, 1,
+		NPC_LID_LD, NPC_LT_LD_UDP_GENEVE, 0, 8, 0x3f,
+		0, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		2, 0, NPC_S_KPU11_TU_IP6, 16, 1,
+		NPC_LID_LD, NPC_LT_LD_UDP_GENEVE, NPC_F_UDP_GENEVE_OAM,
+		8, 0x3f, 0, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		2, 0, NPC_S_KPU11_TU_IP6, 16, 1,
+		NPC_LID_LD, NPC_LT_LD_UDP_GENEVE, NPC_F_UDP_GENEVE_CRI_OPT,
+		8, 0x3f, 0, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		2, 0, NPC_S_KPU11_TU_IP6, 16, 1,
+		NPC_LID_LD, NPC_LT_LD_UDP_GENEVE, NPC_F_UDP_GENEVE_OAM_CRI_OPT,
+		8, 0x3f, 0, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LD, NPC_LT_LD_UDP_GTPC, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		2, 0, NPC_S_KPU11_TU_IP, 16, 1,
+		NPC_LID_LD, NPC_LT_LD_UDP_GTPU, NPC_F_UDP_GTPU_G_PDU, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LD, NPC_LT_LD_UDP_GTPU, NPC_F_UDP_GTPU_UNK, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		6, 0, NPC_S_KPU15_UDP_DATA, 8, 1,
+		NPC_LID_LD, NPC_LT_LD_UDP, NPC_F_UDP_UNK_PORT, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LD, NPC_LT_LD_SCTP, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LD, NPC_LT_LD_ICMP, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LD, NPC_LT_LD_IGMP, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LD, NPC_LT_LD_ICMP6, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LD, NPC_LT_LD_ESP, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LD, NPC_LT_LD_AH, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 12, 16, 20,
+		0, 0, NPC_S_KPU9_TU_ETHER, 8, 1,
+		NPC_LID_LD, NPC_LT_LD_NVGRE, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_LD, NPC_EC_NVGRE, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 0,
+		NPC_LID_LD, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		2, 0, NPC_S_KPU11_TU_IP, 4, 1,
+		NPC_LID_LD, NPC_LT_LD_GRE, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		2, 0, NPC_S_KPU11_TU_IP, 8, 1,
+		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_HAS_CSUM, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		2, 0, NPC_S_KPU11_TU_IP, 8, 1,
+		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_HAS_KEY, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		2, 0, NPC_S_KPU11_TU_IP, 8, 1,
+		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_HAS_SEQ, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		2, 0, NPC_S_KPU11_TU_IP, 12, 1,
+		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_HAS_CSUM_KEY, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		2, 0, NPC_S_KPU11_TU_IP, 12, 1,
+		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_HAS_CSUM_SEQ, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		2, 0, NPC_S_KPU11_TU_IP, 12, 1,
+		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_HAS_KEY_SEQ, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		2, 0, NPC_S_KPU11_TU_IP, 16, 1,
+		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_HAS_CSUM_KEY_SEQ, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
+		2, 0, NPC_S_KPU11_TU_IP6, 4, 1,
+		NPC_LID_LD, NPC_LT_LD_GRE, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
+		2, 0, NPC_S_KPU11_TU_IP6, 8, 1,
+		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_HAS_CSUM, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
+		2, 0, NPC_S_KPU11_TU_IP6, 8, 1,
+		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_HAS_KEY, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
+		2, 0, NPC_S_KPU11_TU_IP6, 8, 1,
+		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_HAS_SEQ, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
+		2, 0, NPC_S_KPU11_TU_IP6, 12, 1,
+		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_HAS_CSUM_KEY, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
+		2, 0, NPC_S_KPU11_TU_IP6, 12, 1,
+		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_HAS_CSUM_SEQ, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
+		2, 0, NPC_S_KPU11_TU_IP6, 12, 1,
+		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_HAS_KEY_SEQ, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
+		2, 0, NPC_S_KPU11_TU_IP6, 16, 1,
+		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_HAS_CSUM_KEY_SEQ, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_HAS_ROUTE, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_UNK_PROTO, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_LD, NPC_EC_GRE, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 0,
+		NPC_LID_LD, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 0, NPC_S_KPU9_TU_PPP, 8, 1,
+		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_VER1, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 0, NPC_S_KPU9_TU_PPP, 12, 1,
+		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_VER1_HAS_SEQ, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 0, NPC_S_KPU9_TU_PPP, 12, 1,
+		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_VER1_HAS_ACK, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 0, NPC_S_KPU9_TU_PPP, 16, 1,
+		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_VER1_HAS_SEQ_ACK, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LD, NPC_LT_LD_GRE, NPC_F_GRE_VER1_UNK_PROTO, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_LD, NPC_EC_GRE_VER1, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 0,
+		NPC_LID_LD, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_LD, NPC_EC_UNK, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 0,
+		NPC_LID_LD, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+};
+
+struct npc_kpu_profile_action kpu9_action_entries[] = {
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		1, 0, NPC_S_KPU11_TU_IP, 14, 1,
+		NPC_LID_LE, NPC_LT_LE_TU_ETHER, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
+		1, 0, NPC_S_KPU11_TU_IP6, 14, 1,
+		NPC_LID_LE, NPC_LT_LE_TU_ETHER, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		1, 0, NPC_S_KPU11_TU_ARP, 14, 1,
+		NPC_LID_LE, NPC_LT_LE_TU_ETHER, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		1, 0, NPC_S_KPU11_TU_IP, 18, 1,
+		NPC_LID_LE, NPC_LT_LE_TU_ETHER, NPC_F_TU_ETHER_HAS_CTAG,
+		0, 0, 0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
+		1, 0, NPC_S_KPU11_TU_IP6, 18, 1,
+		NPC_LID_LE, NPC_LT_LE_TU_ETHER, NPC_F_TU_ETHER_HAS_CTAG,
+		0, 0, 0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		1, 0, NPC_S_KPU11_TU_ARP, 18, 1,
+		NPC_LID_LE, NPC_LT_LE_TU_ETHER, NPC_F_TU_ETHER_HAS_CTAG,
+		0, 0, 0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LE, NPC_LT_LE_TU_ETHER,
+		NPC_F_TU_ETHER_HAS_CTAG_ETYPE_UNK, 0, 0, 0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		1, 0, NPC_S_KPU11_TU_IP, 22, 1,
+		NPC_LID_LE, NPC_LT_LE_TU_ETHER, NPC_F_TU_ETHER_HAS_STAG_CTAG,
+		0, 0, 0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
+		1, 0, NPC_S_KPU11_TU_IP6, 22, 1,
+		NPC_LID_LE, NPC_LT_LE_TU_ETHER, NPC_F_TU_ETHER_HAS_STAG_CTAG,
+		0, 0, 0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		1, 0, NPC_S_KPU11_TU_ARP, 22, 1,
+		NPC_LID_LE, NPC_LT_LE_TU_ETHER, NPC_F_TU_ETHER_HAS_STAG_CTAG,
+		0, 0, 0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LE, NPC_LT_LE_TU_ETHER,
+		NPC_F_TU_ETHER_HAS_STAG_CTAG_ETYPE_UNK, 0, 0, 0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LE, NPC_LT_LE_TU_ETHER,
+		NPC_F_TU_ETHER_HAS_STAG_ETYPE_UNK, 0, 0, 0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 8, 0, 0,
+		1, 0, NPC_S_KPU11_TU_IP, 22, 1,
+		NPC_LID_LE, NPC_LT_LE_TU_ETHER,
+		NPC_F_TU_ETHER_HAS_QINQ_CTAG, 0, 0, 0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 6, 0, 0,
+		1, 0, NPC_S_KPU11_TU_IP6, 22, 1,
+		NPC_LID_LE, NPC_LT_LE_TU_ETHER,
+		NPC_F_TU_ETHER_HAS_QINQ_CTAG, 0, 0, 0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		1, 0, NPC_S_KPU11_TU_ARP, 22, 1,
+		NPC_LID_LE, NPC_LT_LE_TU_ETHER,
+		NPC_F_TU_ETHER_HAS_QINQ_CTAG, 0, 0, 0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LE, NPC_LT_LE_TU_ETHER,
+		NPC_F_TU_ETHER_HAS_QINQ_CTAG_ETYPE_UNK, 0, 0, 0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LE, NPC_LT_LE_TU_ETHER,
+		NPC_F_TU_ETHER_HAS_QINQ_ETYPE_UNK, 0, 0, 0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LE, NPC_LT_LE_TU_ETHER,
+		NPC_F_TU_ETHER_ETYPE_UNK, 0, 0, 0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LE, NPC_LT_LE_TU_PPP, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_LE, NPC_EC_UNK, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 0,
+		NPC_LID_LE, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+};
+
+struct npc_kpu_profile_action kpu10_action_entries[] = {
+	{
+		NPC_ERRLEV_LE, NPC_EC_UNK, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 0,
+		NPC_LID_LE, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+};
+
+struct npc_kpu_profile_action kpu11_action_entries[] = {
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 12, 0,
+		2, 0, NPC_S_KPU14_TU_TCP, 20, 1,
+		NPC_LID_LF, NPC_LT_LF_TU_IP, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 0, 0,
+		2, 0, NPC_S_KPU14_TU_UDP, 20, 1,
+		NPC_LID_LF, NPC_LT_LF_TU_IP, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU14_TU_SCTP, 20, 1,
+		NPC_LID_LF, NPC_LT_LF_TU_IP, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU14_TU_ICMP, 20, 1,
+		NPC_LID_LF, NPC_LT_LF_TU_IP, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU14_TU_IGMP, 20, 1,
+		NPC_LID_LF, NPC_LT_LF_TU_IP, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU14_TU_ESP, 20, 1,
+		NPC_LID_LF, NPC_LT_LF_TU_IP, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU14_TU_AH, 20, 1,
+		NPC_LID_LF, NPC_LT_LF_TU_IP, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LF, NPC_LT_LF_TU_IP, NPC_F_IP_UNK_PROTO, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 12, 0,
+		2, 0, NPC_S_KPU14_TU_TCP, 0, 1,
+		NPC_LID_LF, NPC_LT_LF_TU_IP, NPC_F_IP_HAS_OPTIONS, 0, 0xf,
+		0, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 0, 0,
+		2, 0, NPC_S_KPU14_TU_UDP, 0, 1,
+		NPC_LID_LF, NPC_LT_LF_TU_IP, NPC_F_IP_HAS_OPTIONS, 0, 0xf,
+		0, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU14_TU_SCTP, 0, 1,
+		NPC_LID_LF, NPC_LT_LF_TU_IP, NPC_F_IP_HAS_OPTIONS, 0, 0xf,
+		0, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU14_TU_ICMP, 0, 1,
+		NPC_LID_LF, NPC_LT_LF_TU_IP, NPC_F_IP_HAS_OPTIONS, 0, 0xf,
+		0, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU14_TU_IGMP, 0, 1,
+		NPC_LID_LF, NPC_LT_LF_TU_IP, NPC_F_IP_HAS_OPTIONS, 0, 0xf,
+		0, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU14_TU_ESP, 0, 1,
+		NPC_LID_LF, NPC_LT_LF_TU_IP, NPC_F_IP_HAS_OPTIONS, 0, 0xf,
+		0, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU14_TU_AH, 0, 1,
+		NPC_LID_LF, NPC_LT_LF_TU_IP, NPC_F_IP_HAS_OPTIONS, 0, 0xf,
+		0, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LF, NPC_LT_LF_TU_IP, NPC_F_IP_UNK_PROTO_HAS_OPTIONS,
+		0, 0, 0, 0,
+	},
+	{
+		NPC_ERRLEV_LF, NPC_EC_IP_VER, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LF, NPC_LT_LF_TU_IP, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LF, NPC_LT_LF_TU_ARP, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 12, 0,
+		2, 0, NPC_S_KPU14_TU_TCP, 40, 1,
+		NPC_LID_LF, NPC_LT_LF_TU_IP6, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 0, 0,
+		2, 0, NPC_S_KPU14_TU_UDP, 40, 1,
+		NPC_LID_LF, NPC_LT_LF_TU_IP6, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU14_TU_SCTP, 40, 1,
+		NPC_LID_LF, NPC_LT_LF_TU_IP6, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU14_TU_ICMP, 40, 1,
+		NPC_LID_LF, NPC_LT_LF_TU_IP6, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU14_TU_ICMP6, 40, 1,
+		NPC_LID_LF, NPC_LT_LF_TU_IP6, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU14_TU_ESP, 40, 1,
+		NPC_LID_LC, NPC_LT_LF_TU_IP6, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		2, 0, NPC_S_KPU14_TU_AH, 40, 1,
+		NPC_LID_LC, NPC_LT_LF_TU_IP6, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 2, 0, 0,
+		0, 0, NPC_S_KPU12_TU_IP6_EXT, 0, 1,
+		NPC_LID_LF, NPC_LT_LF_TU_IP6, NPC_F_IP6_HAS_EXT, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_LF, NPC_EC_IP6_VER, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LF, NPC_LT_LF_TU_IP6, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_LF, NPC_EC_UNK, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 0,
+		NPC_LID_LF, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+};
+
+struct npc_kpu_profile_action kpu12_action_entries[] = {
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 0,
+		NPC_LID_LC, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+};
+
+struct npc_kpu_profile_action kpu13_action_entries[] = {
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 0,
+		NPC_LID_LC, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+};
+
+struct npc_kpu_profile_action kpu14_action_entries[] = {
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 0, NPC_S_KPU15_HTTP_DATA, 20, 1,
+		NPC_LID_LG, NPC_LT_LG_TU_TCP, NPC_F_TCP_HTTP, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 0, NPC_S_KPU15_HTTPS_DATA, 20, 1,
+		NPC_LID_LG, NPC_LT_LG_TU_TCP, NPC_F_TCP_HTTPS, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 0, NPC_S_KPU15_TCP_DATA, 20, 1,
+		NPC_LID_LG, NPC_LT_LG_TU_TCP, NPC_F_TCP_UNK_PORT, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 0, NPC_S_KPU15_HTTP_DATA, 0, 1,
+		NPC_LID_LG, NPC_LT_LG_TU_TCP, NPC_F_TCP_HTTP_HAS_OPTIONS,
+		12, 0xf0, 1, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 0, NPC_S_KPU15_HTTPS_DATA, 0, 1,
+		NPC_LID_LG, NPC_LT_LG_TU_TCP, NPC_F_TCP_HTTPS_HAS_OPTIONS,
+		12, 0xf0, 1, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 0, NPC_S_KPU15_TCP_DATA, 0, 1,
+		NPC_LID_LG, NPC_LT_LG_TU_TCP, NPC_F_TCP_UNK_PORT_HAS_OPTIONS,
+		12, 0xf0, 1, 2,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 0, NPC_S_KPU15_UDP_DATA, 8, 1,
+		NPC_LID_LG, NPC_LT_LG_TU_UDP, NPC_F_UDP_UNK_PORT, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LG, NPC_LT_LG_TU_SCTP, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LG, NPC_LT_LG_TU_ICMP, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LG, NPC_LT_LG_TU_IGMP, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LG, NPC_LT_LG_TU_ICMP6, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LG, NPC_LT_LG_TU_ESP, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LG, NPC_LT_LG_TU_AH, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_LG, NPC_EC_L4, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 0,
+		NPC_LID_LG, NPC_LT_NA, 0, 0, 0,
+		0, 0,
+	},
+};
+
+struct npc_kpu_profile_action kpu15_action_entries[] = {
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LH, NPC_LT_LH_TCP_DATA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LH, NPC_LT_LH_HTTP_DATA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LH, NPC_LT_LH_HTTPS_DATA, 0, 0, 0,
+		0, 0,
+	},
+	{
+		NPC_ERRLEV_RE, NPC_EC_NOERR, 0, 0, 0,
+		0, 1, NPC_S_NA, 0, 1,
+		NPC_LID_LH, NPC_LT_LH_UDP_DATA, 0, 0, 0,
+		0, 0,
+	},
+};
+
+struct npc_kpu_profile npc_kpu_profiles[] = {
+	{
+		ARRAY_SIZE(kpu1_cam_entries),
+		ARRAY_SIZE(kpu1_action_entries),
+		&kpu1_cam_entries[0],
+		&kpu1_action_entries[0],
+	},
+	{
+		ARRAY_SIZE(kpu2_cam_entries),
+		ARRAY_SIZE(kpu2_action_entries),
+		&kpu2_cam_entries[0],
+		&kpu2_action_entries[0],
+	},
+	{
+		ARRAY_SIZE(kpu3_cam_entries),
+		ARRAY_SIZE(kpu3_action_entries),
+		&kpu3_cam_entries[0],
+		&kpu3_action_entries[0],
+	},
+	{
+		ARRAY_SIZE(kpu4_cam_entries),
+		ARRAY_SIZE(kpu4_action_entries),
+		&kpu4_cam_entries[0],
+		&kpu4_action_entries[0],
+	},
+	{
+		ARRAY_SIZE(kpu5_cam_entries),
+		ARRAY_SIZE(kpu5_action_entries),
+		&kpu5_cam_entries[0],
+		&kpu5_action_entries[0],
+	},
+	{
+		ARRAY_SIZE(kpu6_cam_entries),
+		ARRAY_SIZE(kpu6_action_entries),
+		&kpu6_cam_entries[0],
+		&kpu6_action_entries[0],
+	},
+	{
+		ARRAY_SIZE(kpu7_cam_entries),
+		ARRAY_SIZE(kpu7_action_entries),
+		&kpu7_cam_entries[0],
+		&kpu7_action_entries[0],
+	},
+	{
+		ARRAY_SIZE(kpu8_cam_entries),
+		ARRAY_SIZE(kpu8_action_entries),
+		&kpu8_cam_entries[0],
+		&kpu8_action_entries[0],
+	},
+	{
+		ARRAY_SIZE(kpu9_cam_entries),
+		ARRAY_SIZE(kpu9_action_entries),
+		&kpu9_cam_entries[0],
+		&kpu9_action_entries[0],
+	},
+	{
+		ARRAY_SIZE(kpu10_cam_entries),
+		ARRAY_SIZE(kpu10_action_entries),
+		&kpu10_cam_entries[0],
+		&kpu10_action_entries[0],
+	},
+	{
+		ARRAY_SIZE(kpu11_cam_entries),
+		ARRAY_SIZE(kpu11_action_entries),
+		&kpu11_cam_entries[0],
+		&kpu11_action_entries[0],
+	},
+	{
+		ARRAY_SIZE(kpu12_cam_entries),
+		ARRAY_SIZE(kpu12_action_entries),
+		&kpu12_cam_entries[0],
+		&kpu12_action_entries[0],
+	},
+	{
+		ARRAY_SIZE(kpu13_cam_entries),
+		ARRAY_SIZE(kpu13_action_entries),
+		&kpu13_cam_entries[0],
+		&kpu13_action_entries[0],
+	},
+	{
+		ARRAY_SIZE(kpu14_cam_entries),
+		ARRAY_SIZE(kpu14_action_entries),
+		&kpu14_cam_entries[0],
+		&kpu14_action_entries[0],
+	},
+	{
+		ARRAY_SIZE(kpu15_cam_entries),
+		ARRAY_SIZE(kpu15_action_entries),
+		&kpu15_cam_entries[0],
+		&kpu15_action_entries[0],
+	},
+};
+
+#endif /* NPC_PROFILE_H */
diff --git a/drivers/net/octeontx2/npc_reg.h b/drivers/net/octeontx2/npc_reg.h
new file mode 100644
index 0000000..4f3e993
--- /dev/null
+++ b/drivers/net/octeontx2/npc_reg.h
@@ -0,0 +1,639 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+/* Register definitions */
+
+/**
+ * NPC AF General Configuration Register
+ */
+union cavm_npc_af_cfg {
+	u64 u;
+	struct npc_af_cfg_s {
+		u64 rsvd_1_0:           2;
+		u64 cclk_force:         1;
+		u64 force_intf_clk_en:  1;
+		u64 rsvd_63_4:          60;
+	} s;
+};
+
+/**
+ * NPC Interrupt-Timer Configuration Register
+ */
+union cavm_npc_af_active_pc {
+	u64 u;
+	struct npc_af_active_pc_s {
+		u64 active_pc;                      
+	} s;
+};
+
+/**
+ * NPC AF Constants Register
+ * This register contains constants for software discovery.
+ */
+union cavm_npc_af_const {
+	u64 u;
+	struct npc_af_const_s {
+		u64 intfs:              4;
+		u64 lids:               4;
+		u64 kpus:               5;
+		u64 rsvd_15_13:         3;
+		u64 mcam_bank_width:    10;
+		u64 rsvd_27_26:         2;
+		u64 mcam_bank_depth:    16;
+		u64 mcam_banks:         4;
+		u64 match_stats:        16;
+	} s;
+};
+
+/**
+ * NPC AF Constants 1 Register
+ * This register contains constants for software discovery.
+ */
+union cavm_npc_af_const1 {
+	u64 u;
+	struct npc_af_const1_s {
+		u64 kpu_entries:        12;
+		u64 pkinds:             8;
+		u64 cpi_size:           16;
+		u64 rsvd_63_36:         28;
+	} s;
+};
+
+/**
+ * NPC AF MCAM Scrub Control Register
+ */
+union cavm_npc_af_mcam_scrub_ctl {
+	u64 u;
+	struct npc_af_mcam_scrub_ctl_s {
+		u64 ena:        1;
+		u64 rsvd_7_1:   7;
+		u64 lp_dis:     1;
+		u64 rsvd_15_9:  7;
+		u64 toth:       4;
+		u64 rsvd_63_20: 44;
+	} s;
+};
+
+/**
+ * NPC AF KPU Configuration Registers
+ */
+union cavm_npc_af_kpux_cfg {
+	u64 u;
+	struct npc_af_kpux_cfg_s {
+		u64 ena:        1;
+		u64 rsvd_63_1:  63;
+	} s;
+};
+
+/**
+ * NPC AF Protocol Check Configuration Register
+ */
+union cavm_npc_af_pck_cfg {
+	u64 u;
+	struct npc_af_pck_cfg_s {
+		u64 rsvd_0:             1;
+		u64 iip4_cksum:         1;
+		u64 oip4_cksum:         1;
+		u64 rsvd_3:             1;
+		u64 l3b:                1;
+		u64 l3m:                1;
+		u64 l2b:                1;
+		u64 l2m:                1;
+		u64 rsvd_23_8:          16;
+		u64 iip4_cksum_errcode: 8;
+		u64 oip4_cksum_errcode: 8;
+		u64 rsvd_63_40:         24;
+	} s;
+};
+
+/**
+ * NPC AF Protocol Check Outer L2 Definition Register
+ * Provides layer information used by the protocol checker to identify an
+ * outer L2 header.
+ */
+union cavm_npc_af_pck_def_ol2 {
+	u64 u;
+	struct npc_af_pck_def_ol2_s {
+		u64 ltype_mask:         4;
+		u64 ltype_match:        4;
+		u64 lid:                3;
+		u64 rsvd_63_11:         53;
+	} s;
+};
+
+/**
+ * NPC AF Key Extract Layer Data Flags Configuration Register
+ */
+union cavm_npc_af_kex_ldatax_flags_cfg {
+	u64 u;
+	struct npc_af_kex_ldatax_flags_cfg_s {
+		u64 lid:        3;
+		u64 rsvd_63_3:  61;
+	} s;
+};
+
+/**
+ * NPC AF Interface Key Extract Configuration Registers
+ */
+union cavm_npc_af_intfx_kex_cfg {
+	u64 u;
+	struct npc_af_intfx_kex_cfg_s {
+		u64 parse_nibble_ena:   31;
+		u64 rsvd_31:            1;
+		u64 keyw:               3;
+		u64 rsvd_63_35:         29;
+	} s;
+};
+
+/**
+ * NPC AF Port Kind Channel Parse Index Definition Registers
+ * These registers specify the layer information and algorithm to compute a
+ * packet's channel parse index (CPI), which provides a port to channel adder
+ * for calculating NPC_RESULT_S[CHAN]. There are two CPI definitions per port
+ * kind, allowing the CPI computation to use two possible layer definitions in
+ * the parsed packet, e.g. DiffServ DSCP from either IPv4 or IPv6 header. CPI
+ * pseudocode: <pre> for (i = 0; i < 2; i++) {  cpi_def =
+ * NPC_AF_PKIND()_CPI_DEF(i);  LX = LA, LB, ..., or LH as selected by
+ * cpi_def[LID];   if (cpi_def[VALID]    && ((cpi_def[LTYPE_MATCH] &
+ * cpi_def[LTYPE_MASK])       == (NPC_RESULT_S[LX[LTYPE]] &
+ * cpi_def[LTYPE_MASK]))    && ((cpi_def[FLAGS_MATCH] & cpi_def[FLAGS_MASK])
+ * == (NPC_RESULT_S[LX[FLAGS]] & cpi_def[FLAGS_MASK])))  {    // Found
+ * matching layer    nibble_offset = (2*NPC_RESULT_S[LX[LPTR]]) +
+ * cpi_def[ADD_OFFSET];    add_byte = byte at nibble_offset from start of
+ * packet;    cpi_add = (add_byte & cpi_def[ADD_MASK]) >> cpi_def[ADD_SHIFT];
+ * cpi = cpi_def[CPI_BASE] + cpi_add;    NPC_RESULT_S[CHAN] +=
+ * NPC_AF_CPI(cpi)_CFG[PADD];    break;  } } </pre>
+ */
+union cavm_npc_af_pkindx_cpi_defx {
+	u64 u;
+	struct npc_af_pkindx_cpi_defx_s {
+		u64 cpi_base:           10;
+		u64 rsvd_11_10:         2;
+		u64 add_shift:          3;
+		u64 rsvd_15:            1;
+		u64 add_mask:           8;
+		u64 add_offset:         8;
+		u64 flags_mask:         8;
+		u64 flags_match:        8;
+		u64 ltype_mask:         4;
+		u64 ltype_match:        4;
+		u64 lid:                3;
+		u64 rsvd_62_59:         4;
+		u64 ena:                1;
+	} s;
+};
+
+/**
+ * NPC AF KPU Entry CAM Registers
+ * KPU comparison ternary data. The field values in NPC_AF_KPU()_ENTRY()_CAM()
+ * are ternary, where each data bit of the search key matches as follows: _
+ * [CAM(1)]<n>=0, [CAM(0)]<n>=0: Always match; search key data<n> don't care.
+ * _ [CAM(1)]<n>=0, [CAM(0)]<n>=1: Match when search key data<n> == 0. _
+ * [CAM(1)]<n>=1, [CAM(0)]<n>=0: Match when search key data<n> == 1. _
+ * [CAM(1)]<n>=1, [CAM(0)]<n>=1: Reserved. The reserved combination is not
+ * allowed. Hardware suppresses any write to CAM(0) or CAM(1) that would
+ * result in the reserved combination for any CAM bit. Software must program a
+ * default entry for each KPU, e.g. by programming each KPU's last entry {b}
+ * (NPC_AF_KPU()_ENTRY({b})_CAM()) to always match all bits.
+ */
+union cavm_npc_af_kpux_entryx_camx {
+	u64 u;
+	struct npc_af_kpux_entryx_camx_s {
+		u64 dp0_data:   16;
+		u64 dp1_data:   16;
+		u64 dp2_data:   16;
+		u64 state:      8;
+		u64 rsvd_63_56: 8;
+	} s;
+};
+
+/**
+ * NPC AF KPU Entry Action Data 0 Registers
+ * When a KPU's search data matches a KPU CAM entry in
+ * NPC_AF_KPU()_ENTRY()_CAM(), the corresponding entry action in
+ * NPC_AF_KPU()_ENTRY()_ACTION0 and NPC_AF_KPU()_ENTRY()_ACTION1 specifies the
+ * next state and operations to perform before exiting the KPU.
+ */
+union cavm_npc_af_kpux_entryx_action0 {
+	u64 u;
+	struct npc_af_kpux_entryx_action0_s {
+		u64 var_len_shift:      3;
+		u64 var_len_right:      1;
+		u64 var_len_mask:       8;
+		u64 var_len_offset:     8;
+		u64 ptr_advance:        8;
+		u64 capture_flags:      8;
+		u64 capture_ltype:      4;
+		u64 capture_lid:        3;
+		u64 rsvd_43:            1;
+		u64 next_state:         8;
+		u64 parse_done:         1;
+		u64 capture_ena:        1;
+		u64 byp_count:          3;
+		u64 rsvd_63_57:         7;
+	} s;
+};
+
+/**
+ * NPC AF KPU Entry Action Data 0 Registers
+ * See NPC_AF_KPU()_ENTRY()_ACTION0.
+ */
+union cavm_npc_af_kpux_entryx_action1 {
+	u64 u;
+	struct npc_af_kpux_entryx_action1_s {
+		u64 dp0_offset: 8;
+		u64 dp1_offset: 8;
+		u64 dp2_offset: 8;
+		u64 errcode:    8;
+		u64 errlev:     4;
+		u64 rsvd_63_36: 28;
+	} s;
+};
+
+/**
+ * NPC AF KPU Entry Disable Registers
+ * See NPC_AF_KPU()_ENTRY()_ACTION0.
+ */
+union cavm_npc_af_kpux_entry_disx {
+	u64 u;
+	struct npc_af_kpux_entry_disx_s {
+		u64 dis;                            
+	} s;
+};
+
+/**
+ * NPC AF Channel Parse Index Table Registers
+ */
+union cavm_npc_af_cpix_cfg {
+	u64 u;
+	struct npc_af_cpix_cfg_s {
+		u64 padd:       4;
+		u64 rsvd_63_4:  60;
+	} s;
+};
+
+/**
+ * NPC AF Interface Layer Data Extract Configuration Registers
+ * These registers control the extraction of layer data (LDATA) into the MCAM
+ * search key for each interface. Up to two LDATA fields can be extracted per
+ * layer (LID(0..7) indexed by NPC_LID_E), with up to 16 bytes per LDATA
+ * field. For each layer, the corresponding NPC_LAYER_INFO_S[LTYPE] value in
+ * NPC_RESULT_S is used as the LTYPE(0..15) index and select the associated
+ * LDATA(0..1) registers. NPC_LAYER_INFO_S[LTYPE]=0x0 means the corresponding
+ * layer not parsed (invalid), so software should keep
+ * NPC_AF_INTF()_LID()_LT(0)_LD()_CFG[ENA] clear to disable extraction when
+ * LTYPE is zero.
+ */
+union cavm_npc_af_intfx_lidx_ltx_ldx_cfg {
+	u64 u;
+	struct npc_af_intfx_lidx_ltx_ldx_cfg_s {
+		u64 key_offset: 6;
+		u64 flags_ena:  1;
+		u64 ena:        1;
+		u64 hdr_offset: 8;
+		u64 bytesm1:    4;
+		u64 rsvd_63_20: 44;
+	} s;
+};
+
+/**
+ * NPC AF Interface Layer Data Flags Configuration Registers
+ * These registers control the extraction of layer data (LDATA) into the MCAM
+ * search key for each interface based on the FLAGS<3:0> bits of two layers
+ * selected by NPC_AF_KEX_LDATA()_FLAGS_CFG.
+ */
+union cavm_npc_af_intfx_ldatax_flagsx_cfg {
+	u64 u;
+	struct npc_af_intfx_ldatax_flagsx_cfg_s {
+		u64 key_offset: 6;
+		u64 rsvd_6:     1;
+		u64 ena:        1;
+		u64 hdr_offset: 8;
+		u64 bytesm1:    4;
+		u64 rsvd_63_20: 44;
+	} s;
+};
+
+/**
+ * NPC AF MCAM Entry Bank CAM Data Interface Registers
+ * MCAM comparison ternary data interface word. The field values in
+ * NPC_AF_MCAME()_BANK()_CAM()_INTF, NPC_AF_MCAME()_BANK()_CAM()_W0 and
+ * NPC_AF_MCAME()_BANK()_CAM()_W1 are ternary, where each data bit of the
+ * search key matches as follows: _ [CAM(1)]<n>=0, [CAM(0)]<n>=0: Always
+ * match; search key data<n> don't care. _ [CAM(1)]<n>=0, [CAM(0)]<n>=1: Match
+ * when search key data<n> == 0. _ [CAM(1)]<n>=1, [CAM(0)]<n>=0: Match when
+ * search key data<n> == 1. _ [CAM(1)]<n>=1, [CAM(0)]<n>=1: Reserved. The
+ * reserved combination is not allowed. Hardware suppresses any write to
+ * CAM(0) or CAM(1) that would result in the reserved combination for any CAM
+ * bit. When an interface is configured to use the NPC_MCAM_KEY_X1_S search
+ * key format (NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X1), the four
+ * banks of every MCAM entry are used as individual entries, each of which is
+ * independently compared with the search key as follows: _
+ * NPC_AF_MCAME()_BANK()_CAM()_INTF[INTF] corresponds to
+ * NPC_MCAM_KEY_X1_S[INTF]. _ NPC_AF_MCAME()_BANK()_CAM()_W0[MD] corresponds
+ * to NPC_MCAM_KEY_X1_S[KW0]. _ NPC_AF_MCAME()_BANK()_CAM()_W1[MD] corresponds
+ * to NPC_MCAM_KEY_X1_S[KW1]. When an interface is configured to use the
+ * NPC_MCAM_KEY_X2_S search key format (NPC_AF_INTF()_KEX_CFG[KEYW] =
+ * NPC_MCAMKEYW_E::X2), banks 0-1 of every MCAM entry are used as one
+ * double-wide entry, banks 2-3 as a second double-wide entry, and each
+ * double-wide entry is independently compared with the search key as follows:
+ * _ NPC_AF_MCAME()_BANK(0,2)_CAM()_INTF[INTF] corresponds to
+ * NPC_MCAM_KEY_X2_S[INTF]. _ NPC_AF_MCAME()_BANK(0,2)_CAM()_W0[MD]
+ * corresponds to NPC_MCAM_KEY_X2_S[KW0]. _
+ * NPC_AF_MCAME()_BANK(0,2)_CAM()_W1[MD] corresponds to
+ * NPC_MCAM_KEY_X2_S[KW1]<47:0>. _ NPC_AF_MCAME()_BANK(1,3)_CAM()_INTF[INTF]
+ * corresponds to NPC_MCAM_KEY_X2_S[INTF]. _
+ * NPC_AF_MCAME()_BANK(1,3)_CAM()_W0[MD]<15:0> corresponds to
+ * NPC_MCAM_KEY_X2_S[KW1]<63:48>. _
+ * NPC_AF_MCAME()_BANK(1,3)_CAM()_W0[MD]<63:16> corresponds to
+ * NPC_MCAM_KEY_X2_S[KW2]<47:0>. _ NPC_AF_MCAME()_BANK(1,3)_CAM()_W1[MD]<15:0>
+ * corresponds to NPC_MCAM_KEY_X2_S[KW2]<63:48>. _
+ * NPC_AF_MCAME()_BANK(1,3)_CAM()_W1[MD]<47:16> corresponds to
+ * NPC_MCAM_KEY_X2_S[KW3]<31:0>. When an interface is configured to use the
+ * NPC_MCAM_KEY_X4_S search key format (NPC_AF_INTF()_KEX_CFG[KEYW] =
+ * NPC_MCAMKEYW_E::X4), the four banks of every MCAM entry are used as a
+ * single quad-wide entry that is compared with the search key as follows: _
+ * NPC_AF_MCAME()_BANK(0)_CAM()_INTF[INTF] corresponds to
+ * NPC_MCAM_KEY_X4_S[INTF]. _ NPC_AF_MCAME()_BANK(0)_CAM()_W0[MD] corresponds
+ * to NPC_MCAM_KEY_X4_S[KW0]. _ NPC_AF_MCAME()_BANK(0)_CAM()_W1[MD]
+ * corresponds to NPC_MCAM_KEY_X4_S[KW1]<47:0>. _
+ * NPC_AF_MCAME()_BANK(1)_CAM()_INTF[INTF] corresponds to
+ * NPC_MCAM_KEY_X4_S[INTF]. _ NPC_AF_MCAME()_BANK(1)_CAM()_W0[MD]<15:0>
+ * corresponds to NPC_MCAM_KEY_X4_S[KW1]<63:48>. _
+ * NPC_AF_MCAME()_BANK(1)_CAM()_W0[MD]<63:16> corresponds to
+ * NPC_MCAM_KEY_X4_S[KW2]<47:0>. _ NPC_AF_MCAME()_BANK(1)_CAM()_W1[MD]<15:0>
+ * corresponds to NPC_MCAM_KEY_X4_S[KW2]<63:48>. _
+ * NPC_AF_MCAME()_BANK(1)_CAM()_W1[MD]<47:16> corresponds to
+ * NPC_MCAM_KEY_X4_S[KW3]<31:0>. _ NPC_AF_MCAME()_BANK(2)_CAM()_INTF[INTF]
+ * corresponds to NPC_MCAM_KEY_X4_S[INTF]. _
+ * NPC_AF_MCAME()_BANK(2)_CAM()_W0[MD]<31:0> corresponds to
+ * NPC_MCAM_KEY_X4_S[KW3]<63:32>. _ NPC_AF_MCAME()_BANK(2)_CAM()_W0[MD]<63:32>
+ * corresponds to NPC_MCAM_KEY_X4_S[KW4]<31:0>. _
+ * NPC_AF_MCAME()_BANK(2)_CAM()_W1[MD]<31:0> corresponds to
+ * NPC_MCAM_KEY_X4_S[KW4]<63:32>. _ NPC_AF_MCAME()_BANK(2)_CAM()_W1[MD]<47:32>
+ * corresponds to NPC_MCAM_KEY_X4_S[KW5]<15:0>. _
+ * NPC_AF_MCAME()_BANK(3)_CAM()_INTF[INTF] corresponds to
+ * NPC_MCAM_KEY_X4_S[INTF]. _ NPC_AF_MCAME()_BANK(3)_CAM()_W0[MD]<47:0>
+ * corresponds to NPC_MCAM_KEY_X4_S[KW5]<63:16>. _
+ * NPC_AF_MCAME()_BANK(3)_CAM()_W0[MD]<63:48> corresponds to
+ * NPC_MCAM_KEY_X4_S[KW6]<15:0>. _ NPC_AF_MCAME()_BANK(3)_CAM()_W1[MD]
+ * corresponds to NPC_MCAM_KEY_X4_S[KW6]<63:16>. Note that for the X2 and X4
+ * formats, a wide entry will not match unless the INTF fields from the
+ * associated two or four banks match the INTF value from the search key. For
+ * the X1 and X2 formats, a match in a lower-numbered bank takes priority over
+ * a match in any higher numbered banks. Within each bank, the lowest numbered
+ * matching entry takes priority over any higher numbered entry.
+ */
+union cavm_npc_af_mcamex_bankx_camx_intf {
+	u64 u;
+	struct npc_af_mcamex_bankx_camx_intf_s {
+		u64 intf:       2;
+		u64 rsvd_63_2:  62;
+	} s;
+};
+
+/**
+ * NPC AF MCAM Entry Bank CAM Data Word 0 Registers
+ * MCAM comparison ternary data word 0. See NPC_AF_MCAME()_BANK()_CAM()_INTF.
+ */
+union cavm_npc_af_mcamex_bankx_camx_w0 {
+	u64 u;
+	struct npc_af_mcamex_bankx_camx_w0_s {
+		u64 md;                             
+	} s;
+};
+
+/**
+ * NPC AF MCAM Entry Bank Data Word 1 Registers
+ * MCAM comparison ternary data word 1. See NPC_AF_MCAME()_BANK()_CAM()_INTF.
+ */
+union cavm_npc_af_mcamex_bankx_camx_w1 {
+	u64 u;
+	struct npc_af_mcamex_bankx_camx_w1_s {
+		u64 md:         48;
+		u64 rsvd_63_48: 16;
+	} s;
+};
+
+/**
+ * NPC AF MCAM Entry Bank Configuration Registers
+ */
+union cavm_npc_af_mcamex_bankx_cfg {
+	u64 u;
+	struct npc_af_mcamex_bankx_cfg_s {
+		u64 ena:        1;
+		u64 rsvd_63_1:  63;
+	} s;
+};
+
+/**
+ * NPC AF MCAM Entry Bank Statistics Action Registers
+ * Used to optionally increment a NPC_AF_MATCH_STAT() counter when a packet
+ * matches an MCAM entry. See also NPC_AF_MCAME()_BANK()_ACTION.
+ */
+union cavm_npc_af_mcamex_bankx_stat_act {
+	u64 u;
+	struct npc_af_mcamex_bankx_stat_act_s {
+		u64 stat_sel:   9;
+		u64 ena:        1;
+		u64 rsvd_63_10: 54;
+	} s;
+};
+
+/**
+ * NPC AF Match Statistics Registers
+ */
+union cavm_npc_af_match_statx {
+	u64 u;
+	struct npc_af_match_statx_s {
+		u64 count:      48;
+		u64 rsvd_63_48: 16;
+	} s;
+};
+
+/**
+ * NPC AF MCAM Entry Bank Action Data Registers
+ * Specifies a packet's match action captured in NPC_RESULT_S[ACTION]. When an
+ * interface is configured to use the NPC_MCAM_KEY_X2_S search key format
+ * (NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X2), *
+ * NPC_AF_MCAME()_BANK(0)_ACTION/_TAG_ACT/_STAT_ACT are used if the search key
+ * matches NPC_AF_MCAME()_BANK(0..1)_CAM()_W*. *
+ * NPC_AF_MCAME()_BANK(2)_ACTION/_TAG_ACT/_STAT_ACT are used if the search key
+ * matches NPC_AF_MCAME()_BANK(2..3)_CAM()_W*. *
+ * NPC_AF_MCAME()_BANK(1,3)_ACTION/_TAG_ACT/_STAT_ACT are not used. When an
+ * interface is configured to use the NPC_MCAM_KEY_X4_S search key format
+ * (NPC_AF_INTF()_KEX_CFG[KEYW] = NPC_MCAMKEYW_E::X4): *
+ * NPC_AF_MCAME()_BANK(0)_ACTION/_TAG_ACT/_STAT_ACT are used if the search key
+ * matches NPC_AF_MCAME()_BANK(0..3)_CAM()_W*. *
+ * NPC_AF_MCAME()_BANK(1..3)_ACTION/_TAG_ACT/_STAT_ACT are not used.
+ */
+union cavm_npc_af_mcamex_bankx_action {
+	u64 u;
+	struct npc_af_mcamex_bankx_action_s {
+		u64 action;                         
+	} s;
+};
+
+/**
+ * NPC AF MCAM Entry Bank VTag Action Data Registers
+ * Specifies a packet's match Vtag action captured in
+ * NPC_RESULT_S[VTAG_ACTION]. See also NPC_AF_MCAME()_BANK()_ACTION.
+ */
+union cavm_npc_af_mcamex_bankx_tag_act {
+	u64 u;
+	struct npc_af_mcamex_bankx_tag_act_s {
+		u64 vtag_action;                    
+	} s;
+};
+
+/**
+ * NPC AF MCAM Bank Hit Registers
+ */
+union cavm_npc_af_mcam_bankx_hitx {
+	u64 u;
+	struct npc_af_mcam_bankx_hitx_s {
+		u64 hit;                            
+	} s;
+};
+
+/**
+ * NPC AF Software Lookup Control Registers
+ */
+union cavm_npc_af_lkup_ctl {
+	u64 u;
+	struct npc_af_lkup_ctl_s {
+		u64 intf:       2;
+		u64 pkind:      6;
+		u64 chan:       12;
+		u64 hdr_sizem1: 8;
+		u64 op:         3;
+		u64 exec:       1;
+		u64 rsvd_63_32: 32;
+	} s;
+};
+
+/**
+ * NPC AF Software Lookup Data Registers
+ */
+union cavm_npc_af_lkup_datax {
+	u64 u;
+	struct npc_af_lkup_datax_s {
+		u64 data;                           
+	} s;
+};
+
+/**
+ * NPC AF Software Lookup Result Registers
+ */
+union cavm_npc_af_lkup_resultx {
+	u64 u;
+	struct npc_af_lkup_resultx_s {
+		u64 data;                           
+	} s;
+};
+
+/**
+ * NPC AF Interface Statistics Registers
+ * Statistics per interface. Index enumerated by NPC_INTF_E.
+ */
+union cavm_npc_af_intfx_stat {
+	u64 u;
+	struct npc_af_intfx_stat_s {
+		u64 count:      48;
+		u64 rsvd_63_48: 16;
+	} s;
+};
+
+/**
+ * NPC AF Debug Control Register
+ * This register controls the capture of debug information in
+ * NPC_AF_KPU()_DBG, NPC_AF_MCAM_DBG, NPC_AF_DBG_DATA() and
+ * NPC_AF_DBG_RESULT().
+ */
+union cavm_npc_af_dbg_ctl {
+	u64 u;
+	struct npc_af_dbg_ctl_s {
+		u64 continuous: 1;
+		u64 lkup_dbg:   1;
+		u64 intf_dbg:   4;
+		u64 rsvd_63_6:  58;
+	} s;
+};
+
+/**
+ * NPC AF Debug Status Register
+ * This register controls the capture of debug information in
+ * NPC_AF_KPU()_DBG, NPC_AF_MCAM_DBG, NPC_AF_LKUP_DATA() and
+ * NPC_AF_LKUP_RESULT().
+ */
+union cavm_npc_af_dbg_status {
+	u64 u;
+	struct npc_af_dbg_status_s {
+		u64 done:       1;
+		u64 rsvd_63_1:  63;
+	} s;
+};
+
+/**
+ * NPC AF KPU Debug Registers
+ * This register contains information for the last packet/lookup for which
+ * debug is enabled by NPC_AF_DBG_CTL[INTF_DBG,LKUP_DBG].
+ */
+union cavm_npc_af_kpux_dbg {
+	u64 u;
+	struct npc_af_kpux_dbg_s {
+		u64 hit_entry:  8;
+		u64 byp:        1;
+		u64 rsvd_63_9:  55;
+	} s;
+};
+
+/**
+ * NPC AF KPU Error Control Registers
+ * This register specifies values captured in NPC_RESULT_S[ERRLEV,ERRCODE]
+ * when errors are detected by a KPU.
+ */
+union cavm_npc_af_kpux_err_ctl {
+	u64 u;
+	struct npc_af_kpux_err_ctl_s {
+		u64 errlev:                     4;
+		u64 dp_offset_errcode:          8;
+		u64 ptr_advance_errcode:        8;
+		u64 var_len_offset_errcode:     8;
+		u64 rsvd_63_28:                 36;
+	} s;
+};
+
+/**
+ * NPC AF MCAM Debug Register
+ * This register contains information for the last packet/lookup for which
+ * debug is enabled by NPC_AF_DBG_CTL[INTF_DBG,LKUP_DBG].
+ */
+union cavm_npc_af_mcam_dbg {
+	u64 u;
+	struct npc_af_mcam_dbg_s {
+		u64 hit_entry:  10;
+		u64 rsvd_11_10: 2;
+		u64 hit_bank:   2;
+		u64 rsvd_15_14: 2;
+		u64 miss:       1;
+		u64 rsvd_63_17: 47;
+	} s;
+};
+
+/**
+ * NPC AF Debug Data Registers
+ * This register contains packet header data for the last packet/lookup for
+ * which debug information is captured by NPC_AF_DBG_CTL[INTF_DBG,LKUP_DBG].
+ */
+union cavm_npc_af_dbg_datax {
+	u64 u;
+	struct npc_af_dbg_datax_s {
+		u64 data;                           
+	} s;
+};
diff --git a/drivers/net/octeontx2/rvu.h b/drivers/net/octeontx2/rvu.h
new file mode 100644
index 0000000..a61da69
--- /dev/null
+++ b/drivers/net/octeontx2/rvu.h
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#ifndef __RVU_H__
+#define __RVU_H__
+
+#include "cavm-csrs-rvu.h"
+
+#define ALIGNED		__aligned(CONFIG_SYS_CACHELINE_SIZE)
+
+/* PCI device IDs */
+#define	PCI_DEVID_OCTEONTX2_CGX			0xA059
+#define	PCI_DEVID_OCTEONTX2_RVU_AF		0xA065
+#define	PCI_DEVID_OCTEONTX2_RVU_PF		0xA063
+#define	PCI_DEVID_OCTEONTX2_RVU_VF		0xA064
+
+#define Q_SIZE_16		0ULL /* 16 entries */
+#define Q_SIZE_64		1ULL /* 64 entries */
+#define Q_SIZE_256		2ULL
+#define Q_SIZE_1K		3ULL
+#define Q_SIZE_4K		4ULL
+#define Q_SIZE_16K		5ULL
+#define Q_SIZE_64K		6ULL
+#define Q_SIZE_256K		7ULL
+#define Q_SIZE_1M		8ULL /* Million entries */
+#define Q_SIZE_MIN		Q_SIZE_16
+#define Q_SIZE_MAX		Q_SIZE_1M
+
+#define Q_COUNT(x)		(16ULL << (2 * x))
+#define Q_SIZE(x, n)		((ilog2(x) - (n)) / 2)
+
+/* Admin queue info */
+
+/* Since we intend to add only one instruction at a time,
+ * keep queue size to it's minimum.
+ */
+#define AQ_SIZE			Q_SIZE_16
+/* HW head & tail pointer mask */
+#define AQ_PTR_MASK		0xFFFFF
+
+struct qmem {
+	void		*base;
+	dma_addr_t	iova;
+	size_t		alloc_sz;
+	u32		qsize;
+	u8		entry_sz;
+};
+
+struct admin_queue {
+	struct qmem inst;
+	struct qmem res;
+};
+
+struct rvu_af {
+	struct udevice *dev;
+	void __iomem *af_base;
+	struct nix_af *nix_af;
+};
+
+struct rvu_pf {
+	struct udevice *dev;
+	struct udevice *afdev;
+	void __iomem *pf_base;
+	struct nix *nix;
+	u8 pfid;
+	int nix_lfid;
+	int npa_lfid;
+};
+
+/**
+ * Store 128 bit value
+ *
+ * @param[out]	dest	pointer to destination address
+ * @param	val0	first 64 bits to write
+ * @param	val1	second 64 bits to write
+ */
+static inline void cavm_st128(void *dest, u64 val0, u64 val1)
+{
+	__asm__ __volatile__(
+		"stp %x[x0], %x[x1], [%[pm]]"
+		:
+		: [x0]"r"(val0), [x1]"r"(val1), [pm]"r"(dest)
+		: "memory");
+}
+
+/**
+ * Load 128 bit value
+ *
+ * @param[in]	source		pointer to 128 bits of data to load
+ * @param[out]	val0		first 64 bits of data
+ * @param[out]	val1		second 64 bits of data
+ */
+static inline void cavm_ld128(const u64 *src, u64 *val0, u64 *val1)
+{
+	__asm__ __volatile__ (
+		"ldp %x[x0], %x[x1], [%[pm]]"
+		:
+		: [x0]"r"(*val0), [x1]"r"(*val1), [pm]"r"(src));
+}
+
+void qmem_free(struct qmem *q);
+int qmem_alloc(struct qmem *q, u32 qsize, size_t entry_sz);
+
+/**
+ * Allocates an admin queue for instructions and results
+ *
+ * @param	aq	admin queue to allocate for
+ * @param	qsize	Number of entries in the queue
+ * @param	inst_size	Size of each instruction
+ * @param	res_size	Size of each result
+ *
+ * @return	-ENOMEM on error, 0 on success
+ */
+int rvu_aq_alloc(struct admin_queue *aq, unsigned qsize,
+		      size_t inst_size, size_t res_size);
+
+/**
+ * Frees an admin queue
+ *
+ * @param	aq	Admin queue to free
+ */
+void rvu_aq_free(struct admin_queue *aq);
+
+void rvu_get_lfid_for_pf(int pf, int *nixid, int *npaid);
+
+#endif /* __RVU_H__ */
+
diff --git a/drivers/net/octeontx2/rvu_af.c b/drivers/net/octeontx2/rvu_af.c
new file mode 100644
index 0000000..c001697
--- /dev/null
+++ b/drivers/net/octeontx2/rvu_af.c
@@ -0,0 +1,180 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#include <common.h>
+#include <net.h>
+#include <malloc.h>
+#include <dm.h>
+#include <misc.h>
+#include <errno.h>
+#include <linux/list.h>
+#include <asm/io.h>
+#include <asm/arch/octeontx2.h>
+#include "cavm-csrs-npa.h"
+#include "nix.h"
+
+struct udevice *rvu_af_dev=NULL;
+
+inline struct rvu_af *get_af(void)
+{
+	return rvu_af_dev ? dev_get_priv(rvu_af_dev) : NULL;
+}
+
+void rvu_get_lfid_for_pf(int pf, int *nixid, int *npaid)
+{
+	union cavm_nixx_af_rvu_lf_cfg_debug nix_lf_dbg;
+	union cavm_npa_af_rvu_lf_cfg_debug npa_lf_dbg;
+	union cavm_rvu_pf_func_s pf_func;
+	struct rvu_af *af = dev_get_priv(rvu_af_dev);
+	struct nix_af *nix_af = af->nix_af;
+
+	pf_func.u = 0;
+	pf_func.s.pf = pf;
+
+	nix_lf_dbg.u = 0;
+	nix_lf_dbg.s.pf_func = pf_func.u & 0xFFFF;
+	nix_lf_dbg.s.exec = 1;
+	nix_af_reg_write(nix_af, CAVM_NIXX_AF_RVU_LF_CFG_DEBUG(),
+			 nix_lf_dbg.u);
+	do {
+		nix_lf_dbg.u = nix_af_reg_read(nix_af,
+				CAVM_NIXX_AF_RVU_LF_CFG_DEBUG());
+	} while (nix_lf_dbg.s.exec);
+
+	if (nix_lf_dbg.s.lf_valid)
+		*nixid = nix_lf_dbg.s.lf; 
+
+	debug("%s: nix lf_valid %d lf %d nixid %d\n", __func__,
+		nix_lf_dbg.s.lf_valid,nix_lf_dbg.s.lf,*nixid);
+
+	npa_lf_dbg.u = 0;
+	npa_lf_dbg.s.pf_func = pf_func.u & 0xFFFF;
+	npa_lf_dbg.s.exec = 1;
+	npa_af_reg_write(nix_af->npa_af, CAVM_NPA_AF_RVU_LF_CFG_DEBUG(),
+			 npa_lf_dbg.u);
+	do {
+		npa_lf_dbg.u = npa_af_reg_read(nix_af->npa_af,
+				CAVM_NPA_AF_RVU_LF_CFG_DEBUG());
+	} while (npa_lf_dbg.s.exec);
+
+	if (npa_lf_dbg.s.lf_valid)
+		*npaid = npa_lf_dbg.s.lf; 
+	debug("%s: npa lf_valid %d lf %d npaid %d\n", __func__,
+		npa_lf_dbg.s.lf_valid,npa_lf_dbg.s.lf,*npaid);
+
+}
+
+struct nix_af *rvu_af_init(struct rvu_af *rvu_af)
+{
+	struct nix_af *nix_af;
+	union cavm_rvu_af_addr_s block_addr;
+	int err;
+
+	nix_af = (struct nix_af *)calloc(1, sizeof(struct nix_af));
+	if (!nix_af) {
+		printf("%s: out of memory\n", __func__);
+		goto error;
+	}
+
+	nix_af->dev = rvu_af->dev;
+
+	block_addr.u = 0;
+	block_addr.s.block = CAVM_RVU_BLOCK_ADDR_E_NIXX(0);
+	nix_af->nix_af_base = rvu_af->af_base + block_addr.u;
+
+	nix_af->npa_af = (struct npa_af *)calloc(1, sizeof(struct npa_af));
+	if (!nix_af->npa_af) {
+		printf("%s: out of memory\n", __func__);
+		goto error;
+	}
+
+	block_addr.u = 0;
+	block_addr.s.block = CAVM_RVU_BLOCK_ADDR_E_NPA;
+	nix_af->npa_af->npa_af_base = rvu_af->af_base + block_addr.u;
+
+	block_addr.u = 0;
+	block_addr.s.block = CAVM_RVU_BLOCK_ADDR_E_NPC;
+	nix_af->npc_af_base = rvu_af->af_base + block_addr.u;
+
+	debug("%s: Setting up npa admin\n", __func__);
+	err = npa_af_setup(nix_af->npa_af);
+	if (err) {
+		printf("%s: Error %d setting up NPA admin\n", __func__, err);
+		goto error;
+	}
+	debug("%s: Setting up nix af\n", __func__);
+	err = nix_af_setup(nix_af);
+	if (err) {
+		printf("%s: Error %d setting up NIX admin\n", __func__, err);
+		goto error;
+	}
+	debug("%s: nix_af: %p\n", __func__, nix_af);
+	return nix_af;
+
+error:
+	if (nix_af->npa_af) {
+		free(nix_af->npa_af);
+		memset(nix_af, 0, sizeof(*nix_af));
+	}
+	if (nix_af) {
+		free(nix_af);
+	}
+	return NULL;
+}
+
+int rvu_af_probe(struct udevice *dev)
+{
+	struct rvu_af *af_ptr = dev_get_priv(dev);
+	size_t size;
+
+	af_ptr->af_base = dm_pci_map_bar(dev, 0, &size, PCI_REGION_MEM);
+	debug("%s RVU AF BAR %p \n", __func__, af_ptr->af_base);
+	af_ptr->dev = rvu_af_dev = dev;
+
+	af_ptr->nix_af = rvu_af_init(af_ptr);
+	if ( !af_ptr->nix_af) {
+		printf("%s: Error: could not initialize NIX AF\n", __func__);
+		return -1;
+	}
+	debug("%s: Done\n", __func__);
+
+	return 0;
+}
+
+int rvu_af_remove(struct udevice *dev)
+{
+	struct rvu_af *rvu_af = dev_get_priv(dev);
+
+	nix_af_shutdown(rvu_af->nix_af);
+	npa_af_shutdown(rvu_af->nix_af->npa_af);
+	npc_af_shutdown(rvu_af->nix_af);
+
+	debug("%s: rvu af down -- \n", __func__);
+	return 0;
+}
+
+static const struct udevice_id rvu_af_ids[] = {
+        { .compatible = "cavium,rvu-af" },
+        {}
+};
+
+U_BOOT_DRIVER(rvu_af) = {
+        .name   = "rvu_af",
+        .id     = UCLASS_MISC,
+        .probe  = rvu_af_probe,
+        .remove = rvu_af_remove,
+        .of_match = rvu_af_ids,
+        .priv_auto_alloc_size = sizeof(struct rvu_af),
+};
+
+static struct pci_device_id rvu_af_supported[] = {
+        { PCI_VDEVICE(CAVIUM, PCI_DEVID_OCTEONTX2_RVU_AF) },
+        {}
+};
+
+U_BOOT_PCI_DEVICE(rvu_af, rvu_af_supported);
diff --git a/drivers/net/octeontx2/rvu_common.c b/drivers/net/octeontx2/rvu_common.c
new file mode 100644
index 0000000..5622b65
--- /dev/null
+++ b/drivers/net/octeontx2/rvu_common.c
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#include <common.h>
+#include <net.h>
+#include <malloc.h>
+#include <dm.h>
+#include <misc.h>
+#include <asm/io.h>
+#include <errno.h>
+
+#include "rvu.h"
+
+int qmem_alloc(struct qmem *q, u32 qsize, size_t entry_sz)
+{
+	q->base = memalign(CONFIG_SYS_CACHELINE_SIZE, qsize * entry_sz);
+	if (!q->base)
+		return -ENOMEM;
+	q->entry_sz = entry_sz;
+	q->qsize = qsize;
+	q->alloc_sz = (size_t)qsize * entry_sz;
+	q->iova = (dma_addr_t)(q->base);
+	debug("NIX: qmem alloc for (%d * %d = %ld bytes) at %p\n",
+	       q->qsize, q->entry_sz, q->alloc_sz, q->base);
+	return 0;
+}
+
+void qmem_free(struct qmem *q)
+{
+	if (q->base)
+		free(q->base);
+	memset(q, 0, sizeof(*q));
+}
+
+/**
+ * Allocates an admin queue for instructions and results
+ *
+ * @param	aq	admin queue to allocate for
+ * @param	qsize	Number of entries in the queue
+ * @param	inst_size	Size of each instruction
+ * @param	res_size	Size of each result
+ *
+ * @return	-ENOMEM on error, 0 on success
+ */
+int rvu_aq_alloc(struct admin_queue *aq, unsigned qsize,
+		      size_t inst_size, size_t res_size)
+{
+	int err;
+
+	err = qmem_alloc(&aq->inst, qsize, inst_size);
+	if (err)
+		return err;
+	err = qmem_alloc(&aq->res, qsize, res_size);
+	if (err)
+		qmem_free(&aq->inst);
+
+	return err;
+}
+
+/**
+ * Frees an admin queue
+ *
+ * @param	aq	Admin queue to free
+ */
+void rvu_aq_free(struct admin_queue *aq)
+{
+	qmem_free(&aq->inst);
+	qmem_free(&aq->res);
+	memset(aq, 0, sizeof(*aq));
+}
+
diff --git a/drivers/net/octeontx2/rvu_pf.c b/drivers/net/octeontx2/rvu_pf.c
new file mode 100644
index 0000000..99d1a12
--- /dev/null
+++ b/drivers/net/octeontx2/rvu_pf.c
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#include <common.h>
+#include <net.h>
+#include <malloc.h>
+#include <dm.h>
+#include <misc.h>
+#include <asm/io.h>
+#include <errno.h>
+#include <asm/types.h>
+#include <asm/arch/octeontx2.h>
+#include "cgx.h"
+#include "nix.h"
+
+extern struct udevice *rvu_af_dev;
+
+int rvu_pf_init(struct rvu_pf *rvu)
+{
+	struct nix *nix;
+	struct eth_pdata *pdata = dev_get_platdata(rvu->dev);
+
+	debug("%s: Allocating nix lf\n", __func__);
+	nix = nix_lf_alloc(rvu->dev);
+	if (!nix) {
+		printf("%s: Error allocating lf for pf %d\n",
+		       __func__, rvu->pfid);
+		return -1;
+	}
+	rvu->nix = nix;
+
+	/* to make post_probe happy */
+	if (is_valid_ethaddr(nix->lmac->mac_addr)) {
+		memcpy(pdata->enetaddr, nix->lmac->mac_addr, 6);
+		eth_env_set_enetaddr_by_index("eth", rvu->dev->seq,
+					      pdata->enetaddr);
+	}
+
+	return 0;
+}
+
+static const struct eth_ops nix_eth_ops = {
+	.start			= nix_lf_init,
+	.send			= nix_lf_xmit,
+	.recv			= nix_lf_recv,
+	.free_pkt		= nix_lf_free_pkt,
+	.stop			= nix_lf_halt,
+	.write_hwaddr		= nix_lf_setup_mac,
+	.read_rom_hwaddr	= nix_lf_read_rom_mac,
+};
+
+int rvu_pf_probe(struct udevice *dev)
+{
+	struct rvu_pf *rvu = dev_get_priv(dev);
+	size_t size;
+	int err;
+	char name[16];
+
+	debug("%s: name: %s\n", __func__, dev->name);
+
+	rvu->pf_base = dm_pci_map_bar(dev, 2, &size, PCI_REGION_MEM);
+	rvu->pfid = dev->seq + 1; // RVU PF's start from 1;
+	rvu->dev = dev;
+	if (!rvu_af_dev) {
+		printf("%s: Error: Could not find RVU AF device\n",
+		       __func__);
+		return -1;
+	}
+	rvu->afdev = rvu_af_dev;
+
+	debug("RVU PF %u BAR2 %p\n", rvu->pfid, rvu->pf_base);
+
+	rvu_get_lfid_for_pf(rvu->pfid, &rvu->nix_lfid,
+				 &rvu->npa_lfid);
+
+	err = rvu_pf_init(rvu);
+	if (err)
+		printf("%s: Error %d adding nix\n", __func__, err);
+
+	/*
+	 * modify device name to include index/sequence number,
+	 * for better readability, this is 1:1 mapping with eth0/1/2.. names.
+	 */
+	sprintf(name, "rvu_pf#%d", dev->seq);
+	device_set_name(dev, name);
+	debug("%s: name: %s\n", __func__, dev->name);
+	return err;
+}
+
+int rvu_pf_remove(struct udevice *dev)
+{
+	struct rvu_pf *rvu = dev_get_priv(dev);
+
+	nix_lf_shutdown(rvu->nix);
+	npa_lf_shutdown(rvu->nix);
+
+	debug("%s: rvu pf%d down -- \n", __func__,  rvu->pfid);
+
+	return 0;
+}
+
+static const struct udevice_id rvu_pf_ids[] = {
+        { .compatible = "cavium,rvu-pf" },
+        {}
+};
+
+U_BOOT_DRIVER(rvu_pf) = {
+        .name   = "rvu_pf",
+        .id     = UCLASS_ETH,
+        .of_match = rvu_pf_ids,
+        .probe  = rvu_pf_probe,
+        .remove = rvu_pf_remove,
+	.ops    = &nix_eth_ops,
+        .priv_auto_alloc_size = sizeof(struct rvu_pf),
+	.platdata_auto_alloc_size = sizeof(struct eth_pdata),
+};
+
+static struct pci_device_id rvu_pf_supported[] = {
+        { PCI_VDEVICE(CAVIUM, PCI_DEVID_OCTEONTX2_RVU_PF) },
+        {}
+};
+
+U_BOOT_PCI_DEVICE(rvu_pf, rvu_pf_supported);
+
diff --git a/drivers/net/phy/Kconfig b/drivers/net/phy/Kconfig
index 7fd4a8d..d108217 100644
--- a/drivers/net/phy/Kconfig
+++ b/drivers/net/phy/Kconfig
@@ -5,6 +5,15 @@ config BITBANGMII
 config MV88E6352_SWITCH
 	bool "Marvell 88E6352 switch support"
 
+config MV88E6XXX_SWITCH
+	bool "Marvel 88E6xxx switch support"
+	select PHYLIB
+	help
+	  Initialize peridot(MV88E6390/290/190) and topaz(MV88E6341/141)
+	  switches connected to SOC. This driver provide basic functionality
+	  like switch info, read/write switch and phy registers, get link
+	  status etc.
+
 menuconfig PHYLIB
 	bool "Ethernet PHY (physical media interface) support"
 	depends on NET
diff --git a/drivers/net/phy/Makefile b/drivers/net/phy/Makefile
index f198037..e07bc26 100644
--- a/drivers/net/phy/Makefile
+++ b/drivers/net/phy/Makefile
@@ -9,6 +9,7 @@ obj-$(CONFIG_BITBANGMII) += miiphybb.o
 obj-$(CONFIG_B53_SWITCH) += b53.o
 obj-$(CONFIG_MV88E61XX_SWITCH) += mv88e61xx.o
 obj-$(CONFIG_MV88E6352_SWITCH) += mv88e6352.o
+obj-$(CONFIG_MV88E6XXX_SWITCH) += mv88e6xxx.o
 
 obj-$(CONFIG_PHYLIB) += phy.o
 obj-$(CONFIG_PHYLIB_10G) += generic_10g.o
@@ -32,3 +33,4 @@ obj-$(CONFIG_PHY_XILINX) += xilinx_phy.o
 obj-$(CONFIG_PHY_VITESSE) += vitesse.o
 obj-$(CONFIG_PHY_MSCC) += mscc.o
 obj-$(CONFIG_PHY_FIXED) += fixed.o
+obj-$(CONFIG_CMD_MVEBU_PHY_FW_DOWNLOAD) += mvebu_fw_download.o
diff --git a/drivers/net/phy/marvell.c b/drivers/net/phy/marvell.c
index 2932340..79152ea 100644
--- a/drivers/net/phy/marvell.c
+++ b/drivers/net/phy/marvell.c
@@ -6,8 +6,10 @@
  * Copyright 2010-2011 Freescale Semiconductor, Inc.
  * author Andy Fleming
  */
+
 #include <config.h>
 #include <common.h>
+#include <console.h>
 #include <errno.h>
 #include <phy.h>
 
@@ -104,6 +106,19 @@
 #define MIIM_88E151x_MODE_SGMII		1
 #define MIIM_88E151x_RESET_OFFS		15
 
+/* 88E2110 PHY defines */
+#define MIIM_88E2110_PHY_STATUS		0x8008
+#define MIIM_88E2110_PHYSTAT_SPEED	0xc000
+#define MIIM_88E2110_PHYSTAT_10GBIT	0xc000
+#define MIIM_88E2110_PHYSTAT_GBIT	0x8000
+#define MIIM_88E2110_PHYSTAT_100	0x4000
+#define MIIM_88E2110_PHYSTAT_DUPLEX	0x2000
+#define MIIM_88E2110_PHYSTAT_SPDDONE	0x0800
+#define MIIM_88E2110_PHYSTAT_LINK	0x0400
+#define MIIM_88E2110_PHYSTAT_SPEED_5G	0x000c
+#define MIIM_88E2110_PHYSTAT_5GBIT	0x0008
+#define MIIM_88E2110_PHYSTAT_2_5GBIT	0x0004
+
 static int m88e1xxx_phy_extread(struct phy_device *phydev, int addr,
 				int devaddr, int regnum)
 {
@@ -333,7 +348,7 @@ static int m88e1518_config(struct phy_device *phydev)
 	 * As per Marvell Release Notes - Alaska 88E1510/88E1518/88E1512
 	 * /88E1514 Rev A0, Errata Section 3.1
 	 */
-
+	debug("%s(%s)\n", __func__, phydev->dev->name);
 	/* EEE initialization */
 	phy_write(phydev, MDIO_DEVAD_NONE, MIIM_88E1118_PHY_PAGE, 0x00ff);
 	phy_write(phydev, MDIO_DEVAD_NONE, 17, 0x214B);
@@ -406,6 +421,7 @@ static int m88e1518_config(struct phy_device *phydev)
 /* Marvell 88E1510 */
 static int m88e1510_config(struct phy_device *phydev)
 {
+	debug("%s(%s)\n", __func__, phydev->dev->name);
 	/* Select page 3 */
 	phy_write(phydev, MDIO_DEVAD_NONE, MIIM_88E1118_PHY_PAGE,
 		  MIIM_88E1118_PHY_LED_PAGE);
@@ -426,8 +442,72 @@ static int m88e1510_config(struct phy_device *phydev)
 
 	/* Reset page selection */
 	phy_write(phydev, MDIO_DEVAD_NONE, MIIM_88E1118_PHY_PAGE, 0);
+	debug("%s: interface mode: %s\n", __func__,
+	      phy_string_for_interface(phydev->interface));
+	/* SGMII-to-Copper mode initialization (88E1512 & 88E1514 only) */
+	if (phydev->interface == PHY_INTERFACE_MODE_SGMII) {
+		/* Select page 18 */
+		phy_write(phydev, MDIO_DEVAD_NONE, 22, 18);
+
+		/* In reg 20, write MODE[2:0] = 0x1 (SGMII to Copper) */
+		m88e1518_phy_writebits(phydev, 20, 0, 3, 1);
+
+		/* PHY reset is necessary after changing MODE[2:0] */
+		m88e1518_phy_writebits(phydev, 20, 15, 1, 1);
+
+		/* Reset page selection */
+		phy_write(phydev, MDIO_DEVAD_NONE, 22, 0);
+	} else if (phydev->interface == PHY_INTERFACE_MODE_RGMII      ||
+		   phydev->interface == PHY_INTERFACE_MODE_RGMII_ID   ||
+		   phydev->interface == PHY_INTERFACE_MODE_RGMII_RXID ||
+		   phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID) {
+		/* RGMII-to-Copper mode initialization */
+
+		/* Select page 2 */
+		phy_write(phydev, MDIO_DEVAD_NONE, 22, 2);
+		/* Set rx and tx delay as needed */
+		switch (phydev->interface) {
+		default:
+		case PHY_INTERFACE_MODE_RGMII:	/* no delay */
+			m88e1518_phy_writebits(phydev, 21, 4, 2, 0);
+			break;
+		case PHY_INTERFACE_MODE_RGMII_ID:	/* delay both */
+			m88e1518_phy_writebits(phydev, 21, 4, 2, 3);
+			break;
+		case PHY_INTERFACE_MODE_RGMII_RXID:	/* delay rx */
+			m88e1518_phy_writebits(phydev, 21, 4, 2, 2);
+			break;
+		case PHY_INTERFACE_MODE_RGMII_TXID:	/* delay tx */
+			m88e1518_phy_writebits(phydev, 21, 4, 2, 1);
+			break;
+		}
+		/* Select page 18 */
+		phy_write(phydev, MDIO_DEVAD_NONE, 22, 18);
+
+		/* In reg 20, write MODE[2:0] = 0x1 (RGMII to Copper) */
+		m88e1518_phy_writebits(phydev, 20, 0, 3, 0);
+
+		/* PHY reset is necessary after changing MODE[2:0] */
+		m88e1518_phy_writebits(phydev, 20, 15, 1, 1);
+
+		/* Reset page selection */
+		phy_write(phydev, MDIO_DEVAD_NONE, 22, 0);
+	} else {
+		printf("%s(%s): Error: unsupported mode %s\n", __func__,
+		       phydev->dev->name,
+		       phy_string_for_interface(phydev->interface));
+		return -1;
+	}
 
-	return m88e1518_config(phydev);
+	udelay(100);
+
+	/* soft reset */
+	phy_reset(phydev);
+
+	genphy_config_aneg(phydev);
+	genphy_restart_aneg(phydev);
+
+	return 0;
 }
 
 /* Marvell 88E1118 */
@@ -617,6 +697,185 @@ static int m88e1680_config(struct phy_device *phydev)
 	return 0;
 }
 
+/* Marvell 88E2110 */
+static int m88e2110_probe(struct phy_device *phydev)
+{
+	/*
+	 * skip reset since phy has its own initial value.
+	 * resettting leads to weird behavior
+	 */
+	phydev->flags |= PHY_FLAG_BROKEN_RESET;
+
+	return 0;
+}
+
+static int m88e2110_config(struct phy_device *phydev)
+{
+	u16 reg;
+
+	/* Perform lane swap */
+	reg = phy_read(phydev, 1, 0xc000);
+	reg |= 0x1;
+	phy_write(phydev, 1, 0xc000, reg);
+
+	/* Configure auto-negotiation advertisement */
+	if (phydev->interface == PHY_INTERFACE_MODE_SFI) {
+		/* Disabled 10G advertisement */
+		phy_write(phydev, 7, 0x20, 0x1e1);
+	} else {
+		if (phydev->interface == PHY_INTERFACE_MODE_SGMII_2500) {
+			/* Disabled 10G/5G advertisements */
+			phy_write(phydev, 7, 0x20, 0xa1);
+		} else {
+			/* Disable 10G/5G/2.5G auto-negotiation advertisement */
+			phy_write(phydev, 7, 0x20, 0x1);
+		}
+	}
+
+	/* Restart auto-negotiation */
+	phy_write(phydev, 7, 0, 0x3200);
+
+	return 0;
+}
+
+/* Parse the 88E2110's status register for speed and duplex
+ * information
+ */
+static uint m88e2110_parse_status(struct phy_device *phydev)
+{
+	unsigned int speed;
+	unsigned int mii_reg;
+
+	mii_reg = phy_read(phydev, 3, MIIM_88E2110_PHY_STATUS);
+
+	if ((mii_reg & MIIM_88E2110_PHYSTAT_LINK) &&
+	    !(mii_reg & MIIM_88E2110_PHYSTAT_SPDDONE)) {
+		int i = 0;
+
+		puts("Waiting for PHY realtime link");
+		while (!(mii_reg & MIIM_88E2110_PHYSTAT_SPDDONE)) {
+			/* Timeout reached ? */
+			if (i > PHY_AUTONEGOTIATE_TIMEOUT) {
+				puts(" TIMEOUT !\n");
+				phydev->link = 0;
+				break;
+			}
+
+			if ((i++ % 1000) == 0)
+				putc('.');
+			udelay(1000);
+			mii_reg = phy_read(phydev, 3, MIIM_88E2110_PHY_STATUS);
+		}
+		puts(" done\n");
+		mdelay(500);	/* another 500 ms (results in faster booting) */
+	} else {
+		if (mii_reg & MIIM_88E2110_PHYSTAT_LINK)
+			phydev->link = 1;
+		else
+			phydev->link = 0;
+	}
+
+	if (mii_reg & MIIM_88E2110_PHYSTAT_DUPLEX)
+		phydev->duplex = DUPLEX_FULL;
+	else
+		phydev->duplex = DUPLEX_HALF;
+
+	speed = mii_reg & MIIM_88E2110_PHYSTAT_SPEED;
+
+	switch (speed) {
+	case MIIM_88E2110_PHYSTAT_10GBIT:
+		switch (mii_reg & MIIM_88E2110_PHYSTAT_SPEED_5G) {
+		case MIIM_88E2110_PHYSTAT_5GBIT:
+			phydev->speed = SPEED_5000;
+			break;
+		case MIIM_88E2110_PHYSTAT_2_5GBIT:
+			phydev->speed = SPEED_2500;
+			break;
+		default:
+			puts(" Unknown speed detected\n");
+			break;
+		}
+	case MIIM_88E2110_PHYSTAT_GBIT:
+		phydev->speed = SPEED_1000;
+		break;
+	case MIIM_88E2110_PHYSTAT_100:
+		phydev->speed = SPEED_100;
+		break;
+	default:
+		phydev->speed = SPEED_10;
+		break;
+	}
+
+	return 0;
+}
+
+static int m88e2110_update_link(struct phy_device *phydev)
+{
+	unsigned int mii_reg;
+
+	/*
+	 * Wait if the link is up, and autonegotiation is in progress
+	 * (ie - we're capable and it's not done)
+	 */
+	mii_reg = phy_read(phydev, 7, MII_BMSR);
+
+	/*
+	 * If we already saw the link up, and it hasn't gone down, then
+	 * we don't need to wait for autoneg again
+	 */
+	if (phydev->link && mii_reg & BMSR_LSTATUS)
+		return 0;
+
+	if ((mii_reg & BMSR_ANEGCAPABLE) && !(mii_reg & BMSR_ANEGCOMPLETE)) {
+		int i = 0;
+
+		debug("%s Waiting for PHY auto negotiation to complete",
+		      phydev->drv->name);
+		while (!(mii_reg & BMSR_ANEGCOMPLETE)) {
+			/*
+			 * Timeout reached ?
+			 */
+			if (i > PHY_ANEG_TIMEOUT) {
+				debug(" TIMEOUT !\n");
+				phydev->link = 0;
+				return 0;
+			}
+
+			if (ctrlc()) {
+				puts("user interrupt!\n");
+				phydev->link = 0;
+				return -EINTR;
+			}
+
+			if ((i++ % 500) == 0)
+				debug(".");
+
+			udelay(1000);	/* 1 ms */
+			mii_reg = phy_read(phydev, 7, MII_BMSR);
+		}
+		debug(" done\n");
+		phydev->link = 1;
+	} else {
+		/* Read the link a second time to clear the latched state */
+		mii_reg = phy_read(phydev, 7, MII_BMSR);
+
+		if (mii_reg & BMSR_LSTATUS)
+			phydev->link = 1;
+		else
+			phydev->link = 0;
+	}
+
+	return 0;
+}
+
+static int m88e2110_startup(struct phy_device *phydev)
+{
+	m88e2110_update_link(phydev);
+	m88e2110_parse_status(phydev);
+
+	return 0;
+}
+
 static struct phy_driver M88E1011S_driver = {
 	.name = "Marvell 88E1011S",
 	.uid = 0x1410c60,
@@ -736,6 +995,17 @@ static struct phy_driver M88E1680_driver = {
 	.shutdown = &genphy_shutdown,
 };
 
+static struct phy_driver M88E2110_driver = {
+	.name = "Marvell 88E2110",
+	.uid = 0x2b09b8,
+	.mask = 0xffffff0,
+	.features = PHY_GBIT_FEATURES,
+	.probe = &m88e2110_probe,
+	.config = &m88e2110_config,
+	.startup = &m88e2110_startup,
+	.shutdown = &genphy_shutdown,
+};
+
 int phy_marvell_init(void)
 {
 	phy_register(&M88E1310_driver);
@@ -749,6 +1019,7 @@ int phy_marvell_init(void)
 	phy_register(&M88E1510_driver);
 	phy_register(&M88E1518_driver);
 	phy_register(&M88E1680_driver);
+	phy_register(&M88E2110_driver);
 
 	return 0;
 }
diff --git a/drivers/net/phy/mv88e6xxx.c b/drivers/net/phy/mv88e6xxx.c
new file mode 100644
index 0000000..e58669d
--- /dev/null
+++ b/drivers/net/phy/mv88e6xxx.c
@@ -0,0 +1,604 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include "mv88e6xxx.h"
+/* If the switch's ADDR[4:0] strap pins are strapped to zero, it will
+ * use all 32 SMI bus addresses on its SMI bus, and all switch registers
+ * will be directly accessible on some {device address,register address}
+ * pair.  If the ADDR[4:0] pins are not strapped to zero, the switch
+ * will only respond to SMI transactions to that specific address, and
+ * an indirect addressing mechanism needs to be used to access its
+ * registers.
+ */
+
+static struct mv88e6xxx_dev soho_dev;
+static struct mv88e6xxx_dev *soho_dev_handle;
+static int REG_PORT_BASE = REG_PORT_BASE_UNDEFINED;
+
+static int mv88e6xxx_reg_wait_ready(struct mv88e6xxx_dev *dev)
+{
+	int ret;
+	int i;
+	int loop_timeout = 16;
+	unsigned short val;
+	const char *name = miiphy_get_current_dev();
+
+	if (!name)
+		return -ENXIO;
+
+	for (i = 0; i < loop_timeout; i++) {
+		ret = miiphy_read(name, dev->phy_addr, SMI_CMD, &val);
+		if (ret < 0)
+			return ret;
+		if ((val & SMI_CMD_BUSY) == 0)
+			return 0;
+	}
+
+	return -ETIMEDOUT;
+}
+
+int mv88e6xxx_read_register(struct mv88e6xxx_dev *dev, int port, int reg)
+{
+	int ret;
+	unsigned short val;
+	const char *name = miiphy_get_current_dev();
+
+	if (!name)
+		return -ENXIO;
+
+	if (!dev)
+		return -ENODEV;
+
+	if (dev->addr_mode == 0) {
+		ret = miiphy_read(name, port, reg, &val);
+		if (ret < 0)
+			return ret;
+		else
+			return (int)val;
+	}
+
+	/* Wait for the bus to become free. */
+	ret = mv88e6xxx_reg_wait_ready(dev);
+	if (ret < 0)
+		return ret;
+
+	/* Transmit the read command. */
+	ret = miiphy_write(
+		name, dev->phy_addr, SMI_CMD,
+		SMI_CMD_OP_22_READ |
+		((port & SMI_CMD_DEV_ADDR_MASK) << SMI_CMD_DEV_ADDR_SIZE) |
+		(reg & SMI_CMD_REG_ADDR_MASK));
+	if (ret < 0)
+		return ret;
+
+	/* Wait for the read command to complete. */
+	ret = mv88e6xxx_reg_wait_ready(dev);
+	if (ret < 0)
+		return ret;
+
+	/* Read the data. */
+	ret = miiphy_read(name, dev->phy_addr, SMI_DATA, &val);
+	if (ret < 0)
+		return ret;
+
+	return (int)val;
+}
+
+int mv88e6xxx_write_register(struct mv88e6xxx_dev *dev, int port, int reg,
+			     unsigned short val)
+{
+	int ret;
+	const char *name = miiphy_get_current_dev();
+
+	if (!name)
+		return -ENXIO;
+
+	if (!dev)
+		return -ENODEV;
+
+	if (dev->addr_mode == 0)
+		return miiphy_write(name, port, reg, val);
+
+	/* Wait for the bus to become free. */
+	ret = mv88e6xxx_reg_wait_ready(dev);
+	if (ret < 0)
+		return ret;
+
+	/* Transmit data to write. */
+	ret = miiphy_write(name, dev->phy_addr, SMI_DATA, val);
+	if (ret < 0)
+		return ret;
+
+	/* Transmit the write command. */
+	ret = miiphy_write(
+		name, dev->phy_addr, SMI_CMD,
+		SMI_CMD_OP_22_WRITE |
+		((port & SMI_CMD_DEV_ADDR_MASK) << SMI_CMD_DEV_ADDR_SIZE) |
+		(reg & SMI_CMD_REG_ADDR_MASK));
+	if (ret < 0)
+		return ret;
+
+	/* Wait for the read command to complete. */
+	ret = mv88e6xxx_reg_wait_ready(dev);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int mv88e6xxx_reg_wait_ready_indirect(struct mv88e6xxx_dev *dev)
+{
+	int ret, i;
+	int loop_timeout = 16;
+
+	for (i = 0; i < loop_timeout; i++) {
+		ret = mv88e6xxx_read_register(dev, REG_GLOBAL2, GLOBAL2_SMI_OP);
+		if (ret < 0)
+			return ret;
+		if (!(ret & GLOBAL2_SMI_OP_BUSY))
+			return 0;
+	}
+	return -ETIMEDOUT;
+}
+
+static int mv88e6xxx_read_indirect(struct mv88e6xxx_dev *dev, int port, int reg)
+{
+	int ret;
+
+	ret = mv88e6xxx_write_register(
+		dev, REG_GLOBAL2, GLOBAL2_SMI_OP,
+		GLOBAL2_SMI_OP_22_READ |
+		((port & SMI_CMD_DEV_ADDR_MASK) << SMI_CMD_DEV_ADDR_SIZE) |
+		(reg & SMI_CMD_REG_ADDR_MASK));
+	if (ret < 0)
+		return ret;
+
+	ret = mv88e6xxx_reg_wait_ready_indirect(dev);
+	if (ret < 0)
+		return ret;
+
+	ret = mv88e6xxx_read_register(dev, REG_GLOBAL2, GLOBAL2_SMI_DATA);
+
+	return ret;
+}
+
+static int mv88e6xxx_write_indirect(struct mv88e6xxx_dev *dev, int port,
+				    int reg, unsigned short val)
+{
+	int ret;
+
+	ret = mv88e6xxx_write_register(dev, REG_GLOBAL2, GLOBAL2_SMI_DATA, val);
+	if (ret < 0)
+		return ret;
+
+	ret = mv88e6xxx_write_register(
+		dev, REG_GLOBAL2, GLOBAL2_SMI_OP,
+		GLOBAL2_SMI_OP_22_WRITE |
+		((port & SMI_CMD_DEV_ADDR_MASK) << SMI_CMD_DEV_ADDR_SIZE) |
+		(reg & SMI_CMD_REG_ADDR_MASK));
+
+	return mv88e6xxx_reg_wait_ready_indirect(dev);
+}
+
+int mv88e6xxx_read_phy_register(struct mv88e6xxx_dev *dev, int port, int page,
+				int reg)
+{
+	int ret;
+
+	if (!dev)
+		return -ENODEV;
+
+	ret = mv88e6xxx_write_indirect(dev, port, SMI_PHY_PAGE_REG, page);
+	if (ret < 0)
+		goto restore_page_0;
+
+	ret = mv88e6xxx_read_indirect(dev, port, reg);
+
+restore_page_0:
+	mv88e6xxx_write_indirect(dev, port, SMI_PHY_PAGE_REG, 0x0);
+
+	return ret;
+}
+
+int mv88e6xxx_write_phy_register(struct mv88e6xxx_dev *dev, int port, int page,
+				 int reg, unsigned short val)
+{
+	int ret;
+
+	if (!dev) {
+		printf("Soho dev not initialized\n");
+		return -1;
+	}
+
+	ret = mv88e6xxx_write_indirect(dev, port, SMI_PHY_PAGE_REG, page);
+	if (ret < 0)
+		goto restore_page_0;
+
+	ret = mv88e6xxx_write_indirect(dev, port, reg, val);
+
+restore_page_0:
+	mv88e6xxx_write_indirect(dev, port, SMI_PHY_PAGE_REG, 0x0);
+
+	return ret;
+}
+
+void mv88e6xxx_display_switch_info(struct mv88e6xxx_dev *dev)
+{
+	unsigned int product_num;
+
+	if (dev->id < 0) {
+		printf("No Switch Device Found\n");
+		return;
+	}
+
+	product_num = ((unsigned int)dev->id) >> 4;
+	if (product_num == PORT_SWITCH_ID_PROD_NUM_6390 ||
+	    product_num == PORT_SWITCH_ID_PROD_NUM_6390X ||
+	    product_num == PORT_SWITCH_ID_PROD_NUM_6290 ||
+	    product_num == PORT_SWITCH_ID_PROD_NUM_6190) {
+		printf("Switch    : SOHO\n");
+		printf("Series    : Peridot\n");
+		printf("Product # : %X\n", product_num);
+		printf("Revision  : %X\n", dev->id & 0xf);
+		if (dev->cpu_port != -1)
+			printf("Cpu port  : %d\n", dev->cpu_port);
+	} else if (product_num == PORT_SWITCH_ID_PROD_NUM_6141 ||
+		   product_num == PORT_SWITCH_ID_PROD_NUM_6341) {
+		printf("Switch    : SOHO\n");
+		printf("Series    : Topaz\n");
+		printf("Product # : %X\n", product_num);
+		printf("Revision  : %X\n", dev->id & 0xf);
+		if (dev->cpu_port != -1)
+			printf("Cpu port  : %d\n", dev->cpu_port);
+	} else {
+		printf("Unknown switch with Device ID: 0x%X\n", dev->id);
+	}
+}
+
+/* We expect the switch to perform auto negotiation if there is a real phy. */
+int mv88e6xxx_get_link_status(struct mv88e6xxx_dev *dev, int port)
+{
+	int ret;
+
+	ret = mv88e6xxx_read_register(dev, REG_PORT(port), PORT_STATUS);
+	if (ret < 0)
+		return ret;
+
+	printf("Port: 0x%X, ", port);
+	if (ret & PORT_STATUS_LINK) {
+		printf("Link: UP, ");
+	} else {
+		printf("Link: Down\n");
+		return 0;
+	}
+
+	if (ret & PORT_STATUS_DUPLEX)
+		printf("Duplex: FULL, ");
+	else
+		printf("Duplex: HALF, ");
+
+	if ((ret & PORT_STATUS_SPEED_MASK) == PORT_STATUS_SPEED_10)
+		printf("Speed: 10 Mbps\n");
+	else if ((ret & PORT_STATUS_SPEED_MASK) == PORT_STATUS_SPEED_100)
+		printf("Speed: 100 Mbps\n");
+	else if ((ret & PORT_STATUS_SPEED_MASK) == PORT_STATUS_SPEED_1000)
+		printf("Speed: 1000 Mbps\n");
+	else if ((ret & PORT_STATUS_SPEED_MASK) == PORT_STATUS_SPEED_2500_10G)
+		printf("Speed: 10 Gb or 2500 Mbps\n");
+	else
+		printf("Speed: Unknown\n");
+
+	return 0;
+}
+
+int mv88e6xxx_get_switch_id(struct mv88e6xxx_dev *dev)
+{
+	int id, product_num;
+
+	/* Peridot switch port device address starts from 0
+	 * Legacy switch port device address starts from 0x10
+	 *
+	 * In order to determine which switch is used, we need to
+	 * read the ID, but inorder to read the ID, we need to know
+	 * the port device address - classic chicken or the egg case.
+	 *
+	 * Let's read with both port device addresses, if we get 0xFFFF,
+	 * the address is incorrect and we need to ready with the second
+	 * address.
+	 */
+	id = mv88e6xxx_read_register(dev, REG_PORT_BASE_LEGACY, PORT_SWITCH_ID);
+	if (id == 0xFFFF)
+		id = mv88e6xxx_read_register(dev, REG_PORT_BASE_PERIDOT,
+					     PORT_SWITCH_ID);
+
+	if (id < 0)
+		return id;
+
+	product_num = id >> 4;
+	if ((product_num == PORT_SWITCH_ID_PROD_NUM_6190) ||
+	    (product_num == PORT_SWITCH_ID_PROD_NUM_6290) ||
+	    (product_num == PORT_SWITCH_ID_PROD_NUM_6390) ||
+	    (product_num == PORT_SWITCH_ID_PROD_NUM_6390X)) {
+		/* Peridot switch port device address starts from 0 */
+		REG_PORT_BASE = REG_PORT_BASE_PERIDOT;
+		return id;
+	} else if (product_num == PORT_SWITCH_ID_PROD_NUM_6141 ||
+		   product_num == PORT_SWITCH_ID_PROD_NUM_6341) {
+		/* Legacy switch port device address starts from 0x10 */
+		REG_PORT_BASE = REG_PORT_BASE_LEGACY;
+		return id;
+	} else {
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+int mv88e6xxx_initialize(const void *blob)
+{
+	int node = 0;
+	int ret;
+	int port;
+
+	soho_dev_handle = NULL;
+
+	/* Read Device Tree */
+	node = fdt_node_offset_by_compatible(blob, -1, "marvell,mv88e6xxx");
+
+	if (node == -FDT_ERR_NOTFOUND)
+		return -ENXIO;
+
+	/* Check whether switch node is enabled */
+	ret = fdtdec_get_is_enabled(blob, node);
+	if (ret == 0)
+		return -EACCES;
+
+	/* Initizalize Switch Device Structure */
+	soho_dev.phy_addr = fdtdec_get_uint(blob, node, "phy-addr", 0);
+	soho_dev.port_mask = fdtdec_get_int(blob, node, "port-mask", 0);
+	if (soho_dev.phy_addr == 0)
+		soho_dev.addr_mode = 0;  /* Single Addressing mode */
+	else
+		soho_dev.addr_mode = 1;  /* Multi Addressing mode */
+
+	soho_dev.id = mv88e6xxx_get_switch_id(&soho_dev);
+
+	soho_dev.cpu_port = fdtdec_get_int(blob, node, "cpu-port", -1);
+	if (soho_dev.cpu_port != -1) {
+		u16 reg;
+
+		/* For 88e6390X switch we need to configure C_MODE field
+		 * in Port Status Register to 0xb (2500 base-x).
+		 * NOTE: Port Status Register is generally RO, but it can
+		 * be written for port9 and port10 (cpu ports).
+		 */
+		if ((soho_dev.id >> 4) == PORT_SWITCH_ID_PROD_NUM_6390X) {
+			reg = mv88e6xxx_read_register(
+				&soho_dev, REG_PORT(soho_dev.cpu_port),
+				PORT_STATUS);
+			reg &= ~PORT_STATUS_CMODE_MASK;
+			reg |= PORT_STATUS_CMODE_2500BASE_X;
+			ret = mv88e6xxx_write_register(
+				&soho_dev, REG_PORT(soho_dev.cpu_port),
+				PORT_STATUS, reg);
+		} else {
+			reg = mv88e6xxx_read_register(
+				&soho_dev, REG_PORT(soho_dev.cpu_port),
+				PORT_PCS_CTRL);
+			/* CPU port is forced link-up, duplex and 1GB speed */
+			reg &= ~PORT_PCS_CTRL_UNFORCED;
+			reg |= PORT_PCS_CTRL_FORCE_LINK |
+			       PORT_PCS_CTRL_LINK_UP |
+			       PORT_PCS_CTRL_DUPLEX_FULL |
+			       PORT_PCS_CTRL_FORCE_DUPLEX |
+			       PORT_PCS_CTRL_1000;
+
+			if ((soho_dev.id >> 4) ==
+			    PORT_SWITCH_ID_PROD_NUM_6341) {
+				/* Configure RGMII Delay on cpu port */
+				reg |= PORT_PCS_CTRL_FORCE_SPEED |
+				       PORT_PCS_CTRL_RGMII_DELAY_TXCLK |
+				       PORT_PCS_CTRL_RGMII_DELAY_RXCLK;
+			}
+
+			ret = mv88e6xxx_write_register(
+				&soho_dev, REG_PORT(soho_dev.cpu_port),
+				PORT_PCS_CTRL, reg);
+		}
+
+		if (ret)
+			return ret;
+	}
+
+	/* Force port setup */
+	for (port = 0; port < sizeof(soho_dev.port_mask) * 8; port++) {
+		if (!(soho_dev.port_mask & BIT(port)))
+			continue;
+
+		/* Set port control register */
+		mv88e6xxx_write_register(&soho_dev,
+					 REG_PORT(port),
+					 PORT_CONTROL,
+					 PORT_CONTROL_STATE_FORWARDING |
+					 PORT_CONTROL_FORWARD_UNKNOWN |
+					 PORT_CONTROL_FORWARD_UNKNOWN_MC |
+					 PORT_CONTROL_USE_TAG |
+					 PORT_CONTROL_USE_IP |
+					 PORT_CONTROL_TAG_IF_BOTH);
+		/* Set port based vlan table */
+		mv88e6xxx_write_register(&soho_dev,
+					 REG_PORT(port),
+					 PORT_BASE_VLAN,
+					 soho_dev.port_mask & ~BIT(port));
+
+		if (port == soho_dev.cpu_port)
+			continue;
+
+		/* Set phy copper control for lan ports */
+		mv88e6xxx_write_phy_register(&soho_dev,
+					     REG_PORT(port),
+					     0,
+					     PHY_COPPER_CONTROL,
+					     PHY_COPPER_CONTROL_SPEED_1G |
+					     PHY_COPPER_CONTROL_DUPLEX |
+					     PHY_COPPER_CONTROL_AUTO_NEG_EN);
+	}
+
+	soho_dev_handle = &soho_dev;
+
+	return 0;
+}
+
+static int sw_resolve_options(char *str)
+{
+	if (strcmp(str, "info") == 0)
+		return SW_INFO;
+	else if (strcmp(str, "read") == 0)
+		return SW_READ;
+	else if (strcmp(str, "write") == 0)
+		return SW_WRITE;
+	else if (strcmp(str, "phy_read") == 0)
+		return SW_PHY_READ;
+	else if (strcmp(str, "phy_write") == 0)
+		return SW_PHY_WRITE;
+	else if (strcmp(str, "link") == 0)
+		return SW_LINK;
+	else
+		return SW_NA;
+}
+
+static int do_sw(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	struct mv88e6xxx_dev *dev;
+	int port, reg, page, val = 0, ret = 0;
+
+	dev = soho_dev_handle;
+
+	if (!dev) {
+		printf("Switch Device not found\n");
+		return -ENODEV;
+	}
+
+	switch (sw_resolve_options(argv[1])) {
+	case SW_INFO:
+		mv88e6xxx_display_switch_info(dev);
+		break;
+	case SW_READ:
+		if (argc < 4) {
+			printf("Syntax Error: switch read <port> <reg>\n");
+			return 1;
+		}
+		port = (int)simple_strtoul(argv[2], NULL, 16);
+		reg  = (int)simple_strtoul(argv[3], NULL, 16);
+		ret = mv88e6xxx_read_register(dev, REG_PORT(port), reg);
+		if (ret < 0) {
+			printf("Failed: Read  - switch port: 0x%X, ", port);
+			printf("reg: 0x%X, ret: %d\n", reg, ret);
+		} else {
+			printf("Read - switch port: 0x%X, ", port);
+			printf("reg: 0x%X, val: 0x%X\n", reg, ret);
+		}
+		break;
+
+	case SW_WRITE:
+		if (argc < 5) {
+			printf("Syntax Error: ");
+			printf("switch write <port> <reg> <val>\n");
+			return 1;
+		}
+		port = (int)simple_strtoul(argv[2], NULL, 16);
+		reg  = (int)simple_strtoul(argv[3], NULL, 16);
+		val  = (int)simple_strtoul(argv[4], NULL, 16);
+		ret = mv88e6xxx_write_register(dev, REG_PORT(port), reg,
+					       (unsigned short)val);
+		if (ret < 0) {
+			printf("Failed: Write - switch port: 0x%X, ", port);
+			printf("reg: 0x%X, val: 0x%X, ret: %d\n",
+			       reg, val, ret);
+		} else {
+			printf("Read  - switch port: 0x%X, ", port);
+			printf("reg: 0x%X, val: 0x%X\n",
+			       reg, val);
+		}
+		break;
+
+	case SW_PHY_READ:
+		if (argc < 5) {
+			printf("Syntax Error: ");
+			printf("switch phy_read <port> <page> <reg>\n");
+			return 1;
+		}
+		port = (int)simple_strtoul(argv[2], NULL, 16);
+		page = (int)simple_strtoul(argv[3], NULL, 16);
+		reg  = (int)simple_strtoul(argv[4], NULL, 16);
+		ret = mv88e6xxx_read_phy_register(dev, REG_PORT(port),
+						  page, reg);
+		if (ret < 0) {
+			printf("Failed: Read - switch port: 0x%X, ", port);
+			printf("page: 0x%X, reg: 0x%X\n, ret: %d",
+			       page, reg, ret);
+		} else {
+			printf("Read - switch port: 0x%X, ", port);
+			printf("page: 0x%X, reg: 0x%X, val: 0x%X\n",
+			       page, reg, ret);
+		}
+		break;
+
+	case SW_PHY_WRITE:
+		if (argc < 6) {
+			printf("Syntax Error: ");
+			printf("switch phy_write <port> <page> <reg> <val>\n");
+			return 1;
+		}
+		port = (int)simple_strtoul(argv[2], NULL, 16);
+		page = (int)simple_strtoul(argv[3], NULL, 16);
+		reg  = (int)simple_strtoul(argv[4], NULL, 16);
+		val  = (int)simple_strtoul(argv[5], NULL, 16);
+		ret = mv88e6xxx_write_phy_register(dev, REG_PORT(port),
+						   page, reg,
+						   (unsigned short)val);
+		if (ret < 0) {
+			printf("Failed: Write - switch port: 0x%X, ", port);
+			printf("page: 0x%X, reg: 0x%X, val: 0x%X, ret: %d\n",
+			       page, reg, val, ret);
+		} else {
+			printf("Read - switch port: 0x%X, ", port);
+			printf("page: 0x%X, reg: 0x%X, val: 0x%X\n",
+			       page, reg, val);
+		}
+		break;
+
+	case SW_LINK:
+		if (argc < 3) {
+			printf("Error: Too few arguments\n");
+			return 1;
+		}
+		port = (int)simple_strtoul(argv[2], NULL, 16);
+		ret = mv88e6xxx_get_link_status(dev, port);
+		break;
+
+	case SW_NA:
+		printf("\"switch %s\" - Wrong command. Try \"help switch\"\n",
+		       argv[1]);
+
+	default:
+		break;
+	}
+	return 0;
+}
+
+/***************************************************/
+U_BOOT_CMD(
+	switch,	6,	1,	do_sw,
+	"Switch Access commands",
+	"switch info - Display switch information\n"
+	"switch read <port> <reg> - read switch register <reg> of a <port>\n"
+	"switch write <port> <reg> <val> - write <val> to switch register <reg> of a <port>\n"
+	"switch phy_read <port> <page> <reg> - read internal switch phy register <reg> at <page> of a switch <port>\n"
+	"switch phy_write <port> <page> <reg> <val>- write <val> to internal phy register at <page> of a <port>\n"
+	"switch link <port> - Display link state and speed of a <port>\n"
+);
diff --git a/drivers/net/phy/mv88e6xxx.h b/drivers/net/phy/mv88e6xxx.h
new file mode 100644
index 0000000..481e664
--- /dev/null
+++ b/drivers/net/phy/mv88e6xxx.h
@@ -0,0 +1,394 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#ifndef _MV88E6XXX_H__
+#define _MV88E6XXX_H__
+
+#include <asm/io.h>
+#include <command.h>
+#include <common.h>
+#include <config.h>
+#include <config/arch/mvebu.h>
+#include <fdtdec.h>
+#include <fdt.h>
+#include <linux/compat.h>
+#include <linux/mbus.h>
+#include <malloc.h>
+#include <miiphy.h>
+#include <net.h>
+#include <netdev.h>
+#include <pci.h>
+#include <phy.h>
+#include <watchdog.h>
+
+#define SMI_CMD					0x00
+#define SMI_CMD_BUSY				BIT(15)
+#define SMI_CMD_CLAUSE_22			BIT(12)
+#define SMI_CMD_OP_22_WRITE			\
+			((1 << 10) | SMI_CMD_BUSY | SMI_CMD_CLAUSE_22)
+#define SMI_CMD_OP_22_READ			\
+			((2 << 10) | SMI_CMD_BUSY | SMI_CMD_CLAUSE_22)
+#define SMI_CMD_OP_45_WRITE_ADDR		((0 << 10) | SMI_CMD_BUSY)
+#define SMI_CMD_OP_45_WRITE_DATA		((1 << 10) | SMI_CMD_BUSY)
+#define SMI_CMD_OP_45_READ_DATA			((2 << 10) | SMI_CMD_BUSY)
+#define SMI_CMD_OP_45_READ_DATA_INC		((3 << 10) | SMI_CMD_BUSY)
+#define SMI_CMD_DEV_ADDR_MASK			0x1f
+#define SMI_CMD_DEV_ADDR_SIZE			5
+#define SMI_CMD_REG_ADDR_MASK			0x1f
+#define SMI_DATA				0x01
+
+#define SMI_PHY_PAGE_REG			0x16
+
+/* Fiber/SERDES Registers are located at SMI address F, page 1 */
+#define REG_FIBER_SERDES			0x0f
+#define PAGE_FIBER_SERDES			0x01
+
+#define REG_PORT_BASE_UNDEFINED			0xFFFF
+#define REG_PORT_BASE_LEGACY			0x10
+#define REG_PORT_BASE_PERIDOT			0
+#define REG_PORT(p)				(REG_PORT_BASE + (p))
+#define PORT_STATUS				0x00
+#define PORT_STATUS_PAUSE_EN			BIT(15)
+#define PORT_STATUS_MY_PAUSE			BIT(14)
+#define PORT_STATUS_HD_FLOW			BIT(13)
+#define PORT_STATUS_PHY_DETECT			BIT(12)
+#define PORT_STATUS_LINK			BIT(11)
+#define PORT_STATUS_DUPLEX			BIT(10)
+#define PORT_STATUS_SPEED_MASK			0x0300
+#define PORT_STATUS_SPEED_10			0x0000
+#define PORT_STATUS_SPEED_100			0x0100
+#define PORT_STATUS_SPEED_1000			0x0200
+#define PORT_STATUS_SPEED_2500_10G		0x0300
+#define PORT_STATUS_EEE				BIT(6) /* 6352 */
+#define PORT_STATUS_AM_DIS			BIT(6) /* 6165 */
+#define PORT_STATUS_MGMII			BIT(6) /* 6185 */
+#define PORT_STATUS_TX_PAUSED			BIT(5)
+#define PORT_STATUS_FLOW_CTRL			BIT(4)
+#define PORT_STATUS_CMODE_MASK			0x0f
+#define PORT_STATUS_CMODE_100BASE_X		0x8
+#define PORT_STATUS_CMODE_1000BASE_X		0x9
+#define PORT_STATUS_CMODE_SGMII			0xa
+#define PORT_STATUS_CMODE_2500BASE_X		0xb
+#define PORT_PCS_CTRL				0x01
+#define PORT_PCS_CTRL_RGMII_DELAY_RXCLK		BIT(15)
+#define PORT_PCS_CTRL_RGMII_DELAY_TXCLK		BIT(14)
+#define PORT_PCS_CTRL_FORCE_SPEED		BIT(13)
+#define PORT_PCS_CTRL_FC			BIT(7)
+#define PORT_PCS_CTRL_FORCE_FC			BIT(6)
+#define PORT_PCS_CTRL_LINK_UP			BIT(5)
+#define PORT_PCS_CTRL_FORCE_LINK		BIT(4)
+#define PORT_PCS_CTRL_DUPLEX_FULL		BIT(3)
+#define PORT_PCS_CTRL_FORCE_DUPLEX		BIT(2)
+#define PORT_PCS_CTRL_10			0x00
+#define PORT_PCS_CTRL_100			0x01
+#define PORT_PCS_CTRL_1000			0x02
+#define PORT_PCS_CTRL_UNFORCED			0x03
+#define PORT_PAUSE_CTRL				0x02
+#define PORT_SWITCH_ID				0x03
+
+#define PORT_SWITCH_ID_PROD_NUM_6190		0x190
+#define PORT_SWITCH_ID_PROD_NUM_6290		0x290
+#define PORT_SWITCH_ID_PROD_NUM_6390		0x390
+#define PORT_SWITCH_ID_PROD_NUM_6390X		0x0a1
+#define PORT_SWITCH_ID_PROD_NUM_6141		0x141
+#define PORT_SWITCH_ID_PROD_NUM_6341		0x341
+
+#define PORT_CONTROL				0x04
+#define PORT_CONTROL_USE_CORE_TAG		BIT(15)
+#define PORT_CONTROL_DROP_ON_LOCK		BIT(14)
+#define PORT_CONTROL_EGRESS_UNMODIFIED		(0x0 << 12)
+#define PORT_CONTROL_EGRESS_UNTAGGED		(0x1 << 12)
+#define PORT_CONTROL_EGRESS_TAGGED		(0x2 << 12)
+#define PORT_CONTROL_EGRESS_ADD_TAG		(0x3 << 12)
+#define PORT_CONTROL_HEADER			BIT(11)
+#define PORT_CONTROL_IGMP_MLD_SNOOP		BIT(10)
+#define PORT_CONTROL_DOUBLE_TAG			BIT(9)
+#define PORT_CONTROL_FRAME_MODE_NORMAL		(0x0 << 8)
+#define PORT_CONTROL_FRAME_MODE_DSA		(0x1 << 8)
+#define PORT_CONTROL_FRAME_MODE_PROVIDER	(0x2 << 8)
+#define PORT_CONTROL_FRAME_ETHER_TYPE_DSA	(0x3 << 8)
+#define PORT_CONTROL_DSA_TAG			BIT(8)
+#define PORT_CONTROL_VLAN_TUNNEL		BIT(7)
+#define PORT_CONTROL_TAG_IF_BOTH		BIT(6)
+#define PORT_CONTROL_USE_IP			BIT(5)
+#define PORT_CONTROL_USE_TAG			BIT(4)
+#define PORT_CONTROL_FORWARD_UNKNOWN_MC		BIT(3)
+#define PORT_CONTROL_FORWARD_UNKNOWN		BIT(2)
+#define PORT_CONTROL_STATE_MASK			0x03
+#define PORT_CONTROL_STATE_DISABLED		0x00
+#define PORT_CONTROL_STATE_BLOCKING		0x01
+#define PORT_CONTROL_STATE_LEARNING		0x02
+#define PORT_CONTROL_STATE_FORWARDING		0x03
+#define PORT_CONTROL_1				0x05
+#define PORT_CONTROL_1_FID_11_4_MASK		(0xff << 0)
+#define PORT_BASE_VLAN				0x06
+#define PORT_BASE_VLAN_FID_3_0_MASK		(0xf << 12)
+#define PORT_DEFAULT_VLAN			0x07
+#define PORT_DEFAULT_VLAN_MASK			0xfff
+#define PORT_CONTROL_2				0x08
+#define PORT_CONTROL_2_IGNORE_FCS		BIT(15)
+#define PORT_CONTROL_2_VTU_PRI_OVERRIDE		BIT(14)
+#define PORT_CONTROL_2_SA_PRIO_OVERRIDE		BIT(13)
+#define PORT_CONTROL_2_DA_PRIO_OVERRIDE		BIT(12)
+#define PORT_CONTROL_2_JUMBO_1522		(0x00 << 12)
+#define PORT_CONTROL_2_JUMBO_2048		(0x01 << 12)
+#define PORT_CONTROL_2_JUMBO_10240		(0x02 << 12)
+#define PORT_CONTROL_2_8021Q_MASK		(0x03 << 10)
+#define PORT_CONTROL_2_8021Q_DISABLED		(0x00 << 10)
+#define PORT_CONTROL_2_8021Q_FALLBACK		(0x01 << 10)
+#define PORT_CONTROL_2_8021Q_CHECK		(0x02 << 10)
+#define PORT_CONTROL_2_8021Q_SECURE		(0x03 << 10)
+#define PORT_CONTROL_2_DISCARD_TAGGED		BIT(9)
+#define PORT_CONTROL_2_DISCARD_UNTAGGED		BIT(8)
+#define PORT_CONTROL_2_MAP_DA			BIT(7)
+#define PORT_CONTROL_2_DEFAULT_FORWARD		BIT(6)
+#define PORT_CONTROL_2_FORWARD_UNKNOWN		BIT(6)
+#define PORT_CONTROL_2_EGRESS_MONITOR		BIT(5)
+#define PORT_CONTROL_2_INGRESS_MONITOR		BIT(4)
+#define PORT_RATE_CONTROL			0x09
+#define PORT_RATE_CONTROL_2			0x0a
+#define PORT_ASSOC_VECTOR			0x0b
+#define PORT_ASSOC_VECTOR_HOLD_AT_1		BIT(15)
+#define PORT_ASSOC_VECTOR_INT_AGE_OUT		BIT(14)
+#define PORT_ASSOC_VECTOR_LOCKED_PORT		BIT(13)
+#define PORT_ASSOC_VECTOR_IGNORE_WRONG		BIT(12)
+#define PORT_ASSOC_VECTOR_REFRESH_LOCKED	BIT(11)
+#define PORT_ATU_CONTROL			0x0c
+#define PORT_PRI_OVERRIDE			0x0d
+#define PORT_ETH_TYPE				0x0f
+#define PORT_IN_DISCARD_LO			0x10
+#define PORT_IN_DISCARD_HI			0x11
+#define PORT_IN_FILTERED			0x12
+#define PORT_OUT_FILTERED			0x13
+#define PORT_TAG_REGMAP_0123			0x18
+#define PORT_TAG_REGMAP_4567			0x19
+
+#define REG_GLOBAL				0x1b
+#define GLOBAL_STATUS				0x00
+#define GLOBAL_STATUS_PPU_STATE			BIT(15) /* 6351 and 6171 */
+/* Two bits for 6165, 6185 etc */
+#define GLOBAL_STATUS_PPU_MASK			(0x3 << 14)
+#define GLOBAL_STATUS_PPU_DISABLED_RST		(0x0 << 14)
+#define GLOBAL_STATUS_PPU_INITIALIZING		(0x1 << 14)
+#define GLOBAL_STATUS_PPU_DISABLED		(0x2 << 14)
+#define GLOBAL_STATUS_PPU_POLLING		(0x3 << 14)
+#define GLOBAL_MAC_01				0x01
+#define GLOBAL_MAC_23				0x02
+#define GLOBAL_MAC_45				0x03
+#define GLOBAL_ATU_FID				0x01 /* 6097 6165 6351 6352 */
+#define GLOBAL_VTU_FID				0x02 /* 6097 6165 6351 6352 */
+#define GLOBAL_VTU_FID_MASK			0xfff
+#define GLOBAL_VTU_SID				0x03 /* 6097 6165 6351 6352 */
+#define GLOBAL_VTU_SID_MASK			0x3f
+#define GLOBAL_CONTROL				0x04
+#define GLOBAL_CONTROL_SW_RESET			BIT(15)
+#define GLOBAL_CONTROL_PPU_ENABLE		BIT(14)
+#define GLOBAL_CONTROL_DISCARD_EXCESS		BIT(13) /* 6352 */
+#define GLOBAL_CONTROL_SCHED_PRIO		BIT(11) /* 6152 */
+#define GLOBAL_CONTROL_MAX_FRAME_1632		BIT(10) /* 6152 */
+#define GLOBAL_CONTROL_RELOAD_EEPROM		BIT(9)	/* 6152 */
+#define GLOBAL_CONTROL_DEVICE_EN		BIT(7)
+#define GLOBAL_CONTROL_STATS_DONE_EN		BIT(6)
+#define GLOBAL_CONTROL_VTU_PROBLEM_EN		BIT(5)
+#define GLOBAL_CONTROL_VTU_DONE_EN		BIT(4)
+#define GLOBAL_CONTROL_ATU_PROBLEM_EN		BIT(3)
+#define GLOBAL_CONTROL_ATU_DONE_EN		BIT(2)
+#define GLOBAL_CONTROL_TCAM_EN			BIT(1)
+#define GLOBAL_CONTROL_EEPROM_DONE_EN		BIT(0)
+#define GLOBAL_VTU_OP				0x05
+#define GLOBAL_VTU_OP_BUSY			BIT(15)
+#define GLOBAL_VTU_OP_FLUSH_ALL			\
+					((0x01 << 12) | GLOBAL_VTU_OP_BUSY)
+#define GLOBAL_VTU_OP_VTU_LOAD_PURGE		\
+					((0x03 << 12) | GLOBAL_VTU_OP_BUSY)
+#define GLOBAL_VTU_OP_VTU_GET_NEXT		\
+					((0x04 << 12) | GLOBAL_VTU_OP_BUSY)
+#define GLOBAL_VTU_OP_STU_LOAD_PURGE		\
+					((0x05 << 12) | GLOBAL_VTU_OP_BUSY)
+#define GLOBAL_VTU_OP_STU_GET_NEXT		\
+					((0x06 << 12) | GLOBAL_VTU_OP_BUSY)
+#define GLOBAL_VTU_VID				0x06
+#define GLOBAL_VTU_VID_MASK			0xfff
+#define GLOBAL_VTU_VID_VALID			BIT(12)
+#define GLOBAL_VTU_DATA_0_3			0x07
+#define GLOBAL_VTU_DATA_4_7			0x08
+#define GLOBAL_VTU_DATA_8_11			0x09
+#define GLOBAL_VTU_STU_DATA_MASK		0x03
+#define GLOBAL_VTU_DATA_MEMBER_TAG_UNMODIFIED	0x00
+#define GLOBAL_VTU_DATA_MEMBER_TAG_UNTAGGED	0x01
+#define GLOBAL_VTU_DATA_MEMBER_TAG_TAGGED	0x02
+#define GLOBAL_VTU_DATA_MEMBER_TAG_NON_MEMBER	0x03
+#define GLOBAL_STU_DATA_PORT_STATE_DISABLED	0x00
+#define GLOBAL_STU_DATA_PORT_STATE_BLOCKING	0x01
+#define GLOBAL_STU_DATA_PORT_STATE_LEARNING	0x02
+#define GLOBAL_STU_DATA_PORT_STATE_FORWARDING	0x03
+#define GLOBAL_ATU_CONTROL			0x0a
+#define GLOBAL_ATU_CONTROL_LEARN2ALL		BIT(3)
+#define GLOBAL_ATU_OP				0x0b
+#define GLOBAL_ATU_OP_BUSY			BIT(15)
+#define GLOBAL_ATU_OP_NOP			(0 << 12)
+#define GLOBAL_ATU_OP_FLUSH_MOVE_ALL		\
+					((1 << 12) | GLOBAL_ATU_OP_BUSY)
+#define GLOBAL_ATU_OP_FLUSH_MOVE_NON_STATIC	\
+					((2 << 12) | GLOBAL_ATU_OP_BUSY)
+#define GLOBAL_ATU_OP_LOAD_DB			\
+					((3 << 12) | GLOBAL_ATU_OP_BUSY)
+#define GLOBAL_ATU_OP_GET_NEXT_DB		\
+					((4 << 12) | GLOBAL_ATU_OP_BUSY)
+#define GLOBAL_ATU_OP_FLUSH_MOVE_ALL_DB		\
+					((5 << 12) | GLOBAL_ATU_OP_BUSY)
+#define GLOBAL_ATU_OP_FLUSH_MOVE_NON_STATIC_DB	\
+					((6 << 12) | GLOBAL_ATU_OP_BUSY)
+#define GLOBAL_ATU_OP_GET_CLR_VIOLATION		\
+					((7 << 12) | GLOBAL_ATU_OP_BUSY)
+#define GLOBAL_ATU_DATA				0x0c
+#define GLOBAL_ATU_DATA_TRUNK			BIT(15)
+#define GLOBAL_ATU_DATA_TRUNK_ID_MASK		0x00f0
+#define GLOBAL_ATU_DATA_TRUNK_ID_SHIFT		4
+#define GLOBAL_ATU_DATA_PORT_VECTOR_MASK	0x3ff0
+#define GLOBAL_ATU_DATA_PORT_VECTOR_SHIFT	4
+#define GLOBAL_ATU_DATA_STATE_MASK		0x0f
+#define GLOBAL_ATU_DATA_STATE_UNUSED		0x00
+#define GLOBAL_ATU_DATA_STATE_UC_MGMT		0x0d
+#define GLOBAL_ATU_DATA_STATE_UC_STATIC		0x0e
+#define GLOBAL_ATU_DATA_STATE_UC_PRIO_OVER	0x0f
+#define GLOBAL_ATU_DATA_STATE_MC_NONE_RATE	0x05
+#define GLOBAL_ATU_DATA_STATE_MC_STATIC		0x07
+#define GLOBAL_ATU_DATA_STATE_MC_MGMT		0x0e
+#define GLOBAL_ATU_DATA_STATE_MC_PRIO_OVER	0x0f
+#define GLOBAL_ATU_MAC_01			0x0d
+#define GLOBAL_ATU_MAC_23			0x0e
+#define GLOBAL_ATU_MAC_45			0x0f
+#define GLOBAL_IP_PRI_0				0x10
+#define GLOBAL_IP_PRI_1				0x11
+#define GLOBAL_IP_PRI_2				0x12
+#define GLOBAL_IP_PRI_3				0x13
+#define GLOBAL_IP_PRI_4				0x14
+#define GLOBAL_IP_PRI_5				0x15
+#define GLOBAL_IP_PRI_6				0x16
+#define GLOBAL_IP_PRI_7				0x17
+#define GLOBAL_IEEE_PRI				0x18
+#define GLOBAL_CORE_TAG_TYPE			0x19
+#define GLOBAL_MONITOR_CONTROL			0x1a
+#define GLOBAL_MONITOR_CONTROL_INGRESS_SHIFT	12
+#define GLOBAL_MONITOR_CONTROL_EGRESS_SHIFT	8
+#define GLOBAL_MONITOR_CONTROL_ARP_SHIFT	4
+#define GLOBAL_MONITOR_CONTROL_MIRROR_SHIFT	0
+#define GLOBAL_MONITOR_CONTROL_ARP_DISABLED	(0xf0)
+#define GLOBAL_CONTROL_2			0x1c
+#define GLOBAL_CONTROL_2_NO_CASCADE		0xe000
+#define GLOBAL_CONTROL_2_MULTIPLE_CASCADE	0xf000
+
+#define GLOBAL_STATS_OP			0x1d
+#define GLOBAL_STATS_OP_BUSY		BIT(15)
+#define GLOBAL_STATS_OP_NOP		(0 << 12)
+#define GLOBAL_STATS_OP_FLUSH_ALL	((1 << 12) | GLOBAL_STATS_OP_BUSY)
+#define GLOBAL_STATS_OP_FLUSH_PORT	((2 << 12) | GLOBAL_STATS_OP_BUSY)
+#define GLOBAL_STATS_OP_READ_CAPTURED	((4 << 12) | GLOBAL_STATS_OP_BUSY)
+#define GLOBAL_STATS_OP_CAPTURE_PORT	((5 << 12) | GLOBAL_STATS_OP_BUSY)
+#define GLOBAL_STATS_OP_HIST_RX		((1 << 10) | GLOBAL_STATS_OP_BUSY)
+#define GLOBAL_STATS_OP_HIST_TX		((2 << 10) | GLOBAL_STATS_OP_BUSY)
+#define GLOBAL_STATS_OP_HIST_RX_TX	((3 << 10) | GLOBAL_STATS_OP_BUSY)
+#define GLOBAL_STATS_OP_BANK_1		BIT(9)
+#define GLOBAL_STATS_COUNTER_32		0x1e
+#define GLOBAL_STATS_COUNTER_01		0x1f
+
+#define REG_GLOBAL2				0x1c
+#define GLOBAL2_INT_SOURCE			0x00
+#define GLOBAL2_INT_MASK			0x01
+#define GLOBAL2_MGMT_EN_2X			0x02
+#define GLOBAL2_MGMT_EN_0X			0x03
+#define GLOBAL2_FLOW_CONTROL			0x04
+#define GLOBAL2_SWITCH_MGMT			0x05
+#define GLOBAL2_SWITCH_MGMT_USE_DOUBLE_TAG_DATA	BIT(15)
+#define GLOBAL2_SWITCH_MGMT_PREVENT_LOOPS	BIT(14)
+#define GLOBAL2_SWITCH_MGMT_FLOW_CONTROL_MSG	BIT(13)
+#define GLOBAL2_SWITCH_MGMT_FORCE_FLOW_CTRL_PRI	BIT(7)
+#define GLOBAL2_SWITCH_MGMT_RSVD2CPU		BIT(3)
+#define GLOBAL2_DEVICE_MAPPING			0x06
+#define GLOBAL2_DEVICE_MAPPING_UPDATE		BIT(15)
+#define GLOBAL2_DEVICE_MAPPING_TARGET_SHIFT	8
+#define GLOBAL2_DEVICE_MAPPING_PORT_MASK	0x0f
+#define GLOBAL2_TRUNK_MASK			0x07
+#define GLOBAL2_TRUNK_MASK_UPDATE		BIT(15)
+#define GLOBAL2_TRUNK_MASK_NUM_SHIFT		12
+#define GLOBAL2_TRUNK_MAPPING			0x08
+#define GLOBAL2_TRUNK_MAPPING_UPDATE		BIT(15)
+#define GLOBAL2_TRUNK_MAPPING_ID_SHIFT		11
+#define GLOBAL2_INGRESS_OP			0x09
+#define GLOBAL2_INGRESS_DATA			0x0a
+#define GLOBAL2_PVT_ADDR			0x0b
+#define GLOBAL2_PVT_DATA			0x0c
+#define GLOBAL2_SWITCH_MAC			0x0d
+#define GLOBAL2_SWITCH_MAC_BUSY			BIT(15)
+#define GLOBAL2_ATU_STATS			0x0e
+#define GLOBAL2_PRIO_OVERRIDE			0x0f
+#define GLOBAL2_PRIO_OVERRIDE_FORCE_SNOOP	BIT(7)
+#define GLOBAL2_PRIO_OVERRIDE_SNOOP_SHIFT	4
+#define GLOBAL2_PRIO_OVERRIDE_FORCE_ARP		BIT(3)
+#define GLOBAL2_PRIO_OVERRIDE_ARP_SHIFT		0
+#define GLOBAL2_EEPROM_OP			0x14
+#define GLOBAL2_EEPROM_OP_BUSY			BIT(15)
+#define GLOBAL2_EEPROM_OP_WRITE			\
+		((3 << 12) | GLOBAL2_EEPROM_OP_BUSY)
+#define GLOBAL2_EEPROM_OP_READ			\
+		((4 << 12) | GLOBAL2_EEPROM_OP_BUSY)
+#define GLOBAL2_EEPROM_OP_LOAD			BIT(11)
+#define GLOBAL2_EEPROM_OP_WRITE_EN		BIT(10)
+#define GLOBAL2_EEPROM_OP_ADDR_MASK		0xff
+#define GLOBAL2_EEPROM_DATA			0x15
+#define GLOBAL2_PTP_AVB_OP			0x16
+#define GLOBAL2_PTP_AVB_DATA			0x17
+#define GLOBAL2_SMI_OP				0x18
+#define GLOBAL2_SMI_OP_BUSY			BIT(15)
+#define GLOBAL2_SMI_OP_CLAUSE_22		BIT(12)
+#define GLOBAL2_SMI_OP_22_WRITE			\
+		((1 << 10) | GLOBAL2_SMI_OP_BUSY | GLOBAL2_SMI_OP_CLAUSE_22)
+#define GLOBAL2_SMI_OP_22_READ			\
+		((2 << 10) | GLOBAL2_SMI_OP_BUSY | GLOBAL2_SMI_OP_CLAUSE_22)
+#define GLOBAL2_SMI_OP_45_WRITE_ADDR		\
+		((0 << 10) | GLOBAL2_SMI_OP_BUSY)
+#define GLOBAL2_SMI_OP_45_WRITE_DATA		\
+		((1 << 10) | GLOBAL2_SMI_OP_BUSY)
+#define GLOBAL2_SMI_OP_45_READ_DATA		\
+		((2 << 10) | GLOBAL2_SMI_OP_BUSY)
+#define GLOBAL2_SMI_DATA			0x19
+#define GLOBAL2_SCRATCH_MISC			0x1a
+#define GLOBAL2_SCRATCH_BUSY			BIT(15)
+#define GLOBAL2_SCRATCH_REGISTER_SHIFT		8
+#define GLOBAL2_SCRATCH_VALUE_MASK		0xff
+#define GLOBAL2_WDOG_CONTROL			0x1b
+#define GLOBAL2_QOS_WEIGHT			0x1c
+#define GLOBAL2_MISC				0x1d
+
+#define PHY_COPPER_CONTROL		0x0
+#define PHY_COPPER_CONTROL_SPEED_1G	BIT(6)
+#define PHY_COPPER_CONTROL_DUPLEX	BIT(8)
+#define PHY_COPPER_CONTROL_POWER_DOWN	BIT(11)
+#define PHY_COPPER_CONTROL_AUTO_NEG_EN	BIT(12)
+#define PHY_COPPER_CONTROL_SPEED_100M	BIT(13)
+
+struct mv88e6xxx_dev {
+	unsigned int phy_addr;
+	unsigned int port_mask;
+	unsigned int addr_mode;
+	int id;
+	int cpu_port;	/* The switch port to which the CPU is attached */
+};
+
+enum sw_opts {
+	SW_INFO,
+	SW_READ,
+	SW_WRITE,
+	SW_PHY_READ,
+	SW_PHY_WRITE,
+	SW_LINK,
+	SW_NA
+};
+
+#endif /* _MV88E6XXX_H__*/
+
diff --git a/drivers/net/phy/mvebu_fw_download.c b/drivers/net/phy/mvebu_fw_download.c
new file mode 100644
index 0000000..8850dee
--- /dev/null
+++ b/drivers/net/phy/mvebu_fw_download.c
@@ -0,0 +1,559 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#include <common.h>
+#include <miiphy.h>
+#include <asm/io.h>
+#include <linux/errno.h>
+
+#define MV_MAX_APP_SIZE			(216 * 1024UL)
+#define MV_HEADER_SIZE			32
+
+struct device_para {
+	u32 dev_id;
+	u32 dev_rev;
+	u32 mem_size;
+};
+
+enum device_errors {
+	MVEBU_FLASH_UPDATE_OK			=  0,
+	/* Slave code did not start */
+	MVEBU_SLAVE_CODE_DID_NOT_START		= -1,
+	/* Flash verified FAILED */
+	MVEBU_VERIFY_ERR			= -2,
+	/* Unknown error */
+	MVEBU_UNKNOWN_DOWNLOAD_TO_FLASH_FAIL	= -3,
+	/* Error reading or writing MDIO register */
+	MVEBU_IO_ERROR				= -4,
+	/*size must be an even number of bytes*/
+	MVEBU_SIZE_NOT_EVEN			= -5,
+	/* Slave encountered error while erasing flash */
+	MVEBU_ERR_ERASING_FLASH			= -6,
+	/* unexpected value read back from download code */
+	MVEBU_ERR_VALUE_READ_BACK		= -7,
+	/* Did not get MVEBU_SLAVE_OK for writing the data */
+	MVEBU_ERR_START_WRITE_DATA		= -8,
+	/* Slave failed to get all the data correctly*/
+	MVEBU_START_WRITE_DATA			= -9,
+	/* Some kind of error occurred on Slave */
+	MVEBU_ERR_ON_SLAVE			= -10,
+	/* Checksum error */
+	MVEBU_ERR_CHECKSUM			= -11,
+	/* Slave didn't write enough words to flash */
+	MVEBU_ERR_SLAVE_WRITE_FULL		= -12,
+	/* last transfer failed */
+	MVEBU_ERR_LAST_TRANSFER			= -13,
+	/* wrong checksum */
+	MVEBU_RAM_HW_CHECKSUM_ERR		= -14,
+	/* PHY wasn't waiting in download mode */
+	MVEBU_PHY_NOT_IN_DOWNLOAD_MODE		= -15,
+	MVEBU_IMAGE_TOO_LARGE_TO_DOWNLOAD	= -16,
+	MVEBU_ERR_GET_DEVICE			= -17,
+};
+
+#define MDIO_DEVICE_ADDRESS		1
+/* Master-Slave Protocol Definitions */
+#define MDIO_MAX_BUFF_SIZE		49192
+#define MDIO_ACTUAL_BUFF_SIZE		49193
+#define MDIO_COMMAND			49194
+#define MDIO_WORDS_WRITTEN		49195
+#define MDIO_LOW_ADDRESS		49196
+#define MDIO_HIGH_ADDRESS		49197
+#define MDIO_DATA			49198
+#define MDIO_CHECKSUM			49199
+#define MDIO_WORDS_RCVD			49200
+#define MDIO_NUM_SECTIONS		49202 /*0xC032*/
+/* Host Commands */
+#define MDIO_CMD_ERASE_FLASH		0x1
+#define MDIO_CMD_FILL_BUFFER		0x2
+#define MDIO_CMD_WRITE_BUFFER		0x6
+#define MDIO_CMD_VERIFY_FLASH		0x7
+/* Slave Responses */
+#define MDIO_CMD_SLV_OK			0x100
+#define MDIO_CMD_SLV_ERR		0x200
+#define MDIO_CMD_SLV_FLASH_BUSY		0x300
+#define MDIO_CMD_SLV_VERIFY_ERR		0x400
+/* 88X3240/3220 Device Number Definitions */
+#define MVEBU_T_UNIT_PMA_PMD		1
+#define MVEBU_T_UNIT_PCS_CU		3
+#define MVEBU_H_UNIT			4
+#define MVEBU_C_UNIT_GENERAL		31
+/* 88X3240/3220 T Unit Registers MMD 1 */
+#define MVEBU_BOOT_STATUS_REG		0xC050
+/* 88X3240/3220 C Unit Registers MMD 31 */
+#define MVEBU_CUNIT_MODE_CONFIG		0xF000
+#define MVEBU_CUNIT_PORT_CTRL		0xF001
+/* Internal PHY Registers for downloading to RAM */
+/* register to set the low part of the address */
+#define MVEBU_LOW_WORD_REG		0xD0F0
+/* register to set the hi part of the address */
+#define MVEBU_HI_WORD_REG		0xD0F1
+/* register to write or read to/from ram */
+#define MVEBU_RAM_DATA_REG		0xD0F2
+/* register to read the checksum from */
+#define MVEBU_RAM_CHECKSUM_REG		0xD0F3
+
+static u32 mvebu_get_reg_field_from_wrod(u16 data, u8 field_off, u8 field_len)
+{
+	u16 mask;
+
+	if ((field_len + field_off) >= 16)
+		mask = (0 - (1 << field_off));
+	else
+		mask = (((1 << (field_len + field_off))) - (1 << field_off));
+
+	return (data & mask) >> field_off;
+}
+
+static void mvebu_set_phy_reg_field(struct mii_dev *bus, u16 port, u16 dev,
+				    u16 reg_addr, u8 field_off, u8 field_len,
+				    u16 data)
+{
+	u16 reg, mask;
+
+	reg = bus->read(bus, port, dev, reg_addr);
+	/* Set register field to word */
+	if ((field_len + field_off) >= 16)
+		mask = (0 - (1 << field_off));
+	else
+		mask = (((1 << (field_len + field_off))) - (1 << field_off));
+	/* Set the desired bits to 0. */
+	reg &= ~mask;
+	/* Set the given data into the above reset bits. */
+	reg |= ((data << field_off) & mask);
+	bus->write(bus, port, dev, reg_addr, reg);
+}
+
+static void mvebu_phy_reset(struct mii_dev *bus, u16 port)
+{
+	mvebu_set_phy_reg_field(bus, port, MVEBU_C_UNIT_GENERAL,
+				MVEBU_CUNIT_PORT_CTRL, 12, 1, 1);
+}
+
+static u32 mvebu_flash_transfer(struct mii_dev *bus, u16 port, u8 data[],
+				u32 max_buff_size, u32 *byte_index, int error)
+{
+	u16 buf_checksum, tmp_checksum, reported_checksum;
+	u16 words_rcvd, words_written, reg;
+	u32 stop_index;
+
+	/* Set the flash start address*/
+	bus->write(bus, port, MDIO_DEVICE_ADDRESS,
+		   MDIO_LOW_ADDRESS, (u16)(*byte_index));
+	bus->write(bus, port, MDIO_DEVICE_ADDRESS,
+		   MDIO_HIGH_ADDRESS, (u16)((*byte_index) >> 16));
+	/* Set the size of the buffer we're going to send*/
+	bus->write(bus, port, MDIO_DEVICE_ADDRESS,
+		   MDIO_ACTUAL_BUFF_SIZE, (u16)(max_buff_size / 2));
+	/* Tell the slave we've written the start address and size */
+	/* and now we're going to start writing data*/
+	bus->write(bus, port, MDIO_DEVICE_ADDRESS,
+		   MDIO_COMMAND, MDIO_CMD_FILL_BUFFER);
+	/* Wait for MDIO_CMD_SLV_OK*/
+	if (error == MVEBU_ERR_LAST_TRANSFER) {
+		do {
+			reg = bus->read(bus, port,
+					MDIO_DEVICE_ADDRESS, MDIO_COMMAND);
+		} while (reg == MDIO_CMD_FILL_BUFFER);
+	} else {
+		do {
+			reg = bus->read(bus, port,
+					MDIO_DEVICE_ADDRESS, MDIO_COMMAND);
+		} while (reg == MDIO_CMD_ERASE_FLASH ||
+			 reg == MDIO_CMD_SLV_FLASH_BUSY);
+	}
+
+	if (reg != MDIO_CMD_SLV_OK)
+		return error;
+
+	/* Write a buffer of data to the slave RAM*/
+	stop_index = (*byte_index) + max_buff_size;
+	buf_checksum = 0;
+	while ((*byte_index) < stop_index) {
+		u16 value;
+
+		value = data[(*byte_index)++];
+		value |= (((u16)data[(*byte_index)++]) << 8);
+		buf_checksum += value;
+		bus->write(bus, port, MDIO_DEVICE_ADDRESS, MDIO_DATA, value);
+	}
+	if (error != MVEBU_ERR_LAST_TRANSFER) {
+		/* check and see if we can go on to the write*/
+		tmp_checksum = bus->read(bus, port,
+					 MDIO_DEVICE_ADDRESS, MDIO_CHECKSUM);
+		words_rcvd = bus->read(bus, port,
+				       MDIO_DEVICE_ADDRESS, MDIO_WORDS_RCVD);
+		if (tmp_checksum != buf_checksum ||
+		    words_rcvd != (u16)(max_buff_size / 2)) {
+			debug("ERROR: phy checksum=0x%x vs buf chksum 0x%x\n",
+			      tmp_checksum, buf_checksum);
+			return MVEBU_START_WRITE_DATA;
+		}
+	}
+
+	/* One full RAM buffer inside DSP is ready to write to flash now*/
+	/* Tell the slave to write it*/
+	bus->write(bus, port, MDIO_DEVICE_ADDRESS,
+		   MDIO_COMMAND, MDIO_CMD_WRITE_BUFFER);
+	if (error == MVEBU_ERR_LAST_TRANSFER)
+		debug("Waiting for slave to programe last buffer to flash\n");
+	else
+		debug("Waiting for slave to finish programming flash\n");
+
+	/* Wait for MDIO_CMD_SLV_OK */
+	do {
+		/*
+		 * This can take several 2-3 seconds, don't poll phy too
+		 * frequently since every read causes an interrupt on the phy.
+		 */
+		reg = bus->read(bus, port, MDIO_DEVICE_ADDRESS, MDIO_COMMAND);
+		mdelay(500);
+	} while (reg == MDIO_CMD_WRITE_BUFFER ||
+		 reg == MDIO_CMD_SLV_FLASH_BUSY);
+
+	if (reg != MDIO_CMD_SLV_OK) {
+		debug("ERROR: slave returns error 0x%x\n", reg);
+
+		if (reg == MDIO_CMD_SLV_VERIFY_ERR) {
+			reg = bus->read(bus, port, MDIO_DEVICE_ADDRESS,
+					MDIO_NUM_SECTIONS);
+			debug("ERROR: Verification failed on section nr %d\n",
+			      reg);
+		}
+
+		return error;
+	}
+
+	/* readback checksum of what was stored in flash */
+	reported_checksum = bus->read(bus, port,
+				      MDIO_DEVICE_ADDRESS, MDIO_CHECKSUM);
+	if (reported_checksum != buf_checksum)
+		return MVEBU_ERR_CHECKSUM;
+
+	words_written = bus->read(bus, port,
+				  MDIO_DEVICE_ADDRESS, MDIO_WORDS_WRITTEN);
+	if (words_written != (max_buff_size / 2))
+		return MVEBU_ERR_SLAVE_WRITE_FULL;
+
+	return 0;
+}
+
+/*
+ * This handles downloading an image pointed to by data which is size bytes
+ * long to the phy's flash interfacing with the slave code as a helper program.
+ * Size must be an even number (the flash can only be written to in words).
+ */
+static u32 mvebu_mdio_flash_download(struct mii_dev *bus, u16 port,
+				     u8 data[], u32 size)
+{
+	u32 max_buff_size, num_trans, last_trans_size, trans_index;
+	u32 byte_index = 0;
+	u16 reg;
+
+	/* size must be an even number of bytes */
+	if (size % 2)
+		return MVEBU_SIZE_NOT_EVEN;
+
+	/* first erase the flash*/
+	printf("Slave will now erase flash. This may take up to 30 seconds.\n");
+	bus->write(bus, port, MDIO_DEVICE_ADDRESS,
+		   MDIO_COMMAND, MDIO_CMD_ERASE_FLASH);
+	do {
+		reg = bus->read(bus, port, MDIO_DEVICE_ADDRESS, MDIO_COMMAND);
+	} while (reg == MDIO_CMD_ERASE_FLASH || reg == MDIO_CMD_SLV_FLASH_BUSY);
+
+	if (reg == MDIO_CMD_SLV_ERR)
+		return MVEBU_ERR_ERASING_FLASH;
+
+	if (reg != MDIO_CMD_SLV_OK)
+		return MVEBU_ERR_VALUE_READ_BACK;
+	printf("Flash program have been erased.\n");
+
+	/* read in the maximum buffer size from the slave */
+	max_buff_size = bus->read(bus, port,
+				  MDIO_DEVICE_ADDRESS, MDIO_MAX_BUFF_SIZE);
+	max_buff_size *= 2;
+	num_trans = size / max_buff_size;
+	last_trans_size = size % max_buff_size;
+
+	debug("trans num %d, max_buff_size %d, size %d, last trans size %d\n",
+	      num_trans, max_buff_size, size, last_trans_size);
+
+	/* handle all the full transfers */
+	for (trans_index = 0; trans_index < num_trans; trans_index++)
+		mvebu_flash_transfer(bus, port, data, max_buff_size,
+				     &byte_index, MVEBU_ERR_ON_SLAVE);
+
+	if (last_trans_size)
+		mvebu_flash_transfer(bus, port, data, last_trans_size,
+				     &byte_index, MVEBU_ERR_LAST_TRANSFER);
+
+	return 0;
+}
+
+/*
+ * This function downloads code to RAM in the DSP and then starts the
+ * application which was downloaded. "size" should be an even number
+ * (memory can only be written word-wise)
+ */
+static u32 mvebu_mdio_ram_download(struct mii_dev *bus, u8 data[],
+				   u32 size, u16 port, u8 ram_checksum_flag)
+{
+	u32 buff_count = 0;
+	u16 reg, ram_checksum, checksum = 0;
+	u8  low_byte, high_byte;
+
+	/* size must be an even number of bytes */
+	if (size % 2)
+		return MVEBU_SIZE_NOT_EVEN;
+
+	/* Put PHY in download mode and reset PHY */
+	mvebu_set_phy_reg_field(bus, port, MVEBU_C_UNIT_GENERAL,
+				0xF008, 5, 1, 1);
+	mvebu_phy_reset(bus, port);
+
+	/* Allow reset to complete */
+	mdelay(2500);
+
+	/*
+	 * Make sure we can access the PHY and it's in the correct mode
+	 * (waiting for download)
+	 */
+	reg = bus->read(bus, port,
+			MVEBU_T_UNIT_PMA_PMD, MVEBU_BOOT_STATUS_REG);
+	if (reg != 0x000A)
+		return MVEBU_PHY_NOT_IN_DOWNLOAD_MODE;
+
+	printf("Downloading code to PHY RAM, please wait...\n");
+	/* clear the checksum */
+	if (ram_checksum_flag)
+		bus->read(bus, port, MVEBU_T_UNIT_PCS_CU,
+			  MVEBU_RAM_CHECKSUM_REG);
+
+	/* Set starting address in RAM to 0x00100000 */
+	bus->write(bus, port, MVEBU_T_UNIT_PCS_CU, MVEBU_LOW_WORD_REG, 0);
+	bus->write(bus, port, MVEBU_T_UNIT_PCS_CU, MVEBU_HI_WORD_REG, 0x0010);
+
+	/*
+	 * Copy the code to the phy's internal RAM,
+	 * calculating checksum as we go.
+	 */
+	while (buff_count < size) {
+		low_byte = data[buff_count++];
+		high_byte = data[buff_count++];
+		checksum += (low_byte + high_byte);
+		bus->write(bus, port, MVEBU_T_UNIT_PCS_CU, MVEBU_RAM_DATA_REG,
+			   (((u16)high_byte) << 8) | low_byte);
+	}
+
+	if (ram_checksum_flag) {
+		ram_checksum = bus->read(bus, port, MVEBU_T_UNIT_PCS_CU,
+					 MVEBU_RAM_CHECKSUM_REG);
+		if (checksum != ram_checksum)
+			return MVEBU_RAM_HW_CHECKSUM_ERR;
+	}
+
+	/* Now start code which was downloaded */
+	mvebu_set_phy_reg_field(bus, port, MVEBU_T_UNIT_PMA_PMD,
+				MVEBU_BOOT_STATUS_REG, 6, 1, 1);
+	/* Give application code time to start */
+	mdelay(100);
+
+	return 0;
+}
+
+static u32 mvebu_get_device(struct mii_dev *bus, u16 port,
+			    struct device_para *dev_param)
+{
+	u16 reg3;
+	u16 model_num;
+	u16 rev_num;
+	u16 oui1, oui2;
+
+	/* Check if this is a Marvell PHY */
+	oui1 = bus->read(bus, port, 1, 2);
+	reg3 = bus->read(bus, port, 1, 3);
+	oui2 = mvebu_get_reg_field_from_wrod(reg3, 10, 6);
+	model_num = mvebu_get_reg_field_from_wrod(reg3, 4, 6);
+	rev_num = mvebu_get_reg_field_from_wrod(reg3, 0, 4);
+
+	debug("%s: OUI oui1 0x%x, oui2 0x%x, model_num 0x%x, rev_num 0x%x\n",
+	      __func__, oui1, oui2, model_num, rev_num);
+	/* Check if the PHY OUI belongs to Marvell */
+	if (!(oui1 == 0x141 && oui2 == 3) && !(oui1 == 0x2b && oui2 == 2))
+		return MVEBU_ERR_GET_DEVICE;
+
+	dev_param->dev_id = model_num;
+	dev_param->dev_rev = rev_num;
+	dev_param->mem_size = MV_MAX_APP_SIZE;
+
+	printf("device id = %x, device revision = %x, memory size = %x\n",
+	       dev_param->dev_id, dev_param->dev_rev, dev_param->mem_size);
+	return 0;
+}
+
+u32 mvebu_update_flash_image(struct mii_dev *bus, u16 port, u8 app_data[],
+			     u32 app_size, u8 salve_data[], u32 slave_size)
+{
+	struct device_para dev;
+	int error;
+	u32 data;
+
+	/*
+	 * All X32X0 have a ram checksum register, can change to 0 if wish to
+	 * ignore it for some reason (not advised but might want to for debug
+	 * purposes)
+	 */
+	u8 ram_checksum = 1;
+
+	error = mvebu_get_device(bus, port, &dev);
+	if (error < 0)
+		return error;
+
+	/* Check if the code can fit into the device's memory */
+	if (app_size > dev.mem_size + MV_HEADER_SIZE)
+		return MVEBU_IMAGE_TOO_LARGE_TO_DOWNLOAD;
+
+	/* Download slave code to PHY's RAM and start it */
+	error = mvebu_mdio_ram_download(bus, salve_data,
+					slave_size, port, ram_checksum);
+	if (error < 0)
+		return error;
+
+	/* make sure the slave code started */
+	data = bus->read(bus, port, MVEBU_T_UNIT_PMA_PMD,
+			 MVEBU_BOOT_STATUS_REG);
+	data = mvebu_get_reg_field_from_wrod(data, 4, 1);
+	if (!data)
+		return MVEBU_SLAVE_CODE_DID_NOT_START;
+
+	/* Write the image to flash */
+	error = mvebu_mdio_flash_download(bus, port, app_data, app_size);
+	if (error < 0)
+		return error;
+
+	/*
+	 * Using slave code to verify image.
+	 * This commands slave to read in entire flash image and calculate
+	 * checksum and make sure checksum matches the checksum in the header.
+	 * A failure means flash was corrupted.
+	 * Another method would be to reset the phy (with SPI_CONFIG[1]= 0)
+	 * and see that the new code starts successfully, since a bad checksum
+	 * will result in the code not being started
+	 */
+	printf("Flash programming complete. Verifying image via slave.\n");
+	bus->write(bus, port, MDIO_DEVICE_ADDRESS,
+		   MDIO_COMMAND, MDIO_CMD_VERIFY_FLASH);
+
+	do {
+		data = bus->read(bus, port, MDIO_DEVICE_ADDRESS, MDIO_COMMAND);
+		mdelay(100);
+	} while (data == MDIO_CMD_VERIFY_FLASH ||
+		 data == MDIO_CMD_SLV_FLASH_BUSY);
+
+	switch (data) {
+	case MDIO_CMD_SLV_OK:
+		printf("Flash image verified. ");
+		printf("Reset F_CFG1 to 0 and reboot to execute new code\n");
+		return MVEBU_FLASH_UPDATE_OK;
+	case MDIO_CMD_SLV_VERIFY_ERR:
+		return MVEBU_VERIFY_ERR;
+	default:
+		return MVEBU_UNKNOWN_DOWNLOAD_TO_FLASH_FAIL;
+	}
+
+	return MVEBU_UNKNOWN_DOWNLOAD_TO_FLASH_FAIL;
+}
+
+/*
+ * mvebu_phy_firmware_download: Update flash image in the PHY
+ *
+ * @port:	MDIO port address, 0-31
+ * @app_data:	application code to be downloaded in to the flash
+ * @app_size:	file size
+ * @slave_data:	slave code to be downloaded in to the RAM
+ * @slave_size:	file size of the slave code
+ * @returns 0 on success, error code otherwise.
+ */
+u32 mvebu_phy_firmware_download(u16 port, u8 app_data[],
+				u32 app_size, u8 salve_data[], u32 slave_size)
+{
+	struct mii_dev *bus;
+	int error;
+
+	printf("Ethernet transceiver PHY firmware download started:\n");
+	bus = mdio_get_current_dev();
+	if (!bus) {
+		pr_err("failed to detect MDIO bus\n");
+		return -1;
+	}
+
+	error = mvebu_update_flash_image(bus, port, app_data, app_size,
+					 salve_data, slave_size);
+	switch (error) {
+	case MVEBU_FLASH_UPDATE_OK:
+		printf("mvebu_update_flash_image succeeded\n");
+		break;
+	case MVEBU_ERR_GET_DEVICE:
+		printf("failed to read device id\n");
+		break;
+	case MVEBU_IMAGE_TOO_LARGE_TO_DOWNLOAD:
+		printf("image is larger than the device memory size\n");
+		break;
+	case MVEBU_SIZE_NOT_EVEN:
+		printf("size must be an even number of bytes\n");
+		break;
+	case MVEBU_VERIFY_ERR:
+		printf("Flash verified FAILED! ");
+		printf("Flash probably corrupted. Re-try download.\n");
+		break;
+	case MVEBU_SLAVE_CODE_DID_NOT_START:
+		printf("Slave download failed. Exiting...\n");
+		break;
+	case MVEBU_PHY_NOT_IN_DOWNLOAD_MODE:
+		printf("Download failed, ");
+		printf("PHY is not in waiting on download mode. ");
+		printf("Expected 0x000A\n");
+		break;
+	case MVEBU_RAM_HW_CHECKSUM_ERR:
+		printf("Error downloading code. ");
+		printf("Got another val from the Expected RAM HW checksum\n");
+		break;
+	case MVEBU_ERR_VALUE_READ_BACK:
+		printf("Unexpected response from PHY. Exiting...\n");
+		break;
+	case MVEBU_ERR_ON_SLAVE:
+		printf("Unexpected error occurred on slave. Exiting...\n");
+		break;
+	case MVEBU_ERR_LAST_TRANSFER:
+		printf("Unexpected error occurred last transfer. ");
+		printf("Exiting...\n");
+		break;
+	case MVEBU_START_WRITE_DATA:
+		printf("Slave failed to get all the data correctly\n");
+		break;
+	case MVEBU_ERR_SLAVE_WRITE_FULL:
+		printf("Slave didn't write enough words to flash. ");
+		printf("Exiting...\n");
+		break;
+	case MVEBU_UNKNOWN_DOWNLOAD_TO_FLASH_FAIL:
+	default:
+		printf("Unknown download to flash fail. Exiting...\n");
+		break;
+	}
+
+	if (error < 0) {
+		printf("Ethernet transceiver PHY firmware download failed.\n");
+		return -1;
+	}
+
+	printf("Ethernet transceiver PHY firmware download succeeded.\n");
+	/* disable download mode in the PHY */
+	mvebu_set_phy_reg_field(bus, port, MVEBU_C_UNIT_GENERAL,
+				0xF008, 5, 1, 0);
+	mvebu_phy_reset(bus, port);
+
+	return 0;
+}
diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c
index 1d8e81b..bcd38aa 100644
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@ -259,7 +259,7 @@ int genphy_update_link(struct phy_device *phydev)
 				return -EINTR;
 			}
 
-			if ((i++ % 500) == 0)
+			if ((i++ % 1000) == 0)
 				printf(".");
 
 			udelay(1000);	/* 1 ms */
diff --git a/drivers/nvme/nvme.c b/drivers/nvme/nvme.c
index 1c3519b..71ea226 100644
--- a/drivers/nvme/nvme.c
+++ b/drivers/nvme/nvme.c
@@ -74,6 +74,9 @@ static int nvme_setup_prps(struct nvme_dev *dev, u64 *prp2,
 	u64 *prp_pool;
 	int length = total_len;
 	int i, nprps;
+	u32 prps_per_page = (page_size >> 3) - 1;
+	u32 num_pages;
+
 	length -= (page_size - offset);
 
 	if (length <= 0) {
@@ -90,15 +93,16 @@ static int nvme_setup_prps(struct nvme_dev *dev, u64 *prp2,
 	}
 
 	nprps = DIV_ROUND_UP(length, page_size);
+	num_pages = DIV_ROUND_UP(nprps, prps_per_page);
 
 	if (nprps > dev->prp_entry_num) {
 		free(dev->prp_pool);
-		dev->prp_pool = malloc(nprps << 3);
+		dev->prp_pool = memalign(page_size, num_pages * page_size);
 		if (!dev->prp_pool) {
 			printf("Error: malloc prp_pool fail\n");
 			return -ENOMEM;
 		}
-		dev->prp_entry_num = nprps;
+		dev->prp_entry_num = ((page_size >> 3) - 1) * num_pages;
 	}
 
 	prp_pool = dev->prp_pool;
@@ -770,11 +774,12 @@ static int nvme_probe(struct udevice *udev)
 {
 	int ret;
 	struct nvme_dev *ndev = dev_get_priv(udev);
+	size_t size;
 
 	ndev->instance = trailing_strtol(udev->name);
 
 	INIT_LIST_HEAD(&ndev->namespaces);
-	ndev->bar = dm_pci_map_bar(udev, PCI_BASE_ADDRESS_0,
+	ndev->bar = dm_pci_map_bar(udev, PCI_BASE_ADDRESS_0, &size,
 			PCI_REGION_MEM);
 	if (readl(&ndev->bar->csts) == -1) {
 		ret = -ENODEV;
@@ -790,12 +795,6 @@ static int nvme_probe(struct udevice *udev)
 	}
 	memset(ndev->queues, 0, NVME_Q_NUM * sizeof(struct nvme_queue *));
 
-	ndev->prp_pool = malloc(MAX_PRP_POOL);
-	if (!ndev->prp_pool) {
-		ret = -ENOMEM;
-		printf("Error: %s: Out of memory!\n", udev->name);
-		goto free_nvme;
-	}
 	ndev->prp_entry_num = MAX_PRP_POOL >> 3;
 
 	ndev->cap = nvme_readq(&ndev->bar->cap);
@@ -807,6 +806,13 @@ static int nvme_probe(struct udevice *udev)
 	if (ret)
 		goto free_queue;
 
+	ndev->prp_pool = memalign(ndev->page_size, MAX_PRP_POOL);
+	if (!ndev->prp_pool) {
+		ret = -ENOMEM;
+		printf("Error: %s: Out of memory!\n", udev->name);
+		goto free_nvme;
+	}
+
 	ret = nvme_setup_io_queues(ndev);
 	if (ret)
 		goto free_queue;
diff --git a/drivers/pci/Kconfig b/drivers/pci/Kconfig
index da6421f..dfc8b86 100644
--- a/drivers/pci/Kconfig
+++ b/drivers/pci/Kconfig
@@ -26,6 +26,16 @@ config DM_PCI_COMPAT
 	  measure when porting a board to use driver model for PCI. Once the
 	  board is fully supported, this option should be disabled.
 
+config PCI_AARDVARK
+	bool "Enable Aardvark PCIe driver"
+	default n
+	depends on DM_PCI
+	depends on ARMADA_3700
+	help
+	  Say Y here if you want to enable PCIe controller support on
+	  Armada37x0 SoCs. The PCIe controller on Armada37x0 is based on
+	  Aardvark hardware.
+
 config PCI_PNP
 	bool "Enable Plug & Play support for PCI"
 	depends on PCI || DM_PCI
@@ -80,6 +90,14 @@ config PCI_TEGRA
 	  with a total of 5 lanes. Some boards require this for Ethernet
 	  support to work (e.g. beaver, jetson-tk1).
 
+config PCI_OCTEONTX_ECAM
+	bool "OcteonTX ECAM support"
+	depends on (ARCH_OCTEONTX || ARCH_OCTEONTX2)
+	help
+	  Enable support for the OcteonTX/TX2 SoC family ECAM controllers.
+	  These controllers provide PCI configuration access to all on-board
+	  peripherals so it should only be disabled for testing purposes
+
 config PCI_XILINX
 	bool "Xilinx AXI Bridge for PCI Express"
 	depends on DM_PCI
@@ -95,4 +113,13 @@ config PCIE_LAYERSCAPE
 	  PCIe controllers. The PCIe may works in RC or EP mode according to
 	  RCW[HOST_AGT_PEX] setting.
 
+config PCI_MVEBU
+	bool "Enable Armada XP/38x PCIe driver"
+	depends on ARCH_MVEBU
+	select DM_PCI
+	select MISC
+	help
+	  Say Y here if you want to enable PCIe controller support on
+	  Armada XP/38x SoCs.
+
 endif
diff --git a/drivers/pci/Makefile b/drivers/pci/Makefile
index 8fbab46..1c872d3 100644
--- a/drivers/pci/Makefile
+++ b/drivers/pci/Makefile
@@ -30,7 +30,9 @@ obj-$(CONFIG_SH4_PCI) += pci_sh4.o
 obj-$(CONFIG_SH7751_PCI) +=pci_sh7751.o
 obj-$(CONFIG_SH7780_PCI) +=pci_sh7780.o
 obj-$(CONFIG_PCI_TEGRA) += pci_tegra.o
+obj-$(CONFIG_PCI_AARDVARK) += pci-aardvark.o
 obj-$(CONFIG_PCIE_DW_MVEBU) += pcie_dw_mvebu.o
 obj-$(CONFIG_PCIE_LAYERSCAPE) += pcie_layerscape.o
 obj-$(CONFIG_PCIE_LAYERSCAPE) += pcie_layerscape_fixup.o
 obj-$(CONFIG_PCI_XILINX) += pcie_xilinx.o
+obj-$(CONFIG_PCI_OCTEONTX_ECAM) += pci_octeontx_ecam.o
diff --git a/drivers/pci/pci-aardvark.c b/drivers/pci/pci-aardvark.c
new file mode 100644
index 0000000..3263061
--- /dev/null
+++ b/drivers/pci/pci-aardvark.c
@@ -0,0 +1,698 @@
+/*
+ * ***************************************************************************
+ * Copyright (C) 2015 Marvell International Ltd.
+ * ***************************************************************************
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * ***************************************************************************
+ */
+/* pcie_advk.c
+ *
+ * Ported from Linux driver - driver/pci/host/pci-aardvark.c
+ *
+ * Author: Victor Gu <xigu@marvell.com>
+ *         Hezi Shahmoon <hezi.shahmoon@marvell.com>
+ *
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <pci.h>
+#include <asm/io.h>
+#include <asm-generic/gpio.h>
+#include <linux/ioport.h>
+
+/* PCIe core registers */
+#define PCIE_CORE_CMD_STATUS_REG				0x4
+#define     PCIE_CORE_CMD_IO_ACCESS_EN				BIT(0)
+#define     PCIE_CORE_CMD_MEM_ACCESS_EN				BIT(1)
+#define     PCIE_CORE_CMD_MEM_IO_REQ_EN				BIT(2)
+#define PCIE_CORE_DEV_CTRL_STATS_REG				0xc8
+#define     PCIE_CORE_DEV_CTRL_STATS_RELAX_ORDER_DISABLE	(0 << 4)
+#define     PCIE_CORE_DEV_CTRL_STATS_SNOOP_DISABLE		(0 << 11)
+#define PCIE_CORE_LINK_CTRL_STAT_REG				0xd0
+#define     PCIE_CORE_LINK_TRAINING				BIT(5)
+#define PCIE_CORE_ERR_CAPCTL_REG				0x118
+#define     PCIE_CORE_ERR_CAPCTL_ECRC_CHK_TX			BIT(5)
+#define     PCIE_CORE_ERR_CAPCTL_ECRC_CHK_TX_EN			BIT(6)
+#define     PCIE_CORE_ERR_CAPCTL_ECRC_CHECK			BIT(7)
+#define     PCIE_CORE_ERR_CAPCTL_ECRC_CHECK_RCV			BIT(8)
+
+/* PIO registers base address and register offsets */
+#define PIO_BASE_ADDR				0x4000
+#define PIO_CTRL				(PIO_BASE_ADDR + 0x0)
+#define   PIO_CTRL_TYPE_MASK			GENMASK(3, 0)
+#define   PIO_CTRL_ADDR_WIN_DISABLE		BIT(24)
+#define PIO_STAT				(PIO_BASE_ADDR + 0x4)
+#define   PIO_COMPLETION_STATUS_SHIFT		7
+#define   PIO_COMPLETION_STATUS_MASK		GENMASK(9, 7)
+#define   PIO_COMPLETION_STATUS_OK		0
+#define   PIO_COMPLETION_STATUS_UR		1
+#define   PIO_COMPLETION_STATUS_CRS		2
+#define   PIO_COMPLETION_STATUS_CA		4
+#define   PIO_NON_POSTED_REQ			BIT(10)
+#define   PIO_ERR_STATUS			BIT(11)
+#define PIO_ADDR_LS				(PIO_BASE_ADDR + 0x8)
+#define PIO_ADDR_MS				(PIO_BASE_ADDR + 0xc)
+#define PIO_WR_DATA				(PIO_BASE_ADDR + 0x10)
+#define PIO_WR_DATA_STRB			(PIO_BASE_ADDR + 0x14)
+#define PIO_RD_DATA				(PIO_BASE_ADDR + 0x18)
+#define PIO_START				(PIO_BASE_ADDR + 0x1c)
+#define PIO_ISR					(PIO_BASE_ADDR + 0x20)
+
+/* Aardvark Control registers */
+#define CONTROL_BASE_ADDR			0x4800
+#define PCIE_CORE_CTRL0_REG			(CONTROL_BASE_ADDR + 0x0)
+#define     PCIE_GEN_SEL_MSK			0x3
+#define     PCIE_GEN_SEL_SHIFT			0x0
+#define     SPEED_GEN_1				0
+#define     SPEED_GEN_2				1
+#define     SPEED_GEN_3				2
+#define     IS_RC_MSK				1
+#define     IS_RC_SHIFT				2
+#define     LANE_CNT_MSK			0x18
+#define     LANE_CNT_SHIFT			0x3
+#define     LANE_COUNT_1			(0 << LANE_CNT_SHIFT)
+#define     LANE_COUNT_2			(1 << LANE_CNT_SHIFT)
+#define     LANE_COUNT_4			(2 << LANE_CNT_SHIFT)
+#define     LANE_COUNT_8			(3 << LANE_CNT_SHIFT)
+#define     LINK_TRAINING_EN			BIT(6)
+#define PCIE_CORE_CTRL2_REG			(CONTROL_BASE_ADDR + 0x8)
+#define     PCIE_CORE_CTRL2_RESERVED		0x7
+#define     PCIE_CORE_CTRL2_TD_ENABLE		BIT(4)
+#define     PCIE_CORE_CTRL2_STRICT_ORDER_ENABLE	BIT(5)
+#define     PCIE_CORE_CTRL2_ADDRWIN_MAP_ENABLE	BIT(6)
+
+#define PCIE_PHY_REF_CLOCK			(CONTROL_BASE_ADDR + 0x14)
+#define     PCIE_PHY_CTRL_OFF			16
+#define     PCIE_PHY_BUF_CTRL_OFF		0
+#define     PCIE_PHY_BUF_CTRL_INIT_VAL		0x1342
+
+/* LMI registers base address and register offsets */
+#define LMI_BASE_ADDR				0x6000
+#define CFG_REG					(LMI_BASE_ADDR + 0x0)
+#define     LTSSM_SHIFT				24
+#define     LTSSM_MASK				0x3f
+#define     LTSSM_L0				0x10
+
+/* PCIe core controller registers */
+#define CTRL_CORE_BASE_ADDR			0x18000
+#define CTRL_CONFIG_REG				(CTRL_CORE_BASE_ADDR + 0x0)
+#define     CTRL_MODE_SHIFT			0x0
+#define     CTRL_MODE_MASK			0x1
+#define     PCIE_CORE_MODE_DIRECT		0x0
+#define     PCIE_CORE_MODE_COMMAND		0x1
+
+/* Transaction types */
+#define PCIE_CONFIG_RD_TYPE0			0x8
+#define PCIE_CONFIG_RD_TYPE1			0x9
+#define PCIE_CONFIG_WR_TYPE0			0xa
+#define PCIE_CONFIG_WR_TYPE1			0xb
+
+/* PCI_BDF shifts 8bit, so we need extra 4bit shift */
+#define PCIE_BDF(dev)				(dev << 4)
+#define PCIE_CONF_BUS(bus)			(((bus) & 0xff) << 20)
+#define PCIE_CONF_DEV(dev)			(((dev) & 0x1f) << 15)
+#define PCIE_CONF_FUNC(fun)			(((fun) & 0x7)	<< 12)
+#define PCIE_CONF_REG(reg)			((reg) & 0xffc)
+#define PCIE_CONF_ADDR(bus, devfn, where)	\
+	(PCIE_CONF_BUS(bus) | PCIE_CONF_DEV(PCI_SLOT(devfn))	| \
+	 PCIE_CONF_FUNC(PCI_FUNC(devfn)) | PCIE_CONF_REG(where))
+
+/* PCIe Retries & Timeout definitions */
+#define MAX_RETRIES				10
+#define PIO_WAIT_TIMEOUT			100
+#define LINK_WAIT_TIMEOUT			100000
+
+#define CFG_RD_UR_VAL			0xFFFFFFFF
+#define CFG_RD_CRS_VAL			0xFFFF0001
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/**
+ * struct pcie_advk - Advk PCIe controller state
+ *
+ * @reg_base:    The base address of the register space.
+ * @first_busno: This driver supports multiple PCIe controllers.
+ *               first_busno stores the bus number of the PCIe root-port
+ *               number which may vary depending on the PCIe setup
+ *               (PEX switches etc).
+ * @device:      The pointer to PCI uclass device.
+ */
+struct pcie_advk {
+	void           *base;
+	int            first_busno;
+	struct udevice *dev;
+};
+
+static inline void advk_writel(struct pcie_advk *pcie, uint val, uint reg)
+{
+	writel(val, pcie->base + reg);
+}
+
+static inline uint advk_readl(struct pcie_advk *pcie, uint reg)
+{
+	return readl(pcie->base + reg);
+}
+
+/**
+ * pcie_advk_addr_valid() - Check for valid bus address
+ *
+ * @bdf: The PCI device to access
+ * @first_busno: Bus number of the PCIe controller root complex
+ *
+ * Return: 1 on valid, 0 on invalid
+ */
+static int pcie_advk_addr_valid(pci_dev_t bdf, int first_busno)
+{
+	/*
+	 * In PCIE-E only a single device (0) can exist
+	 * on the local bus. Beyound the local bus, there might be
+	 * a Switch and everything is possible.
+	 */
+	if ((PCI_BUS(bdf) == first_busno) && (PCI_DEV(bdf) > 0))
+		return 0;
+
+	return 1;
+}
+
+/**
+ * pcie_advk_wait_pio() - Wait for PIO access to be accomplished
+ *
+ * @pcie: The PCI device to access
+ *
+ * Wait up to 1 micro second for PIO access to be accomplished.
+ *
+ * Return 1 (true) if PIO access is accomplished.
+ * Return 0 (false) if PIO access is timed out.
+ */
+static int pcie_advk_wait_pio(struct pcie_advk *pcie)
+{
+	uint start, isr;
+	uint count;
+
+	for (count = 0; count < MAX_RETRIES; count++) {
+		start = advk_readl(pcie, PIO_START);
+		isr = advk_readl(pcie, PIO_ISR);
+		if (!start && isr)
+			return 1;
+		/*
+		 * Do not check the PIO state too frequently,
+		 * 100us delay is appropriate.
+		 */
+		udelay(PIO_WAIT_TIMEOUT);
+	}
+
+	dev_err(pcie->dev, "config read/write timed out\n");
+	return 0;
+}
+
+/**
+ * pcie_advk_check_pio_status() - Validate PIO status and get the read result
+ *
+ * @pcie: Pointer to the PCI bus
+ * @read: Read from or write to configuration space - true(read) false(write)
+ * @read_val: Pointer to the read result, only valid when read is true
+ *
+ */
+static int pcie_advk_check_pio_status(struct pcie_advk *pcie,
+				      bool read,
+				      uint *read_val)
+{
+	uint reg;
+	unsigned int status;
+	char *strcomp_status, *str_posted;
+
+	reg = advk_readl(pcie, PIO_STAT);
+	status = (reg & PIO_COMPLETION_STATUS_MASK) >>
+		PIO_COMPLETION_STATUS_SHIFT;
+
+	switch (status) {
+	case PIO_COMPLETION_STATUS_OK:
+		if (reg & PIO_ERR_STATUS) {
+			strcomp_status = "COMP_ERR";
+			break;
+		}
+		/* Get the read result */
+		if (read)
+			*read_val = advk_readl(pcie, PIO_RD_DATA);
+		/* No error */
+		strcomp_status = NULL;
+		break;
+	case PIO_COMPLETION_STATUS_UR:
+		if (read) {
+			/* For reading, UR is not an error status. */
+			*read_val = CFG_RD_UR_VAL;
+			strcomp_status = NULL;
+		} else {
+			strcomp_status = "UR";
+		}
+		break;
+	case PIO_COMPLETION_STATUS_CRS:
+		if (read) {
+			/* For reading, CRS is not an error status. */
+			*read_val = CFG_RD_CRS_VAL;
+			strcomp_status = NULL;
+		} else {
+			strcomp_status = "CRS";
+		}
+		break;
+	case PIO_COMPLETION_STATUS_CA:
+		strcomp_status = "CA";
+		break;
+	default:
+		strcomp_status = "Unknown";
+		break;
+	}
+
+	if (!strcomp_status)
+		return 0;
+
+	if (reg & PIO_NON_POSTED_REQ)
+		str_posted = "Non-posted";
+	else
+		str_posted = "Posted";
+
+	dev_err(pcie->dev, "%s PIO Response Status: %s, %#x @ %#x\n",
+		str_posted, strcomp_status, reg,
+		advk_readl(pcie, PIO_ADDR_LS));
+
+	return -EFAULT;
+}
+
+/**
+ * pcie_advk_read_config() - Read from configuration space
+ *
+ * @bus: Pointer to the PCI bus
+ * @bdf: Identifies the PCIe device to access
+ * @offset: The offset into the device's configuration space
+ * @valuep: A pointer at which to store the read value
+ * @size: Indicates the size of access to perform
+ *
+ * Read a value of size @size from offset @offset within the configuration
+ * space of the device identified by the bus, device & function numbers in @bdf
+ * on the PCI bus @bus.
+ *
+ * Return: 0 on success
+ */
+static int pcie_advk_read_config(struct udevice *bus, pci_dev_t bdf,
+				 uint offset, ulong *valuep,
+				 enum pci_size_t size)
+{
+	struct pcie_advk *pcie = dev_get_priv(bus);
+	uint reg;
+	int ret;
+
+	dev_dbg(pcie->dev, "PCIE CFG read:  (b,d,f)=(%2d,%2d,%2d) ",
+		PCI_BUS(bdf), PCI_DEV(bdf), PCI_FUNC(bdf));
+
+	if (!pcie_advk_addr_valid(bdf, pcie->first_busno)) {
+		dev_dbg(pcie->dev, "- out of range\n");
+		*valuep = pci_get_ff(size);
+		return 0;
+	}
+
+	/* Start PIO */
+	advk_writel(pcie, 0, PIO_START);
+	advk_writel(pcie, 1, PIO_ISR);
+
+	/* Program the control register */
+	reg = advk_readl(pcie, PIO_CTRL);
+	reg &= ~PIO_CTRL_TYPE_MASK;
+	if (PCI_BUS(bdf) == pcie->first_busno)
+		reg |= PCIE_CONFIG_RD_TYPE0;
+	else
+		reg |= PCIE_CONFIG_RD_TYPE1;
+	advk_writel(pcie, reg, PIO_CTRL);
+
+	/* Program the address registers */
+	reg = PCIE_BDF(bdf) | PCIE_CONF_REG(offset);
+	advk_writel(pcie, reg, PIO_ADDR_LS);
+	advk_writel(pcie, 0, PIO_ADDR_MS);
+
+	/* Start the transfer */
+	advk_writel(pcie, 1, PIO_START);
+
+	if (!pcie_advk_wait_pio(pcie))
+		return -EINVAL;
+
+	/* Check PIO status and get the read result */
+	ret = pcie_advk_check_pio_status(pcie, true, &reg);
+	if (ret)
+		return ret;
+
+	dev_dbg(pcie->dev, "(addr,size,val)=(0x%04x, %d, 0x%08x)\n",
+		offset, size, reg);
+	*valuep = pci_conv_32_to_size(reg, offset, size);
+
+	return 0;
+}
+
+/**
+ * pcie_calc_datastrobe() - Calculate data strobe
+ *
+ * @offset: The offset into the device's configuration space
+ * @size: Indicates the size of access to perform
+ *
+ * Calculate data strobe according to offset and size
+ *
+ */
+static uint pcie_calc_datastrobe(uint offset, enum pci_size_t size)
+{
+	uint bytes, data_strobe;
+
+	switch (size) {
+	case PCI_SIZE_8:
+		bytes = 1;
+		break;
+	case PCI_SIZE_16:
+		bytes = 2;
+		break;
+	default:
+		bytes = 4;
+	}
+
+	data_strobe = GENMASK(bytes - 1, 0) << (offset & 0x3);
+
+	return data_strobe;
+}
+
+/**
+ * pcie_advk_write_config() - Write to configuration space
+ *
+ * @bus: Pointer to the PCI bus
+ * @bdf: Identifies the PCIe device to access
+ * @offset: The offset into the device's configuration space
+ * @value: The value to write
+ * @size: Indicates the size of access to perform
+ *
+ * Write the value @value of size @size from offset @offset within the
+ * configuration space of the device identified by the bus, device & function
+ * numbers in @bdf on the PCI bus @bus.
+ *
+ * Return: 0 on success
+ */
+static int pcie_advk_write_config(struct udevice *bus, pci_dev_t bdf,
+				  uint offset, ulong value,
+				  enum pci_size_t size)
+{
+	struct pcie_advk *pcie = dev_get_priv(bus);
+	uint reg;
+
+	dev_dbg(pcie->dev, "PCIE CFG write: (b,d,f)=(%2d,%2d,%2d) ",
+		PCI_BUS(bdf), PCI_DEV(bdf), PCI_FUNC(bdf));
+	dev_dbg(pcie->dev, "(addr,size,val)=(0x%04x, %d, 0x%08lx)\n",
+		offset, size, value);
+
+	if (!pcie_advk_addr_valid(bdf, pcie->first_busno)) {
+		dev_dbg(pcie->dev, "- out of range\n");
+		return 0;
+	}
+
+	/* Start PIO */
+	advk_writel(pcie, 0, PIO_START);
+	advk_writel(pcie, 1, PIO_ISR);
+
+	/* Program the control register */
+	reg = advk_readl(pcie, PIO_CTRL);
+	reg &= ~PIO_CTRL_TYPE_MASK;
+	if (PCI_BUS(bdf) == pcie->first_busno)
+		reg |= PCIE_CONFIG_WR_TYPE0;
+	else
+		reg |= PCIE_CONFIG_WR_TYPE1;
+	advk_writel(pcie, reg, PIO_CTRL);
+
+	/* Program the address registers */
+	reg = PCIE_BDF(bdf) | PCIE_CONF_REG(offset);
+	advk_writel(pcie, reg, PIO_ADDR_LS);
+	advk_writel(pcie, 0, PIO_ADDR_MS);
+	dev_dbg(pcie->dev, "\tPIO req. - addr = 0x%08x\n", reg);
+
+	/* Program the data register */
+	reg = pci_conv_size_to_32(0, value, offset, size);
+	advk_writel(pcie, reg, PIO_WR_DATA);
+	dev_dbg(pcie->dev, "\tPIO req. - val  = 0x%08x\n", reg);
+
+	/* Program the data strobe */
+	reg = pcie_calc_datastrobe(offset, size);
+	advk_writel(pcie, reg, PIO_WR_DATA_STRB);
+	dev_dbg(pcie->dev, "\tPIO req. - strb = 0x%02x\n", reg);
+
+	/* Start the transfer */
+	advk_writel(pcie, 1, PIO_START);
+
+	if (!pcie_advk_wait_pio(pcie)) {
+		dev_dbg(pcie->dev, "- wait pio timeout\n");
+		return -EINVAL;
+	}
+
+	/* Check PIO status */
+	pcie_advk_check_pio_status(pcie, false, &reg);
+
+	return 0;
+}
+
+/**
+ * pcie_advk_link_up() - Check if PCIe link is up or not
+ *
+ * @pcie: The PCI device to access
+ *
+ * Return 1 (true) on link up.
+ * Return 0 (false) on link down.
+ */
+static int pcie_advk_link_up(struct pcie_advk *pcie)
+{
+	u32 val, ltssm_state;
+
+	val = advk_readl(pcie, CFG_REG);
+	ltssm_state = (val >> LTSSM_SHIFT) & LTSSM_MASK;
+	return ltssm_state >= LTSSM_L0;
+}
+
+/**
+ * pcie_advk_wait_for_link() - Wait for link training to be accomplished
+ *
+ * @pcie: The PCI device to access
+ *
+ * Wait up to 1 second for link training to be accomplished.
+ *
+ * Return 1 (true) if link training ends up with link up success.
+ * Return 0 (false) if link training ends up with link up failure.
+ */
+static int pcie_advk_wait_for_link(struct pcie_advk *pcie)
+{
+	int retries;
+
+	/* check if the link is up or not */
+	for (retries = 0; retries < MAX_RETRIES; retries++) {
+		if (pcie_advk_link_up(pcie)) {
+			printf("PCIE-%d: Link up\n", pcie->first_busno);
+			return 0;
+		}
+
+		udelay(LINK_WAIT_TIMEOUT);
+	}
+
+	printf("PCIE-%d: Link down\n", pcie->first_busno);
+
+	return -ETIMEDOUT;
+}
+
+/**
+ * pcie_advk_setup_hw() - PCIe initailzation
+ *
+ * @pcie: The PCI device to access
+ *
+ * Return: 0 on success
+ */
+static int pcie_advk_setup_hw(struct pcie_advk *pcie)
+{
+	u32 reg;
+
+	/* Set HW Reference Clock Buffer Control */
+	advk_writel(pcie, PCIE_PHY_BUF_CTRL_INIT_VAL, PCIE_PHY_REF_CLOCK);
+
+	/* Set to Direct mode */
+	reg = advk_readl(pcie, CTRL_CONFIG_REG);
+	reg &= ~(CTRL_MODE_MASK << CTRL_MODE_SHIFT);
+	reg |= ((PCIE_CORE_MODE_DIRECT & CTRL_MODE_MASK) << CTRL_MODE_SHIFT);
+	advk_writel(pcie, reg, CTRL_CONFIG_REG);
+
+	/* Set PCI global control register to RC mode */
+	reg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);
+	reg |= (IS_RC_MSK << IS_RC_SHIFT);
+	advk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);
+
+	/* Set Advanced Error Capabilities and Control PF0 register */
+	reg = PCIE_CORE_ERR_CAPCTL_ECRC_CHK_TX |
+		PCIE_CORE_ERR_CAPCTL_ECRC_CHK_TX_EN |
+		PCIE_CORE_ERR_CAPCTL_ECRC_CHECK |
+		PCIE_CORE_ERR_CAPCTL_ECRC_CHECK_RCV;
+	advk_writel(pcie, reg, PCIE_CORE_ERR_CAPCTL_REG);
+
+	/* Set PCIe Device Control and Status 1 PF0 register */
+	reg = PCIE_CORE_DEV_CTRL_STATS_RELAX_ORDER_DISABLE |
+		PCIE_CORE_DEV_CTRL_STATS_SNOOP_DISABLE;
+	advk_writel(pcie, reg, PCIE_CORE_DEV_CTRL_STATS_REG);
+
+	/* Program PCIe Control 2 to disable strict ordering */
+	reg = PCIE_CORE_CTRL2_RESERVED |
+		PCIE_CORE_CTRL2_TD_ENABLE;
+	advk_writel(pcie, reg, PCIE_CORE_CTRL2_REG);
+
+	/* Set GEN2 */
+	reg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);
+	reg &= ~PCIE_GEN_SEL_MSK;
+	reg |= SPEED_GEN_2;
+	advk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);
+
+	/* Set lane X1 */
+	reg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);
+	reg &= ~LANE_CNT_MSK;
+	reg |= LANE_COUNT_1;
+	advk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);
+
+	/* Enable link training */
+	reg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);
+	reg |= LINK_TRAINING_EN;
+	advk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);
+
+	/*
+	 * Enable AXI address window location generation:
+	 * When it is enabled, the default outbound window
+	 * configurations (Default User Field: 0xD0074CFC)
+	 * are used to transparent address translation for
+	 * the outbound transactions. Thus, PCIe address
+	 * windows are not required.
+	 */
+	reg = advk_readl(pcie, PCIE_CORE_CTRL2_REG);
+	reg |= PCIE_CORE_CTRL2_ADDRWIN_MAP_ENABLE;
+	advk_writel(pcie, reg, PCIE_CORE_CTRL2_REG);
+
+	/*
+	 * Bypass the address window mapping for PIO:
+	 * Since PIO access already contains all required
+	 * info over AXI interface by PIO registers, the
+	 * address window is not required.
+	 */
+	reg = advk_readl(pcie, PIO_CTRL);
+	reg |= PIO_CTRL_ADDR_WIN_DISABLE;
+	advk_writel(pcie, reg, PIO_CTRL);
+
+	/* Start link training */
+	reg = advk_readl(pcie, PCIE_CORE_LINK_CTRL_STAT_REG);
+	reg |= PCIE_CORE_LINK_TRAINING;
+	advk_writel(pcie, reg, PCIE_CORE_LINK_CTRL_STAT_REG);
+
+	/* Wait for PCIe link up */
+	if (pcie_advk_wait_for_link(pcie))
+		return -ENXIO;
+
+	reg = advk_readl(pcie, PCIE_CORE_CMD_STATUS_REG);
+	reg |= PCIE_CORE_CMD_MEM_ACCESS_EN |
+		PCIE_CORE_CMD_IO_ACCESS_EN |
+		PCIE_CORE_CMD_MEM_IO_REQ_EN;
+	advk_writel(pcie, reg, PCIE_CORE_CMD_STATUS_REG);
+
+	return 0;
+}
+
+/**
+ * pcie_advk_probe() - Probe the PCIe bus for active link
+ *
+ * @dev: A pointer to the device being operated on
+ *
+ * Probe for an active link on the PCIe bus and configure the controller
+ * to enable this port.
+ *
+ * Return: 0 on success, else -ENODEV
+ */
+static int pcie_advk_probe(struct udevice *dev)
+{
+	struct pcie_advk *pcie = dev_get_priv(dev);
+
+#ifdef CONFIG_DM_GPIO
+	struct gpio_desc reset_gpio;
+
+	gpio_request_by_name(dev, "reset-gpio", 0, &reset_gpio,
+			     GPIOD_IS_OUT);
+	/*
+	 * Issue reset to add-in card through the dedicated GPIO.
+	 * Some boards are connecting the card reset pin to common system
+	 * reset wire and others are using separate GPIO port.
+	 * In the last case we have to release a reset of the addon card
+	 * using this GPIO.
+	 *
+	 * FIX-ME:
+	 *     The PCIe RESET signal is not supposed to be released along
+	 *     with the SOC RESET signal. It should be lowered as early as
+	 *     possible before PCIe PHY initialization. Moreover, the PCIe
+	 *     clock should be gated as well.
+	 */
+	if (dm_gpio_is_valid(&reset_gpio)) {
+		dev_dbg(pcie->dev, "Toggle PCIE Reset GPIO ...\n");
+		dm_gpio_set_value(&reset_gpio, 0);
+		mdelay(200);
+		dm_gpio_set_value(&reset_gpio, 1);
+	}
+#else
+	dev_dbg(pcie->dev, "PCIE Reset on GPIO support is missing\n");
+#endif /* CONFIG_DM_GPIO */
+
+	pcie->first_busno = dev->seq;
+	pcie->dev = pci_get_controller(dev);
+
+	return pcie_advk_setup_hw(pcie);
+}
+
+/**
+ * pcie_advk_ofdata_to_platdata() - Translate from DT to device state
+ *
+ * @dev: A pointer to the device being operated on
+ *
+ * Translate relevant data from the device tree pertaining to device @dev into
+ * state that the driver will later make use of. This state is stored in the
+ * device's private data structure.
+ *
+ * Return: 0 on success, else -EINVAL
+ */
+static int pcie_advk_ofdata_to_platdata(struct udevice *dev)
+{
+	struct pcie_advk *pcie = dev_get_priv(dev);
+
+	/* Get the register base address */
+	pcie->base = (void *)dev_read_addr_index(dev, 0);
+	if ((fdt_addr_t)pcie->base == FDT_ADDR_T_NONE)
+		return -EINVAL;
+
+	return 0;
+}
+
+static const struct dm_pci_ops pcie_advk_ops = {
+	.read_config	= pcie_advk_read_config,
+	.write_config	= pcie_advk_write_config,
+};
+
+static const struct udevice_id pcie_advk_ids[] = {
+	{ .compatible = "marvell,armada-37xx-pcie" },
+	{ }
+};
+
+U_BOOT_DRIVER(pcie_advk) = {
+	.name			= "pcie_advk",
+	.id			= UCLASS_PCI,
+	.of_match		= pcie_advk_ids,
+	.ops			= &pcie_advk_ops,
+	.ofdata_to_platdata	= pcie_advk_ofdata_to_platdata,
+	.probe			= pcie_advk_probe,
+	.priv_auto_alloc_size	= sizeof(struct pcie_advk),
+};
diff --git a/drivers/pci/pci-uclass.c b/drivers/pci/pci-uclass.c
index ad43e8a..5678900 100644
--- a/drivers/pci/pci-uclass.c
+++ b/drivers/pci/pci-uclass.c
@@ -580,12 +580,22 @@ int dm_pci_hose_probe_bus(struct udevice *bus)
 {
 	int sub_bus;
 	int ret;
+	int ea_pos;
+	u8 reg;
 
 	debug("%s\n", __func__);
 
-	sub_bus = pci_get_bus_max() + 1;
-	debug("%s: bus = %d/%s\n", __func__, sub_bus, bus->name);
-	dm_pciauto_prescan_setup_bridge(bus, sub_bus);
+	ea_pos = dm_pci_find_capability(bus, PCI_CAP_ID_EA);
+
+	if (ea_pos) {
+		dm_pci_read_config8(bus, ea_pos + sizeof(u32) + sizeof(u8), &reg);
+		sub_bus = reg;
+		debug("%s: bus = %d/%s\n", __func__, sub_bus, bus->name);
+	} else {
+		sub_bus = pci_get_bus_max() + 1;
+		debug("%s: bus = %d/%s\n", __func__, sub_bus, bus->name);
+		dm_pciauto_prescan_setup_bridge(bus, sub_bus);
+	}
 
 	ret = device_probe(bus);
 	if (ret) {
@@ -593,13 +603,16 @@ int dm_pci_hose_probe_bus(struct udevice *bus)
 		      ret);
 		return ret;
 	}
-	if (sub_bus != bus->seq) {
-		printf("%s: Internal error, bus '%s' got seq %d, expected %d\n",
-		       __func__, bus->name, bus->seq, sub_bus);
-		return -EPIPE;
+
+	if (!ea_pos) {
+		if (sub_bus != bus->seq) {
+			printf("%s: Internal error, bus '%s' got seq %d, expected %d\n",
+			       __func__, bus->name, bus->seq, sub_bus);
+			return -EPIPE;
+		}
+		sub_bus = pci_get_bus_max();
+		dm_pciauto_postscan_setup_bridge(bus, sub_bus);
 	}
-	sub_bus = pci_get_bus_max();
-	dm_pciauto_postscan_setup_bridge(bus, sub_bus);
 
 	return sub_bus;
 }
@@ -729,6 +742,119 @@ error:
 	return ret;
 }
 
+int pci_sriov_init(struct udevice *pdev, int vf_en)
+{
+	u16 vendor, device;
+	struct udevice *bus;
+	struct udevice *dev;
+	pci_dev_t bdf;
+	u16 ctrl;
+	u16 num_vfs;
+	u16 total_vf;
+	u16 vf_offset;
+	u16 vf_stride;
+	int vf, ret;
+	int pos;
+
+	pos = dm_pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_SRIOV);
+	if (!pos) {
+		printf("Error: SRIOV capability not found\n");
+		return -ENODEV;
+	}
+
+	dm_pci_read_config16(pdev, pos + PCI_SRIOV_CTRL, &ctrl);
+
+	dm_pci_read_config16(pdev, pos + PCI_SRIOV_TOTAL_VF, &total_vf);
+	if (vf_en > total_vf)
+		vf_en = total_vf;
+	dm_pci_write_config16(pdev, pos + PCI_SRIOV_NUM_VF, vf_en);
+
+	ctrl |= PCI_SRIOV_CTRL_VFE | PCI_SRIOV_CTRL_MSE;
+	dm_pci_write_config16(pdev, pos + PCI_SRIOV_CTRL, ctrl);
+
+	dm_pci_read_config16(pdev, pos + PCI_SRIOV_NUM_VF, &num_vfs);
+	if (num_vfs > vf_en)
+		num_vfs = vf_en;
+
+	dm_pci_read_config16(pdev, pos + PCI_SRIOV_VF_OFFSET, &vf_offset);
+	dm_pci_read_config16(pdev, pos + PCI_SRIOV_VF_STRIDE, &vf_stride);
+
+	dm_pci_read_config16(pdev, PCI_VENDOR_ID, &vendor);
+	dm_pci_read_config16(pdev, pos + PCI_SRIOV_VF_DID, &device);
+
+	bdf = dm_pci_get_bdf(pdev);
+
+	pci_get_bus(PCI_BUS(bdf), &bus);
+
+	if (!bus)
+		return -ENODEV;
+
+	bdf += PCI_BDF(0, 0, vf_offset);
+
+	for (vf = 0; vf < num_vfs; vf++) {
+		struct pci_child_platdata *pplat;
+		ulong class;
+
+		pci_bus_read_config(bus, bdf, PCI_CLASS_REVISION,
+				    &class, PCI_SIZE_32);
+
+		class >>= 8;
+
+		debug("%s: bus %d/%s: found VF %x:%x\n", __func__,
+		      bus->seq, bus->name, PCI_DEV(bdf), PCI_FUNC(bdf));
+
+		/* Find this device in the device tree */
+		ret = pci_bus_find_devfn(bus, PCI_MASK_BUS(bdf), &dev);
+
+		if (ret == -ENODEV) {
+			struct pci_device_id find_id;
+
+			memset(&find_id, 0, sizeof(find_id));
+
+			find_id.vendor = vendor;
+			find_id.device = device;
+			find_id.class = class >> 8;
+
+			ret = pci_find_and_bind_driver(bus, &find_id,
+						       bdf, &dev);
+
+			if (ret)
+				return ret;
+		}
+
+		/* Update the platform data */
+		pplat = dev_get_parent_platdata(dev);
+		pplat->devfn = PCI_MASK_BUS(bdf);
+		pplat->vendor = vendor;
+		pplat->device = device;
+		pplat->class = class;
+		pplat->is_phys = false;
+		pplat->pdev = pdev;
+		pplat->vf_id = vf * vf_stride + vf_offset;
+
+		bdf += PCI_BDF(0, 0, vf_stride);
+	}
+
+	return 0;
+
+}
+
+int pci_sriov_get_totalvfs(struct udevice *pdev)
+{
+	u16 total_vf;
+	int pos;
+
+	pos = dm_pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_SRIOV);
+	if (!pos) {
+		printf("Error: SRIOV capability not found\n");
+		return -ENODEV;
+	}
+
+	dm_pci_read_config16(pdev, pos + PCI_SRIOV_TOTAL_VF, &total_vf);
+
+	return total_vf;
+}
+
 int pci_bind_bus_devices(struct udevice *bus)
 {
 	ulong vendor, device;
@@ -802,6 +928,8 @@ int pci_bind_bus_devices(struct udevice *bus)
 		pplat->vendor = vendor;
 		pplat->device = device;
 		pplat->class = class;
+		pplat->is_phys = true;
+
 	}
 
 	return 0;
@@ -861,17 +989,17 @@ static int decode_regions(struct pci_controller *hose, ofnode parent_node,
 		} else {
 			continue;
 		}
-		pos = -1;
-		for (i = 0; i < hose->region_count; i++) {
-			if (hose->regions[i].flags == type)
-				pos = i;
-		}
-		if (pos == -1)
-			pos = hose->region_count++;
+
+		pos = hose->region_count++;
 		debug(" - type=%d, pos=%d\n", type, pos);
 		pci_set_region(hose->regions + pos, pci_addr, addr, size, type);
 	}
 
+	if(hose->region_count == MAX_PCI_REGIONS) {
+		printf("PCI region count reached limit, cannot add local memory region");
+		return 1;
+	}
+
 	/* Add a region for our local memory */
 #ifdef CONFIG_NR_DRAM_BANKS
 	bd_t *bd = gd->bd;
@@ -894,6 +1022,7 @@ static int decode_regions(struct pci_controller *hose, ofnode parent_node,
 #endif
 	if (gd->pci_ram_top && gd->pci_ram_top < base + size)
 		size = gd->pci_ram_top - base;
+
 	pci_set_region(hose->regions + hose->region_count++, base, base,
 		       size, PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
 #endif
@@ -971,30 +1100,39 @@ static int pci_uclass_post_probe(struct udevice *bus)
 	return 0;
 }
 
+int pci_get_devfn(struct udevice *dev)
+{
+	struct fdt_pci_addr addr;
+	int ret;
+
+	/* Extract the devfn from fdt_pci_addr */
+	ret = ofnode_read_pci_addr(dev_ofnode(dev), FDT_PCI_SPACE_CONFIG,
+				   "reg", &addr);
+	if (ret) {
+		if (ret != -ENOENT)
+			return -EINVAL;
+	}
+
+	return addr.phys_hi & 0xff00;
+}
+
 static int pci_uclass_child_post_bind(struct udevice *dev)
 {
 	struct pci_child_platdata *pplat;
-	struct fdt_pci_addr addr;
 	int ret;
 
 	if (!dev_of_valid(dev))
 		return 0;
 
-	/*
-	 * We could read vendor, device, class if available. But for now we
-	 * just check the address.
-	 */
 	pplat = dev_get_parent_platdata(dev);
-	ret = ofnode_read_pci_addr(dev_ofnode(dev), FDT_PCI_SPACE_CONFIG, "reg",
-				   &addr);
 
-	if (ret) {
-		if (ret != -ENOENT)
-			return -EINVAL;
-	} else {
-		/* extract the devfn from fdt_pci_addr */
-		pplat->devfn = addr.phys_hi & 0xff00;
-	}
+	/* Extract vendor id and device id if available */
+	ofnode_read_pci_vendev(dev_ofnode(dev), &pplat->vendor, &pplat->device);
+
+	/* Extract the devfn from fdt_pci_addr */
+	pplat->devfn = pci_get_devfn(dev);
+	if (ret < 0)
+		return ret;
 
 	return 0;
 }
@@ -1284,14 +1422,49 @@ pci_addr_t dm_pci_phys_to_bus(struct udevice *dev, phys_addr_t phys_addr,
 	return bus_addr;
 }
 
-void *dm_pci_map_bar(struct udevice *dev, int bar, int flags)
+int dm_pci_ea_bar_read(struct udevice *dev, int bar,
+		       pci_addr_t *start, size_t *size);
+
+void *dm_pci_map_bar(struct udevice *dev, int bar, size_t *size, int flags)
 {
-	pci_addr_t pci_bus_addr;
+	int pos;
+	pci_addr_t pci_bus_start;
 	u32 bar_response;
+	struct pci_child_platdata *pdata = dev_get_parent_platdata(dev);
+
+	if (!pdata->is_phys) {
+		if (bar < 9 || bar > 14)
+			return NULL;
+		dev = pdata->pdev;
+	}
 
-	/* read BAR address */
-	dm_pci_read_config32(dev, bar, &bar_response);
-	pci_bus_addr = (pci_addr_t)(bar_response & ~0xf);
+	pos = dm_pci_find_capability(dev, PCI_CAP_ID_EA);
+
+	if (pos) {
+		dm_pci_ea_bar_read(dev, bar, &pci_bus_start, size);
+	} else {
+		/* read BAR address */
+		if (bar >= 0 && bar <= 5) {
+			bar = PCI_BASE_ADDRESS_0 + bar * 4;
+		} else if (bar >= 9 && bar <= 14) {
+			pos = dm_pci_find_ext_capability(dev, PCI_EXT_CAP_ID_SRIOV);
+			bar = pos + PCI_SRIOV_BAR + bar * 4;
+			//TODO: Get BAR size
+		}
+		dm_pci_read_config32(dev, bar,
+				     &bar_response);
+		pci_bus_start = (pci_addr_t)(bar_response & ~0xf);
+
+		if ((bar_response & PCI_BASE_ADDRESS_MEM_TYPE_MASK) ==
+				PCI_BASE_ADDRESS_MEM_TYPE_64) {
+			bar_response = 0;
+			dm_pci_read_config32(dev, bar + 4, &bar_response);
+		}
+	}
+
+	if (!pdata->is_phys) {
+		pci_bus_start += (pdata->vf_id - 1) * (*size);
+	}
 
 	/*
 	 * Pass "0" as the length argument to pci_bus_to_virt.  The arg
@@ -1299,7 +1472,289 @@ void *dm_pci_map_bar(struct udevice *dev, int bar, int flags)
 	 * linear mapping.  In the future, this could read the BAR size
 	 * and pass that as the size if needed.
 	 */
-	return dm_pci_bus_to_virt(dev, pci_bus_addr, flags, 0, MAP_NOCACHE);
+	return dm_pci_bus_to_virt(dev, pci_bus_start, flags, 0, MAP_NOCACHE);
+}
+
+/* Find the header pointer to the Capabilities*/
+int dm_pci_find_cap_start(struct udevice *dev, u8 hdr_type)
+{
+	u16 status;
+
+	dm_pci_read_config16(dev, PCI_STATUS, &status);
+
+	if (!(status & PCI_STATUS_CAP_LIST))
+		return 0;
+
+	switch (hdr_type) {
+	case PCI_HEADER_TYPE_NORMAL:
+	case PCI_HEADER_TYPE_BRIDGE:
+		return PCI_CAPABILITY_LIST;
+	case PCI_HEADER_TYPE_CARDBUS:
+		return PCI_CB_CAPABILITY_LIST;
+	default:
+		return 0;
+	}
+}
+
+int dm_pci_find_cap(struct udevice *dev, int pos, int cap)
+{
+	int ttl = PCI_FIND_CAP_TTL;
+	u8 id;
+	u8 next_pos;
+
+	while (ttl--) {
+		dm_pci_read_config8(dev, pos, &next_pos);
+		if (next_pos < CAP_START_POS)
+			break;
+		next_pos &= ~3;
+		pos = (int) next_pos;
+		dm_pci_read_config8(dev, pos + PCI_CAP_LIST_ID, &id);
+		if (id == 0xff)
+			break;
+		if (id == cap)
+			return pos;
+		pos += PCI_CAP_LIST_NEXT;
+	}
+	return 0;
+}
+
+/* Returns the address of the requested capability structure within the
+ * device's PCI configuration space or 0 in case the device does not
+ * support it.
+ * */
+int dm_pci_find_capability(struct udevice *dev, int cap)
+{
+	int pos;
+	u8 hdr_type;
+
+	dm_pci_read_config8(dev, PCI_HEADER_TYPE, &hdr_type);
+
+	pos = dm_pci_find_cap_start(dev, hdr_type & 0x7F);
+
+	if (pos)
+		pos = dm_pci_find_cap(dev, pos, cap);
+
+	return pos;
+}
+
+/* Read an Enhanced Allocation (EA) entry */
+static int dm_pci_ea_entry_read(struct udevice *dev, int offset, int *bei, pci_addr_t *start, size_t *size)
+{
+	u32 base;
+	u32 max_offset;
+	u8  prop;
+	int ent_offset = offset;
+	int ent_size;
+	u32 dw0;
+
+	dm_pci_read_config32(dev, ent_offset, &dw0);
+
+	debug("%s: %d: dw0: %lx\n", __FUNCTION__, __LINE__, (unsigned long)dw0);
+
+	ent_offset += sizeof(u32);
+
+	/* Entry size field indicates DWORDs after 1st */
+	ent_size = ((dw0 & PCI_EA_ES) + 1) * sizeof(u32);
+
+	if (!(dw0 & PCI_EA_ENABLE))
+		goto out;
+	*bei = PCI_EA_BEI(dw0);
+
+	prop = PCI_EA_PP(dw0);
+
+	debug("EA property: %x\n", prop);
+
+	/*
+	* If the Property is in the reserved range, try the Secondary
+	* Property instead.
+	*/
+	if (prop > PCI_EA_P_BRIDGE_IO && prop < PCI_EA_P_MEM_RESERVED)
+		prop = PCI_EA_SP(dw0);
+	if (prop > PCI_EA_P_BRIDGE_IO)
+		goto out;
+
+	debug("EA property: %x\n", prop);
+
+	/* Read Base */
+	dm_pci_read_config32(dev, ent_offset, &base);
+	ent_offset += sizeof(u32);
+	*start = (pci_addr_t)base & PCI_EA_FIELD_MASK;
+
+	/* Read MaxOffset */
+	dm_pci_read_config32(dev, ent_offset, &max_offset);
+	ent_offset += sizeof(u32);
+
+	/* Read Base MSBs (if 64-bit entry) */
+	if (base & PCI_EA_IS_64) {
+		dm_pci_read_config32(dev, ent_offset, &base);
+		ent_offset += sizeof(u32);
+#ifdef CONFIG_SYS_PCI_64BIT
+		*start |= (pci_addr_t)base << 32;
+#endif
+	}
+
+	debug("EA (%u,%u) start = %lx\n", PCI_EA_BEI(dw0), prop, (unsigned long)*start);
+
+	*size = ((size_t)max_offset | 0x03) + 1;
+
+	/* Read MaxOffset MSBs (if 64-bit entry) */
+	if (max_offset & PCI_EA_IS_64) {
+		dm_pci_read_config32(dev, ent_offset, &max_offset);
+		ent_offset += sizeof(u32);
+
+		*size |= (size_t)max_offset << 32;
+	}
+
+	debug("EA (%u,%u) size = %lx\n", PCI_EA_BEI(dw0), prop, (unsigned long)*size);
+
+	if (*start + *size < *start) {
+		*size = 0;
+		*start = 0;
+		printf("EA Entry crosses address boundary\n");
+		goto out;
+	}
+
+	if (ent_size != ent_offset - offset) {
+		printf("EA Entry Size (%d) does not match length read (%d)\n",
+			ent_size, ent_offset - offset);
+		goto out;
+	}
+
+out:
+	return offset + ent_size;
+}
+
+/* Read an Enhanced Allocation (EA) BAR */
+int dm_pci_ea_bar_read(struct udevice *dev, int bar, pci_addr_t *start, size_t *size)
+{
+	int ea;
+	int offset;
+	u8  num_ent;
+	u8  hdr_type;
+	int i, bei = -1;
+
+	ea = dm_pci_find_capability(dev, PCI_CAP_ID_EA);
+
+	dm_pci_read_config8(dev, ea + PCI_EA_NUM_ENT, &num_ent);
+	num_ent &= PCI_EA_NUM_ENT_MASK;
+
+	offset = ea + PCI_EA_FIRST_ENT;
+
+	dm_pci_read_config8(dev, PCI_HEADER_TYPE, &hdr_type);
+
+	/* Skip DWORD 2 for type 1 functions */
+	if (hdr_type == PCI_HEADER_TYPE_BRIDGE)
+		offset += sizeof(u32);
+
+	for (i = 0; (i < num_ent) && (bar != bei); i++) {
+		offset = dm_pci_ea_entry_read(dev, offset, &bei, start, size);
+	}
+
+	return (bar == bei);
+}
+
+/**
+ * dm_pci_find_next_ext_capability - Find an extended capability
+ *
+ * Returns the address of the next matching extended capability structure
+ * within the device's PCI configuration space or 0 if the device does
+ * not support it.  Some capabilities can occur several times, e.g., the
+ * vendor-specific capability, and this provides a way to find them all.
+ */
+int dm_pci_find_next_ext_capability(struct udevice *dev,
+				    int start, int cap)
+{
+	u32 header;
+	int ttl, pos = PCI_CFG_SPACE_SIZE;
+
+	/* minimum 8 bytes per capability */
+	ttl = (PCI_CFG_SPACE_EXP_SIZE - PCI_CFG_SPACE_SIZE) / 8;
+
+	if (start)
+		pos = start;
+
+	dm_pci_read_config32(dev, pos, &header);
+	if (header == 0xffffffff || header == 0)
+		return 0;
+
+	while (ttl-- > 0) {
+		if (PCI_EXT_CAP_ID(header) == cap && pos != start)
+			return pos;
+
+		pos = PCI_EXT_CAP_NEXT(header);
+		if (pos < PCI_CFG_SPACE_SIZE)
+			break;
+
+		dm_pci_read_config32(dev, pos, &header);
+		if (header == 0xffffffff || header == 0)
+			break;
+	}
+
+	return 0;
+}
+
+/**
+ * dm_pci_find_ext_capability - Find an extended capability
+ *
+ * Returns the address of the requested extended capability structure
+ * within the device's PCI configuration space or 0 if the device does
+ * not support it.
+ */
+int dm_pci_find_ext_capability(struct udevice *dev, int cap)
+{
+	return dm_pci_find_next_ext_capability(dev, 0, cap);
+}
+
+/**
+ * pci_bus_find_next_ext_capability - Find an extended capability
+ *
+ * Returns the address of the next matching extended capability structure
+ * within the device's PCI configuration space or 0 if the device does
+ * not support it.  Some capabilities can occur several times, e.g., the
+ * vendor-specific capability, and this provides a way to find them all.
+ */
+static int pci_bus_find_next_ext_capability(struct udevice *bus,
+					    pci_dev_t bdf, int start, int cap)
+{
+	ulong header;
+	int ttl, pos = PCI_CFG_SPACE_SIZE;
+
+	/* minimum 8 bytes per capability */
+	ttl = (PCI_CFG_SPACE_EXP_SIZE - PCI_CFG_SPACE_SIZE) / 8;
+
+	if (start)
+		pos = start;
+
+	pci_bus_read_config(bus, bdf, pos, &header, PCI_SIZE_32);
+	if (header == 0xffffffff || header == 0)
+		return 0;
+
+	while (ttl-- > 0) {
+		if (PCI_EXT_CAP_ID(header) == cap && pos != start)
+			return pos;
+
+		pos = PCI_EXT_CAP_NEXT(header);
+		if (pos < PCI_CFG_SPACE_SIZE)
+			break;
+
+		pci_bus_read_config(bus, bdf, pos, &header, PCI_SIZE_32);
+		if (header == 0xffffffff || header == 0)
+			break;
+	}
+
+	return 0;
+}
+
+/**
+ * pci_find_ext_capability - Find an extended capability
+ *
+ * Returns the address of the requested extended capability structure
+ * within the device's PCI configuration space or 0 if the device does
+ * not support it.
+ */
+int pci_bus_find_ext_capability(struct udevice *bus, pci_dev_t bdf, int cap)
+{
+	return pci_bus_find_next_ext_capability(bus, bdf, 0, cap);
 }
 
 UCLASS_DRIVER(pci) = {
diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index bbc7dab..ec9d647 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -192,10 +192,10 @@ int pci_hose_config_device(struct pci_controller *hose,
 			   unsigned long command)
 {
 	u32 bar_response;
-	unsigned int old_command;
+	u32 old_command;
 	pci_addr_t bar_value;
 	pci_size_t bar_size;
-	unsigned char pin;
+	u8 pin;
 	int bar, found_mem64;
 
 	debug("PCI Config: I/O=0x%lx, Memory=0x%llx, Command=0x%lx\n", io,
@@ -326,6 +326,24 @@ void pci_cfgfunc_do_nothing(struct pci_controller *hose,
  */
 extern int pciauto_config_device(struct pci_controller *hose, pci_dev_t dev);
 
+__weak int pci_config_fixed(struct pci_controller *hose, pci_dev_t dev)
+{
+	/*
+	 * Check if pci device has a fixed configuration
+	 */
+	return 0;
+}
+
+__weak int pci_prescan_config(struct pci_controller *hose, pci_dev_t dev)
+{
+	return 0;
+}
+
+__weak int pci_postscan_config(struct pci_controller *hose, pci_dev_t dev)
+{
+	return 0;
+}
+
 #ifdef CONFIG_PCI_SCAN_SHOW
 __weak int pci_print_dev(struct pci_controller *hose, pci_dev_t dev)
 {
diff --git a/drivers/pci/pci_auto.c b/drivers/pci/pci_auto.c
index c2bc326..b18c702 100644
--- a/drivers/pci/pci_auto.c
+++ b/drivers/pci/pci_auto.c
@@ -12,6 +12,7 @@
 #include <dm.h>
 #include <errno.h>
 #include <pci.h>
+#include <dm/device-internal.h>
 
 /* the user can define CONFIG_SYS_PCI_CACHE_LINE_SIZE to avoid problems */
 #ifndef CONFIG_SYS_PCI_CACHE_LINE_SIZE
@@ -310,11 +311,12 @@ int dm_pciauto_config_device(struct udevice *dev)
 	struct pci_region *pci_io;
 	unsigned int sub_bus = PCI_BUS(dm_pci_get_bdf(dev));
 	unsigned short class;
-	bool enum_only = false;
+	bool enum_only;
 	struct udevice *ctlr = pci_get_controller(dev);
 	struct pci_controller *ctlr_hose = dev_get_uclass_priv(ctlr);
 	int n;
 
+	enum_only = dm_pci_find_capability(dev, PCI_CAP_ID_EA);
 #ifdef CONFIG_PCI_ENUM_ONLY
 	enum_only = true;
 #endif
diff --git a/drivers/pci/pci_auto_old.c b/drivers/pci/pci_auto_old.c
index edc9a7b..b5198b0 100644
--- a/drivers/pci/pci_auto_old.c
+++ b/drivers/pci/pci_auto_old.c
@@ -313,6 +313,37 @@ void pciauto_postscan_setup_bridge(struct pci_controller *hose,
 }
 
 
+int pci_bridge_read_config(struct pci_controller *hose, pci_dev_t dev,
+			   u8 *pri, u8 *sec, u8 *sub)
+{
+	int res;
+	u32 reg;
+
+	pci_hose_read_config_byte(hose, dev, PCI_PRIMARY_BUS, pri);
+
+	res = pci_hose_find_capability(hose, dev, PCI_CAP_ID_EA);
+
+	if (res) {
+		pci_hose_read_config_dword(hose, dev,
+					   res + sizeof(u32), &reg);
+		*sec = (reg >> 0) & 0xff;
+		*sub = (reg >> 8) & 0xff;
+	} else {
+		pci_hose_read_config_byte(hose, dev,
+					  PCI_SECONDARY_BUS, sec);
+		pci_hose_read_config_byte(hose, dev,
+					  PCI_SUBORDINATE_BUS, sub);
+	}
+
+	debug("pri: %d, sec: %d, sub: %d\n", *pri, *sec, *sub);
+
+	return 0;
+}
+
+extern int pci_config_fixed(struct pci_controller *hose, pci_dev_t dev);
+extern int pci_prescan_config(struct pci_controller *hose, pci_dev_t dev);
+extern int pci_postscan_config(struct pci_controller *hose, pci_dev_t dev);
+
 /*
  * HJF: Changed this to return int. I think this is required
  * to get the correct result when scanning bridges
@@ -322,41 +353,75 @@ int pciauto_config_device(struct pci_controller *hose, pci_dev_t dev)
 	struct pci_region *pci_mem;
 	struct pci_region *pci_prefetch;
 	struct pci_region *pci_io;
-	unsigned int sub_bus = PCI_BUS(dev);
-	unsigned short class;
+	u8 hdr_type, pri_bus, sec_bus, sub_bus =  PCI_BUS(dev);
 	int n;
 
 	pci_mem = hose->pci_mem;
 	pci_prefetch = hose->pci_prefetch;
 	pci_io = hose->pci_io;
 
-	pci_hose_read_config_word(hose, dev, PCI_CLASS_DEVICE, &class);
+	pci_hose_read_config_byte(hose, dev, PCI_HEADER_TYPE, &hdr_type);
 
-	switch (class) {
-	case PCI_CLASS_BRIDGE_PCI:
+	switch (hdr_type) {
+	case PCI_HEADER_TYPE_BRIDGE:
 		debug("PCI Autoconfig: Found P2P bridge, device %d\n",
 		      PCI_DEV(dev));
+		hose->current_busno++;
+		pci_prescan_config(hose, dev);
 
-		pciauto_setup_device(hose, dev, 2, pci_mem,
-				     pci_prefetch, pci_io);
+		if (!pci_config_fixed(hose, dev)) {
+			pciauto_setup_device(hose, dev, 2, pci_mem,
+					     pci_prefetch, pci_io);
+		}
 
 		/* Passing in current_busno allows for sibling P2P bridges */
-		hose->current_busno++;
 		pciauto_prescan_setup_bridge(hose, dev, hose->current_busno);
+
+		if (!pci_config_fixed(hose, dev)) {
+			/* Passing in current_busno allows for sibling P2P bridges */
+			pciauto_prescan_setup_bridge(hose, dev,
+						     hose->current_busno);
+		} else {
+			pci_bridge_read_config(hose, dev, &pri_bus,
+					       &sec_bus, &sub_bus);
+			pri_bus += hose->first_busno;
+			sec_bus += hose->first_busno;
+			sub_bus += hose->first_busno;
+
+			hose->current_busno = sec_bus;
+		}
 		/*
 		 * need to figure out if this is a subordinate bridge on the bus
 		 * to be able to properly set the pri/sec/sub bridge registers.
 		 */
 		n = pci_hose_scan_bus(hose, hose->current_busno);
 
+		debug("hose->current_busno: %d, n: %d, sub_bus: %d\n",
+			hose->current_busno, n, sub_bus);
+
 		/* figure out the deepest we've gone for this leg */
-		sub_bus = max((unsigned int)n, sub_bus);
-		pciauto_postscan_setup_bridge(hose, dev, sub_bus);
+		sub_bus = max((unsigned int)n, (unsigned int)sub_bus);
+		if (!pci_config_fixed(hose, dev)) {
+			pciauto_postscan_setup_bridge(hose, dev, sub_bus);
+		}
 
 		sub_bus = hose->current_busno;
+		pci_postscan_config(hose, dev);
+
 		break;
+/*
+	case PCI_CLASS_STORAGE_IDE:
+		pci_hose_read_config_byte(hose, dev, PCI_CLASS_PROG, &prg_iface);
+		if (!(prg_iface & PCIAUTO_IDE_MODE_MASK)) {
+			DEBUGF("PCI Autoconfig: Skipping legacy mode IDE controller\n");
+			return sub_bus;
+		}
 
-	case PCI_CLASS_BRIDGE_CARDBUS:
+		pciauto_setup_device(hose, dev, 6, hose->pci_mem,
+			hose->pci_prefetch, hose->pci_io);
+		break;
+*/
+	case PCI_HEADER_TYPE_CARDBUS:
 		/*
 		 * just do a minimal setup of the bridge,
 		 * let the OS take care of the rest
@@ -370,32 +435,16 @@ int pciauto_config_device(struct pci_controller *hose, pci_dev_t dev)
 		hose->current_busno++;
 		break;
 
-#if defined(CONFIG_PCIAUTO_SKIP_HOST_BRIDGE)
-	case PCI_CLASS_BRIDGE_OTHER:
-		debug("PCI Autoconfig: Skipping bridge device %d\n",
-		      PCI_DEV(dev));
-		break;
-#endif
-#if defined(CONFIG_MPC834x) && !defined(CONFIG_VME8349)
-	case PCI_CLASS_BRIDGE_OTHER:
-		/*
-		 * The host/PCI bridge 1 seems broken in 8349 - it presents
-		 * itself as 'PCI_CLASS_BRIDGE_OTHER' and appears as an _agent_
-		 * device claiming resources io/mem/irq.. we only allow for
-		 * the PIMMR window to be allocated (BAR0 - 1MB size)
-		 */
-		debug("PCI Autoconfig: Broken bridge found, only minimal config\n");
-		pciauto_setup_device(hose, dev, 0, hose->pci_mem,
-			hose->pci_prefetch, hose->pci_io);
-		break;
-#endif
+	default:
+		pci_prescan_config(hose, dev);
 
-	case PCI_CLASS_PROCESSOR_POWERPC: /* an agent or end-point */
-		debug("PCI AutoConfig: Found PowerPC device\n");
+		if (!pci_config_fixed(hose, dev)) {
+			pciauto_setup_device(hose, dev, 6, pci_mem,
+					     pci_prefetch, pci_io);
+		}
+
+		pci_postscan_config(hose, dev);
 
-	default:
-		pciauto_setup_device(hose, dev, 6, pci_mem,
-				     pci_prefetch, pci_io);
 		break;
 	}
 
diff --git a/drivers/pci/pci_mvebu.c b/drivers/pci/pci_mvebu.c
index 076a63f..15711e3 100644
--- a/drivers/pci/pci_mvebu.c
+++ b/drivers/pci/pci_mvebu.c
@@ -11,11 +11,16 @@
  */
 
 #include <common.h>
+#include <dm.h>
+#include <dm/device-internal.h>
+#include <dm/lists.h>
+#include <dm/of_access.h>
 #include <pci.h>
-#include <linux/errno.h>
 #include <asm/io.h>
 #include <asm/arch/cpu.h>
 #include <asm/arch/soc.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
 #include <linux/mbus.h>
 
 DECLARE_GLOBAL_DATA_PTR;
@@ -60,26 +65,22 @@ DECLARE_GLOBAL_DATA_PTR;
 #define PCIE_DEBUG_CTRL			0x1a60
 #define  PCIE_DEBUG_SOFT_RESET		BIT(20)
 
-struct resource {
-	u32 start;
-	u32 end;
-};
-
 struct mvebu_pcie {
 	struct pci_controller hose;
-	char *name;
 	void __iomem *base;
 	void __iomem *membase;
 	struct resource mem;
 	void __iomem *iobase;
 	u32 port;
 	u32 lane;
+	int devfn;
 	u32 lane_mask;
 	pci_dev_t dev;
+	char name[16];
+	unsigned int mem_target;
+	unsigned int mem_attr;
 };
 
-#define to_pcie(_hc)	container_of(_hc, struct mvebu_pcie, pci)
-
 /*
  * MVEBU PCIe controller needs MEMORY and I/O BARs to be mapped
  * into SoCs address space. Each controller will map 128M of MEM
@@ -88,82 +89,6 @@ struct mvebu_pcie {
 static void __iomem *mvebu_pcie_membase = (void __iomem *)MBUS_PCI_MEM_BASE;
 #define PCIE_MEM_SIZE	(128 << 20)
 
-#if defined(CONFIG_ARMADA_38X)
-#define PCIE_BASE(if)					\
-	((if) == 0 ?					\
-	 MVEBU_REG_PCIE0_BASE :				\
-	 (MVEBU_REG_PCIE_BASE + 0x4000 * (if - 1)))
-
-/*
- * On A38x MV6820 these PEX ports are supported:
- *  0 - Port 0.0
- *  1 - Port 1.0
- *  2 - Port 2.0
- *  3 - Port 3.0
- */
-#define MAX_PEX 4
-static struct mvebu_pcie pcie_bus[MAX_PEX];
-
-static void mvebu_get_port_lane(struct mvebu_pcie *pcie, int pex_idx,
-				int *mem_target, int *mem_attr)
-{
-	u8 port[] = { 0, 1, 2, 3 };
-	u8 lane[] = { 0, 0, 0, 0 };
-	u8 target[] = { 8, 4, 4, 4 };
-	u8 attr[] = { 0xe8, 0xe8, 0xd8, 0xb8 };
-
-	pcie->port = port[pex_idx];
-	pcie->lane = lane[pex_idx];
-	*mem_target = target[pex_idx];
-	*mem_attr = attr[pex_idx];
-}
-#else
-#define PCIE_BASE(if)							\
-	((if) < 8 ?							\
-	 (MVEBU_REG_PCIE_BASE + ((if) / 4) * 0x40000 + ((if) % 4) * 0x4000) : \
-	 (MVEBU_REG_PCIE_BASE + 0x2000 + ((if) % 8) * 0x40000))
-
-/*
- * On AXP MV78460 these PEX ports are supported:
- *  0 - Port 0.0
- *  1 - Port 0.1
- *  2 - Port 0.2
- *  3 - Port 0.3
- *  4 - Port 1.0
- *  5 - Port 1.1
- *  6 - Port 1.2
- *  7 - Port 1.3
- *  8 - Port 2.0
- *  9 - Port 3.0
- */
-#define MAX_PEX 10
-static struct mvebu_pcie pcie_bus[MAX_PEX];
-
-static void mvebu_get_port_lane(struct mvebu_pcie *pcie, int pex_idx,
-				int *mem_target, int *mem_attr)
-{
-	u8 port[] = { 0, 0, 0, 0, 1, 1, 1, 1, 2, 3 };
-	u8 lane[] = { 0, 1, 2, 3, 0, 1, 2, 3, 0, 0 };
-	u8 target[] = { 4, 4, 4, 4, 8, 8, 8, 8, 4, 8 };
-	u8 attr[] = { 0xe8, 0xd8, 0xb8, 0x78,
-		      0xe8, 0xd8, 0xb8, 0x78,
-		      0xf8, 0xf8 };
-
-	pcie->port = port[pex_idx];
-	pcie->lane = lane[pex_idx];
-	*mem_target = target[pex_idx];
-	*mem_attr = attr[pex_idx];
-}
-#endif
-
-static int mvebu_pex_unit_is_x4(int pex_idx)
-{
-	int pex_unit = pex_idx < 9 ? pex_idx >> 2 : 3;
-	u32 mask = (0x0f << (pex_unit * 8));
-
-	return (readl(COMPHY_REFCLK_ALIGNMENT) & mask) == mask;
-}
-
 static inline bool mvebu_pcie_link_up(struct mvebu_pcie *pcie)
 {
 	u32 val;
@@ -212,67 +137,83 @@ static inline struct mvebu_pcie *hose_to_pcie(struct pci_controller *hose)
 	return container_of(hose, struct mvebu_pcie, hose);
 }
 
-static int mvebu_pcie_read_config_dword(struct pci_controller *hose,
-		pci_dev_t dev, int offset, u32 *val)
+static int mvebu_pcie_read_config(struct udevice *bus, pci_dev_t bdf,
+				  uint offset, ulong *valuep,
+				  enum pci_size_t size)
 {
-	struct mvebu_pcie *pcie = hose_to_pcie(hose);
+	struct mvebu_pcie *pcie = dev_get_platdata(bus);
 	int local_bus = PCI_BUS(pcie->dev);
 	int local_dev = PCI_DEV(pcie->dev);
 	u32 reg;
+	u32 data;
+
+	debug("PCIE CFG read:  (b,d,f)=(%2d,%2d,%2d) ",
+	      PCI_BUS(bdf), PCI_DEV(bdf), PCI_FUNC(bdf));
 
 	/* Only allow one other device besides the local one on the local bus */
-	if (PCI_BUS(dev) == local_bus && PCI_DEV(dev) != local_dev) {
-		if (local_dev == 0 && PCI_DEV(dev) != 1) {
+	if (PCI_BUS(bdf) == local_bus && PCI_DEV(bdf) != local_dev) {
+		if (local_dev == 0 && PCI_DEV(bdf) != 1) {
+			debug("- out of range\n");
 			/*
 			 * If local dev is 0, the first other dev can
 			 * only be 1
 			 */
-			*val = 0xffffffff;
-			return 1;
-		} else if (local_dev != 0 && PCI_DEV(dev) != 0) {
+			*valuep = pci_get_ff(size);
+			return 0;
+		} else if (local_dev != 0 && PCI_DEV(bdf) != 0) {
+			debug("- out of range\n");
 			/*
 			 * If local dev is not 0, the first other dev can
 			 * only be 0
 			 */
-			*val = 0xffffffff;
-			return 1;
+			*valuep = pci_get_ff(size);
+			return 0;
 		}
 	}
 
 	/* write address */
-	reg = PCIE_CONF_ADDR(dev, offset);
+	reg = PCIE_CONF_ADDR(bdf, offset);
 	writel(reg, pcie->base + PCIE_CONF_ADDR_OFF);
-	*val = readl(pcie->base + PCIE_CONF_DATA_OFF);
+	data = readl(pcie->base + PCIE_CONF_DATA_OFF);
+	debug("(addr,val)=(0x%04x, 0x%08x)\n", offset, data);
+	*valuep = pci_conv_32_to_size(data, offset, size);
 
 	return 0;
 }
 
-static int mvebu_pcie_write_config_dword(struct pci_controller *hose,
-		pci_dev_t dev, int offset, u32 val)
+static int mvebu_pcie_write_config(struct udevice *bus, pci_dev_t bdf,
+				   uint offset, ulong value,
+				   enum pci_size_t size)
 {
-	struct mvebu_pcie *pcie = hose_to_pcie(hose);
+	struct mvebu_pcie *pcie = dev_get_platdata(bus);
 	int local_bus = PCI_BUS(pcie->dev);
 	int local_dev = PCI_DEV(pcie->dev);
+	u32 data;
+
+	debug("PCIE CFG write: (b,d,f)=(%2d,%2d,%2d) ",
+	      PCI_BUS(bdf), PCI_DEV(bdf), PCI_FUNC(bdf));
+	debug("(addr,val)=(0x%04x, 0x%08lx)\n", offset, value);
 
 	/* Only allow one other device besides the local one on the local bus */
-	if (PCI_BUS(dev) == local_bus && PCI_DEV(dev) != local_dev) {
-		if (local_dev == 0 && PCI_DEV(dev) != 1) {
+	if (PCI_BUS(bdf) == local_bus && PCI_DEV(bdf) != local_dev) {
+		if (local_dev == 0 && PCI_DEV(bdf) != 1) {
 			/*
 			 * If local dev is 0, the first other dev can
 			 * only be 1
 			 */
-			return 1;
-		} else if (local_dev != 0 && PCI_DEV(dev) != 0) {
+			return 0;
+		} else if (local_dev != 0 && PCI_DEV(bdf) != 0) {
 			/*
 			 * If local dev is not 0, the first other dev can
 			 * only be 0
 			 */
-			return 1;
+			return 0;
 		}
 	}
 
-	writel(PCIE_CONF_ADDR(dev, offset), pcie->base + PCIE_CONF_ADDR_OFF);
-	writel(val, pcie->base + PCIE_CONF_DATA_OFF);
+	writel(PCIE_CONF_ADDR(bdf, offset), pcie->base + PCIE_CONF_ADDR_OFF);
+	data = pci_conv_size_to_32(0, value, offset, size);
+	writel(data, pcie->base + PCIE_CONF_DATA_OFF);
 
 	return 0;
 }
@@ -332,107 +273,258 @@ static void mvebu_pcie_setup_wins(struct mvebu_pcie *pcie)
 	       pcie->base + PCIE_BAR_CTRL_OFF(1));
 }
 
-void pci_init_board(void)
+static void mvebu_pci_fixup_classid(struct mvebu_pcie *pcie)
+{
+	/* Setting pci class id to "bridge other" together with defining flag
+	 * CONFIG_PCIAUTO_SKIP_HOST_BRIDGE allows to skip autoconfiguration
+	 * of BDF=0.0.0 during pci enumeration. Thanks to that the driver
+	 * settings will not be overwritten as it happen with defaults
+	 * configuration where the pcie under BDF 0.0.0 introduce itself as
+	 * Memory controller with classid "0x0580" and in reality is pointing to
+	 * RC itself.
+	 */
+	writew(PCI_CLASS_BRIDGE_OTHER, pcie->base + PCI_CLASS_DEVICE);
+}
+
+static int mvebu_pcie_probe(struct udevice *dev)
 {
-	int mem_target, mem_attr, i;
-	int bus = 0;
+	struct mvebu_pcie *pcie = dev_get_platdata(dev);
+	struct udevice *ctlr = pci_get_controller(dev);
+	struct pci_controller *hose = dev_get_uclass_priv(ctlr);
+	static int bus;
 	u32 reg;
-	u32 soc_ctrl = readl(MVEBU_SYSTEM_REG_BASE + 0x4);
 
-	/* Check SoC Control Power State */
-	debug("%s: SoC Control %08x, 0en %01lx, 1en %01lx, 2en %01lx\n",
-	      __func__, soc_ctrl, SELECT(soc_ctrl, 0), SELECT(soc_ctrl, 1),
-	      SELECT(soc_ctrl, 2));
+	debug("%s: PCIe %d.%d - up, base %08x\n", __func__,
+	      pcie->port, pcie->lane, (u32)pcie->base);
+
+	/* Read Id info and local bus/dev */
+	debug("direct conf read %08x, local bus %d, local dev %d\n",
+	      readl(pcie->base), mvebu_pcie_get_local_bus_nr(pcie),
+	      mvebu_pcie_get_local_dev_nr(pcie));
+
+	mvebu_pcie_set_local_bus_nr(pcie, bus);
+	mvebu_pcie_set_local_dev_nr(pcie, 0);
+	pcie->dev = PCI_BDF(bus, 0, 0);
+
+	pcie->mem.start = (u32)mvebu_pcie_membase;
+	pcie->mem.end = pcie->mem.start + PCIE_MEM_SIZE - 1;
+	mvebu_pcie_membase += PCIE_MEM_SIZE;
+
+	if (mvebu_mbus_add_window_by_id(pcie->mem_target, pcie->mem_attr,
+					(phys_addr_t)pcie->mem.start,
+					PCIE_MEM_SIZE)) {
+		printf("PCIe unable to add mbus window for mem at %08x+%08x\n",
+		       (u32)pcie->mem.start, PCIE_MEM_SIZE);
+	}
+
+	/* Setup windows and configure host bridge */
+	mvebu_pcie_setup_wins(pcie);
 
-	for (i = 0; i < MAX_PEX; i++) {
-		struct mvebu_pcie *pcie = &pcie_bus[i];
-		struct pci_controller *hose = &pcie->hose;
+	/* Master + slave enable. */
+	reg = readl(pcie->base + PCIE_CMD_OFF);
+	reg |= PCI_COMMAND_MEMORY;
+	reg |= PCI_COMMAND_MASTER;
+	reg |= BIT(10);		/* disable interrupts */
+	writel(reg, pcie->base + PCIE_CMD_OFF);
+
+	/* Fixup classid */
+	mvebu_pci_fixup_classid(pcie);
+
+	/* Set BAR0 to internal registers */
+	writel(SOC_REGS_PHY_BASE, pcie->base + PCIE_BAR_LO_OFF(0));
+	writel(0, pcie->base + PCIE_BAR_HI_OFF(0));
+
+	/* PCI memory space */
+	pci_set_region(hose->regions + 0, pcie->mem.start,
+		       pcie->mem.start, PCIE_MEM_SIZE, PCI_REGION_MEM);
+	pci_set_region(hose->regions + 1,
+		       0, 0,
+		       gd->ram_size,
+		       PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
+	hose->region_count = 2;
+
+	bus++;
+
+	return 0;
+}
+
+static int mvebu_pcie_port_parse_dt(ofnode node, struct mvebu_pcie *pcie)
+{
+	const u32 *addr;
+	int len;
+
+	addr = ofnode_get_property(node, "assigned-addresses", &len);
+	if (!addr) {
+		pr_err("property \"assigned-addresses\" not found");
+		return -FDT_ERR_NOTFOUND;
+	}
 
-		/* Get port number, lane number and memory target / attr */
-		mvebu_get_port_lane(pcie, i, &mem_target, &mem_attr);
+	pcie->base = (void *)(fdt32_to_cpu(addr[2]) + SOC_REGS_PHY_BASE);
 
-		/* Don't read at all from pci registers if port power is down */
-		if (SELECT(soc_ctrl, pcie->port) == 0) {
-			if (pcie->lane == 0)
-				debug("%s: skipping port %d\n", __func__, pcie->port);
+	return 0;
+}
+
+#define DT_FLAGS_TO_TYPE(flags)       (((flags) >> 24) & 0x03)
+#define    DT_TYPE_IO                 0x1
+#define    DT_TYPE_MEM32              0x2
+#define DT_CPUADDR_TO_TARGET(cpuaddr) (((cpuaddr) >> 56) & 0xFF)
+#define DT_CPUADDR_TO_ATTR(cpuaddr)   (((cpuaddr) >> 48) & 0xFF)
+
+static int mvebu_get_tgt_attr(ofnode node, int devfn,
+			      unsigned long type,
+			      unsigned int *tgt,
+			      unsigned int *attr)
+{
+	const int na = 3, ns = 2;
+	const __be32 *range;
+	int rlen, nranges, rangesz, pna, i;
+
+	*tgt = -1;
+	*attr = -1;
+
+	range = ofnode_get_property(node, "ranges", &rlen);
+	if (!range)
+		return -EINVAL;
+
+	pna = 2; /* hardcoded for now because of lack of of_n_addr_cells() */
+	rangesz = pna + na + ns;
+	nranges = rlen / sizeof(__be32) / rangesz;
+
+	for (i = 0; i < nranges; i++, range += rangesz) {
+		u32 flags = of_read_number(range, 1);
+		u32 slot = of_read_number(range + 1, 1);
+		u64 cpuaddr = of_read_number(range + na, pna);
+		unsigned long rtype;
+
+		if (DT_FLAGS_TO_TYPE(flags) == DT_TYPE_IO)
+			rtype = IORESOURCE_IO;
+		else if (DT_FLAGS_TO_TYPE(flags) == DT_TYPE_MEM32)
+			rtype = IORESOURCE_MEM;
+		else
 			continue;
+
+		/*
+		 * The Linux code used PCI_SLOT() here, which expects devfn
+		 * in bits 7..0. PCI_DEV() in U-Boot is similar to PCI_SLOT(),
+		 * only expects devfn in 15..8, where its saved in this driver.
+		 */
+		if (slot == PCI_DEV(devfn) && type == rtype) {
+			*tgt = DT_CPUADDR_TO_TARGET(cpuaddr);
+			*attr = DT_CPUADDR_TO_ATTR(cpuaddr);
+			return 0;
 		}
+	}
+
+	return -ENOENT;
+}
+
+static int mvebu_pcie_ofdata_to_platdata(struct udevice *dev)
+{
+	struct mvebu_pcie *pcie = dev_get_platdata(dev);
+	int ret = 0;
+
+	/* Get port number, lane number and memory target / attr */
+	if (ofnode_read_u32(dev_ofnode(dev), "marvell,pcie-port",
+			    &pcie->port)) {
+		ret = -ENODEV;
+		goto err;
+	}
+
+	if (ofnode_read_u32(dev_ofnode(dev), "marvell,pcie-lane", &pcie->lane))
+		pcie->lane = 0;
+
+	sprintf(pcie->name, "pcie%d.%d", pcie->port, pcie->lane);
 
-		pcie->base = (void __iomem *)PCIE_BASE(i);
+	/* pci_get_devfn() returns devfn in bits 15..8, see PCI_DEV usage */
+	pcie->devfn = pci_get_devfn(dev);
+	if (pcie->devfn < 0) {
+		ret = -ENODEV;
+		goto err;
+	}
+
+	ret = mvebu_get_tgt_attr(dev_ofnode(dev->parent), pcie->devfn,
+				 IORESOURCE_MEM,
+				 &pcie->mem_target, &pcie->mem_attr);
+	if (ret < 0) {
+		printf("%s: cannot get tgt/attr for mem window\n", pcie->name);
+		goto err;
+	}
+
+	/* Parse PCIe controller register base from DT */
+	ret = mvebu_pcie_port_parse_dt(dev_ofnode(dev), pcie);
+	if (ret < 0)
+		goto err;
+
+	/* Check link and skip ports that have no link */
+	if (!mvebu_pcie_link_up(pcie)) {
+		debug("%s: %s - down\n", __func__, pcie->name);
+		ret = -ENODEV;
+		goto err;
+	}
+
+	return 0;
 
-		/* Check link and skip ports that have no link */
-		if (!mvebu_pcie_link_up(pcie)) {
-			debug("%s: PCIe %d.%d - down\n", __func__,
-			      pcie->port, pcie->lane);
+err:
+	return ret;
+}
+
+static const struct dm_pci_ops mvebu_pcie_ops = {
+	.read_config	= mvebu_pcie_read_config,
+	.write_config	= mvebu_pcie_write_config,
+};
+
+static struct driver pcie_mvebu_drv = {
+	.name			= "pcie_mvebu",
+	.id			= UCLASS_PCI,
+	.ops			= &mvebu_pcie_ops,
+	.probe			= mvebu_pcie_probe,
+	.ofdata_to_platdata	= mvebu_pcie_ofdata_to_platdata,
+	.platdata_auto_alloc_size = sizeof(struct mvebu_pcie),
+};
+
+/*
+ * Use a MISC device to bind the n instances (child nodes) of the
+ * PCIe base controller in UCLASS_PCI.
+ */
+static int mvebu_pcie_bind(struct udevice *parent)
+{
+	struct mvebu_pcie *pcie;
+	struct uclass_driver *drv;
+	struct udevice *dev;
+	ofnode subnode;
+
+	/* Lookup eth driver */
+	drv = lists_uclass_lookup(UCLASS_PCI);
+	if (!drv) {
+		puts("Cannot find PCI driver\n");
+		return -ENOENT;
+	}
+
+	ofnode_for_each_subnode(subnode, dev_ofnode(parent)) {
+		if (!ofnode_is_available(subnode))
 			continue;
-		}
-		debug("%s: PCIe %d.%d - up, base %08x\n", __func__,
-		      pcie->port, pcie->lane, (u32)pcie->base);
-
-		/* Read Id info and local bus/dev */
-		debug("direct conf read %08x, local bus %d, local dev %d\n",
-		      readl(pcie->base), mvebu_pcie_get_local_bus_nr(pcie),
-		      mvebu_pcie_get_local_dev_nr(pcie));
-
-		mvebu_pcie_set_local_bus_nr(pcie, bus);
-		mvebu_pcie_set_local_dev_nr(pcie, 0);
-		pcie->dev = PCI_BDF(bus, 0, 0);
-
-		pcie->mem.start = (u32)mvebu_pcie_membase;
-		pcie->mem.end = pcie->mem.start + PCIE_MEM_SIZE - 1;
-		mvebu_pcie_membase += PCIE_MEM_SIZE;
-
-		if (mvebu_mbus_add_window_by_id(mem_target, mem_attr,
-						(phys_addr_t)pcie->mem.start,
-						PCIE_MEM_SIZE)) {
-			printf("PCIe unable to add mbus window for mem at %08x+%08x\n",
-			       (u32)pcie->mem.start, PCIE_MEM_SIZE);
-		}
 
-		/* Setup windows and configure host bridge */
-		mvebu_pcie_setup_wins(pcie);
-
-		/* Master + slave enable. */
-		reg = readl(pcie->base + PCIE_CMD_OFF);
-		reg |= PCI_COMMAND_MEMORY;
-		reg |= PCI_COMMAND_MASTER;
-		reg |= BIT(10);		/* disable interrupts */
-		writel(reg, pcie->base + PCIE_CMD_OFF);
-
-		/* Setup U-Boot PCI Controller */
-		hose->first_busno = 0;
-		hose->current_busno = bus;
-
-		/* PCI memory space */
-		pci_set_region(hose->regions + 0, pcie->mem.start,
-			       pcie->mem.start, PCIE_MEM_SIZE, PCI_REGION_MEM);
-		pci_set_region(hose->regions + 1,
-			       0, 0,
-			       gd->ram_size,
-			       PCI_REGION_MEM | PCI_REGION_SYS_MEMORY);
-		hose->region_count = 2;
-
-		pci_set_ops(hose,
-			    pci_hose_read_config_byte_via_dword,
-			    pci_hose_read_config_word_via_dword,
-			    mvebu_pcie_read_config_dword,
-			    pci_hose_write_config_byte_via_dword,
-			    pci_hose_write_config_word_via_dword,
-			    mvebu_pcie_write_config_dword);
-		pci_register_hose(hose);
-
-		hose->last_busno = pci_hose_scan(hose);
-
-		/* Set BAR0 to internal registers */
-		writel(SOC_REGS_PHY_BASE, pcie->base + PCIE_BAR_LO_OFF(0));
-		writel(0, pcie->base + PCIE_BAR_HI_OFF(0));
-
-		bus = hose->last_busno + 1;
-
-		/* need to skip more for X4 links, otherwise scan will hang */
-		if (mvebu_soc_family() == MVEBU_SOC_AXP) {
-			if (mvebu_pex_unit_is_x4(i))
-				i += 3;
-		}
+		pcie = calloc(1, sizeof(*pcie));
+		if (!pcie)
+			return -ENOMEM;
+
+		/* Create child device UCLASS_PCI and bind it */
+		device_bind_ofnode(parent, &pcie_mvebu_drv, pcie->name, pcie,
+				   subnode, &dev);
 	}
+
+	return 0;
 }
+
+static const struct udevice_id mvebu_pcie_ids[] = {
+	{ .compatible = "marvell,armada-xp-pcie" },
+	{ .compatible = "marvell,armada-370-pcie" },
+	{ }
+};
+
+U_BOOT_DRIVER(pcie_mvebu_base) = {
+	.name			= "pcie_mvebu_base",
+	.id			= UCLASS_MISC,
+	.of_match		= mvebu_pcie_ids,
+	.bind			= mvebu_pcie_bind,
+};
diff --git a/drivers/pci/pci_octeontx_ecam.c b/drivers/pci/pci_octeontx_ecam.c
new file mode 100644
index 0000000..63e304d
--- /dev/null
+++ b/drivers/pci/pci_octeontx_ecam.c
@@ -0,0 +1,550 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#include <common.h>
+#include <dm.h>
+#include <errno.h>
+#include <fdtdec.h>
+#include <malloc.h>
+#include <pci.h>
+
+#include <asm/io.h>
+
+#if defined(CONFIG_ARCH_OCTEONTX2)
+
+#define PEM_CFG_WR 0x18
+#define PEM_CFG_RD 0x20
+
+#define PCIERC_RASDP_DE_ME		0x440
+#define PCIERC_RASDP_EP_CTL		0x420
+#define PCIERC_RAS_EINJ_EN		0x348
+#define PCIERC_RAS_EINJ_CTL6PE		0x3A4
+#define PCIERC_RAS_EINJ_CTL6_CMPP0	0x364
+#define PCIERC_RAS_EINJ_CTL6_CMPV0	0x374
+#define PCIERC_RAS_EINJ_CTL6_CHGP1	0x388
+#define PCIERC_RAS_EINJ_CTL6_CHGV1	0x398
+
+#endif
+
+
+DECLARE_GLOBAL_DATA_PTR;
+
+struct octeontx_pci {
+	unsigned int type;
+
+	struct fdt_resource cfg;
+	struct fdt_resource bus;
+#if defined(CONFIG_ARCH_OCTEONTX2)
+	struct fdt_resource pem;
+#endif
+};
+
+static int pci_octeontx_ecam_read_config(struct udevice *bus, pci_dev_t bdf,
+					 uint offset, ulong *valuep,
+					 enum pci_size_t size)
+{
+	struct octeontx_pci *pcie = (void *)dev_get_priv(bus);
+	struct pci_controller *hose = dev_get_uclass_priv(bus);
+	uintptr_t address;
+	u32 b, d, f;
+
+	b = PCI_BUS(bdf) + pcie->bus.start - hose->first_busno;
+	d = PCI_DEV(bdf);
+	f = PCI_FUNC(bdf);
+
+	address = (b << 20) | (d << 15) | (f << 12) | offset;
+
+	address += pcie->cfg.start;
+
+	switch (size) {
+	case PCI_SIZE_8:
+		*valuep = readb(address);
+		break;
+	case PCI_SIZE_16:
+		*valuep = readw(address);
+		break;
+	case PCI_SIZE_32:
+		*valuep = readl(address);
+		break;
+	};
+
+/*
+	debug("%02x.%02x.%02x: u%d %x -> %lx\n",
+	      b, d, f, size, offset, *valuep);
+*/
+	return 0;
+}
+
+static int pci_octeontx_ecam_write_config(struct udevice *bus, pci_dev_t bdf,
+					 uint offset, ulong valuep,
+					 enum pci_size_t size)
+{
+	struct octeontx_pci *pcie = (void *)dev_get_priv(bus);
+	struct pci_controller *hose = dev_get_uclass_priv(bus);
+	uintptr_t address;
+	u32 b, d, f;
+
+	b = PCI_BUS(bdf) + pcie->bus.start - hose->first_busno;
+	d = PCI_DEV(bdf);
+	f = PCI_FUNC(bdf);
+
+	address = (b << 20) | (d << 15) | (f << 12) | offset;
+
+	address += pcie->cfg.start;
+
+	switch (size) {
+	case PCI_SIZE_8:
+		writeb(valuep, address);
+		break;
+	case PCI_SIZE_16:
+		writew(valuep, address);
+		break;
+	case PCI_SIZE_32:
+		writel(valuep, address);
+		break;
+	};
+
+/*
+	debug("%02x.%02x.%02x: u%d %x <- %lx\n",
+	      b, d, f, size, offset, valuep);
+*/
+	return 0;
+}
+
+static int pci_octeontx_pem_read_config(struct udevice *bus, pci_dev_t bdf,
+					uint offset, ulong *valuep,
+					enum pci_size_t size)
+{
+	struct octeontx_pci *pcie = (void *)dev_get_priv(bus);
+	struct pci_controller *hose = dev_get_uclass_priv(bus);
+	uintptr_t address;
+	u32 b, d, f;
+	u8  hdrtype;
+	u8  pri_bus = pcie->bus.start + 1 - hose->first_busno;
+	u32 bus_offs = (pri_bus << 16) | (pri_bus << 8) | (pri_bus << 0);
+
+	b = PCI_BUS(bdf) + 1 - hose->first_busno;
+	d = PCI_DEV(bdf);
+	f = PCI_FUNC(bdf);
+
+	address = (b << 24) | (d << 19) | (f << 16);
+
+	address += pcie->cfg.start;
+
+	*valuep = pci_conv_32_to_size(~0UL, offset, size);
+
+	if (b == 1 && d > 0)
+		return 0;
+
+	switch (size) {
+	case PCI_SIZE_8:
+		*valuep = readb(address + offset);
+		break;
+	case PCI_SIZE_16:
+		*valuep = readw(address + offset);
+		break;
+	case PCI_SIZE_32:
+		*valuep = readl(address + offset);
+		break;
+	default:
+		printf("Invalid size\n");
+	}
+
+	hdrtype = readb(address + PCI_HEADER_TYPE);
+
+	if ((hdrtype == PCI_HEADER_TYPE_BRIDGE) &&
+	    (offset >= PCI_PRIMARY_BUS) &&
+	    (offset <= PCI_SUBORDINATE_BUS) &&
+	    *valuep != pci_conv_32_to_size(~0UL, offset, size)) {
+		*valuep -= pci_conv_32_to_size(bus_offs, offset, size);
+	}
+/*
+	debug("%02x.%02x.%02x: u%d %x (%lx) -> %lx\n",
+	      b, d, f, size, offset, address, *valuep);
+*/
+	return 0;
+}
+
+static int pci_octeontx_pem_write_config(struct udevice *bus, pci_dev_t bdf,
+					 uint offset, ulong value,
+					 enum pci_size_t size)
+{
+	struct octeontx_pci *pcie = (void *)dev_get_priv(bus);
+	struct pci_controller *hose = dev_get_uclass_priv(bus);
+	uintptr_t address;
+	u32 b, d, f;
+	u8  hdrtype;
+	u8  pri_bus = pcie->bus.start + 1 - hose->first_busno;
+	u32 bus_offs = (pri_bus << 16) | (pri_bus << 8) | (pri_bus << 0);
+
+	b = PCI_BUS(bdf) + 1 - hose->first_busno;
+	d = PCI_DEV(bdf);
+	f = PCI_FUNC(bdf);
+
+	address = (b << 24) | (d << 19) | (f << 16);
+
+	address += pcie->cfg.start;
+
+	hdrtype = readb(address + PCI_HEADER_TYPE);
+
+	if ((hdrtype == PCI_HEADER_TYPE_BRIDGE) &&
+	    (offset >= PCI_PRIMARY_BUS) &&
+	    (offset <= PCI_SUBORDINATE_BUS) &&
+	    (value != pci_conv_32_to_size(~0UL, offset, size))) {
+		value +=  pci_conv_32_to_size(bus_offs, offset, size);
+	}
+
+	if (b == 1 && d > 0)
+		return 0;
+
+	switch (size) {
+	case PCI_SIZE_8:
+		writeb(value, address + offset);
+		break;
+	case PCI_SIZE_16:
+		writew(value, address + offset);
+		break;
+	case PCI_SIZE_32:
+		writel(value, address + offset);
+		break;
+	default:
+		printf("Invalid size\n");
+	}
+/*
+	debug("%02x.%02x.%02x: u%d %x (%lx) <- %lx\n",
+	      b, d, f, size, offset, address, value);
+*/
+	return 0;
+}
+
+static int pci_octeontx2_pem_read_config(struct udevice *bus, pci_dev_t bdf,
+					uint offset, ulong *valuep,
+					enum pci_size_t size)
+{
+	struct octeontx_pci *pcie = (void *)dev_get_priv(bus);
+	struct pci_controller *hose = dev_get_uclass_priv(bus);
+	uintptr_t address;
+	u32 b, d, f;
+
+	b = PCI_BUS(bdf) + 1 - hose->first_busno;
+	d = PCI_DEV(bdf);
+	f = PCI_FUNC(bdf);
+
+	address = (b << 20) | (d << 15) | (f << 12);
+
+	debug("bdf %x %02x.%02x.%02x: u%d %x (%lx) \n",
+	      bdf, b, d, f, size, offset, address);
+	address += pcie->cfg.start;
+
+	debug("%02x.%02x.%02x: u%d %x (%lx) %lx \n",
+	      b, d, f, size, offset, address, *valuep);
+	*valuep = pci_conv_32_to_size(~0UL, offset, size);
+
+	if (b == 1 && d > 0)
+		return 0;
+
+	switch (size) {
+	case PCI_SIZE_8:
+		debug("byte %lx\n",address+offset);
+		*valuep = readb(address + offset);
+		break;
+	case PCI_SIZE_16:
+		debug("word %lx\n",address+offset);
+		*valuep = readw(address + offset);
+		break;
+	case PCI_SIZE_32:
+		debug("long %lx\n",address+offset);
+		*valuep = readl(address + offset);
+		break;
+	default:
+		printf("Invalid size\n");
+	}
+
+	debug("%02x.%02x.%02x: u%d %x (%lx) -> %lx\n",
+	      b, d, f, size, offset, address, *valuep);
+
+	return 0;
+}
+
+static void pci_octeontx2_pem_errata(struct udevice *bus, uint offset,
+					 enum pci_size_t size)
+{
+#if defined(CONFIG_ARCH_OCTEONTX2)
+	struct octeontx_pci *pcie = (void *)dev_get_priv(bus);
+	u64 rval, wval;
+	u32 cfg_off, data;
+	u64 raddr, waddr;
+	u8 shift;
+
+	raddr = pcie->pem.start + PEM_CFG_RD;
+	waddr = pcie->pem.start + PEM_CFG_WR;
+
+	debug("%s raddr %llx waddr %llx\n", __func__, raddr, waddr);
+		cfg_off = rval = wval = data = 0;
+
+		cfg_off = PCIERC_RASDP_DE_ME;
+		wval = cfg_off;
+	debug("%s DE_ME raddr %llx wval %llx\n", __func__, raddr, wval);
+		writeq(wval, raddr);
+		rval = readq(raddr);
+	debug("%s DE_ME raddr %llx rval %llx\n", __func__, raddr, rval);
+		data = rval >> 32;
+		if (data & 0x1) {
+			data = (data & (~0x1));
+			wval |= ((u64)data << 32);
+	debug("%s DE_ME waddr %llx wval %llx\n", __func__, waddr, wval);
+			writeq(wval, waddr);
+		}
+
+		cfg_off = PCIERC_RAS_EINJ_CTL6_CMPP0;
+		wval = cfg_off;
+		data = 0xFE000000;
+		wval |= ((u64)data << 32);
+	debug("%s CMPP0 waddr %llx wval %llx\n", __func__, waddr, wval);
+		writeq(wval, waddr);
+
+		cfg_off = PCIERC_RAS_EINJ_CTL6_CMPV0;
+		wval = cfg_off;
+		data = 0x44000000;
+		wval |= ((u64)data << 32);
+	debug("%s CMPV0 waddr %llx wval %llx\n", __func__, waddr, wval);
+		writeq(wval, waddr);
+
+		cfg_off = PCIERC_RAS_EINJ_CTL6_CHGP1;
+		wval = cfg_off;
+		data = 0xFF;
+		wval |= ((u64)data << 32);
+	debug("%s CHGP1 waddr %llx wval %llx\n", __func__, waddr, wval);
+		writeq(wval, waddr);
+
+	cfg_off = PCIERC_RAS_EINJ_EN;
+	wval = cfg_off;
+	data = 0x40;
+	wval |= ((u64)data << 32);
+	debug("%s EINJ_EN waddr %llx wval %llx\n", __func__, waddr, wval);
+	writeq(wval, waddr);
+
+	cfg_off = PCIERC_RAS_EINJ_CTL6PE;
+	wval = cfg_off;
+	data = 0x1;
+	wval |= ((u64)data << 32);
+	debug("%s EINJ_CTL6PE waddr %llx wval %llx\n", __func__, waddr, wval);
+	writeq(wval, waddr);
+
+	switch (size) {
+		case PCI_SIZE_8:
+			shift = offset % 4;
+			data = (0x1 << shift);
+		break;
+		case PCI_SIZE_16:
+			shift = (offset % 4) ? 2 : 0;
+			data = (0x3 << shift);
+		break;
+		default:
+		case PCI_SIZE_32:
+			data = 0xF;
+		break;
+	}
+
+	cfg_off = PCIERC_RAS_EINJ_CTL6_CHGV1;
+	wval = cfg_off;
+	wval |= ((u64)data << 32);
+	debug("%s EINJ_CHGV1 waddr %llx <= wval %llx\n", __func__, waddr, wval);
+	writeq(wval, waddr);
+
+	cfg_off = PCIERC_RASDP_EP_CTL;
+	wval = cfg_off;
+	wval |= ((u64)0x1 << 32);
+	debug("%s EP_CTL waddr %llx <= wval %llx\n", __func__, waddr, wval);
+	writeq(wval, waddr);
+
+	wval = readq(waddr);
+	debug("%s EP_CTL waddr %llx => wval %llx\n", __func__, waddr, wval);
+#endif
+}
+
+static int pci_octeontx2_pem_write_config(struct udevice *bus, pci_dev_t bdf,
+					 uint offset, ulong value,
+					 enum pci_size_t size)
+{
+	struct octeontx_pci *pcie = (void *)dev_get_priv(bus);
+	struct pci_controller *hose = dev_get_uclass_priv(bus);
+	uintptr_t address, addr;
+	u32 b, d, f;
+	u32 data;
+	int tmp;
+
+	b = PCI_BUS(bdf) + 1 - hose->first_busno;
+	d = PCI_DEV(bdf);
+	f = PCI_FUNC(bdf);
+
+	address = (b << 20) | (d << 15) | (f << 12);
+
+	debug("bdf %x %02x.%02x.%02x: u%d %x (%lx) \n",
+	      bdf, b, d, f, size, offset, address);
+	address += pcie->cfg.start;
+
+	debug("%02x.%02x.%02x: u%d %x (%lx) %lx \n",
+	      b, d, f, size, offset, address, value);
+
+	if (b == 1 && d > 0)
+		return 0;
+
+	addr = (address + offset) & ~0x3UL;
+	switch (size) {
+	case PCI_SIZE_8:
+		tmp = (address + offset) & 0x3;
+		size = PCI_SIZE_32;
+		data = readl(addr);
+		debug("tmp 8 long %lx %x\n",addr, data);
+		tmp *= 8;
+		value = (data & ~(0xFFUL << tmp)) | ((value & 0xFF) << tmp);
+	break;
+	case PCI_SIZE_16:
+		tmp = (address + offset) & 0x3;
+		size = PCI_SIZE_32;
+		data = readl(addr);
+		debug("tmp 16 long %lx %x\n",addr, data);
+		tmp *= 8;
+		value = (data & 0xFFFF) | (value << tmp);
+	break;
+	case PCI_SIZE_32:
+	break;
+	}
+	debug("tmp long %lx %lx\n",addr, value);
+
+	pci_octeontx2_pem_errata(bus, offset, size);
+
+	switch (size) {
+	case PCI_SIZE_8:
+		debug("byte %lx %lx\n",address+offset, value);
+		writeb(value, address + offset);
+		break;
+	case PCI_SIZE_16:
+		debug("word %lx %lx\n",address+offset, value);
+		writew(value, address + offset);
+		break;
+	case PCI_SIZE_32:
+		debug("long %lx %lx\n",addr, value);
+		writel(value, addr);
+		break;
+	default:
+		printf("Invalid size\n");
+	}
+
+	debug("%02x.%02x.%02x: u%d %x (%lx) <- %lx\n",
+	      b, d, f, size, offset, addr, value);
+
+	return 0;
+}
+
+static int pci_octeontx_ofdata_to_platdata(struct udevice *dev)
+{
+	return 0;
+}
+
+static int pci_octeontx_ecam_probe(struct udevice *dev)
+{
+	struct octeontx_pci *pcie = (void *)dev_get_priv(dev);
+	int err;
+
+	err = fdt_get_resource(gd->fdt_blob, dev->node.of_offset, "reg", 0,
+			       &pcie->cfg);
+
+	if (err) {
+		printf("Error reading resource: %s\n", fdt_strerror(err));
+		return err;
+	}
+
+#if defined(CONFIG_ARCH_OCTEONTX2)
+	err = fdt_node_check_compatible(gd->fdt_blob, dev->node.of_offset,
+					"marvell,pci-host-octeontx2-pem");
+	if (!err) {
+		err = fdt_get_resource(gd->fdt_blob, dev->node.of_offset,
+					"reg", 1, &pcie->pem);
+
+		if (err) {
+			printf("Error reading resource: %s\n",
+				fdt_strerror(err));
+			return err;
+		}
+	}
+#endif
+	err = fdtdec_get_pci_bus_range(gd->fdt_blob, dev->node.of_offset,
+				       &pcie->bus);
+
+	if (err) {
+		printf("Error reading resource: %s\n", fdt_strerror(err));
+		return err;
+	}
+
+	return 0;
+}
+
+static const struct dm_pci_ops pci_octeontx_ecam_ops = {
+	.read_config	= pci_octeontx_ecam_read_config,
+	.write_config	= pci_octeontx_ecam_write_config,
+};
+
+static const struct udevice_id pci_octeontx_ecam_ids[] = {
+	{ .compatible = "cavium,pci-host-thunder-ecam" },
+	{ .compatible = "cavium,pci-host-octeontx-ecam" },
+	{ .compatible = "pci-host-ecam-generic" },
+	{ }
+};
+
+static const struct dm_pci_ops pci_octeontx_pem_ops = {
+	.read_config	= pci_octeontx_pem_read_config,
+	.write_config	= pci_octeontx_pem_write_config,
+};
+
+static const struct udevice_id pci_octeontx_pem_ids[] = {
+	{ .compatible = "cavium,pci-host-thunder-pem" },
+	{ }
+};
+
+static const struct dm_pci_ops pci_octeontx2_pem_ops = {
+	.read_config	= pci_octeontx2_pem_read_config,
+	.write_config	= pci_octeontx2_pem_write_config,
+};
+
+static const struct udevice_id pci_octeontx2_pem_ids[] = {
+	{ .compatible = "marvell,pci-host-octeontx2-pem" },
+	{ }
+};
+
+U_BOOT_DRIVER(pci_octeontx_ecam) = {
+	.name	= "pci_octeontx_ecam",
+	.id	= UCLASS_PCI,
+	.of_match = pci_octeontx_ecam_ids,
+	.ops	= &pci_octeontx_ecam_ops,
+	.ofdata_to_platdata = pci_octeontx_ofdata_to_platdata,
+	.probe	= pci_octeontx_ecam_probe,
+	.priv_auto_alloc_size = sizeof(struct octeontx_pci),
+	.flags = DM_FLAG_PRE_RELOC,
+};
+
+U_BOOT_DRIVER(pci_octeontx2_pcie) = {
+	.name	= "pci_octeontx2_pem",
+	.id	= UCLASS_PCI,
+	.of_match = pci_octeontx2_pem_ids,
+	.ops	= &pci_octeontx2_pem_ops,
+	.ofdata_to_platdata = pci_octeontx_ofdata_to_platdata,
+	.probe	= pci_octeontx_ecam_probe,
+	.priv_auto_alloc_size = sizeof(struct octeontx_pci),
+};
+
+U_BOOT_DRIVER(pci_octeontx_pcie) = {
+	.name	= "pci_octeontx_pem",
+	.id	= UCLASS_PCI,
+	.of_match = pci_octeontx_pem_ids,
+	.ops	= &pci_octeontx_pem_ops,
+	.ofdata_to_platdata = pci_octeontx_ofdata_to_platdata,
+	.probe	= pci_octeontx_ecam_probe,
+	.priv_auto_alloc_size = sizeof(struct octeontx_pci),
+};
diff --git a/drivers/phy/marvell/Makefile b/drivers/phy/marvell/Makefile
index f181505..86d1c44 100644
--- a/drivers/phy/marvell/Makefile
+++ b/drivers/phy/marvell/Makefile
@@ -3,6 +3,5 @@
 #
 
 obj-$(CONFIG_MVEBU_COMPHY_SUPPORT) += comphy_core.o
-obj-$(CONFIG_MVEBU_COMPHY_SUPPORT) += comphy_mux.o
 obj-$(CONFIG_ARMADA_3700) += comphy_a3700.o
 obj-$(CONFIG_ARMADA_8K) += comphy_cp110.o
diff --git a/drivers/phy/marvell/comphy.h b/drivers/phy/marvell/comphy.h
deleted file mode 100644
index c9b94a4..0000000
--- a/drivers/phy/marvell/comphy.h
+++ /dev/null
@@ -1,154 +0,0 @@
-/*
- * Copyright (C) 2015-2016 Marvell International Ltd.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#ifndef _COMPHY_H_
-#define _COMPHY_H_
-
-#include <dt-bindings/comphy/comphy_data.h>
-#include <fdtdec.h>
-
-#if defined(DEBUG)
-#define debug_enter()	printf("----> Enter %s\n", __func__);
-#define debug_exit()	printf("<---- Exit  %s\n", __func__);
-#else
-#define debug_enter()
-#define debug_exit()
-#endif
-
-/* COMPHY registers */
-#define COMMON_PHY_CFG1_REG			0x0
-#define COMMON_PHY_CFG1_PWR_UP_OFFSET		1
-#define COMMON_PHY_CFG1_PWR_UP_MASK		\
-	(0x1 << COMMON_PHY_CFG1_PWR_UP_OFFSET)
-#define COMMON_PHY_CFG1_PIPE_SELECT_OFFSET	2
-#define COMMON_PHY_CFG1_PIPE_SELECT_MASK	\
-	(0x1 << COMMON_PHY_CFG1_PIPE_SELECT_OFFSET)
-#define COMMON_PHY_CFG1_PWR_ON_RESET_OFFSET	13
-#define COMMON_PHY_CFG1_PWR_ON_RESET_MASK	\
-	(0x1 << COMMON_PHY_CFG1_PWR_ON_RESET_OFFSET)
-#define COMMON_PHY_CFG1_CORE_RSTN_OFFSET	14
-#define COMMON_PHY_CFG1_CORE_RSTN_MASK		\
-	(0x1 << COMMON_PHY_CFG1_CORE_RSTN_OFFSET)
-#define COMMON_PHY_PHY_MODE_OFFSET		15
-#define COMMON_PHY_PHY_MODE_MASK		\
-	(0x1 << COMMON_PHY_PHY_MODE_OFFSET)
-
-#define COMMON_PHY_CFG6_REG			0x14
-#define COMMON_PHY_CFG6_IF_40_SEL_OFFSET	18
-#define COMMON_PHY_CFG6_IF_40_SEL_MASK		\
-	(0x1 << COMMON_PHY_CFG6_IF_40_SEL_OFFSET)
-
-#define COMMON_SELECTOR_PHY_OFFSET		0x140
-#define COMMON_SELECTOR_PIPE_OFFSET		0x144
-
-#define COMMON_PHY_SD_CTRL1			0x148
-#define COMMON_PHY_SD_CTRL1_COMPHY_0_4_PORT_OFFSET	0
-#define COMMON_PHY_SD_CTRL1_COMPHY_0_4_PORT_MASK	0xFFFF
-#define COMMON_PHY_SD_CTRL1_PCIE_X4_EN_OFFSET	24
-#define COMMON_PHY_SD_CTRL1_PCIE_X4_EN_MASK	\
-	(0x1 << COMMON_PHY_SD_CTRL1_PCIE_X4_EN_OFFSET)
-#define COMMON_PHY_SD_CTRL1_PCIE_X2_EN_OFFSET	25
-#define COMMON_PHY_SD_CTRL1_PCIE_X2_EN_MASK	\
-	(0x1 << COMMON_PHY_SD_CTRL1_PCIE_X2_EN_OFFSET)
-#define COMMON_PHY_SD_CTRL1_RXAUI1_OFFSET	26
-#define COMMON_PHY_SD_CTRL1_RXAUI1_MASK		\
-	(0x1 << COMMON_PHY_SD_CTRL1_RXAUI1_OFFSET)
-#define COMMON_PHY_SD_CTRL1_RXAUI0_OFFSET	27
-#define COMMON_PHY_SD_CTRL1_RXAUI0_MASK		\
-	(0x1 << COMMON_PHY_SD_CTRL1_RXAUI0_OFFSET)
-
-/* ToDo: Get this address via DT */
-#define MVEBU_CP0_REGS_BASE			0xF2000000UL
-
-#define DFX_DEV_GEN_CTRL12			(MVEBU_CP0_REGS_BASE + 0x400280)
-#define DFX_DEV_GEN_PCIE_CLK_SRC_OFFSET		7
-#define DFX_DEV_GEN_PCIE_CLK_SRC_MASK		\
-	(0x3 << DFX_DEV_GEN_PCIE_CLK_SRC_OFFSET)
-
-#define MAX_LANE_OPTIONS			10
-#define MAX_UTMI_PHY_COUNT			3
-
-struct comphy_mux_options {
-	u32 type;
-	u32 mux_value;
-};
-
-struct comphy_mux_data {
-	u32 max_lane_values;
-	struct comphy_mux_options mux_values[MAX_LANE_OPTIONS];
-};
-
-struct comphy_map {
-	u32 type;
-	u32 speed;
-	u32 invert;
-	bool clk_src;
-	bool end_point;
-};
-
-struct chip_serdes_phy_config {
-	struct comphy_mux_data *mux_data;
-	int (*ptr_comphy_chip_init)(struct chip_serdes_phy_config *,
-				    struct comphy_map *);
-	void __iomem *comphy_base_addr;
-	void __iomem *hpipe3_base_addr;
-	u32 comphy_lanes_count;
-	u32 comphy_mux_bitcount;
-	u32 cp_index;
-};
-
-/* Register helper functions */
-void reg_set(void __iomem *addr, u32 data, u32 mask);
-void reg_set_silent(void __iomem *addr, u32 data, u32 mask);
-void reg_set16(void __iomem *addr, u16 data, u16 mask);
-void reg_set_silent16(void __iomem *addr, u16 data, u16 mask);
-
-/* SoC specific init functions */
-#ifdef CONFIG_ARMADA_3700
-int comphy_a3700_init(struct chip_serdes_phy_config *ptr_chip_cfg,
-		      struct comphy_map *serdes_map);
-#else
-static inline int comphy_a3700_init(struct chip_serdes_phy_config *ptr_chip_cfg,
-				    struct comphy_map *serdes_map)
-{
-	/*
-	 * This function should never be called in this configuration, so
-	 * lets return an error here.
-	 */
-	return -1;
-}
-#endif
-
-#ifdef CONFIG_ARMADA_8K
-int comphy_cp110_init(struct chip_serdes_phy_config *ptr_chip_cfg,
-		      struct comphy_map *serdes_map);
-#else
-static inline int comphy_cp110_init(struct chip_serdes_phy_config *ptr_chip_cfg,
-		      struct comphy_map *serdes_map)
-{
-	/*
-	 * This function should never be called in this configuration, so
-	 * lets return an error here.
-	 */
-	return -1;
-}
-#endif
-
-void comphy_dedicated_phys_init(void);
-
-/* MUX function */
-void comphy_mux_init(struct chip_serdes_phy_config *ptr_chip_cfg,
-		     struct comphy_map *comphy_map_data,
-		     void __iomem *selector_base);
-
-void comphy_pcie_config_set(u32 comphy_max_count,
-			    struct comphy_map *serdes_map);
-void comphy_pcie_config_detect(u32 comphy_max_count,
-			       struct comphy_map *serdes_map);
-void comphy_pcie_unit_general_config(u32 pex_index);
-
-#endif /* _COMPHY_H_ */
-
diff --git a/drivers/phy/marvell/comphy_a3700.c b/drivers/phy/marvell/comphy_a3700.c
index 5afd23c..40b042d 100644
--- a/drivers/phy/marvell/comphy_a3700.c
+++ b/drivers/phy/marvell/comphy_a3700.c
@@ -14,92 +14,41 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
-struct sgmii_phy_init_data_fix {
-	u16 addr;
-	u16 value;
-};
-
-/* Changes to 40M1G25 mode data required for running 40M3G125 init mode */
-static struct sgmii_phy_init_data_fix sgmii_phy_init_fix[] = {
-	{0x005, 0x07CC}, {0x015, 0x0000}, {0x01B, 0x0000}, {0x01D, 0x0000},
-	{0x01E, 0x0000}, {0x01F, 0x0000}, {0x020, 0x0000}, {0x021, 0x0030},
-	{0x026, 0x0888}, {0x04D, 0x0152}, {0x04F, 0xA020}, {0x050, 0x07CC},
-	{0x053, 0xE9CA}, {0x055, 0xBD97}, {0x071, 0x3015}, {0x076, 0x03AA},
-	{0x07C, 0x0FDF}, {0x0C2, 0x3030}, {0x0C3, 0x8000}, {0x0E2, 0x5550},
-	{0x0E3, 0x12A4}, {0x0E4, 0x7D00}, {0x0E6, 0x0C83}, {0x101, 0xFCC0},
-	{0x104, 0x0C10}
-};
-
-/* 40M1G25 mode init data */
-static u16 sgmii_phy_init[512] = {
-	/* 0       1       2       3       4       5       6       7 */
-	/*-----------------------------------------------------------*/
-	/* 8       9       A       B       C       D       E       F */
-	0x3110, 0xFD83, 0x6430, 0x412F, 0x82C0, 0x06FA, 0x4500, 0x6D26,	/* 00 */
-	0xAFC0, 0x8000, 0xC000, 0x0000, 0x2000, 0x49CC, 0x0BC9, 0x2A52,	/* 08 */
-	0x0BD2, 0x0CDE, 0x13D2, 0x0CE8, 0x1149, 0x10E0, 0x0000, 0x0000,	/* 10 */
-	0x0000, 0x0000, 0x0000, 0x0001, 0x0000, 0x4134, 0x0D2D, 0xFFFF,	/* 18 */
-	0xFFE0, 0x4030, 0x1016, 0x0030, 0x0000, 0x0800, 0x0866, 0x0000,	/* 20 */
-	0x0000, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,	/* 28 */
-	0xFFFF, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/* 30 */
-	0x0000, 0x0000, 0x000F, 0x6A62, 0x1988, 0x3100, 0x3100, 0x3100,	/* 38 */
-	0x3100, 0xA708, 0x2430, 0x0830, 0x1030, 0x4610, 0xFF00, 0xFF00,	/* 40 */
-	0x0060, 0x1000, 0x0400, 0x0040, 0x00F0, 0x0155, 0x1100, 0xA02A,	/* 48 */
-	0x06FA, 0x0080, 0xB008, 0xE3ED, 0x5002, 0xB592, 0x7A80, 0x0001,	/* 50 */
-	0x020A, 0x8820, 0x6014, 0x8054, 0xACAA, 0xFC88, 0x2A02, 0x45CF,	/* 58 */
-	0x000F, 0x1817, 0x2860, 0x064F, 0x0000, 0x0204, 0x1800, 0x6000,	/* 60 */
-	0x810F, 0x4F23, 0x4000, 0x4498, 0x0850, 0x0000, 0x000E, 0x1002,	/* 68 */
-	0x9D3A, 0x3009, 0xD066, 0x0491, 0x0001, 0x6AB0, 0x0399, 0x3780,	/* 70 */
-	0x0040, 0x5AC0, 0x4A80, 0x0000, 0x01DF, 0x0000, 0x0007, 0x0000,	/* 78 */
-	0x2D54, 0x00A1, 0x4000, 0x0100, 0xA20A, 0x0000, 0x0000, 0x0000,	/* 80 */
-	0x0000, 0x0000, 0x0000, 0x7400, 0x0E81, 0x1000, 0x1242, 0x0210,	/* 88 */
-	0x80DF, 0x0F1F, 0x2F3F, 0x4F5F, 0x6F7F, 0x0F1F, 0x2F3F, 0x4F5F,	/* 90 */
-	0x6F7F, 0x4BAD, 0x0000, 0x0000, 0x0800, 0x0000, 0x2400, 0xB651,	/* 98 */
-	0xC9E0, 0x4247, 0x0A24, 0x0000, 0xAF19, 0x1004, 0x0000, 0x0000,	/* A0 */
-	0x0000, 0x0013, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/* A8 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/* B0 */
-	0x0000, 0x0000, 0x0000, 0x0060, 0x0000, 0x0000, 0x0000, 0x0000,	/* B8 */
-	0x0000, 0x0000, 0x3010, 0xFA00, 0x0000, 0x0000, 0x0000, 0x0003,	/* C0 */
-	0x1618, 0x8200, 0x8000, 0x0400, 0x050F, 0x0000, 0x0000, 0x0000,	/* C8 */
-	0x4C93, 0x0000, 0x1000, 0x1120, 0x0010, 0x1242, 0x1242, 0x1E00,	/* D0 */
-	0x0000, 0x0000, 0x0000, 0x00F8, 0x0000, 0x0041, 0x0800, 0x0000,	/* D8 */
-	0x82A0, 0x572E, 0x2490, 0x14A9, 0x4E00, 0x0000, 0x0803, 0x0541,	/* E0 */
-	0x0C15, 0x0000, 0x0000, 0x0400, 0x2626, 0x0000, 0x0000, 0x4200,	/* E8 */
-	0x0000, 0xAA55, 0x1020, 0x0000, 0x0000, 0x5010, 0x0000, 0x0000,	/* F0 */
-	0x0000, 0x0000, 0x5000, 0x0000, 0x0000, 0x0000, 0x02F2, 0x0000,	/* F8 */
-	0x101F, 0xFDC0, 0x4000, 0x8010, 0x0110, 0x0006, 0x0000, 0x0000,	/*100 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*108 */
-	0x04CF, 0x0000, 0x04CF, 0x0000, 0x04CF, 0x0000, 0x04C6, 0x0000,	/*110 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*118 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*120 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*128 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*130 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*138 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*140 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*148 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*150 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*158 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*160 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*168 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*170 */
-	0x0000, 0x0000, 0x0000, 0x00F0, 0x08A2, 0x3112, 0x0A14, 0x0000,	/*178 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*180 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*188 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*190 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*198 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1A0 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1A8 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1B0 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1B8 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1C0 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1C8 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1D0 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1D8 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1E0 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1E8 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1F0 */
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000	/*1F8 */
-};
+/* Firmware related definitions used for SMC calls */
+#define MV_SIP_COMPHY_POWER_ON	0x82000001
+
+#define COMPHY_FW_MODE_FORMAT(mode, invert)	((mode) << 12 | (invert) << 0)
+
+#define COMPHY_SATA_MODE	0x1
+#define COMPHY_SGMII_MODE	0x2	/* SGMII 1G */
+#define COMPHY_HS_SGMII_MODE	0x3	/* SGMII 2.5G */
+#define COMPHY_USB3H_MODE	0x4
+#define COMPHY_USB3D_MODE	0x5
+#define COMPHY_PCIE_MODE	0x6
+#define COMPHY_RXAUI_MODE	0x7
+#define COMPHY_XFI_MODE		0x8
+#define COMPHY_SFI_MODE		0x9
+#define COMPHY_USB3_MODE	0xa
+#define COMPHY_AP_MODE		0xb
+
+#define A3700_LANE_MAX_NUM	3
+
+static int comphy_smc(u32 function_id, u32 lane, u32 mode)
+{
+#ifndef CONFIG_MVEBU_PALLADIUM
+	struct pt_regs pregs = {0};
+
+	pregs.regs[0] = function_id;
+	pregs.regs[1] = lane;
+	pregs.regs[2] = mode;
+
+	smc_call(&pregs);
+
+	return pregs.regs[0];
+#else
+	return 1;
+#endif
+}
 
 /*
  * comphy_poll_reg
@@ -128,181 +77,28 @@ static u32 comphy_poll_reg(void *addr, u32 val, u32 mask, u32 timeout,
 }
 
 /*
- * comphy_pcie_power_up
- *
- * return: 1 if PLL locked (OK), 0 otherwise (FAIL)
- */
-static int comphy_pcie_power_up(u32 speed, u32 invert)
-{
-	int	ret;
-
-	debug_enter();
-
-	/*
-	 * 1. Enable max PLL.
-	 */
-	reg_set16((void __iomem *)LANE_CFG1_ADDR(PCIE),
-		  bf_use_max_pll_rate, 0);
-
-	/*
-	 * 2. Select 20 bit SERDES interface.
-	 */
-	reg_set16((void __iomem *)GLOB_CLK_SRC_LO_ADDR(PCIE),
-		  bf_cfg_sel_20b, 0);
-
-	/*
-	 * 3. Force to use reg setting for PCIe mode
-	 */
-	reg_set16((void __iomem *)MISC_REG1_ADDR(PCIE),
-		  bf_sel_bits_pcie_force, 0);
-
-	/*
-	 * 4. Change RX wait
-	 */
-	reg_set16((void __iomem *)PWR_MGM_TIM1_ADDR(PCIE), 0x10C, 0xFFFF);
-
-	/*
-	 * 5. Enable idle sync
-	 */
-	reg_set16((void __iomem *)UNIT_CTRL_ADDR(PCIE),
-		  0x60 | rb_idle_sync_en, 0xFFFF);
-
-	/*
-	 * 6. Enable the output of 100M/125M/500M clock
-	 */
-	reg_set16((void __iomem *)MISC_REG0_ADDR(PCIE),
-		  0xA00D | rb_clk500m_en | rb_clk100m_125m_en, 0xFFFF);
-
-	/*
-	 * 7. Enable TX
-	 */
-	reg_set((void __iomem *)PHY_REF_CLK_ADDR, 0x1342, 0xFFFFFFFF);
-
-	/*
-	 * 8. Check crystal jumper setting and program the Power and PLL
-	 *    Control accordingly
-	 */
-	if (get_ref_clk() == 40) {
-		reg_set16((void __iomem *)PWR_PLL_CTRL_ADDR(PCIE),
-			  0xFC63, 0xFFFF); /* 40 MHz */
-	} else {
-		reg_set16((void __iomem *)PWR_PLL_CTRL_ADDR(PCIE),
-			  0xFC62, 0xFFFF); /* 25 MHz */
-	}
-
-	/*
-	 * 9. Override Speed_PLL value and use MAC PLL
-	 */
-	reg_set16((void __iomem *)KVCO_CAL_CTRL_ADDR(PCIE),
-		  0x0040 | rb_use_max_pll_rate, 0xFFFF);
-
-	/*
-	 * 10. Check the Polarity invert bit
-	 */
-	if (invert & PHY_POLARITY_TXD_INVERT) {
-		reg_set16((void __iomem *)SYNC_PATTERN_ADDR(PCIE),
-			  phy_txd_inv, 0);
-	}
-
-	if (invert & PHY_POLARITY_RXD_INVERT) {
-		reg_set16((void __iomem *)SYNC_PATTERN_ADDR(PCIE),
-			  phy_rxd_inv, 0);
-	}
-
-	/*
-	 * 11. Release SW reset
-	 */
-	reg_set16((void __iomem *)GLOB_PHY_CTRL0_ADDR(PCIE),
-		  rb_mode_core_clk_freq_sel | rb_mode_pipe_width_32,
-		  bf_soft_rst | bf_mode_refdiv);
-
-	/* Wait for > 55 us to allow PCLK be enabled */
-	udelay(PLL_SET_DELAY_US);
-
-	/* Assert PCLK enabled */
-	ret = comphy_poll_reg((void *)LANE_STAT1_ADDR(PCIE),	/* address */
-			      rb_txdclk_pclk_en,		/* value */
-			      rb_txdclk_pclk_en,		/* mask */
-			      PLL_LOCK_TIMEOUT,			/* timeout */
-			      POLL_16B_REG);			/* 16bit */
-	if (ret == 0)
-		printf("Failed to lock PCIe PLL\n");
-
-	debug_exit();
-
-	/* Return the status of the PLL */
-	return ret;
-}
-
-/*
  * comphy_sata_power_up
  *
  * return: 1 if PLL locked (OK), 0 otherwise (FAIL)
  */
-static int comphy_sata_power_up(void)
+static int comphy_sata_power_up(u32 invert, u32 lane)
 {
 	int	ret;
 
 	debug_enter();
 
 	/*
-	 * 0. Swap SATA TX lines
-	 */
-	reg_set((void __iomem *)rh_vsreg_addr,
-		vphy_sync_pattern_reg, 0xFFFFFFFF);
-	reg_set((void __iomem *)rh_vsreg_data, bs_txd_inv, bs_txd_inv);
-
-	/*
-	 * 1. Select 40-bit data width width
-	 */
-	reg_set((void __iomem *)rh_vsreg_addr, vphy_loopback_reg0, 0xFFFFFFFF);
-	reg_set((void __iomem *)rh_vsreg_data, 0x800, bs_phyintf_40bit);
-
-	/*
-	 * 2. Select reference clock and PHY mode (SATA)
-	 */
-	reg_set((void __iomem *)rh_vsreg_addr, vphy_power_reg0, 0xFFFFFFFF);
-	if (get_ref_clk() == 40) {
-		reg_set((void __iomem *)rh_vsreg_data,
-			0x3, 0x00FF); /* 40 MHz */
-	} else {
-		reg_set((void __iomem *)rh_vsreg_data,
-			0x1, 0x00FF); /* 25 MHz */
-	}
-
-	/*
-	 * 3. Use maximum PLL rate (no power save)
-	 */
-	reg_set((void __iomem *)rh_vsreg_addr, vphy_calctl_reg, 0xFFFFFFFF);
-	reg_set((void __iomem *)rh_vsreg_data,
-		bs_max_pll_rate, bs_max_pll_rate);
-
-	/*
-	 * 4. Reset reserved bit (??)
-	 */
-	reg_set((void __iomem *)rh_vsreg_addr, vphy_reserve_reg, 0xFFFFFFFF);
-	reg_set((void __iomem *)rh_vsreg_data, 0, bs_phyctrl_frm_pin);
-
-	/*
-	 * 5. Set vendor-specific configuration (??)
+	 * Set vendor-specific configuration (??).
+	 * It was done in the middle of comphy initialization but test shows
+	 * that moving it before strict comphy init works ok. Thanks to that the
+	 * comphy init can be done with pure comphy range access, not touching
+	 * ahci range.
 	 */
 	reg_set((void __iomem *)rh_vs0_a, vsata_ctrl_reg, 0xFFFFFFFF);
 	reg_set((void __iomem *)rh_vs0_d, bs_phy_pu_pll, bs_phy_pu_pll);
 
-	/* Wait for > 55 us to allow PLL be enabled */
-	udelay(PLL_SET_DELAY_US);
-
-	/* Assert SATA PLL enabled */
-	reg_set((void __iomem *)rh_vsreg_addr, vphy_loopback_reg0, 0xFFFFFFFF);
-	ret = comphy_poll_reg((void *)rh_vsreg_data,	/* address */
-			      bs_pll_ready_tx,		/* value */
-			      bs_pll_ready_tx,		/* mask */
-			      PLL_LOCK_TIMEOUT,		/* timeout */
-			      POLL_32B_REG);		/* 32bit */
-	if (ret == 0)
-		printf("Failed to lock SATA PLL\n");
-
-	debug_exit();
+	ret = comphy_smc(MV_SIP_COMPHY_POWER_ON, lane,
+			 COMPHY_FW_MODE_FORMAT(COMPHY_SATA_MODE, invert));
 
 	return ret;
 }
@@ -312,7 +108,8 @@ static int comphy_sata_power_up(void)
  *
  * return: 1 if PLL locked (OK), 0 otherwise (FAIL)
  */
-static int comphy_usb3_power_up(u32 type, u32 speed, u32 invert)
+static int comphy_usb3_power_up(u32 speed, u32 invert, u32 lane,
+				bool indirect_reg_access)
 {
 	int	ret;
 
@@ -330,136 +127,21 @@ static int comphy_usb3_power_up(u32 type, u32 speed, u32 invert)
 	reg_set((void __iomem *)USB3_CTRPUL_VAL_REG,
 		0x8 << 24, rb_usb3_ctr_100ns);
 
+	ret = comphy_smc(MV_SIP_COMPHY_POWER_ON, lane,
+			 COMPHY_FW_MODE_FORMAT(COMPHY_USB3_MODE, invert));
 
-	/* 0xd005c300 = 0x1001 */
-	/* set PRD_TXDEEMPH (3.5db de-emph) */
-	reg_set16((void __iomem *)LANE_CFG0_ADDR(USB3), 0x1, 0xFF);
-
-	/*
-	 * unset BIT0: set Tx Electrical Idle Mode: Transmitter is in
-	 * low impedance mode during electrical idle
+	/* No matter host mode and device mode, it works with Hard ID detection
+	 * Unset DP and DM pulldown for USB2 Device mode
 	 */
-	/* unset BIT4: set G2 Tx Datapath with no Delayed Latency */
-	/* unset BIT6: set Tx Detect Rx Mode at LoZ mode */
-	reg_set16((void __iomem *)LANE_CFG1_ADDR(USB3), 0x0, 0xFFFF);
-
+	reg_set((void __iomem *)USB2_OTG_PHY_CTRL_ADDR, 0x0,
+		rb_usb2_dp_pulldn_dev_mode | rb_usb2_dm_pulldn_dev_mode);
 
-	/* 0xd005c310 = 0x93: set Spread Spectrum Clock Enabled  */
-	reg_set16((void __iomem *)LANE_CFG4_ADDR(USB3),
-		  bf_spread_spectrum_clock_en, 0x80);
+	/* Disbale VBus interrupt which will be enable again in kernel */
+	reg_set((void __iomem *)USB3_TOP_INT_ENABLE_REG, 0x0, vbus_int_enable);
 
-	/*
-	 * set Override Margining Controls From the MAC: Use margining signals
-	 * from lane configuration
-	 */
-	reg_set16((void __iomem *)TEST_MODE_CTRL_ADDR(USB3),
-		  rb_mode_margin_override, 0xFFFF);
-
-	/* set Lane-to-Lane Bundle Clock Sampling Period = per PCLK cycles */
-	/* set Mode Clock Source = PCLK is generated from REFCLK */
-	reg_set16((void __iomem *)GLOB_CLK_SRC_LO_ADDR(USB3), 0x0, 0xFF);
-
-	/* set G2 Spread Spectrum Clock Amplitude at 4K */
-	reg_set16((void __iomem *)GEN2_SETTING_2_ADDR(USB3), g2_tx_ssc_amp,
-		  0xF000);
-
-	/*
-	 * unset G3 Spread Spectrum Clock Amplitude & set G3 TX and RX Register
-	 * Master Current Select
-	 */
-	reg_set16((void __iomem *)GEN2_SETTING_3_ADDR(USB3), 0x0, 0xFFFF);
-
-	/*
-	 * 3. Check crystal jumper setting and program the Power and PLL
-	 * Control accordingly
-	 */
-	if (get_ref_clk() == 40) {
-		reg_set16((void __iomem *)PWR_PLL_CTRL_ADDR(USB3), 0xFCA3,
-			  0xFFFF); /* 40 MHz */
-	} else {
-		reg_set16((void __iomem *)PWR_PLL_CTRL_ADDR(USB3), 0xFCA2,
-			  0xFFFF); /* 25 MHz */
-	}
-
-	/*
-	 * 4. Change RX wait
-	 */
-	reg_set16((void __iomem *)PWR_MGM_TIM1_ADDR(USB3), 0x10C, 0xFFFF);
-
-	/*
-	 * 5. Enable idle sync
-	 */
-	reg_set16((void __iomem *)UNIT_CTRL_ADDR(USB3), 0x60 | rb_idle_sync_en,
-		  0xFFFF);
-
-	/*
-	 * 6. Enable the output of 500M clock
-	 */
-	reg_set16((void __iomem *)MISC_REG0_ADDR(USB3), 0xA00D | rb_clk500m_en,
-		  0xFFFF);
-
-	/*
-	 * 7. Set 20-bit data width
-	 */
-	reg_set16((void __iomem *)DIG_LB_EN_ADDR(USB3), 0x0400, 0xFFFF);
-
-	/*
-	 * 8. Override Speed_PLL value and use MAC PLL
-	 */
-	reg_set16((void __iomem *)KVCO_CAL_CTRL_ADDR(USB3),
-		  0x0040 | rb_use_max_pll_rate, 0xFFFF);
-
-	/*
-	 * 9. Check the Polarity invert bit
-	 */
-	if (invert & PHY_POLARITY_TXD_INVERT) {
-		reg_set16((void __iomem *)SYNC_PATTERN_ADDR(USB3),
-			  phy_txd_inv, 0);
-	}
-
-	if (invert & PHY_POLARITY_RXD_INVERT) {
-		reg_set16((void __iomem *)SYNC_PATTERN_ADDR(USB3),
-			  phy_rxd_inv, 0);
-	}
-
-	/*
-	 * 10. Release SW reset
-	 */
-	reg_set16((void __iomem *)GLOB_PHY_CTRL0_ADDR(USB3),
-		  rb_mode_core_clk_freq_sel | rb_mode_pipe_width_32 | 0x20,
-		  0xFFFF);
-
-	/* Wait for > 55 us to allow PCLK be enabled */
-	udelay(PLL_SET_DELAY_US);
-
-	/* Assert PCLK enabled */
-	ret = comphy_poll_reg((void *)LANE_STAT1_ADDR(USB3),	/* address */
-			      rb_txdclk_pclk_en,		/* value */
-			      rb_txdclk_pclk_en,		/* mask */
-			      PLL_LOCK_TIMEOUT,			/* timeout */
-			      POLL_16B_REG);			/* 16bit */
-	if (ret == 0)
-		printf("Failed to lock USB3 PLL\n");
-
-	/*
-	 * Set Soft ID for Host mode (Device mode works with Hard ID
-	 * detection)
-	 */
-	if (type == PHY_TYPE_USB3_HOST0) {
-		/*
-		 * set   BIT0: set ID_MODE of Host/Device = "Soft ID" (BIT1)
-		 * clear BIT1: set SOFT_ID = Host
-		 * set   BIT4: set INT_MODE = ID. Interrupt Mode: enable
-		 *             interrupt by ID instead of using both interrupts
-		 *             of HOST and Device ORed simultaneously
-		 *             INT_MODE=ID in order to avoid unexpected
-		 *             behaviour or both interrupts together
-		 */
-		reg_set((void __iomem *)USB32_CTRL_BASE,
-			usb32_ctrl_id_mode | usb32_ctrl_int_mode,
-			usb32_ctrl_id_mode | usb32_ctrl_soft_id |
-			usb32_ctrl_int_mode);
-	}
+	/* Clear VBus interrupt to prepare a clean state for kernel */
+	reg_set((void __iomem *)USB3_TOP_INT_STATUS_REG,
+		vbus_int_state, vbus_int_state);
 
 	debug_exit();
 
@@ -550,6 +232,18 @@ static int comphy_usb2_power_up(u8 usb32)
 	if (ret == 0)
 		printf("Failed to lock USB2 PLL\n");
 
+	if (usb32) {
+		/*
+		 * Disbale VBus interrupt which will be
+		 * enable again in kernel
+		 */
+		reg_set((void __iomem *)USB3_TOP_INT_ENABLE_REG, 0x0,
+			vbus_int_enable);
+		/* Clear VBus interrupt to prepare a clean state for kernel */
+		reg_set((void __iomem *)USB3_TOP_INT_STATUS_REG,
+			vbus_int_state, vbus_int_state);
+	}
+
 	debug_exit();
 
 	return ret;
@@ -603,234 +297,9 @@ static int comphy_emmc_power_up(void)
 }
 
 /*
- * comphy_sgmii_power_up
- *
- * return:
- */
-static void comphy_sgmii_phy_init(u32 lane, u32 speed)
-{
-	const int fix_arr_sz = ARRAY_SIZE(sgmii_phy_init_fix);
-	int addr, fix_idx;
-	u16 val;
-
-	fix_idx = 0;
-	for (addr = 0; addr < 512; addr++) {
-		/*
-		 * All PHY register values are defined in full for 3.125Gbps
-		 * SERDES speed. The values required for 1.25 Gbps are almost
-		 * the same and only few registers should be "fixed" in
-		 * comparison to 3.125 Gbps values. These register values are
-		 * stored in "sgmii_phy_init_fix" array.
-		 */
-		if ((speed != PHY_SPEED_1_25G) &&
-		    (sgmii_phy_init_fix[fix_idx].addr == addr)) {
-			/* Use new value */
-			val = sgmii_phy_init_fix[fix_idx].value;
-			if (fix_idx < fix_arr_sz)
-				fix_idx++;
-		} else {
-			val = sgmii_phy_init[addr];
-		}
-
-		phy_write16(lane, addr, val, 0xFFFF);
-	}
-}
-
-/*
- * comphy_sgmii_power_up
- *
- * return: 1 if PLL locked (OK), 0 otherwise (FAIL)
+ * comphy_dedicated_phys_init initialize the dedicated PHYs
+ * - not muxed SerDes lanes e.g. UTMI PHY
  */
-static int comphy_sgmii_power_up(u32 lane, u32 speed, u32 invert)
-{
-	int	ret;
-
-	debug_enter();
-
-	/*
-	 * 1. Configure PHY to SATA/SAS mode by setting pin PIN_PIPE_SEL=0
-	 */
-	reg_set((void __iomem *)COMPHY_SEL_ADDR, 0, rf_compy_select(lane));
-
-	/*
-	 * 2. Reset PHY by setting PHY input port PIN_RESET=1.
-	 * 3. Set PHY input port PIN_TX_IDLE=1, PIN_PU_IVREF=1 to keep
-	 *    PHY TXP/TXN output to idle state during PHY initialization
-	 * 4. Set PHY input port PIN_PU_PLL=0, PIN_PU_RX=0, PIN_PU_TX=0.
-	 */
-	reg_set((void __iomem *)COMPHY_PHY_CFG1_ADDR(lane),
-		rb_pin_reset_comphy | rb_pin_tx_idle | rb_pin_pu_iveref,
-		rb_pin_reset_core | rb_pin_pu_pll |
-		rb_pin_pu_rx | rb_pin_pu_tx);
-
-	/*
-	 * 5. Release reset to the PHY by setting PIN_RESET=0.
-	 */
-	reg_set((void __iomem *)COMPHY_PHY_CFG1_ADDR(lane),
-		0, rb_pin_reset_comphy);
-
-	/*
-	 * 7. Set PIN_PHY_GEN_TX[3:0] and PIN_PHY_GEN_RX[3:0] to decide
-	 *    COMPHY bit rate
-	 */
-	if (speed == PHY_SPEED_3_125G) { /* 3.125 GHz */
-		reg_set((void __iomem *)COMPHY_PHY_CFG1_ADDR(lane),
-			(0x8 << rf_gen_rx_sel_shift) |
-			(0x8 << rf_gen_tx_sel_shift),
-			rf_gen_rx_select | rf_gen_tx_select);
-
-	} else if (speed == PHY_SPEED_1_25G) { /* 1.25 GHz */
-		reg_set((void __iomem *)COMPHY_PHY_CFG1_ADDR(lane),
-			(0x6 << rf_gen_rx_sel_shift) |
-			(0x6 << rf_gen_tx_sel_shift),
-			rf_gen_rx_select | rf_gen_tx_select);
-	} else {
-		printf("Unsupported COMPHY speed!\n");
-		return 0;
-	}
-
-	/*
-	 * 8. Wait 1mS for bandgap and reference clocks to stabilize;
-	 *    then start SW programming.
-	 */
-	mdelay(10);
-
-	/* 9. Program COMPHY register PHY_MODE */
-	phy_write16(lane, PHY_PWR_PLL_CTRL_ADDR,
-		    PHY_MODE_SGMII << rf_phy_mode_shift, rf_phy_mode_mask);
-
-	/*
-	 * 10. Set COMPHY register REFCLK_SEL to select the correct REFCLK
-	 *     source
-	 */
-	phy_write16(lane, PHY_MISC_REG0_ADDR, 0, rb_ref_clk_sel);
-
-	/*
-	 * 11. Set correct reference clock frequency in COMPHY register
-	 *     REF_FREF_SEL.
-	 */
-	if (get_ref_clk() == 40) {
-		phy_write16(lane, PHY_PWR_PLL_CTRL_ADDR,
-			    0x4 << rf_ref_freq_sel_shift, rf_ref_freq_sel_mask);
-	} else {
-		/* 25MHz */
-		phy_write16(lane, PHY_PWR_PLL_CTRL_ADDR,
-			    0x1 << rf_ref_freq_sel_shift, rf_ref_freq_sel_mask);
-	}
-
-	/* 12. Program COMPHY register PHY_GEN_MAX[1:0] */
-	/*
-	 * This step is mentioned in the flow received from verification team.
-	 * However the PHY_GEN_MAX value is only meaningful for other
-	 * interfaces (not SGMII). For instance, it selects SATA speed
-	 * 1.5/3/6 Gbps or PCIe speed  2.5/5 Gbps
-	 */
-
-	/*
-	 * 13. Program COMPHY register SEL_BITS to set correct parallel data
-	 *     bus width
-	 */
-	/* 10bit */
-	phy_write16(lane, PHY_DIG_LB_EN_ADDR, 0, rf_data_width_mask);
-
-	/*
-	 * 14. As long as DFE function needs to be enabled in any mode,
-	 *     COMPHY register DFE_UPDATE_EN[5:0] shall be programmed to 0x3F
-	 *     for real chip during COMPHY power on.
-	 */
-	/*
-	 * The step 14 exists (and empty) in the original initialization flow
-	 * obtained from the verification team. According to the functional
-	 * specification DFE_UPDATE_EN already has the default value 0x3F
-	 */
-
-	/*
-	 * 15. Program COMPHY GEN registers.
-	 *     These registers should be programmed based on the lab testing
-	 *     result to achieve optimal performance. Please contact the CEA
-	 *     group to get the related GEN table during real chip bring-up.
-	 *     We only requred to run though the entire registers programming
-	 *     flow defined by "comphy_sgmii_phy_init" when the REF clock is
-	 *     40 MHz. For REF clock 25 MHz the default values stored in PHY
-	 *     registers are OK.
-	 */
-	debug("Running C-DPI phy init %s mode\n",
-	      speed == PHY_SPEED_3_125G ? "2G5" : "1G");
-	if (get_ref_clk() == 40)
-		comphy_sgmii_phy_init(lane, speed);
-
-	/*
-	 * 16. [Simulation Only] should not be used for real chip.
-	 *     By pass power up calibration by programming EXT_FORCE_CAL_DONE
-	 *     (R02h[9]) to 1 to shorten COMPHY simulation time.
-	 */
-	/*
-	 * 17. [Simulation Only: should not be used for real chip]
-	 *     Program COMPHY register FAST_DFE_TIMER_EN=1 to shorten RX
-	 *     training simulation time.
-	 */
-
-	/*
-	 * 18. Check the PHY Polarity invert bit
-	 */
-	if (invert & PHY_POLARITY_TXD_INVERT)
-		phy_write16(lane, PHY_SYNC_PATTERN_ADDR, phy_txd_inv, 0);
-
-	if (invert & PHY_POLARITY_RXD_INVERT)
-		phy_write16(lane, PHY_SYNC_PATTERN_ADDR, phy_rxd_inv, 0);
-
-	/*
-	 * 19. Set PHY input ports PIN_PU_PLL, PIN_PU_TX and PIN_PU_RX to 1
-	 *     to start PHY power up sequence. All the PHY register
-	 *     programming should be done before PIN_PU_PLL=1. There should be
-	 *     no register programming for normal PHY operation from this point.
-	 */
-	reg_set((void __iomem *)COMPHY_PHY_CFG1_ADDR(lane),
-		rb_pin_pu_pll | rb_pin_pu_rx | rb_pin_pu_tx,
-		rb_pin_pu_pll | rb_pin_pu_rx | rb_pin_pu_tx);
-
-	/*
-	 * 20. Wait for PHY power up sequence to finish by checking output ports
-	 *     PIN_PLL_READY_TX=1 and PIN_PLL_READY_RX=1.
-	 */
-	ret = comphy_poll_reg((void *)COMPHY_PHY_STAT1_ADDR(lane), /* address */
-			      rb_pll_ready_tx | rb_pll_ready_rx, /* value */
-			      rb_pll_ready_tx | rb_pll_ready_rx, /* mask */
-			      PLL_LOCK_TIMEOUT,			/* timeout */
-			      POLL_32B_REG);			/* 32bit */
-	if (ret == 0)
-		printf("Failed to lock PLL for SGMII PHY %d\n", lane);
-
-	/*
-	 * 21. Set COMPHY input port PIN_TX_IDLE=0
-	 */
-	reg_set((void __iomem *)COMPHY_PHY_CFG1_ADDR(lane),
-		0x0, rb_pin_tx_idle);
-
-	/*
-	 * 22. After valid data appear on PIN_RXDATA bus, set PIN_RX_INIT=1.
-	 *     to start RX initialization. PIN_RX_INIT_DONE will be cleared to
-	 *     0 by the PHY. After RX initialization is done, PIN_RX_INIT_DONE
-	 *     will be set to 1 by COMPHY. Set PIN_RX_INIT=0 after
-	 *     PIN_RX_INIT_DONE= 1.
-	 *     Please refer to RX initialization part for details.
-	 */
-	reg_set((void __iomem *)COMPHY_PHY_CFG1_ADDR(lane), rb_phy_rx_init,
-		0x0);
-
-	ret = comphy_poll_reg((void *)COMPHY_PHY_STAT1_ADDR(lane), /* address */
-			      rb_rx_init_done,			/* value */
-			      rb_rx_init_done,			/* mask */
-			      PLL_LOCK_TIMEOUT,		/* timeout */
-			      POLL_32B_REG);			/* 32bit */
-	if (ret == 0)
-		printf("Failed to init RX of SGMII PHY %d\n", lane);
-
-	debug_exit();
-
-	return ret;
-}
-
 void comphy_dedicated_phys_init(void)
 {
 	int node, usb32, ret = 1;
@@ -845,7 +314,7 @@ void comphy_dedicated_phys_init(void)
 		 */
 		if (usb32 == 0) {
 			node = fdt_node_offset_by_compatible(
-				blob, -1, "marvell,armada-3700-ehci");
+				blob, -1, "marvell,armada3700-ehci");
 		} else {
 			node = fdt_node_offset_by_compatible(
 				blob, -1, "marvell,armada3700-xhci");
@@ -868,22 +337,6 @@ void comphy_dedicated_phys_init(void)
 	}
 
 	node = fdt_node_offset_by_compatible(blob, -1,
-					     "marvell,armada-3700-ahci");
-	if (node > 0) {
-		if (fdtdec_get_is_enabled(blob, node)) {
-			ret = comphy_sata_power_up();
-			if (ret == 0)
-				printf("Failed to initialize SATA PHY\n");
-			else
-				debug("SATA PHY init succeed\n");
-		} else {
-			debug("SATA node is disabled\n");
-		}
-	}  else {
-		debug("No SATA node in DT\n");
-	}
-
-	node = fdt_node_offset_by_compatible(blob, -1,
 					     "marvell,armada-8k-sdhci");
 	if (node <= 0) {
 		node = fdt_node_offset_by_compatible(
@@ -913,9 +366,15 @@ int comphy_a3700_init(struct chip_serdes_phy_config *chip_cfg,
 	struct comphy_map *comphy_map;
 	u32 comphy_max_count = chip_cfg->comphy_lanes_count;
 	u32 lane, ret = 0;
+	u32 mode = 0, fw_format = 0;
 
 	debug_enter();
 
+	if (comphy_max_count > A3700_LANE_MAX_NUM) {
+		printf("Comphy number %d is too large\n", comphy_max_count);
+		return 1;
+	}
+
 	for (lane = 0, comphy_map = serdes_map; lane < comphy_max_count;
 	     lane++, comphy_map++) {
 		debug("Initialize serdes number %d\n", lane);
@@ -923,26 +382,46 @@ int comphy_a3700_init(struct chip_serdes_phy_config *chip_cfg,
 		      comphy_map->type, comphy_map->invert);
 
 		switch (comphy_map->type) {
-		case PHY_TYPE_UNCONNECTED:
+		case COMPHY_TYPE_UNCONNECTED:
 			continue;
 			break;
 
-		case PHY_TYPE_PEX0:
-			ret = comphy_pcie_power_up(comphy_map->speed,
-						   comphy_map->invert);
+		case COMPHY_TYPE_PEX0:
+			fw_format = COMPHY_FW_MODE_FORMAT(COMPHY_PCIE_MODE,
+							  comphy_map->invert);
+			ret = comphy_smc(MV_SIP_COMPHY_POWER_ON, lane,
+					 fw_format);
 			break;
 
-		case PHY_TYPE_USB3_HOST0:
-		case PHY_TYPE_USB3_DEVICE:
-			ret = comphy_usb3_power_up(comphy_map->type,
-						   comphy_map->speed,
-						   comphy_map->invert);
+		case COMPHY_TYPE_USB3:
+		case COMPHY_TYPE_USB3_HOST0:
+		case COMPHY_TYPE_USB3_DEVICE:
+
+			ret = comphy_usb3_power_up(comphy_map->speed,
+						   comphy_map->invert,
+						   lane,
+						   (lane == 2) ? true : false);
 			break;
 
-		case PHY_TYPE_SGMII0:
-		case PHY_TYPE_SGMII1:
-			ret = comphy_sgmii_power_up(lane, comphy_map->speed,
-						    comphy_map->invert);
+		case COMPHY_TYPE_SGMII0:
+		case COMPHY_TYPE_SGMII1:
+			if (comphy_map->speed == COMPHY_SPEED_1_25G)
+				mode = COMPHY_SGMII_MODE;
+			else if (comphy_map->speed == COMPHY_SPEED_3_125G)
+				mode = COMPHY_HS_SGMII_MODE;
+			else
+				printf("Unsupported COMPHY speed!\n");
+
+			fw_format = COMPHY_FW_MODE_FORMAT(mode,
+							  comphy_map->invert);
+			ret = comphy_smc(MV_SIP_COMPHY_POWER_ON, lane,
+					 fw_format);
+
+			break;
+
+		case COMPHY_TYPE_SATA0:
+			ret = comphy_sata_power_up(comphy_map->invert, lane);
+
 			break;
 
 		default:
@@ -951,7 +430,7 @@ int comphy_a3700_init(struct chip_serdes_phy_config *chip_cfg,
 			ret = 1;
 			break;
 		}
-		if (ret == 0)
+		if (ret != 0)
 			printf("PLL is not locked - Failed to initialize lane %d\n",
 			       lane);
 	}
diff --git a/drivers/phy/marvell/comphy_a3700.h b/drivers/phy/marvell/comphy_a3700.h
index dd60b88..645cf5f 100644
--- a/drivers/phy/marvell/comphy_a3700.h
+++ b/drivers/phy/marvell/comphy_a3700.h
@@ -7,185 +7,33 @@
 #ifndef _COMPHY_A3700_H_
 #define _COMPHY_A3700_H_
 
-#include "comphy.h"
-#include "comphy_hpipe.h"
+#include "comphy_priv.h"
 
 #define MVEBU_REG(offs)			((uintptr_t)MVEBU_REGISTER(offs))
 
-#define DEFAULT_REFCLK_MHZ		25
-#define PLL_SET_DELAY_US		600
 #define PLL_LOCK_TIMEOUT		1000
 #define POLL_16B_REG			1
 #define POLL_32B_REG			0
 
 /*
- * COMPHY SB definitions
+ * USB definitions
  */
-#define COMPHY_SEL_ADDR			MVEBU_REG(0x0183FC)
-#define rf_compy_select(lane)		(0x1 << (((lane) == 1) ? 4 : 0))
-
-#define COMPHY_PHY_CFG1_ADDR(lane)	MVEBU_REG(0x018300 + (lane) * 0x28)
-#define rb_pin_pu_iveref		BIT(1)
-#define rb_pin_reset_core		BIT(11)
-#define rb_pin_reset_comphy		BIT(12)
-#define rb_pin_pu_pll			BIT(16)
-#define rb_pin_pu_rx			BIT(17)
-#define rb_pin_pu_tx			BIT(18)
-#define rb_pin_tx_idle			BIT(19)
-#define rf_gen_rx_sel_shift		22
-#define rf_gen_rx_select		(0x0F << rf_gen_rx_sel_shift)
-#define rf_gen_tx_sel_shift		26
-#define rf_gen_tx_select		(0x0F << rf_gen_tx_sel_shift)
-#define rb_phy_rx_init			BIT(30)
-
-#define COMPHY_PHY_STAT1_ADDR(lane)	MVEBU_REG(0x018318 + (lane) * 0x28)
-#define rb_rx_init_done			BIT(0)
-#define rb_pll_ready_rx			BIT(2)
-#define rb_pll_ready_tx			BIT(3)
-
-/*
- * PCIe/USB/SGMII definitions
- */
-#define PCIE_BASE			MVEBU_REG(0x070000)
-#define PCIETOP_BASE			MVEBU_REG(0x080000)
-#define PCIE_RAMBASE			MVEBU_REG(0x08C000)
-#define PCIEPHY_BASE			MVEBU_REG(0x01F000)
-#define PCIEPHY_SHFT			2
-
 #define USB32_BASE			MVEBU_REG(0x050000) /* usb3 device */
-#define USB32H_BASE			MVEBU_REG(0x058000) /* usb3 host */
-#define USB3PHY_BASE			MVEBU_REG(0x05C000)
 #define USB2PHY_BASE			MVEBU_REG(0x05D000)
 #define USB2PHY2_BASE			MVEBU_REG(0x05F000)
-#define USB32_CTRL_BASE			MVEBU_REG(0x05D800)
-#define USB3PHY_SHFT			2
-
-#define SGMIIPHY_BASE(l)	(l == 1 ? USB3PHY_BASE : PCIEPHY_BASE)
-#define SGMIIPHY_ADDR(l, a)	(((a & 0x00007FF) * 2) | SGMIIPHY_BASE(l))
-
-#define phy_read16(l, a)	read16((void __iomem *)SGMIIPHY_ADDR(l, a))
-#define phy_write16(l, a, data, mask)	\
-	reg_set16((void __iomem *)SGMIIPHY_ADDR(l, a), data, mask)
-
-/* units */
-#define PCIE				1
-#define USB3				2
-
-#define PHY_BASE(unit)		((unit == PCIE) ? PCIEPHY_BASE : USB3PHY_BASE)
-#define PHY_SHFT(unit)		((unit == PCIE) ? PCIEPHY_SHFT : USB3PHY_SHFT)
-
-/* bit definition for USB32_CTRL_BASE (USB32 Control Mode) */
-#define usb32_ctrl_id_mode		BIT(0)
-#define usb32_ctrl_soft_id		BIT(1)
-#define usb32_ctrl_int_mode		BIT(4)
-
-
-#define PHY_PWR_PLL_CTRL_ADDR	0x01	/* for phy_read16 and phy_write16 */
-#define PWR_PLL_CTRL_ADDR(unit)		\
-	(PHY_PWR_PLL_CTRL_ADDR * PHY_SHFT(unit) + PHY_BASE(unit))
-#define rf_phy_mode_shift		5
-#define rf_phy_mode_mask		(0x7 << rf_phy_mode_shift)
-#define rf_ref_freq_sel_shift		0
-#define rf_ref_freq_sel_mask		(0x1F << rf_ref_freq_sel_shift)
-#define PHY_MODE_SGMII			0x4
-
-/* for phy_read16 and phy_write16 */
-#define PHY_REG_KVCO_CAL_CTRL_ADDR	0x02
-#define KVCO_CAL_CTRL_ADDR(unit)	\
-	(PHY_REG_KVCO_CAL_CTRL_ADDR * PHY_SHFT(unit) + PHY_BASE(unit))
-#define rb_use_max_pll_rate		BIT(12)
-#define rb_force_calibration_done	BIT(9)
-
-/* for phy_read16 and phy_write16 */
-#define PHY_DIG_LB_EN_ADDR		0x23
-#define DIG_LB_EN_ADDR(unit)		\
-	(PHY_DIG_LB_EN_ADDR * PHY_SHFT(unit) + PHY_BASE(unit))
-#define rf_data_width_shift		10
-#define rf_data_width_mask		(0x3 << rf_data_width_shift)
-
-/* for phy_read16 and phy_write16 */
-#define PHY_SYNC_PATTERN_ADDR		0x24
-#define SYNC_PATTERN_ADDR(unit)		\
-	(PHY_SYNC_PATTERN_ADDR * PHY_SHFT(unit) + PHY_BASE(unit))
-#define phy_txd_inv			BIT(10)
-#define phy_rxd_inv			BIT(11)
-
-/* for phy_read16 and phy_write16 */
-#define PHY_REG_UNIT_CTRL_ADDR		0x48
-#define UNIT_CTRL_ADDR(unit)		\
-	(PHY_REG_UNIT_CTRL_ADDR * PHY_SHFT(unit) + PHY_BASE(unit))
-#define rb_idle_sync_en			BIT(12)
-
-/* for phy_read16 and phy_write16 */
-#define PHY_REG_GEN2_SETTINGS_2		0x3e
-#define GEN2_SETTING_2_ADDR(unit)	\
-	(PHY_REG_GEN2_SETTINGS_2 * PHY_SHFT(unit) + PHY_BASE(unit))
-#define g2_tx_ssc_amp			BIT(14)
-
-/* for phy_read16 and phy_write16 */
-#define PHY_REG_GEN2_SETTINGS_3		0x3f
-#define GEN2_SETTING_3_ADDR(unit)	\
-	(PHY_REG_GEN2_SETTINGS_3 * PHY_SHFT(unit) + PHY_BASE(unit))
-
-/* for phy_read16 and phy_write16 */
-#define PHY_MISC_REG0_ADDR		0x4f
-#define MISC_REG0_ADDR(unit)		\
-	(PHY_MISC_REG0_ADDR * PHY_SHFT(unit) + PHY_BASE(unit))
-#define rb_clk100m_125m_en		BIT(4)
-#define rb_clk500m_en			BIT(7)
-#define rb_ref_clk_sel			BIT(10)
-
-/* for phy_read16 and phy_write16 */
-#define PHY_REG_IFACE_REF_CLK_CTRL_ADDR		0x51
-#define UNIT_IFACE_REF_CLK_CTRL_ADDR(unit)	\
-	(PHY_REG_IFACE_REF_CLK_CTRL_ADDR * PHY_SHFT(unit) + PHY_BASE(unit))
-#define rb_ref1m_gen_div_force		BIT(8)
-#define rf_ref1m_gen_div_value_shift	0
-#define rf_ref1m_gen_div_value_mask	(0xFF << rf_ref1m_gen_div_value_shift)
-
-/* for phy_read16 and phy_write16 */
-#define PHY_REG_ERR_CNT_CONST_CTRL_ADDR	0x6A
-#define UNIT_ERR_CNT_CONST_CTRL_ADDR(unit) \
-	(PHY_REG_ERR_CNT_CONST_CTRL_ADDR * PHY_SHFT(unit) + PHY_BASE(unit))
-#define rb_fast_dfe_enable		BIT(13)
-
-#define MISC_REG1_ADDR(u)		(0x73 * PHY_SHFT(u) + PHY_BASE(u))
-#define bf_sel_bits_pcie_force		BIT(15)
-
-#define LANE_CFG0_ADDR(u)		(0x180 * PHY_SHFT(u) + PHY_BASE(u))
-#define bf_use_max_pll_rate		BIT(9)
-#define LANE_CFG1_ADDR(u)		(0x181 * PHY_SHFT(u) + PHY_BASE(u))
-#define bf_use_max_pll_rate		BIT(9)
-/* 0x5c310 = 0x93 (set BIT7) */
-#define LANE_CFG4_ADDR(u)		(0x188 * PHY_SHFT(u) + PHY_BASE(u))
-#define bf_spread_spectrum_clock_en	BIT(7)
-
-#define LANE_STAT1_ADDR(u)		(0x183 * PHY_SHFT(u) + PHY_BASE(u))
-#define rb_txdclk_pclk_en		BIT(0)
-
-#define GLOB_PHY_CTRL0_ADDR(u)		(0x1c1 * PHY_SHFT(u) + PHY_BASE(u))
-#define bf_soft_rst			BIT(0)
-#define bf_mode_refdiv			0x30
-#define rb_mode_core_clk_freq_sel	BIT(9)
-#define rb_mode_pipe_width_32		BIT(3)
-
-#define TEST_MODE_CTRL_ADDR(u)		(0x1c2 * PHY_SHFT(u) + PHY_BASE(u))
-#define rb_mode_margin_override		BIT(2)
-
-#define GLOB_CLK_SRC_LO_ADDR(u)		(0x1c3 * PHY_SHFT(u) + PHY_BASE(u))
-#define bf_cfg_sel_20b			BIT(15)
-
-#define PWR_MGM_TIM1_ADDR(u)		(0x1d0 * PHY_SHFT(u) + PHY_BASE(u))
-
-#define PHY_REF_CLK_ADDR		(0x4814 + PCIE_BASE)
 
 #define USB3_CTRPUL_VAL_REG		(0x20 + USB32_BASE)
-#define USB3H_CTRPUL_VAL_REG		(0x3454 + USB32H_BASE)
+#define USB3_TOP_INT_STATUS_REG		(0xd8 + USB32_BASE)
+#define vbus_int_state			BIT(5)
+#define USB3_TOP_INT_ENABLE_REG		(0xdc + USB32_BASE)
+#define vbus_int_enable			BIT(5)
 #define rb_usb3_ctr_100ns		0xff000000
 
 #define USB2_OTG_PHY_CTRL_ADDR		(0x820 + USB2PHY_BASE)
 #define rb_usb2phy_suspm		BIT(14)
 #define rb_usb2phy_pu			BIT(0)
+#define rb_usb2_dp_pulldn_dev_mode	BIT(5)
+#define rb_usb2_dm_pulldn_dev_mode	BIT(6)
 
 #define USB2_PHY_OTG_CTRL_ADDR		(0x34 + USB2PHY_BASE)
 #define rb_pu_otg			BIT(4)
@@ -235,27 +83,9 @@
  */
 #define AHCI_BASE			MVEBU_REG(0xE0000)
 
-#define rh_vsreg_addr			(AHCI_BASE + 0x178)
-#define rh_vsreg_data			(AHCI_BASE + 0x17C)
 #define rh_vs0_a			(AHCI_BASE + 0xA0)
 #define rh_vs0_d			(AHCI_BASE + 0xA4)
 
-#define vphy_sync_pattern_reg		0x224
-#define bs_txd_inv			BIT(10)
-#define bs_rxd_inv			BIT(11)
-
-#define vphy_loopback_reg0		0x223
-#define bs_phyintf_40bit		0x0C00
-#define bs_pll_ready_tx			0x10
-
-#define vphy_power_reg0			0x201
-
-#define vphy_calctl_reg			0x202
-#define bs_max_pll_rate			BIT(12)
-
-#define vphy_reserve_reg		0x0e
-#define bs_phyctrl_frm_pin		BIT(13)
-
 #define vsata_ctrl_reg			0x00
 #define bs_phy_pu_pll			BIT(6)
 
diff --git a/drivers/phy/marvell/comphy_core.c b/drivers/phy/marvell/comphy_core.c
index 426db30..c849166 100644
--- a/drivers/phy/marvell/comphy_core.c
+++ b/drivers/phy/marvell/comphy_core.c
@@ -12,7 +12,7 @@
 #include <linux/errno.h>
 #include <asm/io.h>
 
-#include "comphy.h"
+#include "comphy_priv.h"
 
 #define COMPHY_MAX_CHIP 4
 
@@ -20,11 +20,12 @@ DECLARE_GLOBAL_DATA_PTR;
 
 static char *get_speed_string(u32 speed)
 {
-	char *speed_strings[] = {"1.25 Gbps", "1.5 Gbps", "2.5 Gbps",
-				 "3.0 Gbps", "3.125 Gbps", "5 Gbps", "6 Gbps",
-				 "6.25 Gbps", "10.31 Gbps" };
+	char * const speed_strings[] = {
+		"1.25 Gbps", "2.5 Gbps", "3.125 Gbps",
+		"5 Gbps", "5.125 Gpbs", "6 Gbps",
+		"10.3125 Gbps" };
 
-	if (speed < 0 || speed > PHY_SPEED_MAX)
+	if (speed < 0 || speed > COMPHY_SPEED_MAX)
 		return "invalid";
 
 	return speed_strings[speed];
@@ -32,14 +33,14 @@ static char *get_speed_string(u32 speed)
 
 static char *get_type_string(u32 type)
 {
-	char *type_strings[] = {"UNCONNECTED", "PEX0", "PEX1", "PEX2", "PEX3",
-				"SATA0", "SATA1", "SATA2", "SATA3", "SGMII0",
-				"SGMII1", "SGMII2", "SGMII3", "QSGMII",
-				"USB3_HOST0", "USB3_HOST1", "USB3_DEVICE",
-				"XAUI0", "XAUI1", "XAUI2", "XAUI3",
-				"RXAUI0", "RXAUI1", "SFI", "IGNORE"};
-
-	if (type < 0 || type > PHY_TYPE_MAX)
+	char * const type_strings[] = {
+		"UNCONNECTED", "PEX0", "PEX1", "PEX2", "PEX3",
+		"SATA0", "SATA1", "SGMII0", "SGMII1", "SGMII2",
+		"USB3", "USB3_HOST0", "USB3_HOST1",
+		"USB3_DEVICE", "RXAUI0", "RXAUI1", "SFI0", "SFI1",
+		"AP", "IGNORE"};
+
+	if (type < 0 || type > COMPHY_TYPE_MAX)
 		return "invalid";
 
 	return type_strings[type];
@@ -90,7 +91,7 @@ void comphy_print(struct chip_serdes_phy_config *chip_cfg,
 
 	for (lane = 0; lane < chip_cfg->comphy_lanes_count;
 	     lane++, comphy_map_data++) {
-		if (comphy_map_data->speed == PHY_SPEED_INVALID) {
+		if (comphy_map_data->speed == COMPHY_SPEED_INVALID) {
 			printf("Comphy-%d: %-13s\n", lane,
 			       get_type_string(comphy_map_data->type));
 		} else {
@@ -101,12 +102,21 @@ void comphy_print(struct chip_serdes_phy_config *chip_cfg,
 	}
 }
 
+int comphy_rx_training(struct udevice *dev, u32 lane)
+{
+	struct chip_serdes_phy_config *chip_cfg = dev_get_priv(dev);
+
+	if (chip_cfg->rx_training)
+		return chip_cfg->rx_training(chip_cfg, lane);
+
+	return 0;
+}
+
 static int comphy_probe(struct udevice *dev)
 {
 	const void *blob = gd->fdt_blob;
 	int node = dev_of_offset(dev);
 	struct chip_serdes_phy_config *chip_cfg = dev_get_priv(dev);
-	struct comphy_map comphy_map_data[MAX_LANE_OPTIONS];
 	int subnode;
 	int lane;
 	int last_idx = 0;
@@ -135,11 +145,15 @@ static int comphy_probe(struct udevice *dev)
 		return -EINVAL;
 	}
 
-	if (device_is_compatible(dev, "marvell,comphy-armada-3700"))
+	if (device_is_compatible(dev, "marvell,comphy-armada-3700")) {
 		chip_cfg->ptr_comphy_chip_init = comphy_a3700_init;
+		chip_cfg->rx_training = NULL;
+	}
 
-	if (device_is_compatible(dev, "marvell,comphy-cp110"))
+	if (device_is_compatible(dev, "marvell,comphy-cp110")) {
 		chip_cfg->ptr_comphy_chip_init = comphy_cp110_init;
+		chip_cfg->rx_training = comphy_cp110_sfi_rx_training;
+	}
 
 	/*
 	 * Bail out if no chip_init function is defined, e.g. no
@@ -156,32 +170,41 @@ static int comphy_probe(struct udevice *dev)
 		if (!fdtdec_get_is_enabled(blob, subnode))
 			continue;
 
-		comphy_map_data[lane].speed = fdtdec_get_int(
-			blob, subnode, "phy-speed", PHY_TYPE_INVALID);
-		comphy_map_data[lane].type = fdtdec_get_int(
-			blob, subnode, "phy-type", PHY_SPEED_INVALID);
-		comphy_map_data[lane].invert = fdtdec_get_int(
-			blob, subnode, "phy-invert", PHY_POLARITY_NO_INVERT);
-		comphy_map_data[lane].clk_src = fdtdec_get_bool(blob, subnode,
-								"clk-src");
-		comphy_map_data[lane].end_point = fdtdec_get_bool(blob, subnode,
-								  "end_point");
-		if (comphy_map_data[lane].type == PHY_TYPE_INVALID) {
+		chip_cfg->comphy_map_data[lane].type =
+			fdtdec_get_int(blob, subnode, "phy-type",
+				       COMPHY_TYPE_INVALID);
+
+		if (chip_cfg->comphy_map_data[lane].type ==
+		    COMPHY_TYPE_INVALID) {
 			printf("no phy type for lane %d, setting lane as unconnected\n",
 			       lane + 1);
+			continue;
 		}
 
+		chip_cfg->comphy_map_data[lane].speed =
+			fdtdec_get_int(blob, subnode, "phy-speed",
+				       COMPHY_SPEED_INVALID);
+
+		chip_cfg->comphy_map_data[lane].invert =
+			fdtdec_get_int(blob, subnode, "phy-invert",
+				       COMPHY_POLARITY_NO_INVERT);
+
+		chip_cfg->comphy_map_data[lane].clk_src =
+			fdtdec_get_bool(blob, subnode, "clk-src");
+
+		chip_cfg->comphy_map_data[lane].end_point =
+			fdtdec_get_bool(blob, subnode, "end_point");
+
 		lane++;
 	}
 
 	/* Save CP index for MultiCP devices (A8K) */
 	chip_cfg->cp_index = current_idx++;
 	/* PHY power UP sequence */
-	chip_cfg->ptr_comphy_chip_init(chip_cfg, comphy_map_data);
+	chip_cfg->ptr_comphy_chip_init(chip_cfg, chip_cfg->comphy_map_data);
 	/* PHY print SerDes status */
-	if (of_machine_is_compatible("marvell,armada8040"))
-		printf("Comphy chip #%d:\n", chip_cfg->cp_index);
-	comphy_print(chip_cfg, comphy_map_data);
+	printf("Comphy chip #%d:\n", chip_cfg->cp_index);
+	comphy_print(chip_cfg, chip_cfg->comphy_map_data);
 
 	/*
 	 * Only run the dedicated PHY init code once, in the last PHY init call
diff --git a/drivers/phy/marvell/comphy_cp110.c b/drivers/phy/marvell/comphy_cp110.c
index 3718788..e5dfb1a 100644
--- a/drivers/phy/marvell/comphy_cp110.c
+++ b/drivers/phy/marvell/comphy_cp110.c
@@ -10,64 +10,55 @@
 #include <asm/arch/cpu.h>
 #include <asm/arch/soc.h>
 
-#include "comphy.h"
-#include "comphy_hpipe.h"
+#include "comphy_priv.h"
 #include "sata.h"
 #include "utmi_phy.h"
 
 DECLARE_GLOBAL_DATA_PTR;
 
-#define SD_ADDR(base, lane)			(base + 0x1000 * lane)
-#define HPIPE_ADDR(base, lane)			(SD_ADDR(base, lane) + 0x800)
-#define COMPHY_ADDR(base, lane)			(base + 0x28 * lane)
+/* Firmware related definitions used for SMC calls */
+#define MV_SIP_COMPHY_POWER_ON	0x82000001
+#define MV_SIP_COMPHY_POWER_OFF	0x82000002
+#define MV_SIP_COMPHY_PLL_LOCK	0x82000003
+#define MV_SIP_COMPHY_XFI_TRAIN	0x82000004
+
+/* Used to distinguish between different possible callers (U-boot/Linux) */
+#define COMPHY_CALLER_UBOOT			(0x1 << 21)
+
+#define COMPHY_FW_MODE_FORMAT(mode)		((mode) << 12)
+#define COMPHY_FW_FORMAT(mode, idx, speeds)	\
+			(((mode) << 12) | ((idx) << 8) | ((speeds) << 2))
+
+#define COMPHY_FW_PCIE_FORMAT(pcie_width, clk_src, mode, speeds)	\
+			(COMPHY_CALLER_UBOOT | ((pcie_width) << 18) |	\
+			((clk_src) << 17) | COMPHY_FW_FORMAT(mode, 0, speeds))
+
+#define COMPHY_SATA_MODE	0x1
+#define COMPHY_SGMII_MODE	0x2	/* SGMII 1G */
+#define COMPHY_HS_SGMII_MODE	0x3	/* SGMII 2.5G */
+#define COMPHY_USB3H_MODE	0x4
+#define COMPHY_USB3D_MODE	0x5
+#define COMPHY_PCIE_MODE	0x6
+#define COMPHY_RXAUI_MODE	0x7
+#define COMPHY_XFI_MODE		0x8
+#define COMPHY_SFI_MODE		0x9
+#define COMPHY_USB3_MODE	0xa
+#define COMPHY_AP_MODE		0xb
+
+/* Comphy unit index macro */
+#define COMPHY_UNIT_ID0		0
+#define COMPHY_UNIT_ID1		1
+#define COMPHY_UNIT_ID2		2
+#define COMPHY_UNIT_ID3		3
 
 struct utmi_phy_data {
+	void __iomem *utmi_pll_addr;
 	void __iomem *utmi_base_addr;
 	void __iomem *usb_cfg_addr;
 	void __iomem *utmi_cfg_addr;
 	u32 utmi_phy_port;
 };
 
-/*
- * For CP-110 we have 2 Selector registers "PHY Selectors",
- * and "PIPE Selectors".
- * PIPE selector include USB and PCIe options.
- * PHY selector include the Ethernet and SATA options, every Ethernet
- * option has different options, for example: serdes lane2 had option
- * Eth_port_0 that include (SGMII0, RXAUI0, SFI)
- */
-struct comphy_mux_data cp110_comphy_phy_mux_data[] = {
-	{4, {{PHY_TYPE_UNCONNECTED, 0x0}, {PHY_TYPE_SGMII1, 0x1}, /* Lane 0 */
-	     {PHY_TYPE_SATA1, 0x4} } },
-	{4, {{PHY_TYPE_UNCONNECTED, 0x0}, {PHY_TYPE_SGMII2, 0x1}, /* Lane 1 */
-	     {PHY_TYPE_SATA0, 0x4} } },
-	{6, {{PHY_TYPE_UNCONNECTED, 0x0}, {PHY_TYPE_SGMII0, 0x1}, /* Lane 2 */
-	     {PHY_TYPE_RXAUI0, 0x1}, {PHY_TYPE_SFI, 0x1},
-	     {PHY_TYPE_SATA0, 0x4} } },
-	{8, {{PHY_TYPE_UNCONNECTED, 0x0}, {PHY_TYPE_RXAUI1, 0x1}, /* Lane 3 */
-	     {PHY_TYPE_SGMII1, 0x2}, {PHY_TYPE_SATA1, 0x4} } },
-	{7, {{PHY_TYPE_UNCONNECTED, 0x0}, {PHY_TYPE_SGMII0, 0x2}, /* Lane 4 */
-	     {PHY_TYPE_RXAUI0, 0x2}, {PHY_TYPE_SFI, 0x2},
-	     {PHY_TYPE_SGMII1, 0x1} } },
-	{6, {{PHY_TYPE_UNCONNECTED, 0x0}, {PHY_TYPE_SGMII2, 0x1}, /* Lane 5 */
-	     {PHY_TYPE_RXAUI1, 0x2}, {PHY_TYPE_SATA1, 0x4} } },
-};
-
-struct comphy_mux_data cp110_comphy_pipe_mux_data[] = {
-	{2, {{PHY_TYPE_UNCONNECTED, 0x0}, {PHY_TYPE_PEX0, 0x4} } }, /* Lane 0 */
-	{4, {{PHY_TYPE_UNCONNECTED, 0x0}, /* Lane 1 */
-	     {PHY_TYPE_USB3_HOST0, 0x1}, {PHY_TYPE_USB3_DEVICE, 0x2},
-	     {PHY_TYPE_PEX0, 0x4} } },
-	{3, {{PHY_TYPE_UNCONNECTED, 0x0}, /* Lane 2 */
-	     {PHY_TYPE_USB3_HOST0, 0x1}, {PHY_TYPE_PEX0, 0x4} } },
-	{3, {{PHY_TYPE_UNCONNECTED, 0x0}, /* Lane 3 */
-	     {PHY_TYPE_USB3_HOST1, 0x1}, {PHY_TYPE_PEX0, 0x4} } },
-	{4, {{PHY_TYPE_UNCONNECTED, 0x0}, /* Lane 4 */
-	     {PHY_TYPE_USB3_HOST1, 0x1},
-	     {PHY_TYPE_USB3_DEVICE, 0x2}, {PHY_TYPE_PEX1, 0x4} } },
-	{2, {{PHY_TYPE_UNCONNECTED, 0x0}, {PHY_TYPE_PEX2, 0x4} } }, /* Lane 5 */
-};
-
 static u32 polling_with_timeout(void __iomem *addr, u32 val,
 				u32 mask, unsigned long usec_timout)
 {
@@ -84,571 +75,31 @@ static u32 polling_with_timeout(void __iomem *addr, u32 val,
 	return 0;
 }
 
-static int comphy_pcie_power_up(u32 lane, u32 pcie_width, bool clk_src,
-				bool is_end_point, void __iomem *hpipe_base,
-				void __iomem *comphy_base)
+static int comphy_smc(u32 function_id, void __iomem *comphy_base_addr,
+		      u32 lane, u32 mode)
 {
-	u32 mask, data, ret = 1;
-	void __iomem *hpipe_addr = HPIPE_ADDR(hpipe_base, lane);
-	void __iomem *comphy_addr = COMPHY_ADDR(comphy_base, lane);
-	void __iomem *addr;
-	u32 pcie_clk = 0; /* set input by default */
-
-	debug_enter();
-
-	/*
-	 * ToDo:
-	 * Add SAR (Sample-At-Reset) configuration for the PCIe clock
-	 * direction. SAR code is currently not ported from Marvell
-	 * U-Boot to mainline version.
-	 *
-	 * SerDes Lane 4/5 got the PCIe ref-clock #1,
-	 * and SerDes Lane 0 got PCIe ref-clock #0
-	 */
-	debug("PCIe clock = %x\n", pcie_clk);
-	debug("PCIe RC    = %d\n", !is_end_point);
-	debug("PCIe width = %d\n", pcie_width);
-
-	/* enable PCIe by4 and by2 */
-	if (lane == 0) {
-		if (pcie_width == 4) {
-			reg_set(comphy_base + COMMON_PHY_SD_CTRL1,
-				0x1 << COMMON_PHY_SD_CTRL1_PCIE_X4_EN_OFFSET,
-				COMMON_PHY_SD_CTRL1_PCIE_X4_EN_MASK);
-		} else if (pcie_width == 2) {
-			reg_set(comphy_base + COMMON_PHY_SD_CTRL1,
-				0x1 << COMMON_PHY_SD_CTRL1_PCIE_X2_EN_OFFSET,
-				COMMON_PHY_SD_CTRL1_PCIE_X2_EN_MASK);
-		}
-	}
-
-	/*
-	 * If PCIe clock is output and clock source from SerDes lane 5,
-	 * we need to configure the clock-source MUX.
-	 * By default, the clock source is from lane 4
-	 */
-	if (pcie_clk && clk_src && (lane == 5)) {
-		reg_set((void __iomem *)DFX_DEV_GEN_CTRL12,
-			0x3 << DFX_DEV_GEN_PCIE_CLK_SRC_OFFSET,
-			DFX_DEV_GEN_PCIE_CLK_SRC_MASK);
-	}
-
-	debug("stage: RFU configurations - hard reset comphy\n");
-	/* RFU configurations - hard reset comphy */
-	mask = COMMON_PHY_CFG1_PWR_UP_MASK;
-	data = 0x1 << COMMON_PHY_CFG1_PWR_UP_OFFSET;
-	mask |= COMMON_PHY_CFG1_PIPE_SELECT_MASK;
-	data |= 0x1 << COMMON_PHY_CFG1_PIPE_SELECT_OFFSET;
-	mask |= COMMON_PHY_CFG1_PWR_ON_RESET_MASK;
-	data |= 0x0 << COMMON_PHY_CFG1_PWR_ON_RESET_OFFSET;
-	mask |= COMMON_PHY_CFG1_CORE_RSTN_MASK;
-	data |= 0x0 << COMMON_PHY_CFG1_CORE_RSTN_OFFSET;
-	mask |= COMMON_PHY_PHY_MODE_MASK;
-	data |= 0x0 << COMMON_PHY_PHY_MODE_OFFSET;
-	reg_set(comphy_addr + COMMON_PHY_CFG1_REG, data, mask);
-
-	/* release from hard reset */
-	mask = COMMON_PHY_CFG1_PWR_ON_RESET_MASK;
-	data = 0x1 << COMMON_PHY_CFG1_PWR_ON_RESET_OFFSET;
-	mask |= COMMON_PHY_CFG1_CORE_RSTN_MASK;
-	data |= 0x1 << COMMON_PHY_CFG1_CORE_RSTN_OFFSET;
-	reg_set(comphy_addr + COMMON_PHY_CFG1_REG, data, mask);
-
-	/* Wait 1ms - until band gap and ref clock ready */
-	mdelay(1);
-	/* Start comphy Configuration */
-	debug("stage: Comphy configuration\n");
-	/* Set PIPE soft reset */
-	mask = HPIPE_RST_CLK_CTRL_PIPE_RST_MASK;
-	data = 0x1 << HPIPE_RST_CLK_CTRL_PIPE_RST_OFFSET;
-	/* Set PHY datapath width mode for V0 */
-	mask |= HPIPE_RST_CLK_CTRL_FIXED_PCLK_MASK;
-	data |= 0x1 << HPIPE_RST_CLK_CTRL_FIXED_PCLK_OFFSET;
-	/* Set Data bus width USB mode for V0 */
-	mask |= HPIPE_RST_CLK_CTRL_PIPE_WIDTH_MASK;
-	data |= 0x0 << HPIPE_RST_CLK_CTRL_PIPE_WIDTH_OFFSET;
-	/* Set CORE_CLK output frequency for 250Mhz */
-	mask |= HPIPE_RST_CLK_CTRL_CORE_FREQ_SEL_MASK;
-	data |= 0x0 << HPIPE_RST_CLK_CTRL_CORE_FREQ_SEL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_RST_CLK_CTRL_REG, data, mask);
-	/* Set PLL ready delay for 0x2 */
-	data = 0x2 << HPIPE_CLK_SRC_LO_PLL_RDY_DL_OFFSET;
-	mask = HPIPE_CLK_SRC_LO_PLL_RDY_DL_MASK;
-	if (pcie_width != 1) {
-		data |= 0x1 << HPIPE_CLK_SRC_LO_BUNDLE_PERIOD_SEL_OFFSET;
-		mask |= HPIPE_CLK_SRC_LO_BUNDLE_PERIOD_SEL_MASK;
-		data |= 0x1 << HPIPE_CLK_SRC_LO_BUNDLE_PERIOD_SCALE_OFFSET;
-		mask |= HPIPE_CLK_SRC_LO_BUNDLE_PERIOD_SCALE_MASK;
-	}
-	reg_set(hpipe_addr + HPIPE_CLK_SRC_LO_REG, data, mask);
-
-	/* Set PIPE mode interface to PCIe3 - 0x1  & set lane order */
-	data = 0x1 << HPIPE_CLK_SRC_HI_MODE_PIPE_OFFSET;
-	mask = HPIPE_CLK_SRC_HI_MODE_PIPE_MASK;
-	if (pcie_width != 1) {
-		mask |= HPIPE_CLK_SRC_HI_LANE_STRT_MASK;
-		mask |= HPIPE_CLK_SRC_HI_LANE_MASTER_MASK;
-		mask |= HPIPE_CLK_SRC_HI_LANE_BREAK_MASK;
-		if (lane == 0) {
-			data |= 0x1 << HPIPE_CLK_SRC_HI_LANE_STRT_OFFSET;
-			data |= 0x1 << HPIPE_CLK_SRC_HI_LANE_MASTER_OFFSET;
-		} else if (lane == (pcie_width - 1)) {
-			data |= 0x1 << HPIPE_CLK_SRC_HI_LANE_BREAK_OFFSET;
-		}
-	}
-	reg_set(hpipe_addr + HPIPE_CLK_SRC_HI_REG, data, mask);
-	/* Config update polarity equalization */
-	reg_set(hpipe_addr + HPIPE_LANE_EQ_CFG1_REG,
-		0x1 << HPIPE_CFG_UPDATE_POLARITY_OFFSET,
-		HPIPE_CFG_UPDATE_POLARITY_MASK);
-	/* Set PIPE version 4 to mode enable */
-	reg_set(hpipe_addr + HPIPE_DFE_CTRL_28_REG,
-		0x1 << HPIPE_DFE_CTRL_28_PIPE4_OFFSET,
-		HPIPE_DFE_CTRL_28_PIPE4_MASK);
-	/* TODO: check if pcie clock is output/input - for bringup use input*/
-	/* Enable PIN clock 100M_125M */
-	mask = 0;
-	data = 0;
-	/* Only if clock is output, configure the clock-source mux */
-	if (pcie_clk) {
-		mask |= HPIPE_MISC_CLK100M_125M_MASK;
-		data |= 0x1 << HPIPE_MISC_CLK100M_125M_OFFSET;
-	}
-	/*
-	 * Set PIN_TXDCLK_2X Clock Frequency Selection for outputs 500MHz
-	 * clock
-	 */
-	mask |= HPIPE_MISC_TXDCLK_2X_MASK;
-	data |= 0x0 << HPIPE_MISC_TXDCLK_2X_OFFSET;
-	/* Enable 500MHz Clock */
-	mask |= HPIPE_MISC_CLK500_EN_MASK;
-	data |= 0x1 << HPIPE_MISC_CLK500_EN_OFFSET;
-	if (pcie_clk) { /* output */
-		/* Set reference clock comes from group 1 */
-		mask |= HPIPE_MISC_REFCLK_SEL_MASK;
-		data |= 0x0 << HPIPE_MISC_REFCLK_SEL_OFFSET;
-	} else {
-		/* Set reference clock comes from group 2 */
-		mask |= HPIPE_MISC_REFCLK_SEL_MASK;
-		data |= 0x1 << HPIPE_MISC_REFCLK_SEL_OFFSET;
-	}
-	mask |= HPIPE_MISC_ICP_FORCE_MASK;
-	data |= 0x1 << HPIPE_MISC_ICP_FORCE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_MISC_REG, data, mask);
-	if (pcie_clk) { /* output */
-		/* Set reference frequcency select - 0x2 for 25MHz*/
-		mask = HPIPE_PWR_PLL_REF_FREQ_MASK;
-		data = 0x2 << HPIPE_PWR_PLL_REF_FREQ_OFFSET;
-	} else {
-		/* Set reference frequcency select - 0x0 for 100MHz*/
-		mask = HPIPE_PWR_PLL_REF_FREQ_MASK;
-		data = 0x0 << HPIPE_PWR_PLL_REF_FREQ_OFFSET;
-	}
-	/* Set PHY mode to PCIe */
-	mask |= HPIPE_PWR_PLL_PHY_MODE_MASK;
-	data |= 0x3 << HPIPE_PWR_PLL_PHY_MODE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PWR_PLL_REG, data, mask);
-
-	/* ref clock alignment */
-	if (pcie_width != 1) {
-		mask = HPIPE_LANE_ALIGN_OFF_MASK;
-		data = 0x0 << HPIPE_LANE_ALIGN_OFF_OFFSET;
-		reg_set(hpipe_addr + HPIPE_LANE_ALIGN_REG, data, mask);
-	}
+	struct pt_regs pregs = {0};
 
-	/*
-	 * Set the amount of time spent in the LoZ state - set for 0x7 only if
-	 * the PCIe clock is output
-	 */
-	if (pcie_clk) {
-		reg_set(hpipe_addr + HPIPE_GLOBAL_PM_CTRL,
-			0x7 << HPIPE_GLOBAL_PM_RXDLOZ_WAIT_OFFSET,
-			HPIPE_GLOBAL_PM_RXDLOZ_WAIT_MASK);
-	}
+	pregs.regs[0] = function_id;
+	pregs.regs[1] = (unsigned long)comphy_base_addr;
+	pregs.regs[2] = lane;
+	pregs.regs[3] = mode;
 
-	/* Set Maximal PHY Generation Setting(8Gbps) */
-	mask = HPIPE_INTERFACE_GEN_MAX_MASK;
-	data = 0x2 << HPIPE_INTERFACE_GEN_MAX_OFFSET;
-	/* Bypass frame detection and sync detection for RX DATA */
-	mask = HPIPE_INTERFACE_DET_BYPASS_MASK;
-	data = 0x1 << HPIPE_INTERFACE_DET_BYPASS_OFFSET;
-	/* Set Link Train Mode (Tx training control pins are used) */
-	mask |= HPIPE_INTERFACE_LINK_TRAIN_MASK;
-	data |= 0x1 << HPIPE_INTERFACE_LINK_TRAIN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_INTERFACE_REG, data, mask);
-
-	/* Set Idle_sync enable */
-	mask = HPIPE_PCIE_IDLE_SYNC_MASK;
-	data = 0x1 << HPIPE_PCIE_IDLE_SYNC_OFFSET;
-	/* Select bits for PCIE Gen3(32bit) */
-	mask |= HPIPE_PCIE_SEL_BITS_MASK;
-	data |= 0x2 << HPIPE_PCIE_SEL_BITS_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PCIE_REG0, data, mask);
-
-	/* Enable Tx_adapt_g1 */
-	mask = HPIPE_TX_TRAIN_CTRL_G1_MASK;
-	data = 0x1 << HPIPE_TX_TRAIN_CTRL_G1_OFFSET;
-	/* Enable Tx_adapt_gn1 */
-	mask |= HPIPE_TX_TRAIN_CTRL_GN1_MASK;
-	data |= 0x1 << HPIPE_TX_TRAIN_CTRL_GN1_OFFSET;
-	/* Disable Tx_adapt_g0 */
-	mask |= HPIPE_TX_TRAIN_CTRL_G0_MASK;
-	data |= 0x0 << HPIPE_TX_TRAIN_CTRL_G0_OFFSET;
-	reg_set(hpipe_addr + HPIPE_TX_TRAIN_CTRL_REG, data, mask);
-
-	/* Set reg_tx_train_chk_init */
-	mask = HPIPE_TX_TRAIN_CHK_INIT_MASK;
-	data = 0x0 << HPIPE_TX_TRAIN_CHK_INIT_OFFSET;
-	/* Enable TX_COE_FM_PIN_PCIE3_EN */
-	mask |= HPIPE_TX_TRAIN_COE_FM_PIN_PCIE3_MASK;
-	data |= 0x1 << HPIPE_TX_TRAIN_COE_FM_PIN_PCIE3_OFFSET;
-	reg_set(hpipe_addr + HPIPE_TX_TRAIN_REG, data, mask);
-
-	debug("stage: TRx training parameters\n");
-	/* Set Preset sweep configurations */
-	mask = HPIPE_TX_TX_STATUS_CHECK_MODE_MASK;
-	data = 0x1 << HPIPE_TX_STATUS_CHECK_MODE_OFFSET;
-
-	mask |= HPIPE_TX_NUM_OF_PRESET_MASK;
-	data |= 0x7 << HPIPE_TX_NUM_OF_PRESET_OFFSET;
-
-	mask |= HPIPE_TX_SWEEP_PRESET_EN_MASK;
-	data |= 0x1 << HPIPE_TX_SWEEP_PRESET_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_TX_TRAIN_CTRL_11_REG, data, mask);
-
-	/* Tx train start configuration */
-	mask = HPIPE_TX_TRAIN_START_SQ_EN_MASK;
-	data = 0x1 << HPIPE_TX_TRAIN_START_SQ_EN_OFFSET;
-
-	mask |= HPIPE_TX_TRAIN_START_FRM_DET_EN_MASK;
-	data |= 0x0 << HPIPE_TX_TRAIN_START_FRM_DET_EN_OFFSET;
-
-	mask |= HPIPE_TX_TRAIN_START_FRM_LOCK_EN_MASK;
-	data |= 0x0 << HPIPE_TX_TRAIN_START_FRM_LOCK_EN_OFFSET;
-
-	mask |= HPIPE_TX_TRAIN_WAIT_TIME_EN_MASK;
-	data |= 0x1 << HPIPE_TX_TRAIN_WAIT_TIME_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_TX_TRAIN_CTRL_5_REG, data, mask);
-
-	/* Enable Tx train P2P */
-	mask = HPIPE_TX_TRAIN_P2P_HOLD_MASK;
-	data = 0x1 << HPIPE_TX_TRAIN_P2P_HOLD_OFFSET;
-	reg_set(hpipe_addr + HPIPE_TX_TRAIN_CTRL_0_REG, data, mask);
-
-	/* Configure Tx train timeout */
-	mask = HPIPE_TRX_TRAIN_TIMER_MASK;
-	data = 0x17 << HPIPE_TRX_TRAIN_TIMER_OFFSET;
-	reg_set(hpipe_addr + HPIPE_TX_TRAIN_CTRL_4_REG, data, mask);
-
-	/* Disable G0/G1/GN1 adaptation */
-	mask = HPIPE_TX_TRAIN_CTRL_G1_MASK | HPIPE_TX_TRAIN_CTRL_GN1_MASK
-		| HPIPE_TX_TRAIN_CTRL_G0_OFFSET;
-	data = 0;
-	reg_set(hpipe_addr + HPIPE_TX_TRAIN_CTRL_REG, data, mask);
-
-	/* Disable DTL frequency loop */
-	mask = HPIPE_PWR_CTR_DTL_FLOOP_EN_MASK;
-	data = 0x0 << HPIPE_PWR_CTR_DTL_FLOOP_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PWR_CTR_DTL_REG, data, mask);
-
-	/* Configure G3 DFE */
-	mask = HPIPE_G3_DFE_RES_MASK;
-	data = 0x3 << HPIPE_G3_DFE_RES_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G3_SETTING_4_REG, data, mask);
-
-	/* Use TX/RX training result for DFE */
-	mask = HPIPE_DFE_RES_FORCE_MASK;
-	data = 0x0 << HPIPE_DFE_RES_FORCE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_DFE_REG0,  data, mask);
-
-	/* Configure initial and final coefficient value for receiver */
-	mask = HPIPE_G3_SET_1_G3_RX_SELMUPI_MASK;
-	data = 0x1 << HPIPE_G3_SET_1_G3_RX_SELMUPI_OFFSET;
-
-	mask |= HPIPE_G3_SET_1_G3_RX_SELMUPF_MASK;
-	data |= 0x1 << HPIPE_G3_SET_1_G3_RX_SELMUPF_OFFSET;
-
-	mask |= HPIPE_G3_SET_1_G3_SAMPLER_INPAIRX2_EN_MASK;
-	data |= 0x0 << HPIPE_G3_SET_1_G3_SAMPLER_INPAIRX2_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G3_SET_1_REG,  data, mask);
-
-	/* Trigger sampler enable pulse */
-	mask = HPIPE_SMAPLER_MASK;
-	data = 0x1 << HPIPE_SMAPLER_OFFSET;
-	reg_set(hpipe_addr + HPIPE_SAMPLER_N_PROC_CALIB_CTRL_REG, data, mask);
-	udelay(5);
-	reg_set(hpipe_addr + HPIPE_SAMPLER_N_PROC_CALIB_CTRL_REG, 0, mask);
-
-	/* FFE resistor tuning for different bandwidth  */
-	mask = HPIPE_G3_FFE_DEG_RES_LEVEL_MASK;
-	data = 0x1 << HPIPE_G3_FFE_DEG_RES_LEVEL_OFFSET;
-
-	mask |= HPIPE_G3_FFE_LOAD_RES_LEVEL_MASK;
-	data |= 0x3 << HPIPE_G3_FFE_LOAD_RES_LEVEL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G3_SETTING_3_REG, data, mask);
-
-	/* Pattern lock lost timeout disable */
-	mask = HPIPE_PATTERN_LOCK_LOST_TIMEOUT_EN_MASK;
-	data = 0x0 << HPIPE_PATTERN_LOCK_LOST_TIMEOUT_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_FRAME_DETECT_CTRL_3_REG, data, mask);
-
-	/* Configure DFE adaptations */
-	mask = HPIPE_CDR_MAX_DFE_ADAPT_1_MASK;
-	data = 0x1 << HPIPE_CDR_MAX_DFE_ADAPT_1_OFFSET;
-	mask |= HPIPE_CDR_MAX_DFE_ADAPT_0_MASK;
-	data |= 0x0 << HPIPE_CDR_MAX_DFE_ADAPT_0_OFFSET;
-	mask |= HPIPE_CDR_RX_MAX_DFE_ADAPT_1_MASK;
-	data |= 0x0 << HPIPE_CDR_RX_MAX_DFE_ADAPT_1_OFFSET;
-	reg_set(hpipe_addr + HPIPE_CDR_CONTROL_REG, data, mask);
-	mask = HPIPE_DFE_TX_MAX_DFE_ADAPT_MASK;
-	data = 0x0 << HPIPE_DFE_TX_MAX_DFE_ADAPT_OFFSET;
-	reg_set(hpipe_addr + HPIPE_DFE_CONTROL_REG, data, mask);
-
-	/* Genration 2 setting 1*/
-	mask = HPIPE_G2_SET_1_G2_RX_SELMUPI_MASK;
-	data = 0x0 << HPIPE_G2_SET_1_G2_RX_SELMUPI_OFFSET;
-	mask |= HPIPE_G2_SET_1_G2_RX_SELMUPP_MASK;
-	data |= 0x1 << HPIPE_G2_SET_1_G2_RX_SELMUPP_OFFSET;
-	mask |= HPIPE_G2_SET_1_G2_RX_SELMUFI_MASK;
-	data |= 0x0 << HPIPE_G2_SET_1_G2_RX_SELMUFI_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G2_SET_1_REG, data, mask);
-
-	/* DFE enable */
-	mask = HPIPE_G2_DFE_RES_MASK;
-	data = 0x3 << HPIPE_G2_DFE_RES_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G2_SETTINGS_4_REG, data, mask);
-
-	/* Configure DFE Resolution */
-	mask = HPIPE_LANE_CFG4_DFE_EN_SEL_MASK;
-	data = 0x1 << HPIPE_LANE_CFG4_DFE_EN_SEL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_LANE_CFG4_REG, data, mask);
-
-	/* VDD calibration control */
-	mask = HPIPE_EXT_SELLV_RXSAMPL_MASK;
-	data = 0x16 << HPIPE_EXT_SELLV_RXSAMPL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_VDD_CAL_CTRL_REG, data, mask);
-
-	/* Set PLL Charge-pump Current Control */
-	mask = HPIPE_G3_SETTING_5_G3_ICP_MASK;
-	data = 0x4 << HPIPE_G3_SETTING_5_G3_ICP_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G3_SETTING_5_REG, data, mask);
-
-	/* Set lane rqualization remote setting */
-	mask = HPIPE_LANE_CFG_FOM_DIRN_OVERRIDE_MASK;
-	data = 0x1 << HPIPE_LANE_CFG_FOM_DIRN_OVERRIDE_OFFSET;
-	mask |= HPIPE_LANE_CFG_FOM_ONLY_MODE_MASK;
-	data |= 0x1 << HPIPE_LANE_CFG_FOM_ONLY_MODE_OFFFSET;
-	mask |= HPIPE_LANE_CFG_FOM_PRESET_VECTOR_MASK;
-	data |= 0x2 << HPIPE_LANE_CFG_FOM_PRESET_VECTOR_OFFSET;
-	reg_set(hpipe_addr + HPIPE_LANE_EQ_REMOTE_SETTING_REG, data, mask);
-
-	if (!is_end_point) {
-		/* Set phy in root complex mode */
-		mask = HPIPE_CFG_PHY_RC_EP_MASK;
-		data = 0x1 << HPIPE_CFG_PHY_RC_EP_OFFSET;
-		reg_set(hpipe_addr + HPIPE_LANE_EQU_CONFIG_0_REG, data, mask);
-	}
-
-	debug("stage: Comphy power up\n");
+	smc_call(&pregs);
 
 	/*
-	 * For PCIe by4 or by2 - release from reset only after finish to
-	 * configure all lanes
+	 * TODO: Firmware return 0 on success, temporary map it to u-boot
+	 * convention, but after all comphy will be reworked the convention in
+	 * u-boot should be change and this conversion removed
 	 */
-	if ((pcie_width == 1) || (lane == (pcie_width - 1))) {
-		u32 i, start_lane, end_lane;
-
-		if (pcie_width != 1) {
-			/* allows writing to all lanes in one write */
-			reg_set(comphy_base + COMMON_PHY_SD_CTRL1,
-				0x0 <<
-				COMMON_PHY_SD_CTRL1_COMPHY_0_4_PORT_OFFSET,
-				COMMON_PHY_SD_CTRL1_COMPHY_0_4_PORT_MASK);
-			start_lane = 0;
-			end_lane = pcie_width;
-
-			/*
-			 * Release from PIPE soft reset
-			 * for PCIe by4 or by2 - release from soft reset
-			 * all lanes - can't use read modify write
-			 */
-			reg_set(HPIPE_ADDR(hpipe_base, 0) +
-				HPIPE_RST_CLK_CTRL_REG, 0x24, 0xffffffff);
-		} else {
-			start_lane = lane;
-			end_lane = lane + 1;
-
-			/*
-			 * Release from PIPE soft reset
-			 * for PCIe by4 or by2 - release from soft reset
-			 * all lanes
-			 */
-			reg_set(hpipe_addr + HPIPE_RST_CLK_CTRL_REG,
-				0x0 << HPIPE_RST_CLK_CTRL_PIPE_RST_OFFSET,
-				HPIPE_RST_CLK_CTRL_PIPE_RST_MASK);
-		}
-
-
-		if (pcie_width != 1) {
-			/* disable writing to all lanes with one write */
-			reg_set(comphy_base + COMMON_PHY_SD_CTRL1,
-				0x3210 <<
-				COMMON_PHY_SD_CTRL1_COMPHY_0_4_PORT_OFFSET,
-				COMMON_PHY_SD_CTRL1_COMPHY_0_4_PORT_MASK);
-		}
-
-		debug("stage: Check PLL\n");
-		/* Read lane status */
-		for (i = start_lane; i < end_lane; i++) {
-			addr = HPIPE_ADDR(hpipe_base, i) +
-				HPIPE_LANE_STATUS1_REG;
-			data = HPIPE_LANE_STATUS1_PCLK_EN_MASK;
-			mask = data;
-			data = polling_with_timeout(addr, data, mask, 15000);
-			if (data != 0) {
-				debug("Read from reg = %p - value = 0x%x\n",
-				      hpipe_addr + HPIPE_LANE_STATUS1_REG,
-				      data);
-				pr_err("HPIPE_LANE_STATUS1_PCLK_EN_MASK is 0\n");
-				ret = 0;
-			}
-		}
-	}
-
-	debug_exit();
-	return ret;
-}
-
-static int comphy_usb3_power_up(u32 lane, void __iomem *hpipe_base,
-				void __iomem *comphy_base)
-{
-	u32 mask, data, ret = 1;
-	void __iomem *hpipe_addr = HPIPE_ADDR(hpipe_base, lane);
-	void __iomem *comphy_addr = COMPHY_ADDR(comphy_base, lane);
-	void __iomem *addr;
-
-	debug_enter();
-	debug("stage: RFU configurations - hard reset comphy\n");
-	/* RFU configurations - hard reset comphy */
-	mask = COMMON_PHY_CFG1_PWR_UP_MASK;
-	data = 0x1 << COMMON_PHY_CFG1_PWR_UP_OFFSET;
-	mask |= COMMON_PHY_CFG1_PIPE_SELECT_MASK;
-	data |= 0x1 << COMMON_PHY_CFG1_PIPE_SELECT_OFFSET;
-	mask |= COMMON_PHY_CFG1_PWR_ON_RESET_MASK;
-	data |= 0x0 << COMMON_PHY_CFG1_PWR_ON_RESET_OFFSET;
-	mask |= COMMON_PHY_CFG1_CORE_RSTN_MASK;
-	data |= 0x0 << COMMON_PHY_CFG1_CORE_RSTN_OFFSET;
-	mask |= COMMON_PHY_PHY_MODE_MASK;
-	data |= 0x1 << COMMON_PHY_PHY_MODE_OFFSET;
-	reg_set(comphy_addr + COMMON_PHY_CFG1_REG, data, mask);
-
-	/* release from hard reset */
-	mask = COMMON_PHY_CFG1_PWR_ON_RESET_MASK;
-	data = 0x1 << COMMON_PHY_CFG1_PWR_ON_RESET_OFFSET;
-	mask |= COMMON_PHY_CFG1_CORE_RSTN_MASK;
-	data |= 0x1 << COMMON_PHY_CFG1_CORE_RSTN_OFFSET;
-	reg_set(comphy_addr + COMMON_PHY_CFG1_REG, data, mask);
-
-	/* Wait 1ms - until band gap and ref clock ready */
-	mdelay(1);
-
-	/* Start comphy Configuration */
-	debug("stage: Comphy configuration\n");
-	/* Set PIPE soft reset */
-	mask = HPIPE_RST_CLK_CTRL_PIPE_RST_MASK;
-	data = 0x1 << HPIPE_RST_CLK_CTRL_PIPE_RST_OFFSET;
-	/* Set PHY datapath width mode for V0 */
-	mask |= HPIPE_RST_CLK_CTRL_FIXED_PCLK_MASK;
-	data |= 0x0 << HPIPE_RST_CLK_CTRL_FIXED_PCLK_OFFSET;
-	/* Set Data bus width USB mode for V0 */
-	mask |= HPIPE_RST_CLK_CTRL_PIPE_WIDTH_MASK;
-	data |= 0x0 << HPIPE_RST_CLK_CTRL_PIPE_WIDTH_OFFSET;
-	/* Set CORE_CLK output frequency for 250Mhz */
-	mask |= HPIPE_RST_CLK_CTRL_CORE_FREQ_SEL_MASK;
-	data |= 0x0 << HPIPE_RST_CLK_CTRL_CORE_FREQ_SEL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_RST_CLK_CTRL_REG, data, mask);
-	/* Set PLL ready delay for 0x2 */
-	reg_set(hpipe_addr + HPIPE_CLK_SRC_LO_REG,
-		0x2 << HPIPE_CLK_SRC_LO_PLL_RDY_DL_OFFSET,
-		HPIPE_CLK_SRC_LO_PLL_RDY_DL_MASK);
-	/* Set reference clock to come from group 1 - 25Mhz */
-	reg_set(hpipe_addr + HPIPE_MISC_REG,
-		0x0 << HPIPE_MISC_REFCLK_SEL_OFFSET,
-		HPIPE_MISC_REFCLK_SEL_MASK);
-	/* Set reference frequcency select - 0x2 */
-	mask = HPIPE_PWR_PLL_REF_FREQ_MASK;
-	data = 0x2 << HPIPE_PWR_PLL_REF_FREQ_OFFSET;
-	/* Set PHY mode to USB - 0x5 */
-	mask |= HPIPE_PWR_PLL_PHY_MODE_MASK;
-	data |= 0x5 << HPIPE_PWR_PLL_PHY_MODE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PWR_PLL_REG, data, mask);
-	/* Set the amount of time spent in the LoZ state - set for 0x7 */
-	reg_set(hpipe_addr + HPIPE_GLOBAL_PM_CTRL,
-		0x7 << HPIPE_GLOBAL_PM_RXDLOZ_WAIT_OFFSET,
-		HPIPE_GLOBAL_PM_RXDLOZ_WAIT_MASK);
-	/* Set max PHY generation setting - 5Gbps */
-	reg_set(hpipe_addr + HPIPE_INTERFACE_REG,
-		0x1 << HPIPE_INTERFACE_GEN_MAX_OFFSET,
-		HPIPE_INTERFACE_GEN_MAX_MASK);
-	/* Set select data width 20Bit (SEL_BITS[2:0]) */
-	reg_set(hpipe_addr + HPIPE_LOOPBACK_REG,
-		0x1 << HPIPE_LOOPBACK_SEL_OFFSET,
-		HPIPE_LOOPBACK_SEL_MASK);
-	/* select de-emphasize 3.5db */
-	reg_set(hpipe_addr + HPIPE_LANE_CONFIG0_REG,
-		0x1 << HPIPE_LANE_CONFIG0_TXDEEMPH0_OFFSET,
-		HPIPE_LANE_CONFIG0_TXDEEMPH0_MASK);
-	/* override tx margining from the MAC */
-	reg_set(hpipe_addr + HPIPE_TST_MODE_CTRL_REG,
-		0x1 << HPIPE_TST_MODE_CTRL_MODE_MARGIN_OFFSET,
-		HPIPE_TST_MODE_CTRL_MODE_MARGIN_MASK);
-
-	/* Start analog paramters from ETP(HW) */
-	debug("stage: Analog paramters from ETP(HW)\n");
-	/* Set Pin DFE_PAT_DIS -> Bit[1]: PIN_DFE_PAT_DIS = 0x0 */
-	mask = HPIPE_LANE_CFG4_DFE_CTRL_MASK;
-	data = 0x1 << HPIPE_LANE_CFG4_DFE_CTRL_OFFSET;
-	/* Set Override PHY DFE control pins for 0x1 */
-	mask |= HPIPE_LANE_CFG4_DFE_OVER_MASK;
-	data |= 0x1 << HPIPE_LANE_CFG4_DFE_OVER_OFFSET;
-	/* Set Spread Spectrum Clock Enable fot 0x1 */
-	mask |= HPIPE_LANE_CFG4_SSC_CTRL_MASK;
-	data |= 0x1 << HPIPE_LANE_CFG4_SSC_CTRL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_LANE_CFG4_REG, data, mask);
-	/* End of analog parameters */
-
-	debug("stage: Comphy power up\n");
-	/* Release from PIPE soft reset */
-	reg_set(hpipe_addr + HPIPE_RST_CLK_CTRL_REG,
-		0x0 << HPIPE_RST_CLK_CTRL_PIPE_RST_OFFSET,
-		HPIPE_RST_CLK_CTRL_PIPE_RST_MASK);
-
-	/* wait 15ms - for comphy calibration done */
-	debug("stage: Check PLL\n");
-	/* Read lane status */
-	addr = hpipe_addr + HPIPE_LANE_STATUS1_REG;
-	data = HPIPE_LANE_STATUS1_PCLK_EN_MASK;
-	mask = data;
-	data = polling_with_timeout(addr, data, mask, 15000);
-	if (data != 0) {
-		debug("Read from reg = %p - value = 0x%x\n",
-		      hpipe_addr + HPIPE_LANE_STATUS1_REG, data);
-		pr_err("HPIPE_LANE_STATUS1_PCLK_EN_MASK is 0\n");
-		ret = 0;
-	}
-
-	debug_exit();
-	return ret;
+	return pregs.regs[0] ? 0 : 1;
 }
 
 static int comphy_sata_power_up(u32 lane, void __iomem *hpipe_base,
-				void __iomem *comphy_base, int cp_index)
+				void __iomem *comphy_base_addr, int cp_index,
+				u32 type)
 {
 	u32 mask, data, i, ret = 1;
-	void __iomem *hpipe_addr = HPIPE_ADDR(hpipe_base, lane);
-	void __iomem *sd_ip_addr = SD_ADDR(hpipe_base, lane);
-	void __iomem *comphy_addr = COMPHY_ADDR(comphy_base, lane);
-	void __iomem *addr;
 	void __iomem *sata_base = NULL;
 	int sata_node = -1; /* Set to -1 in order to read the first sata node */
 
@@ -701,242 +152,8 @@ static int comphy_sata_power_up(u32 lane, void __iomem *hpipe_base,
 	data |= 0x0 << SATA3_CTRL_SATA_SSU_OFFSET;
 	reg_set(sata_base + SATA3_VENDOR_DATA, data, mask);
 
-	debug("stage: RFU configurations - hard reset comphy\n");
-	/* RFU configurations - hard reset comphy */
-	mask = COMMON_PHY_CFG1_PWR_UP_MASK;
-	data = 0x1 << COMMON_PHY_CFG1_PWR_UP_OFFSET;
-	mask |= COMMON_PHY_CFG1_PIPE_SELECT_MASK;
-	data |= 0x0 << COMMON_PHY_CFG1_PIPE_SELECT_OFFSET;
-	mask |= COMMON_PHY_CFG1_PWR_ON_RESET_MASK;
-	data |= 0x0 << COMMON_PHY_CFG1_PWR_ON_RESET_OFFSET;
-	mask |= COMMON_PHY_CFG1_CORE_RSTN_MASK;
-	data |= 0x0 << COMMON_PHY_CFG1_CORE_RSTN_OFFSET;
-	reg_set(comphy_addr + COMMON_PHY_CFG1_REG, data, mask);
-
-	/* Set select data  width 40Bit - SATA mode only */
-	reg_set(comphy_addr + COMMON_PHY_CFG6_REG,
-		0x1 << COMMON_PHY_CFG6_IF_40_SEL_OFFSET,
-		COMMON_PHY_CFG6_IF_40_SEL_MASK);
-
-	/* release from hard reset in SD external */
-	mask = SD_EXTERNAL_CONFIG1_RESET_IN_MASK;
-	data = 0x1 << SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RESET_CORE_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
-
-	/* Wait 1ms - until band gap and ref clock ready */
-	mdelay(1);
+	ret = comphy_smc(MV_SIP_COMPHY_POWER_ON, comphy_base_addr, lane, type);
 
-	debug("stage: Comphy configuration\n");
-	/* Start comphy Configuration */
-	/* Set reference clock to comes from group 1 - choose 25Mhz */
-	reg_set(hpipe_addr + HPIPE_MISC_REG,
-		0x0 << HPIPE_MISC_REFCLK_SEL_OFFSET,
-		HPIPE_MISC_REFCLK_SEL_MASK);
-	/* Reference frequency select set 1 (for SATA = 25Mhz) */
-	mask = HPIPE_PWR_PLL_REF_FREQ_MASK;
-	data = 0x1 << HPIPE_PWR_PLL_REF_FREQ_OFFSET;
-	/* PHY mode select (set SATA = 0x0 */
-	mask |= HPIPE_PWR_PLL_PHY_MODE_MASK;
-	data |= 0x0 << HPIPE_PWR_PLL_PHY_MODE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PWR_PLL_REG, data, mask);
-	/* Set max PHY generation setting - 6Gbps */
-	reg_set(hpipe_addr + HPIPE_INTERFACE_REG,
-		0x2 << HPIPE_INTERFACE_GEN_MAX_OFFSET,
-		HPIPE_INTERFACE_GEN_MAX_MASK);
-	/* Set select data  width 40Bit (SEL_BITS[2:0]) */
-	reg_set(hpipe_addr + HPIPE_LOOPBACK_REG,
-		0x2 << HPIPE_LOOPBACK_SEL_OFFSET, HPIPE_LOOPBACK_SEL_MASK);
-
-	debug("stage: Analog paramters from ETP(HW)\n");
-	/* Set analog parameters from ETP(HW) */
-	/* G1 settings */
-	mask = HPIPE_G1_SET_1_G1_RX_SELMUPI_MASK;
-	data = 0x0 << HPIPE_G1_SET_1_G1_RX_SELMUPI_OFFSET;
-	mask |= HPIPE_G1_SET_1_G1_RX_SELMUPP_MASK;
-	data |= 0x1 << HPIPE_G1_SET_1_G1_RX_SELMUPP_OFFSET;
-	mask |= HPIPE_G1_SET_1_G1_RX_SELMUFI_MASK;
-	data |= 0x0 << HPIPE_G1_SET_1_G1_RX_SELMUFI_OFFSET;
-	mask |= HPIPE_G1_SET_1_G1_RX_SELMUFF_MASK;
-	data |= 0x3 << HPIPE_G1_SET_1_G1_RX_SELMUFF_OFFSET;
-	mask |= HPIPE_G1_SET_1_G1_RX_DIGCK_DIV_MASK;
-	data |= 0x1 << HPIPE_G1_SET_1_G1_RX_DIGCK_DIV_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G1_SET_1_REG, data, mask);
-
-	mask = HPIPE_G1_SETTINGS_3_G1_FFE_CAP_SEL_MASK;
-	data = 0xf << HPIPE_G1_SETTINGS_3_G1_FFE_CAP_SEL_OFFSET;
-	mask |= HPIPE_G1_SETTINGS_3_G1_FFE_RES_SEL_MASK;
-	data |= 0x2 << HPIPE_G1_SETTINGS_3_G1_FFE_RES_SEL_OFFSET;
-	mask |= HPIPE_G1_SETTINGS_3_G1_FFE_SETTING_FORCE_MASK;
-	data |= 0x1 << HPIPE_G1_SETTINGS_3_G1_FFE_SETTING_FORCE_OFFSET;
-	mask |= HPIPE_G1_SETTINGS_3_G1_FFE_DEG_RES_LEVEL_MASK;
-	data |= 0x1 << HPIPE_G1_SETTINGS_3_G1_FFE_DEG_RES_LEVEL_OFFSET;
-	mask |= HPIPE_G1_SETTINGS_3_G1_FFE_LOAD_RES_LEVEL_MASK;
-	data |= 0x1 << HPIPE_G1_SETTINGS_3_G1_FFE_LOAD_RES_LEVEL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G1_SETTINGS_3_REG, data, mask);
-
-	/* G2 settings */
-	mask = HPIPE_G2_SET_1_G2_RX_SELMUPI_MASK;
-	data = 0x0 << HPIPE_G2_SET_1_G2_RX_SELMUPI_OFFSET;
-	mask |= HPIPE_G2_SET_1_G2_RX_SELMUPP_MASK;
-	data |= 0x1 << HPIPE_G2_SET_1_G2_RX_SELMUPP_OFFSET;
-	mask |= HPIPE_G2_SET_1_G2_RX_SELMUFI_MASK;
-	data |= 0x0 << HPIPE_G2_SET_1_G2_RX_SELMUFI_OFFSET;
-	mask |= HPIPE_G2_SET_1_G2_RX_SELMUFF_MASK;
-	data |= 0x3 << HPIPE_G2_SET_1_G2_RX_SELMUFF_OFFSET;
-	mask |= HPIPE_G2_SET_1_G2_RX_DIGCK_DIV_MASK;
-	data |= 0x1 << HPIPE_G2_SET_1_G2_RX_DIGCK_DIV_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G2_SET_1_REG, data, mask);
-
-	/* G3 settings */
-	mask = HPIPE_G3_SET_1_G3_RX_SELMUPI_MASK;
-	data = 0x2 << HPIPE_G3_SET_1_G3_RX_SELMUPI_OFFSET;
-	mask |= HPIPE_G3_SET_1_G3_RX_SELMUPF_MASK;
-	data |= 0x2 << HPIPE_G3_SET_1_G3_RX_SELMUPF_OFFSET;
-	mask |= HPIPE_G3_SET_1_G3_RX_SELMUFI_MASK;
-	data |= 0x3 << HPIPE_G3_SET_1_G3_RX_SELMUFI_OFFSET;
-	mask |= HPIPE_G3_SET_1_G3_RX_SELMUFF_MASK;
-	data |= 0x3 << HPIPE_G3_SET_1_G3_RX_SELMUFF_OFFSET;
-	mask |= HPIPE_G3_SET_1_G3_RX_DFE_EN_MASK;
-	data |= 0x1 << HPIPE_G3_SET_1_G3_RX_DFE_EN_OFFSET;
-	mask |= HPIPE_G3_SET_1_G3_RX_DIGCK_DIV_MASK;
-	data |= 0x2 << HPIPE_G3_SET_1_G3_RX_DIGCK_DIV_OFFSET;
-	mask |= HPIPE_G3_SET_1_G3_SAMPLER_INPAIRX2_EN_MASK;
-	data |= 0x0 << HPIPE_G3_SET_1_G3_SAMPLER_INPAIRX2_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G3_SET_1_REG, data, mask);
-
-	/* DTL Control */
-	mask = HPIPE_PWR_CTR_DTL_SQ_DET_EN_MASK;
-	data = 0x1 << HPIPE_PWR_CTR_DTL_SQ_DET_EN_OFFSET;
-	mask |= HPIPE_PWR_CTR_DTL_SQ_PLOOP_EN_MASK;
-	data |= 0x1 << HPIPE_PWR_CTR_DTL_SQ_PLOOP_EN_OFFSET;
-	mask |= HPIPE_PWR_CTR_DTL_FLOOP_EN_MASK;
-	data |= 0x1 << HPIPE_PWR_CTR_DTL_FLOOP_EN_OFFSET;
-	mask |= HPIPE_PWR_CTR_DTL_CLAMPING_SEL_MASK;
-	data |= 0x1 << HPIPE_PWR_CTR_DTL_CLAMPING_SEL_OFFSET;
-	mask |= HPIPE_PWR_CTR_DTL_INTPCLK_DIV_FORCE_MASK;
-	data |= 0x1 << HPIPE_PWR_CTR_DTL_INTPCLK_DIV_FORCE_OFFSET;
-	mask |= HPIPE_PWR_CTR_DTL_CLK_MODE_MASK;
-	data |= 0x1 << HPIPE_PWR_CTR_DTL_CLK_MODE_OFFSET;
-	mask |= HPIPE_PWR_CTR_DTL_CLK_MODE_FORCE_MASK;
-	data |= 0x1 << HPIPE_PWR_CTR_DTL_CLK_MODE_FORCE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PWR_CTR_DTL_REG, data, mask);
-
-	/* Trigger sampler enable pulse (by toggleing the bit) */
-	mask = HPIPE_SMAPLER_MASK;
-	data = 0x1 << HPIPE_SMAPLER_OFFSET;
-	reg_set(hpipe_addr + HPIPE_SAMPLER_N_PROC_CALIB_CTRL_REG, data, mask);
-	mask = HPIPE_SMAPLER_MASK;
-	data = 0x0 << HPIPE_SMAPLER_OFFSET;
-	reg_set(hpipe_addr + HPIPE_SAMPLER_N_PROC_CALIB_CTRL_REG, data, mask);
-
-	/* VDD Calibration Control 3 */
-	mask = HPIPE_EXT_SELLV_RXSAMPL_MASK;
-	data = 0x10 << HPIPE_EXT_SELLV_RXSAMPL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_VDD_CAL_CTRL_REG, data, mask);
-
-	/* DFE Resolution Control */
-	mask = HPIPE_DFE_RES_FORCE_MASK;
-	data = 0x1 << HPIPE_DFE_RES_FORCE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_DFE_REG0, data, mask);
-
-	/* DFE F3-F5 Coefficient Control */
-	mask = HPIPE_DFE_F3_F5_DFE_EN_MASK;
-	data = 0x0 << HPIPE_DFE_F3_F5_DFE_EN_OFFSET;
-	mask |= HPIPE_DFE_F3_F5_DFE_CTRL_MASK;
-	data = 0x0 << HPIPE_DFE_F3_F5_DFE_CTRL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_DFE_F3_F5_REG, data, mask);
-
-	/* G3 Setting 3 */
-	mask = HPIPE_G3_FFE_CAP_SEL_MASK;
-	data = 0xf << HPIPE_G3_FFE_CAP_SEL_OFFSET;
-	mask |= HPIPE_G3_FFE_RES_SEL_MASK;
-	data |= 0x4 << HPIPE_G3_FFE_RES_SEL_OFFSET;
-	mask |= HPIPE_G3_FFE_SETTING_FORCE_MASK;
-	data |= 0x1 << HPIPE_G3_FFE_SETTING_FORCE_OFFSET;
-	mask |= HPIPE_G3_FFE_DEG_RES_LEVEL_MASK;
-	data |= 0x1 << HPIPE_G3_FFE_DEG_RES_LEVEL_OFFSET;
-	mask |= HPIPE_G3_FFE_LOAD_RES_LEVEL_MASK;
-	data |= 0x3 << HPIPE_G3_FFE_LOAD_RES_LEVEL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G3_SETTING_3_REG, data, mask);
-
-	/* G3 Setting 4 */
-	mask = HPIPE_G3_DFE_RES_MASK;
-	data = 0x2 << HPIPE_G3_DFE_RES_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G3_SETTING_4_REG, data, mask);
-
-	/* Offset Phase Control */
-	mask = HPIPE_OS_PH_OFFSET_MASK;
-	data = 0x5c << HPIPE_OS_PH_OFFSET_OFFSET;
-	mask |= HPIPE_OS_PH_OFFSET_FORCE_MASK;
-	data |= 0x1 << HPIPE_OS_PH_OFFSET_FORCE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PHASE_CONTROL_REG, data, mask);
-	mask = HPIPE_OS_PH_VALID_MASK;
-	data = 0x1 << HPIPE_OS_PH_VALID_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PHASE_CONTROL_REG, data, mask);
-	mask = HPIPE_OS_PH_VALID_MASK;
-	data = 0x0 << HPIPE_OS_PH_VALID_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PHASE_CONTROL_REG, data, mask);
-
-	/* Set G1 TX amplitude and TX post emphasis value */
-	mask = HPIPE_G1_SET_0_G1_TX_AMP_MASK;
-	data = 0x8 << HPIPE_G1_SET_0_G1_TX_AMP_OFFSET;
-	mask |= HPIPE_G1_SET_0_G1_TX_AMP_ADJ_MASK;
-	data |= 0x1 << HPIPE_G1_SET_0_G1_TX_AMP_ADJ_OFFSET;
-	mask |= HPIPE_G1_SET_0_G1_TX_EMPH1_MASK;
-	data |= 0x1 << HPIPE_G1_SET_0_G1_TX_EMPH1_OFFSET;
-	mask |= HPIPE_G1_SET_0_G1_TX_EMPH1_EN_MASK;
-	data |= 0x1 << HPIPE_G1_SET_0_G1_TX_EMPH1_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G1_SET_0_REG, data, mask);
-
-	/* Set G2 TX amplitude and TX post emphasis value */
-	mask = HPIPE_G2_SET_0_G2_TX_AMP_MASK;
-	data = 0xa << HPIPE_G2_SET_0_G2_TX_AMP_OFFSET;
-	mask |= HPIPE_G2_SET_0_G2_TX_AMP_ADJ_MASK;
-	data |= 0x1 << HPIPE_G2_SET_0_G2_TX_AMP_ADJ_OFFSET;
-	mask |= HPIPE_G2_SET_0_G2_TX_EMPH1_MASK;
-	data |= 0x2 << HPIPE_G2_SET_0_G2_TX_EMPH1_OFFSET;
-	mask |= HPIPE_G2_SET_0_G2_TX_EMPH1_EN_MASK;
-	data |= 0x1 << HPIPE_G2_SET_0_G2_TX_EMPH1_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G2_SET_0_REG, data, mask);
-
-	/* Set G3 TX amplitude and TX post emphasis value */
-	mask = HPIPE_G3_SET_0_G3_TX_AMP_MASK;
-	data = 0xe << HPIPE_G3_SET_0_G3_TX_AMP_OFFSET;
-	mask |= HPIPE_G3_SET_0_G3_TX_AMP_ADJ_MASK;
-	data |= 0x1 << HPIPE_G3_SET_0_G3_TX_AMP_ADJ_OFFSET;
-	mask |= HPIPE_G3_SET_0_G3_TX_EMPH1_MASK;
-	data |= 0x6 << HPIPE_G3_SET_0_G3_TX_EMPH1_OFFSET;
-	mask |= HPIPE_G3_SET_0_G3_TX_EMPH1_EN_MASK;
-	data |= 0x1 << HPIPE_G3_SET_0_G3_TX_EMPH1_EN_OFFSET;
-	mask |= HPIPE_G3_SET_0_G3_TX_SLEW_RATE_SEL_MASK;
-	data |= 0x4 << HPIPE_G3_SET_0_G3_TX_SLEW_RATE_SEL_OFFSET;
-	mask |= HPIPE_G3_SET_0_G3_TX_SLEW_CTRL_EN_MASK;
-	data |= 0x0 << HPIPE_G3_SET_0_G3_TX_SLEW_CTRL_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G3_SET_0_REG, data, mask);
-
-	/* SERDES External Configuration 2 register */
-	mask = SD_EXTERNAL_CONFIG2_SSC_ENABLE_MASK;
-	data = 0x1 << SD_EXTERNAL_CONFIG2_SSC_ENABLE_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG2_REG, data, mask);
-
-	/* DFE reset sequence */
-	reg_set(hpipe_addr + HPIPE_PWR_CTR_REG,
-		0x1 << HPIPE_PWR_CTR_RST_DFE_OFFSET,
-		HPIPE_PWR_CTR_RST_DFE_MASK);
-	reg_set(hpipe_addr + HPIPE_PWR_CTR_REG,
-		0x0 << HPIPE_PWR_CTR_RST_DFE_OFFSET,
-		HPIPE_PWR_CTR_RST_DFE_MASK);
-	/* SW reset for interupt logic */
-	reg_set(hpipe_addr + HPIPE_PWR_CTR_REG,
-		0x1 << HPIPE_PWR_CTR_SFT_RST_OFFSET,
-		HPIPE_PWR_CTR_SFT_RST_MASK);
-	reg_set(hpipe_addr + HPIPE_PWR_CTR_REG,
-		0x0 << HPIPE_PWR_CTR_SFT_RST_OFFSET,
-		HPIPE_PWR_CTR_SFT_RST_MASK);
-
-	debug("stage: Comphy power up\n");
 	/*
 	 * MAC configuration power up comphy - power up PLL/TX/RX
 	 * use indirect address for vendor spesific SATA control register
@@ -966,649 +183,38 @@ static int comphy_sata_power_up(u32 lane, void __iomem *hpipe_base,
 	reg_set(sata_base + SATA3_VENDOR_DATA,
 		0x1 << SATA_MBUS_REGRET_EN_OFFSET, SATA_MBUS_REGRET_EN_MASK);
 
-	debug("stage: Check PLL\n");
-
-	addr = sd_ip_addr + SD_EXTERNAL_STATUS0_REG;
-	data = SD_EXTERNAL_STATUS0_PLL_TX_MASK &
-		SD_EXTERNAL_STATUS0_PLL_RX_MASK;
-	mask = data;
-	data = polling_with_timeout(addr, data, mask, 15000);
-	if (data != 0) {
-		debug("Read from reg = %p - value = 0x%x\n",
-		      hpipe_addr + HPIPE_LANE_STATUS1_REG, data);
-		pr_err("SD_EXTERNAL_STATUS0_PLL_TX is %d, SD_EXTERNAL_STATUS0_PLL_RX is %d\n",
-		      (data & SD_EXTERNAL_STATUS0_PLL_TX_MASK),
-		      (data & SD_EXTERNAL_STATUS0_PLL_RX_MASK));
-		ret = 0;
-	}
+	ret = comphy_smc(MV_SIP_COMPHY_PLL_LOCK, comphy_base_addr, lane, type);
 
 	debug_exit();
 	return ret;
 }
 
-static int comphy_sgmii_power_up(u32 lane, u32 sgmii_speed,
-				 void __iomem *hpipe_base,
-				 void __iomem *comphy_base)
-{
-	u32 mask, data, ret = 1;
-	void __iomem *hpipe_addr = HPIPE_ADDR(hpipe_base, lane);
-	void __iomem *sd_ip_addr = SD_ADDR(hpipe_base, lane);
-	void __iomem *comphy_addr = COMPHY_ADDR(comphy_base, lane);
-	void __iomem *addr;
-
-	debug_enter();
-	debug("stage: RFU configurations - hard reset comphy\n");
-	/* RFU configurations - hard reset comphy */
-	mask = COMMON_PHY_CFG1_PWR_UP_MASK;
-	data = 0x1 << COMMON_PHY_CFG1_PWR_UP_OFFSET;
-	mask |= COMMON_PHY_CFG1_PIPE_SELECT_MASK;
-	data |= 0x0 << COMMON_PHY_CFG1_PIPE_SELECT_OFFSET;
-	reg_set(comphy_addr + COMMON_PHY_CFG1_REG, data, mask);
-
-	/* Select Baud Rate of Comphy And PD_PLL/Tx/Rx */
-	mask = SD_EXTERNAL_CONFIG0_SD_PU_PLL_MASK;
-	data = 0x0 << SD_EXTERNAL_CONFIG0_SD_PU_PLL_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_MASK;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_MASK;
-	if (sgmii_speed == PHY_SPEED_1_25G) {
-		data |= 0x6 << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_OFFSET;
-		data |= 0x6 << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_OFFSET;
-	} else {
-		/* 3.125G */
-		data |= 0x8 << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_OFFSET;
-		data |= 0x8 << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_OFFSET;
-	}
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_RX_MASK;
-	data |= 0 << SD_EXTERNAL_CONFIG0_SD_PU_RX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_TX_MASK;
-	data |= 0 << SD_EXTERNAL_CONFIG0_SD_PU_TX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_MASK;
-	data |= 1 << SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG0_REG, data, mask);
-
-	/* release from hard reset */
-	mask = SD_EXTERNAL_CONFIG1_RESET_IN_MASK;
-	data = 0x0 << SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RESET_CORE_MASK;
-	data |= 0x0 << SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RF_RESET_IN_MASK;
-	data |= 0x0 << SD_EXTERNAL_CONFIG1_RF_RESET_IN_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
-
-	/* release from hard reset */
-	mask = SD_EXTERNAL_CONFIG1_RESET_IN_MASK;
-	data = 0x1 << SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RESET_CORE_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
-
-
-	/* Wait 1ms - until band gap and ref clock ready */
-	mdelay(1);
-
-	/* Start comphy Configuration */
-	debug("stage: Comphy configuration\n");
-	/* set reference clock */
-	mask = HPIPE_MISC_REFCLK_SEL_MASK;
-	data = 0x0 << HPIPE_MISC_REFCLK_SEL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_MISC_REG, data, mask);
-	/* Power and PLL Control */
-	mask = HPIPE_PWR_PLL_REF_FREQ_MASK;
-	data = 0x1 << HPIPE_PWR_PLL_REF_FREQ_OFFSET;
-	mask |= HPIPE_PWR_PLL_PHY_MODE_MASK;
-	data |= 0x4 << HPIPE_PWR_PLL_PHY_MODE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PWR_PLL_REG, data, mask);
-	/* Loopback register */
-	mask = HPIPE_LOOPBACK_SEL_MASK;
-	data = 0x1 << HPIPE_LOOPBACK_SEL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_LOOPBACK_REG, data, mask);
-	/* rx control 1 */
-	mask = HPIPE_RX_CONTROL_1_RXCLK2X_SEL_MASK;
-	data = 0x1 << HPIPE_RX_CONTROL_1_RXCLK2X_SEL_OFFSET;
-	mask |= HPIPE_RX_CONTROL_1_CLK8T_EN_MASK;
-	data |= 0x0 << HPIPE_RX_CONTROL_1_CLK8T_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_RX_CONTROL_1_REG, data, mask);
-	/* DTL Control */
-	mask = HPIPE_PWR_CTR_DTL_FLOOP_EN_MASK;
-	data = 0x0 << HPIPE_PWR_CTR_DTL_FLOOP_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PWR_CTR_DTL_REG, data, mask);
-
-	/* Set analog paramters from ETP(HW) - for now use the default datas */
-	debug("stage: Analog paramters from ETP(HW)\n");
-
-	reg_set(hpipe_addr + HPIPE_G1_SET_0_REG,
-		0x1 << HPIPE_G1_SET_0_G1_TX_EMPH1_OFFSET,
-		HPIPE_G1_SET_0_G1_TX_EMPH1_MASK);
-
-	debug("stage: RFU configurations- Power Up PLL,Tx,Rx\n");
-	/* SERDES External Configuration */
-	mask = SD_EXTERNAL_CONFIG0_SD_PU_PLL_MASK;
-	data = 0x1 << SD_EXTERNAL_CONFIG0_SD_PU_PLL_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_RX_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG0_SD_PU_RX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_TX_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG0_SD_PU_TX_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG0_REG, data, mask);
-
-	/* check PLL rx & tx ready */
-	addr = sd_ip_addr + SD_EXTERNAL_STATUS0_REG;
-	data = SD_EXTERNAL_STATUS0_PLL_RX_MASK |
-		SD_EXTERNAL_STATUS0_PLL_TX_MASK;
-	mask = data;
-	data = polling_with_timeout(addr, data, mask, 15000);
-	if (data != 0) {
-		debug("Read from reg = %p - value = 0x%x\n",
-		      sd_ip_addr + SD_EXTERNAL_STATUS0_REG, data);
-		pr_err("SD_EXTERNAL_STATUS0_PLL_RX is %d, SD_EXTERNAL_STATUS0_PLL_TX is %d\n",
-		      (data & SD_EXTERNAL_STATUS0_PLL_RX_MASK),
-		      (data & SD_EXTERNAL_STATUS0_PLL_TX_MASK));
-		ret = 0;
-	}
-
-	/* RX init */
-	mask = SD_EXTERNAL_CONFIG1_RX_INIT_MASK;
-	data = 0x1 << SD_EXTERNAL_CONFIG1_RX_INIT_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
-
-	/* check that RX init done */
-	addr = sd_ip_addr + SD_EXTERNAL_STATUS0_REG;
-	data = SD_EXTERNAL_STATUS0_RX_INIT_MASK;
-	mask = data;
-	data = polling_with_timeout(addr, data, mask, 100);
-	if (data != 0) {
-		debug("Read from reg = %p - value = 0x%x\n", sd_ip_addr + SD_EXTERNAL_STATUS0_REG, data);
-		pr_err("SD_EXTERNAL_STATUS0_RX_INIT is 0\n");
-		ret = 0;
-	}
-
-	debug("stage: RF Reset\n");
-	/* RF Reset */
-	mask =  SD_EXTERNAL_CONFIG1_RX_INIT_MASK;
-	data = 0x0 << SD_EXTERNAL_CONFIG1_RX_INIT_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RF_RESET_IN_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG1_RF_RESET_IN_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
-
-	debug_exit();
-	return ret;
-}
-
-static int comphy_sfi_power_up(u32 lane, void __iomem *hpipe_base,
-			       void __iomem *comphy_base, u32 speed)
+/* This function performs RX training for all FFE possible values.
+ * We get the result for each FFE and eventually the best FFE will
+ * be used and set to the HW.
+ *
+ * Return '1' on succsess.
+ * Return '0' on failure.
+ */
+int comphy_cp110_sfi_rx_training(struct chip_serdes_phy_config *ptr_chip_cfg,
+				 u32 lane)
 {
-	u32 mask, data, ret = 1;
-	void __iomem *hpipe_addr = HPIPE_ADDR(hpipe_base, lane);
-	void __iomem *sd_ip_addr = SD_ADDR(hpipe_base, lane);
-	void __iomem *comphy_addr = COMPHY_ADDR(comphy_base, lane);
-	void __iomem *addr;
+	int ret;
+	u32 type = ptr_chip_cfg->comphy_map_data[lane].type;
 
 	debug_enter();
-	debug("stage: RFU configurations - hard reset comphy\n");
-	/* RFU configurations - hard reset comphy */
-	mask = COMMON_PHY_CFG1_PWR_UP_MASK;
-	data = 0x1 << COMMON_PHY_CFG1_PWR_UP_OFFSET;
-	mask |= COMMON_PHY_CFG1_PIPE_SELECT_MASK;
-	data |= 0x0 << COMMON_PHY_CFG1_PIPE_SELECT_OFFSET;
-	reg_set(comphy_addr + COMMON_PHY_CFG1_REG, data, mask);
-
-	/* Select Baud Rate of Comphy And PD_PLL/Tx/Rx */
-	mask = SD_EXTERNAL_CONFIG0_SD_PU_PLL_MASK;
-	data = 0x0 << SD_EXTERNAL_CONFIG0_SD_PU_PLL_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_MASK;
-	data |= 0xE << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_MASK;
-	data |= 0xE << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_RX_MASK;
-	data |= 0 << SD_EXTERNAL_CONFIG0_SD_PU_RX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_TX_MASK;
-	data |= 0 << SD_EXTERNAL_CONFIG0_SD_PU_TX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_MASK;
-	data |= 0 << SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG0_REG, data, mask);
-
-	/* release from hard reset */
-	mask = SD_EXTERNAL_CONFIG1_RESET_IN_MASK;
-	data = 0x0 << SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RESET_CORE_MASK;
-	data |= 0x0 << SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RF_RESET_IN_MASK;
-	data |= 0x0 << SD_EXTERNAL_CONFIG1_RF_RESET_IN_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
-
-	mask = SD_EXTERNAL_CONFIG1_RESET_IN_MASK;
-	data = 0x1 << SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RESET_CORE_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
-
-
-	/* Wait 1ms - until band gap and ref clock ready */
-	mdelay(1);
-
-	/* Start comphy Configuration */
-	debug("stage: Comphy configuration\n");
-	/* set reference clock */
-	mask = HPIPE_MISC_ICP_FORCE_MASK;
-	data = (speed == PHY_SPEED_5_15625G) ?
-		(0x0 << HPIPE_MISC_ICP_FORCE_OFFSET) :
-		(0x1 << HPIPE_MISC_ICP_FORCE_OFFSET);
-	mask |= HPIPE_MISC_REFCLK_SEL_MASK;
-	data |= 0x0 << HPIPE_MISC_REFCLK_SEL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_MISC_REG, data, mask);
-	/* Power and PLL Control */
-	mask = HPIPE_PWR_PLL_REF_FREQ_MASK;
-	data = 0x1 << HPIPE_PWR_PLL_REF_FREQ_OFFSET;
-	mask |= HPIPE_PWR_PLL_PHY_MODE_MASK;
-	data |= 0x4 << HPIPE_PWR_PLL_PHY_MODE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PWR_PLL_REG, data, mask);
-	/* Loopback register */
-	mask = HPIPE_LOOPBACK_SEL_MASK;
-	data = 0x1 << HPIPE_LOOPBACK_SEL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_LOOPBACK_REG, data, mask);
-	/* rx control 1 */
-	mask = HPIPE_RX_CONTROL_1_RXCLK2X_SEL_MASK;
-	data = 0x1 << HPIPE_RX_CONTROL_1_RXCLK2X_SEL_OFFSET;
-	mask |= HPIPE_RX_CONTROL_1_CLK8T_EN_MASK;
-	data |= 0x1 << HPIPE_RX_CONTROL_1_CLK8T_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_RX_CONTROL_1_REG, data, mask);
-	/* DTL Control */
-	mask = HPIPE_PWR_CTR_DTL_FLOOP_EN_MASK;
-	data = 0x1 << HPIPE_PWR_CTR_DTL_FLOOP_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PWR_CTR_DTL_REG, data, mask);
-
-	/* Transmitter/Receiver Speed Divider Force */
-	if (speed == PHY_SPEED_5_15625G) {
-		mask = HPIPE_SPD_DIV_FORCE_RX_SPD_DIV_MASK;
-		data = 1 << HPIPE_SPD_DIV_FORCE_RX_SPD_DIV_OFFSET;
-		mask |= HPIPE_SPD_DIV_FORCE_RX_SPD_DIV_FORCE_MASK;
-		data |= 1 << HPIPE_SPD_DIV_FORCE_RX_SPD_DIV_FORCE_OFFSET;
-		mask |= HPIPE_SPD_DIV_FORCE_TX_SPD_DIV_MASK;
-		data |= 1 << HPIPE_SPD_DIV_FORCE_TX_SPD_DIV_OFFSET;
-		mask |= HPIPE_SPD_DIV_FORCE_TX_SPD_DIV_FORCE_MASK;
-		data |= 1 << HPIPE_SPD_DIV_FORCE_TX_SPD_DIV_FORCE_OFFSET;
-	} else {
-		mask = HPIPE_TXDIGCK_DIV_FORCE_MASK;
-		data = 0x1 << HPIPE_TXDIGCK_DIV_FORCE_OFFSET;
-	}
-	reg_set(hpipe_addr + HPIPE_SPD_DIV_FORCE_REG, data, mask);
-
-	/* Set analog paramters from ETP(HW) */
-	debug("stage: Analog paramters from ETP(HW)\n");
-	/* SERDES External Configuration 2 */
-	mask = SD_EXTERNAL_CONFIG2_PIN_DFE_EN_MASK;
-	data = 0x1 << SD_EXTERNAL_CONFIG2_PIN_DFE_EN_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG2_REG, data, mask);
-	/* 0x7-DFE Resolution control */
-	mask = HPIPE_DFE_RES_FORCE_MASK;
-	data = 0x1 << HPIPE_DFE_RES_FORCE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_DFE_REG0, data, mask);
-	/* 0xd-G1_Setting_0 */
-	if (speed == PHY_SPEED_5_15625G) {
-		mask = HPIPE_G1_SET_0_G1_TX_EMPH1_MASK;
-		data = 0x6 << HPIPE_G1_SET_0_G1_TX_EMPH1_OFFSET;
-	} else {
-		mask = HPIPE_G1_SET_0_G1_TX_AMP_MASK;
-		data = 0x1c << HPIPE_G1_SET_0_G1_TX_AMP_OFFSET;
-		mask |= HPIPE_G1_SET_0_G1_TX_EMPH1_MASK;
-		data |= 0xe << HPIPE_G1_SET_0_G1_TX_EMPH1_OFFSET;
-	}
-	reg_set(hpipe_addr + HPIPE_G1_SET_0_REG, data, mask);
-	/* Genration 1 setting 2 (G1_Setting_2) */
-	mask = HPIPE_G1_SET_2_G1_TX_EMPH0_MASK;
-	data = 0x0 << HPIPE_G1_SET_2_G1_TX_EMPH0_OFFSET;
-	mask |= HPIPE_G1_SET_2_G1_TX_EMPH0_EN_MASK;
-	data |= 0x1 << HPIPE_G1_SET_2_G1_TX_EMPH0_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G1_SET_2_REG, data, mask);
-	/* Transmitter Slew Rate Control register (tx_reg1) */
-	mask = HPIPE_TX_REG1_TX_EMPH_RES_MASK;
-	data = 0x3 << HPIPE_TX_REG1_TX_EMPH_RES_OFFSET;
-	mask |= HPIPE_TX_REG1_SLC_EN_MASK;
-	data |= 0x3f << HPIPE_TX_REG1_SLC_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_TX_REG1_REG, data, mask);
-	/* Impedance Calibration Control register (cal_reg1) */
-	mask = HPIPE_CAL_REG_1_EXT_TXIMP_MASK;
-	data = 0xe << HPIPE_CAL_REG_1_EXT_TXIMP_OFFSET;
-	mask |= HPIPE_CAL_REG_1_EXT_TXIMP_EN_MASK;
-	data |= 0x1 << HPIPE_CAL_REG_1_EXT_TXIMP_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_CAL_REG1_REG, data, mask);
-	/* Generation 1 Setting 5 (g1_setting_5) */
-	mask = HPIPE_G1_SETTING_5_G1_ICP_MASK;
-	data = 0 << HPIPE_CAL_REG_1_EXT_TXIMP_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G1_SETTING_5_REG, data, mask);
-	/* 0xE-G1_Setting_1 */
-	mask = HPIPE_G1_SET_1_G1_RX_DFE_EN_MASK;
-	data = 0x1 << HPIPE_G1_SET_1_G1_RX_DFE_EN_OFFSET;
-	if (speed == PHY_SPEED_5_15625G) {
-		mask |= HPIPE_G1_SET_1_G1_RX_SELMUPI_MASK;
-		data |= 0x1 << HPIPE_G1_SET_1_G1_RX_SELMUPI_OFFSET;
-		mask |= HPIPE_G1_SET_1_G1_RX_SELMUPP_MASK;
-		data |= 0x1 << HPIPE_G1_SET_1_G1_RX_SELMUPP_OFFSET;
-	} else {
-		mask |= HPIPE_G1_SET_1_G1_RX_SELMUPI_MASK;
-		data |= 0x2 << HPIPE_G1_SET_1_G1_RX_SELMUPI_OFFSET;
-		mask |= HPIPE_G1_SET_1_G1_RX_SELMUPP_MASK;
-		data |= 0x2 << HPIPE_G1_SET_1_G1_RX_SELMUPP_OFFSET;
-		mask |= HPIPE_G1_SET_1_G1_RX_SELMUFI_MASK;
-		data |= 0x0 << HPIPE_G1_SET_1_G1_RX_SELMUFI_OFFSET;
-		mask |= HPIPE_G1_SET_1_G1_RX_SELMUFF_MASK;
-		data |= 0x1 << HPIPE_G1_SET_1_G1_RX_SELMUFF_OFFSET;
-		mask |= HPIPE_G1_SET_1_G1_RX_DIGCK_DIV_MASK;
-		data |= 0x3 << HPIPE_G1_SET_1_G1_RX_DIGCK_DIV_OFFSET;
-	}
-	reg_set(hpipe_addr + HPIPE_G1_SET_1_REG, data, mask);
-
-	/* 0xA-DFE_Reg3 */
-	mask = HPIPE_DFE_F3_F5_DFE_EN_MASK;
-	data = 0x0 << HPIPE_DFE_F3_F5_DFE_EN_OFFSET;
-	mask |= HPIPE_DFE_F3_F5_DFE_CTRL_MASK;
-	data |= 0x0 << HPIPE_DFE_F3_F5_DFE_CTRL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_DFE_F3_F5_REG, data, mask);
-
-	/* 0x111-G1_Setting_4 */
-	mask = HPIPE_G1_SETTINGS_4_G1_DFE_RES_MASK;
-	data = 0x1 << HPIPE_G1_SETTINGS_4_G1_DFE_RES_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G1_SETTINGS_4_REG, data, mask);
-	/* Genration 1 setting 3 (G1_Setting_3) */
-	mask = HPIPE_G1_SETTINGS_3_G1_FBCK_SEL_MASK;
-	data = 0x1 << HPIPE_G1_SETTINGS_3_G1_FBCK_SEL_OFFSET;
-	if (speed == PHY_SPEED_5_15625G) {
-		/* Force FFE (Feed Forward Equalization) to 5G */
-		mask |= HPIPE_G1_SETTINGS_3_G1_FFE_CAP_SEL_MASK;
-		data |= 0xf << HPIPE_G1_SETTINGS_3_G1_FFE_CAP_SEL_OFFSET;
-		mask |= HPIPE_G1_SETTINGS_3_G1_FFE_RES_SEL_MASK;
-		data |= 0x4 << HPIPE_G1_SETTINGS_3_G1_FFE_RES_SEL_OFFSET;
-		mask |= HPIPE_G1_SETTINGS_3_G1_FFE_SETTING_FORCE_MASK;
-		data |= 0x1 << HPIPE_G1_SETTINGS_3_G1_FFE_SETTING_FORCE_OFFSET;
-	}
-	reg_set(hpipe_addr + HPIPE_G1_SETTINGS_3_REG, data, mask);
-
-	/* Connfigure RX training timer */
-	mask = HPIPE_RX_TRAIN_TIMER_MASK;
-	data = 0x13 << HPIPE_RX_TRAIN_TIMER_OFFSET;
-	reg_set(hpipe_addr + HPIPE_TX_TRAIN_CTRL_5_REG, data, mask);
-
-	/* Enable TX train peak to peak hold */
-	mask = HPIPE_TX_TRAIN_P2P_HOLD_MASK;
-	data = 0x1 << HPIPE_TX_TRAIN_P2P_HOLD_OFFSET;
-	reg_set(hpipe_addr + HPIPE_TX_TRAIN_CTRL_0_REG, data, mask);
-
-	/* Configure TX preset index */
-	mask = HPIPE_TX_PRESET_INDEX_MASK;
-	data = 0x2 << HPIPE_TX_PRESET_INDEX_OFFSET;
-	reg_set(hpipe_addr + HPIPE_TX_PRESET_INDEX_REG, data, mask);
-
-	/* Disable pattern lock lost timeout */
-	mask = HPIPE_PATTERN_LOCK_LOST_TIMEOUT_EN_MASK;
-	data = 0x0 << HPIPE_PATTERN_LOCK_LOST_TIMEOUT_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_FRAME_DETECT_CTRL_3_REG, data, mask);
-
-	/* Configure TX training pattern and TX training 16bit auto */
-	mask = HPIPE_TX_TRAIN_16BIT_AUTO_EN_MASK;
-	data = 0x1 << HPIPE_TX_TRAIN_16BIT_AUTO_EN_OFFSET;
-	mask |= HPIPE_TX_TRAIN_PAT_SEL_MASK;
-	data |= 0x1 << HPIPE_TX_TRAIN_PAT_SEL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_TX_TRAIN_REG, data, mask);
-
-	/* Configure Training patten number */
-	mask = HPIPE_TRAIN_PAT_NUM_MASK;
-	data = 0x88 << HPIPE_TRAIN_PAT_NUM_OFFSET;
-	reg_set(hpipe_addr + HPIPE_FRAME_DETECT_CTRL_0_REG, data, mask);
-
-	/* Configure differencial manchester encoter to ethernet mode */
-	mask = HPIPE_DME_ETHERNET_MODE_MASK;
-	data = 0x1 << HPIPE_DME_ETHERNET_MODE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_DME_REG, data, mask);
-
-	/* Configure VDD Continuous Calibration */
-	mask = HPIPE_CAL_VDD_CONT_MODE_MASK;
-	data = 0x1 << HPIPE_CAL_VDD_CONT_MODE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_VDD_CAL_0_REG, data, mask);
-
-	/* Trigger sampler enable pulse (by toggleing the bit) */
-	mask = HPIPE_RX_SAMPLER_OS_GAIN_MASK;
-	data = 0x3 << HPIPE_RX_SAMPLER_OS_GAIN_OFFSET;
-	mask |= HPIPE_SMAPLER_MASK;
-	data |= 0x1 << HPIPE_SMAPLER_OFFSET;
-	reg_set(hpipe_addr + HPIPE_SAMPLER_N_PROC_CALIB_CTRL_REG, data, mask);
-	mask = HPIPE_SMAPLER_MASK;
-	data = 0x0 << HPIPE_SMAPLER_OFFSET;
-	reg_set(hpipe_addr + HPIPE_SAMPLER_N_PROC_CALIB_CTRL_REG, data, mask);
-
-	/* Set External RX Regulator Control */
-	mask = HPIPE_EXT_SELLV_RXSAMPL_MASK;
-	data = 0x1A << HPIPE_EXT_SELLV_RXSAMPL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_VDD_CAL_CTRL_REG, data, mask);
-
-	debug("stage: RFU configurations- Power Up PLL,Tx,Rx\n");
-	/* SERDES External Configuration */
-	mask = SD_EXTERNAL_CONFIG0_SD_PU_PLL_MASK;
-	data = 0x1 << SD_EXTERNAL_CONFIG0_SD_PU_PLL_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_RX_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG0_SD_PU_RX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_TX_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG0_SD_PU_TX_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG0_REG, data, mask);
-
-
-	/* check PLL rx & tx ready */
-	addr = sd_ip_addr + SD_EXTERNAL_STATUS0_REG;
-	data = SD_EXTERNAL_STATUS0_PLL_RX_MASK |
-		SD_EXTERNAL_STATUS0_PLL_TX_MASK;
-	mask = data;
-	data = polling_with_timeout(addr, data, mask, 15000);
-	if (data != 0) {
-		debug("Read from reg = %p - value = 0x%x\n", sd_ip_addr + SD_EXTERNAL_STATUS0_REG, data);
-		pr_err("SD_EXTERNAL_STATUS0_PLL_RX is %d, SD_EXTERNAL_STATUS0_PLL_TX is %d\n",
-		      (data & SD_EXTERNAL_STATUS0_PLL_RX_MASK),
-		      (data & SD_EXTERNAL_STATUS0_PLL_TX_MASK));
-		ret = 0;
-	}
-
-	/* RX init */
-	mask = SD_EXTERNAL_CONFIG1_RX_INIT_MASK;
-	data = 0x1 << SD_EXTERNAL_CONFIG1_RX_INIT_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
 
-
-	/* check that RX init done */
-	addr = sd_ip_addr + SD_EXTERNAL_STATUS0_REG;
-	data = SD_EXTERNAL_STATUS0_RX_INIT_MASK;
-	mask = data;
-	data = polling_with_timeout(addr, data, mask, 100);
-	if (data != 0) {
-		debug("Read from reg = %p - value = 0x%x\n",
-		      sd_ip_addr + SD_EXTERNAL_STATUS0_REG, data);
-		pr_err("SD_EXTERNAL_STATUS0_RX_INIT is 0\n");
-		ret = 0;
+	if (type != COMPHY_TYPE_SFI0 && type != COMPHY_TYPE_SFI1) {
+		pr_err("Comphy %d isn't configured to SFI\n", lane);
+		return 0;
 	}
 
-	debug("stage: RF Reset\n");
-	/* RF Reset */
-	mask =  SD_EXTERNAL_CONFIG1_RX_INIT_MASK;
-	data = 0x0 << SD_EXTERNAL_CONFIG1_RX_INIT_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RF_RESET_IN_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG1_RF_RESET_IN_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
+	/* Mode is not relevant for xfi training */
+	ret = comphy_smc(MV_SIP_COMPHY_XFI_TRAIN,
+			 ptr_chip_cfg->comphy_base_addr, lane, 0);
 
 	debug_exit();
-	return ret;
-}
-
-static int comphy_rxauii_power_up(u32 lane, void __iomem *hpipe_base,
-				  void __iomem *comphy_base)
-{
-	u32 mask, data, ret = 1;
-	void __iomem *hpipe_addr = HPIPE_ADDR(hpipe_base, lane);
-	void __iomem *sd_ip_addr = SD_ADDR(hpipe_base, lane);
-	void __iomem *comphy_addr = COMPHY_ADDR(comphy_base, lane);
-	void __iomem *addr;
-
-	debug_enter();
-	debug("stage: RFU configurations - hard reset comphy\n");
-	/* RFU configurations - hard reset comphy */
-	mask = COMMON_PHY_CFG1_PWR_UP_MASK;
-	data = 0x1 << COMMON_PHY_CFG1_PWR_UP_OFFSET;
-	mask |= COMMON_PHY_CFG1_PIPE_SELECT_MASK;
-	data |= 0x0 << COMMON_PHY_CFG1_PIPE_SELECT_OFFSET;
-	reg_set(comphy_addr + COMMON_PHY_CFG1_REG, data, mask);
-
-	if (lane == 2) {
-		reg_set(comphy_base + COMMON_PHY_SD_CTRL1,
-			0x1 << COMMON_PHY_SD_CTRL1_RXAUI0_OFFSET,
-			COMMON_PHY_SD_CTRL1_RXAUI0_MASK);
-	}
-	if (lane == 4) {
-		reg_set(comphy_base + COMMON_PHY_SD_CTRL1,
-			0x1 << COMMON_PHY_SD_CTRL1_RXAUI1_OFFSET,
-			COMMON_PHY_SD_CTRL1_RXAUI1_MASK);
-	}
 
-	/* Select Baud Rate of Comphy And PD_PLL/Tx/Rx */
-	mask = SD_EXTERNAL_CONFIG0_SD_PU_PLL_MASK;
-	data = 0x0 << SD_EXTERNAL_CONFIG0_SD_PU_PLL_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_MASK;
-	data |= 0xB << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_MASK;
-	data |= 0xB << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_RX_MASK;
-	data |= 0x0 << SD_EXTERNAL_CONFIG0_SD_PU_RX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_TX_MASK;
-	data |= 0x0 << SD_EXTERNAL_CONFIG0_SD_PU_TX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_MASK;
-	data |= 0x0 << SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_MEDIA_MODE_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG0_MEDIA_MODE_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG0_REG, data, mask);
-
-	/* release from hard reset */
-	mask = SD_EXTERNAL_CONFIG1_RESET_IN_MASK;
-	data = 0x0 << SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RESET_CORE_MASK;
-	data |= 0x0 << SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RF_RESET_IN_MASK;
-	data |= 0x0 << SD_EXTERNAL_CONFIG1_RF_RESET_IN_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
-
-	mask = SD_EXTERNAL_CONFIG1_RESET_IN_MASK;
-	data = 0x1 << SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RESET_CORE_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
-
-	/* Wait 1ms - until band gap and ref clock ready */
-	mdelay(1);
-
-	/* Start comphy Configuration */
-	debug("stage: Comphy configuration\n");
-	/* set reference clock */
-	reg_set(hpipe_addr + HPIPE_MISC_REG,
-		0x0 << HPIPE_MISC_REFCLK_SEL_OFFSET,
-		HPIPE_MISC_REFCLK_SEL_MASK);
-	/* Power and PLL Control */
-	mask = HPIPE_PWR_PLL_REF_FREQ_MASK;
-	data = 0x1 << HPIPE_PWR_PLL_REF_FREQ_OFFSET;
-	mask |= HPIPE_PWR_PLL_PHY_MODE_MASK;
-	data |= 0x4 << HPIPE_PWR_PLL_PHY_MODE_OFFSET;
-	reg_set(hpipe_addr + HPIPE_PWR_PLL_REG, data, mask);
-	/* Loopback register */
-	reg_set(hpipe_addr + HPIPE_LOOPBACK_REG,
-		0x1 << HPIPE_LOOPBACK_SEL_OFFSET, HPIPE_LOOPBACK_SEL_MASK);
-	/* rx control 1 */
-	mask = HPIPE_RX_CONTROL_1_RXCLK2X_SEL_MASK;
-	data = 0x1 << HPIPE_RX_CONTROL_1_RXCLK2X_SEL_OFFSET;
-	mask |= HPIPE_RX_CONTROL_1_CLK8T_EN_MASK;
-	data |= 0x1 << HPIPE_RX_CONTROL_1_CLK8T_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_RX_CONTROL_1_REG, data, mask);
-	/* DTL Control */
-	reg_set(hpipe_addr + HPIPE_PWR_CTR_DTL_REG,
-		0x0 << HPIPE_PWR_CTR_DTL_FLOOP_EN_OFFSET,
-		HPIPE_PWR_CTR_DTL_FLOOP_EN_MASK);
-
-	/* Set analog paramters from ETP(HW) */
-	debug("stage: Analog paramters from ETP(HW)\n");
-	/* SERDES External Configuration 2 */
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG2_REG,
-		0x1 << SD_EXTERNAL_CONFIG2_PIN_DFE_EN_OFFSET,
-		SD_EXTERNAL_CONFIG2_PIN_DFE_EN_MASK);
-	/* 0x7-DFE Resolution control */
-	reg_set(hpipe_addr + HPIPE_DFE_REG0, 0x1 << HPIPE_DFE_RES_FORCE_OFFSET,
-		HPIPE_DFE_RES_FORCE_MASK);
-	/* 0xd-G1_Setting_0 */
-	reg_set(hpipe_addr + HPIPE_G1_SET_0_REG,
-		0xd << HPIPE_G1_SET_0_G1_TX_EMPH1_OFFSET,
-		HPIPE_G1_SET_0_G1_TX_EMPH1_MASK);
-	/* 0xE-G1_Setting_1 */
-	mask = HPIPE_G1_SET_1_G1_RX_SELMUPI_MASK;
-	data = 0x1 << HPIPE_G1_SET_1_G1_RX_SELMUPI_OFFSET;
-	mask |= HPIPE_G1_SET_1_G1_RX_SELMUPP_MASK;
-	data |= 0x1 << HPIPE_G1_SET_1_G1_RX_SELMUPP_OFFSET;
-	mask |= HPIPE_G1_SET_1_G1_RX_DFE_EN_MASK;
-	data |= 0x1 << HPIPE_G1_SET_1_G1_RX_DFE_EN_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G1_SET_1_REG, data, mask);
-	/* 0xA-DFE_Reg3 */
-	mask = HPIPE_DFE_F3_F5_DFE_EN_MASK;
-	data = 0x0 << HPIPE_DFE_F3_F5_DFE_EN_OFFSET;
-	mask |= HPIPE_DFE_F3_F5_DFE_CTRL_MASK;
-	data |= 0x0 << HPIPE_DFE_F3_F5_DFE_CTRL_OFFSET;
-	reg_set(hpipe_addr + HPIPE_DFE_F3_F5_REG, data, mask);
-
-	/* 0x111-G1_Setting_4 */
-	mask = HPIPE_G1_SETTINGS_4_G1_DFE_RES_MASK;
-	data = 0x1 << HPIPE_G1_SETTINGS_4_G1_DFE_RES_OFFSET;
-	reg_set(hpipe_addr + HPIPE_G1_SETTINGS_4_REG, data, mask);
-
-	debug("stage: RFU configurations- Power Up PLL,Tx,Rx\n");
-	/* SERDES External Configuration */
-	mask = SD_EXTERNAL_CONFIG0_SD_PU_PLL_MASK;
-	data = 0x1 << SD_EXTERNAL_CONFIG0_SD_PU_PLL_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_RX_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG0_SD_PU_RX_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG0_SD_PU_TX_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG0_SD_PU_TX_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG0_REG, data, mask);
-
-
-	/* check PLL rx & tx ready */
-	addr = sd_ip_addr + SD_EXTERNAL_STATUS0_REG;
-	data = SD_EXTERNAL_STATUS0_PLL_RX_MASK |
-		SD_EXTERNAL_STATUS0_PLL_TX_MASK;
-	mask = data;
-	data = polling_with_timeout(addr, data, mask, 15000);
-	if (data != 0) {
-		debug("Read from reg = %p - value = 0x%x\n",
-		      sd_ip_addr + SD_EXTERNAL_STATUS0_REG, data);
-		pr_err("SD_EXTERNAL_STATUS0_PLL_RX is %d, SD_EXTERNAL_STATUS0_PLL_TX is %d\n",
-		      (data & SD_EXTERNAL_STATUS0_PLL_RX_MASK),
-		      (data & SD_EXTERNAL_STATUS0_PLL_TX_MASK));
-		ret = 0;
-	}
-
-	/* RX init */
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG,
-		0x1 << SD_EXTERNAL_CONFIG1_RX_INIT_OFFSET,
-		SD_EXTERNAL_CONFIG1_RX_INIT_MASK);
-
-	/* check that RX init done */
-	addr = sd_ip_addr + SD_EXTERNAL_STATUS0_REG;
-	data = SD_EXTERNAL_STATUS0_RX_INIT_MASK;
-	mask = data;
-	data = polling_with_timeout(addr, data, mask, 100);
-	if (data != 0) {
-		debug("Read from reg = %p - value = 0x%x\n",
-		      sd_ip_addr + SD_EXTERNAL_STATUS0_REG, data);
-		pr_err("SD_EXTERNAL_STATUS0_RX_INIT is 0\n");
-		ret = 0;
-	}
-
-	debug("stage: RF Reset\n");
-	/* RF Reset */
-	mask =  SD_EXTERNAL_CONFIG1_RX_INIT_MASK;
-	data = 0x0 << SD_EXTERNAL_CONFIG1_RX_INIT_OFFSET;
-	mask |= SD_EXTERNAL_CONFIG1_RF_RESET_IN_MASK;
-	data |= 0x1 << SD_EXTERNAL_CONFIG1_RF_RESET_IN_OFFSET;
-	reg_set(sd_ip_addr + SD_EXTERNAL_CONFIG1_REG, data, mask);
-
-	debug_exit();
 	return ret;
 }
 
@@ -1657,7 +263,8 @@ static void comphy_utmi_power_down(u32 utmi_index, void __iomem *utmi_base_addr,
 	return;
 }
 
-static void comphy_utmi_phy_config(u32 utmi_index, void __iomem *utmi_base_addr,
+static void comphy_utmi_phy_config(u32 utmi_index, void __iomem *utmi_pll_addr,
+				   void __iomem *utmi_base_addr,
 				   void __iomem *usb_cfg_addr,
 				   void __iomem *utmi_cfg_addr,
 				   u32 utmi_phy_port)
@@ -1675,27 +282,37 @@ static void comphy_utmi_phy_config(u32 utmi_index, void __iomem *utmi_base_addr,
 	/* Select LPFR - 0x0 for 25Mhz/5=5Mhz*/
 	mask |= UTMI_PLL_CTRL_SEL_LPFR_MASK;
 	data |= 0x0 << UTMI_PLL_CTRL_SEL_LPFR_OFFSET;
-	reg_set(utmi_base_addr + UTMI_PLL_CTRL_REG, data, mask);
+	reg_set(utmi_pll_addr + UTMI_PLL_CTRL_REG, data, mask);
 
 	/* Impedance Calibration Threshold Setting */
-	reg_set(utmi_base_addr + UTMI_CALIB_CTRL_REG,
-		0x6 << UTMI_CALIB_CTRL_IMPCAL_VTH_OFFSET,
-		UTMI_CALIB_CTRL_IMPCAL_VTH_MASK);
+	mask = UTMI_CALIB_CTRL_IMPCAL_VTH_MASK;
+	data = 0x7 << UTMI_CALIB_CTRL_IMPCAL_VTH_OFFSET;
+	reg_set(utmi_pll_addr + UTMI_CALIB_CTRL_REG, data, mask);
+
+	/* Start Impedance and PLL Calibration */
+	mask = UTMI_CALIB_CTRL_PLLCAL_START_MASK;
+	data = (0x1 << UTMI_CALIB_CTRL_PLLCAL_START_OFFSET);
+	mask |= UTMI_CALIB_CTRL_IMPCAL_START_MASK;
+	data |= (0x1 << UTMI_CALIB_CTRL_IMPCAL_START_OFFSET);
+	reg_set(utmi_pll_addr + UTMI_CALIB_CTRL_REG, data, mask);
 
 	/* Set LS TX driver strength coarse control */
-	mask = UTMI_TX_CH_CTRL_DRV_EN_LS_MASK;
-	data = 0x3 << UTMI_TX_CH_CTRL_DRV_EN_LS_OFFSET;
-	/* Set LS TX driver fine adjustment */
+	mask = UTMI_TX_CH_CTRL_AMP_MASK;
+	data = 0x4 << UTMI_TX_CH_CTRL_AMP_OFFSET;
 	mask |= UTMI_TX_CH_CTRL_IMP_SEL_LS_MASK;
 	data |= 0x3 << UTMI_TX_CH_CTRL_IMP_SEL_LS_OFFSET;
+	mask |= UTMI_TX_CH_CTRL_DRV_EN_LS_MASK;
+	data |= 0x3 << UTMI_TX_CH_CTRL_DRV_EN_LS_OFFSET;
 	reg_set(utmi_base_addr + UTMI_TX_CH_CTRL_REG, data, mask);
 
 	/* Enable SQ */
 	mask = UTMI_RX_CH_CTRL0_SQ_DET_MASK;
-	data = 0x0 << UTMI_RX_CH_CTRL0_SQ_DET_OFFSET;
+	data = 0x1 << UTMI_RX_CH_CTRL0_SQ_DET_OFFSET;
 	/* Enable analog squelch detect */
 	mask |= UTMI_RX_CH_CTRL0_SQ_ANA_DTC_MASK;
-	data |= 0x1 << UTMI_RX_CH_CTRL0_SQ_ANA_DTC_OFFSET;
+	data |= 0x0 << UTMI_RX_CH_CTRL0_SQ_ANA_DTC_OFFSET;
+	mask |= UTMI_RX_CH_CTRL0_DISCON_THRESH_MASK;
+	data |= 0x0 << UTMI_RX_CH_CTRL0_DISCON_THRESH_OFFSET;
 	reg_set(utmi_base_addr + UTMI_RX_CH_CTRL0_REG, data, mask);
 
 	/* Set External squelch calibration number */
@@ -1718,7 +335,8 @@ static void comphy_utmi_phy_config(u32 utmi_index, void __iomem *utmi_base_addr,
 	return;
 }
 
-static int comphy_utmi_power_up(u32 utmi_index, void __iomem *utmi_base_addr,
+static int comphy_utmi_power_up(u32 utmi_index, void __iomem *utmi_pll_addr,
+				void __iomem *utmi_base_addr,
 				void __iomem *usb_cfg_addr,
 				void __iomem *utmi_cfg_addr, u32 utmi_phy_port)
 {
@@ -1737,7 +355,7 @@ static int comphy_utmi_power_up(u32 utmi_index, void __iomem *utmi_base_addr,
 		UTMI_CTRL_STATUS0_TEST_SEL_MASK);
 
 	debug("stage: Polling for PLL and impedance calibration done, and PLL ready done\n");
-	addr = utmi_base_addr + UTMI_CALIB_CTRL_REG;
+	addr = utmi_pll_addr + UTMI_CALIB_CTRL_REG;
 	data = UTMI_CALIB_CTRL_IMPCAL_DONE_MASK;
 	mask = data;
 	data = polling_with_timeout(addr, data, mask, 100);
@@ -1756,7 +374,7 @@ static int comphy_utmi_power_up(u32 utmi_index, void __iomem *utmi_base_addr,
 		ret = 0;
 	}
 
-	addr = utmi_base_addr + UTMI_PLL_CTRL_REG;
+	addr = utmi_pll_addr + UTMI_PLL_CTRL_REG;
 	data = UTMI_PLL_CTRL_PLL_RDY_MASK;
 	mask = data;
 	data = polling_with_timeout(addr, data, mask, 100);
@@ -1780,7 +398,7 @@ static int comphy_utmi_power_up(u32 utmi_index, void __iomem *utmi_base_addr,
  * the init split in 3 parts:
  * 1. Power down transceiver and PLL
  * 2. UTMI PHY configure
- * 3. Powe up transceiver and PLL
+ * 3. Power up transceiver and PLL
  * Note: - Power down/up should be once for both UTMI PHYs
  *       - comphy_dedicated_phys_init call this function if at least there is
  *         one UTMI PHY exists in FDT blob. access to cp110_utmi_data[0] is
@@ -1807,14 +425,16 @@ static void comphy_utmi_phy_init(u32 utmi_phy_count,
 	}
 	/* UTMI configure */
 	for (i = 0; i < utmi_phy_count; i++) {
-		comphy_utmi_phy_config(i, cp110_utmi_data[i].utmi_base_addr,
+		comphy_utmi_phy_config(i, cp110_utmi_data[i].utmi_pll_addr,
+				       cp110_utmi_data[i].utmi_base_addr,
 				       cp110_utmi_data[i].usb_cfg_addr,
 				       cp110_utmi_data[i].utmi_cfg_addr,
 				       cp110_utmi_data[i].utmi_phy_port);
 	}
 	/* UTMI Power up */
 	for (i = 0; i < utmi_phy_count; i++) {
-		if (!comphy_utmi_power_up(i, cp110_utmi_data[i].utmi_base_addr,
+		if (!comphy_utmi_power_up(i, cp110_utmi_data[i].utmi_pll_addr,
+					  cp110_utmi_data[i].utmi_base_addr,
 					  cp110_utmi_data[i].usb_cfg_addr,
 					  cp110_utmi_data[i].utmi_cfg_addr,
 					  cp110_utmi_data[i].utmi_phy_port)) {
@@ -1847,45 +467,61 @@ static void comphy_utmi_phy_init(u32 utmi_phy_count,
 void comphy_dedicated_phys_init(void)
 {
 	struct utmi_phy_data cp110_utmi_data[MAX_UTMI_PHY_COUNT];
-	int node;
-	int i;
+	int node = -1;
+	int node_idx;
+	int parent = -1;
 
 	debug_enter();
 	debug("Initialize USB UTMI PHYs\n");
 
-	/* Find the UTMI phy node in device tree and go over them */
-	node = fdt_node_offset_by_compatible(gd->fdt_blob, -1,
-					     "marvell,mvebu-utmi-2.6.0");
+	for (node_idx = 0; node_idx < MAX_UTMI_PHY_COUNT;) {
+		/* Find the UTMI phy node in device tree */
+		node = fdt_node_offset_by_compatible(gd->fdt_blob, node,
+						     "marvell,mvebu-utmi-2.6.0");
+		if (node <= 0)
+			break;
+
+		/* check if node is enabled */
+		if (!fdtdec_get_is_enabled(gd->fdt_blob, node))
+			continue;
+
+		parent = fdt_parent_offset(gd->fdt_blob, node);
+		if (parent <= 0)
+			break;
+
+		/* get base address of UTMI PLL */
+		cp110_utmi_data[node_idx].utmi_pll_addr =
+			(void __iomem *)fdtdec_get_addr_size_auto_noparent(
+				gd->fdt_blob, parent, "reg", 0, NULL, true);
+		if (!cp110_utmi_data[node_idx].utmi_pll_addr) {
+			pr_err("UTMI PHY PLL address is invalid\n");
+			continue;
+		}
 
-	i = 0;
-	while (node > 0) {
 		/* get base address of UTMI phy */
-		cp110_utmi_data[i].utmi_base_addr =
+		cp110_utmi_data[node_idx].utmi_base_addr =
 			(void __iomem *)fdtdec_get_addr_size_auto_noparent(
 				gd->fdt_blob, node, "reg", 0, NULL, true);
-		if (cp110_utmi_data[i].utmi_base_addr == NULL) {
+		if (!cp110_utmi_data[node_idx].utmi_base_addr) {
 			pr_err("UTMI PHY base address is invalid\n");
-			i++;
 			continue;
 		}
 
 		/* get usb config address */
-		cp110_utmi_data[i].usb_cfg_addr =
+		cp110_utmi_data[node_idx].usb_cfg_addr =
 			(void __iomem *)fdtdec_get_addr_size_auto_noparent(
 				gd->fdt_blob, node, "reg", 1, NULL, true);
-		if (cp110_utmi_data[i].usb_cfg_addr == NULL) {
+		if (!cp110_utmi_data[node_idx].usb_cfg_addr) {
 			pr_err("UTMI PHY base address is invalid\n");
-			i++;
 			continue;
 		}
 
 		/* get UTMI config address */
-		cp110_utmi_data[i].utmi_cfg_addr =
+		cp110_utmi_data[node_idx].utmi_cfg_addr =
 			(void __iomem *)fdtdec_get_addr_size_auto_noparent(
 				gd->fdt_blob, node, "reg", 2, NULL, true);
-		if (cp110_utmi_data[i].utmi_cfg_addr == NULL) {
+		if (!cp110_utmi_data[node_idx].utmi_cfg_addr) {
 			pr_err("UTMI PHY base address is invalid\n");
-			i++;
 			continue;
 		}
 
@@ -1893,71 +529,32 @@ void comphy_dedicated_phys_init(void)
 		 * get the port number (to check if the utmi connected to
 		 * host/device)
 		 */
-		cp110_utmi_data[i].utmi_phy_port = fdtdec_get_int(
+		cp110_utmi_data[node_idx].utmi_phy_port = fdtdec_get_int(
 			gd->fdt_blob, node, "utmi-port", UTMI_PHY_INVALID);
-		if (cp110_utmi_data[i].utmi_phy_port == UTMI_PHY_INVALID) {
+		if (cp110_utmi_data[node_idx].utmi_phy_port ==
+							UTMI_PHY_INVALID) {
 			pr_err("UTMI PHY port type is invalid\n");
-			i++;
 			continue;
 		}
 
-		node = fdt_node_offset_by_compatible(
-			gd->fdt_blob, node, "marvell,mvebu-utmi-2.6.0");
-		i++;
+		/* count valid UTMI unit */
+		node_idx++;
 	}
 
-	if (i > 0)
-		comphy_utmi_phy_init(i, cp110_utmi_data);
+	if (node_idx > 0)
+		comphy_utmi_phy_init(node_idx, cp110_utmi_data);
 
 	debug_exit();
 }
 
-static void comphy_mux_cp110_init(struct chip_serdes_phy_config *ptr_chip_cfg,
-				  struct comphy_map *serdes_map)
-{
-	void __iomem *comphy_base_addr;
-	struct comphy_map comphy_map_pipe_data[MAX_LANE_OPTIONS];
-	struct comphy_map comphy_map_phy_data[MAX_LANE_OPTIONS];
-	u32 lane, comphy_max_count;
-
-	comphy_max_count = ptr_chip_cfg->comphy_lanes_count;
-	comphy_base_addr = ptr_chip_cfg->comphy_base_addr;
-
-	/*
-	 * Copy the SerDes map configuration for PIPE map and PHY map
-	 * the comphy_mux_init modify the type of the lane if the type
-	 * is not valid because we have 2 selectores run the
-	 * comphy_mux_init twice and after that update the original
-	 * serdes_map
-	 */
-	for (lane = 0; lane < comphy_max_count; lane++) {
-		comphy_map_pipe_data[lane].type = serdes_map[lane].type;
-		comphy_map_pipe_data[lane].speed = serdes_map[lane].speed;
-		comphy_map_phy_data[lane].type = serdes_map[lane].type;
-		comphy_map_phy_data[lane].speed = serdes_map[lane].speed;
-	}
-	ptr_chip_cfg->mux_data = cp110_comphy_phy_mux_data;
-	comphy_mux_init(ptr_chip_cfg, comphy_map_phy_data,
-			comphy_base_addr + COMMON_SELECTOR_PHY_OFFSET);
-
-	ptr_chip_cfg->mux_data = cp110_comphy_pipe_mux_data;
-	comphy_mux_init(ptr_chip_cfg, comphy_map_pipe_data,
-			comphy_base_addr + COMMON_SELECTOR_PIPE_OFFSET);
-	/* Fix the type after check the PHY and PIPE configuration */
-	for (lane = 0; lane < comphy_max_count; lane++) {
-		if ((comphy_map_pipe_data[lane].type == PHY_TYPE_UNCONNECTED) &&
-		    (comphy_map_phy_data[lane].type == PHY_TYPE_UNCONNECTED))
-			serdes_map[lane].type = PHY_TYPE_UNCONNECTED;
-	}
-}
-
 int comphy_cp110_init(struct chip_serdes_phy_config *ptr_chip_cfg,
 		      struct comphy_map *serdes_map)
 {
 	struct comphy_map *ptr_comphy_map;
 	void __iomem *comphy_base_addr, *hpipe_base_addr;
-	u32 comphy_max_count, lane, ret = 0;
+	u32 comphy_max_count, lane, id, ret = 0;
 	u32 pcie_width = 0;
+	u32 mode;
 
 	debug_enter();
 
@@ -1965,13 +562,10 @@ int comphy_cp110_init(struct chip_serdes_phy_config *ptr_chip_cfg,
 	comphy_base_addr = ptr_chip_cfg->comphy_base_addr;
 	hpipe_base_addr = ptr_chip_cfg->hpipe3_base_addr;
 
-	/* Config Comphy mux configuration */
-	comphy_mux_cp110_init(ptr_chip_cfg, serdes_map);
-
 	/* Check if the first 4 lanes configured as By-4 */
 	for (lane = 0, ptr_comphy_map = serdes_map; lane < 4;
 	     lane++, ptr_comphy_map++) {
-		if (ptr_comphy_map->type != PHY_TYPE_PEX0)
+		if (ptr_comphy_map->type != COMPHY_TYPE_PEX0)
 			break;
 		pcie_width++;
 	}
@@ -1988,55 +582,88 @@ int comphy_cp110_init(struct chip_serdes_phy_config *ptr_chip_cfg,
 			pcie_width = 1;
 		}
 		switch (ptr_comphy_map->type) {
-		case PHY_TYPE_UNCONNECTED:
-		case PHY_TYPE_IGNORE:
+		case COMPHY_TYPE_UNCONNECTED:
+			mode = COMPHY_TYPE_UNCONNECTED | COMPHY_CALLER_UBOOT;
+			ret = comphy_smc(MV_SIP_COMPHY_POWER_OFF,
+					 ptr_chip_cfg->comphy_base_addr,
+					 lane, mode);
+		case COMPHY_TYPE_IGNORE:
 			continue;
 			break;
-		case PHY_TYPE_PEX0:
-		case PHY_TYPE_PEX1:
-		case PHY_TYPE_PEX2:
-		case PHY_TYPE_PEX3:
-			ret = comphy_pcie_power_up(
-				lane, pcie_width, ptr_comphy_map->clk_src,
-				serdes_map->end_point,
-				hpipe_base_addr, comphy_base_addr);
+		case COMPHY_TYPE_PEX0:
+		case COMPHY_TYPE_PEX1:
+		case COMPHY_TYPE_PEX2:
+		case COMPHY_TYPE_PEX3:
+			mode = COMPHY_FW_PCIE_FORMAT(pcie_width,
+						     ptr_comphy_map->clk_src,
+						     COMPHY_PCIE_MODE,
+						     ptr_comphy_map->speed);
+			ret = comphy_smc(MV_SIP_COMPHY_POWER_ON,
+					 ptr_chip_cfg->comphy_base_addr, lane,
+					 mode);
+			break;
+		case COMPHY_TYPE_SATA0:
+		case COMPHY_TYPE_SATA1:
+			mode =  COMPHY_FW_MODE_FORMAT(COMPHY_SATA_MODE);
+			ret = comphy_sata_power_up(lane, hpipe_base_addr,
+						   comphy_base_addr,
+						   ptr_chip_cfg->cp_index,
+						   mode);
 			break;
-		case PHY_TYPE_SATA0:
-		case PHY_TYPE_SATA1:
-		case PHY_TYPE_SATA2:
-		case PHY_TYPE_SATA3:
-			ret = comphy_sata_power_up(
-				lane, hpipe_base_addr, comphy_base_addr,
-				ptr_chip_cfg->cp_index);
+		case COMPHY_TYPE_USB3_HOST0:
+		case COMPHY_TYPE_USB3_HOST1:
+			mode = COMPHY_FW_MODE_FORMAT(COMPHY_USB3H_MODE);
+			ret = comphy_smc(MV_SIP_COMPHY_POWER_ON,
+					 ptr_chip_cfg->comphy_base_addr, lane,
+					 mode);
 			break;
-		case PHY_TYPE_USB3_HOST0:
-		case PHY_TYPE_USB3_HOST1:
-		case PHY_TYPE_USB3_DEVICE:
-			ret = comphy_usb3_power_up(lane, hpipe_base_addr,
-						   comphy_base_addr);
+		case COMPHY_TYPE_USB3_DEVICE:
+			mode = COMPHY_FW_MODE_FORMAT(COMPHY_USB3D_MODE);
+			ret = comphy_smc(MV_SIP_COMPHY_POWER_ON,
+					 ptr_chip_cfg->comphy_base_addr, lane,
+					 mode);
 			break;
-		case PHY_TYPE_SGMII0:
-		case PHY_TYPE_SGMII1:
-		case PHY_TYPE_SGMII2:
-		case PHY_TYPE_SGMII3:
-			if (ptr_comphy_map->speed == PHY_SPEED_INVALID) {
-				debug("Warning: SGMII PHY speed in lane %d is invalid, set PHY speed to 1.25G\n",
+		case COMPHY_TYPE_SGMII0:
+		case COMPHY_TYPE_SGMII1:
+		case COMPHY_TYPE_SGMII2:
+			/* Calculate SGMII ID */
+			id = ptr_comphy_map->type - COMPHY_TYPE_SGMII0;
+
+			if (ptr_comphy_map->speed == COMPHY_SPEED_INVALID) {
+				debug("Warning: ");
+				debug("SGMII PHY speed in lane %d is invalid,",
 				      lane);
-				ptr_comphy_map->speed = PHY_SPEED_1_25G;
+				debug(" set PHY speed to 1.25G\n");
+				ptr_comphy_map->speed = COMPHY_SPEED_1_25G;
 			}
-			ret = comphy_sgmii_power_up(
-				lane, ptr_comphy_map->speed, hpipe_base_addr,
-				comphy_base_addr);
+
+			mode = COMPHY_FW_FORMAT(COMPHY_SGMII_MODE, id,
+						ptr_comphy_map->speed);
+			ret = comphy_smc(MV_SIP_COMPHY_POWER_ON,
+					 ptr_chip_cfg->comphy_base_addr, lane,
+					 mode);
+			break;
+		case COMPHY_TYPE_SFI0:
+		case COMPHY_TYPE_SFI1:
+			/* Calculate SFI id */
+			id = ptr_comphy_map->type - COMPHY_TYPE_SFI0;
+			mode = COMPHY_FW_FORMAT(COMPHY_SFI_MODE, id,
+						ptr_comphy_map->speed);
+			ret = comphy_smc(MV_SIP_COMPHY_POWER_ON,
+				ptr_chip_cfg->comphy_base_addr, lane, mode);
 			break;
-		case PHY_TYPE_SFI:
-			ret = comphy_sfi_power_up(lane, hpipe_base_addr,
-						  comphy_base_addr,
-						  ptr_comphy_map->speed);
+		case COMPHY_TYPE_RXAUI0:
+		case COMPHY_TYPE_RXAUI1:
+			mode = COMPHY_FW_MODE_FORMAT(COMPHY_RXAUI_MODE);
+			ret = comphy_smc(MV_SIP_COMPHY_POWER_ON,
+					 ptr_chip_cfg->comphy_base_addr, lane,
+					 mode);
 			break;
-		case PHY_TYPE_RXAUI0:
-		case PHY_TYPE_RXAUI1:
-			ret = comphy_rxauii_power_up(lane, hpipe_base_addr,
-						     comphy_base_addr);
+		case COMPHY_TYPE_AP:
+			mode = COMPHY_FW_MODE_FORMAT(COMPHY_AP_MODE);
+			ret = comphy_smc(MV_SIP_COMPHY_POWER_ON,
+					 ptr_chip_cfg->comphy_base_addr, lane,
+					 mode);
 			break;
 		default:
 			debug("Unknown SerDes type, skip initialize SerDes %d\n",
@@ -2046,9 +673,9 @@ int comphy_cp110_init(struct chip_serdes_phy_config *ptr_chip_cfg,
 		if (ret == 0) {
 			/*
 			 * If interface wans't initialized, set the lane to
-			 * PHY_TYPE_UNCONNECTED state.
+			 * COMPHY_TYPE_UNCONNECTED state.
 			 */
-			ptr_comphy_map->type = PHY_TYPE_UNCONNECTED;
+			ptr_comphy_map->type = COMPHY_TYPE_UNCONNECTED;
 			pr_err("PLL is not locked - Failed to initialize lane %d\n",
 			      lane);
 		}
diff --git a/drivers/phy/marvell/comphy_hpipe.h b/drivers/phy/marvell/comphy_hpipe.h
deleted file mode 100644
index fbceb2a..0000000
--- a/drivers/phy/marvell/comphy_hpipe.h
+++ /dev/null
@@ -1,655 +0,0 @@
-/*
- * Copyright (C) 2015-2016 Marvell International Ltd.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#ifndef _COMPHY_HPIPE_H_
-#define _COMPHY_HPIPE_H_
-
-/* SerDes IP register */
-#define SD_EXTERNAL_CONFIG0_REG			0
-#define SD_EXTERNAL_CONFIG0_SD_PU_PLL_OFFSET	1
-#define SD_EXTERNAL_CONFIG0_SD_PU_PLL_MASK	\
-	(1 << SD_EXTERNAL_CONFIG0_SD_PU_PLL_OFFSET)
-#define SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_OFFSET 3
-#define SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_MASK	\
-	(0xf << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_RX_OFFSET)
-#define SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_OFFSET 7
-#define SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_MASK	\
-	(0xf << SD_EXTERNAL_CONFIG0_SD_PHY_GEN_TX_OFFSET)
-#define SD_EXTERNAL_CONFIG0_SD_PU_RX_OFFSET	11
-#define SD_EXTERNAL_CONFIG0_SD_PU_RX_MASK	\
-	(1 << SD_EXTERNAL_CONFIG0_SD_PU_RX_OFFSET)
-#define SD_EXTERNAL_CONFIG0_SD_PU_TX_OFFSET	12
-#define SD_EXTERNAL_CONFIG0_SD_PU_TX_MASK	\
-	(1 << SD_EXTERNAL_CONFIG0_SD_PU_TX_OFFSET)
-#define SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_OFFSET 14
-#define SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_MASK	\
-	(1 << SD_EXTERNAL_CONFIG0_HALF_BUS_MODE_OFFSET)
-#define SD_EXTERNAL_CONFIG0_MEDIA_MODE_OFFSET	15
-#define SD_EXTERNAL_CONFIG0_MEDIA_MODE_MASK	\
-	(0x1 << SD_EXTERNAL_CONFIG0_MEDIA_MODE_OFFSET)
-
-#define SD_EXTERNAL_CONFIG1_REG			0x4
-#define SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET	3
-#define SD_EXTERNAL_CONFIG1_RESET_IN_MASK	\
-	(0x1 << SD_EXTERNAL_CONFIG1_RESET_IN_OFFSET)
-#define SD_EXTERNAL_CONFIG1_RX_INIT_OFFSET	4
-#define SD_EXTERNAL_CONFIG1_RX_INIT_MASK	\
-	(0x1 << SD_EXTERNAL_CONFIG1_RX_INIT_OFFSET)
-#define SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET	5
-#define SD_EXTERNAL_CONFIG1_RESET_CORE_MASK	\
-	(0x1 << SD_EXTERNAL_CONFIG1_RESET_CORE_OFFSET)
-#define SD_EXTERNAL_CONFIG1_RF_RESET_IN_OFFSET	6
-#define SD_EXTERNAL_CONFIG1_RF_RESET_IN_MASK	\
-	(0x1 << SD_EXTERNAL_CONFIG1_RF_RESET_IN_OFFSET)
-
-#define SD_EXTERNAL_CONFIG2_REG			0x8
-#define SD_EXTERNAL_CONFIG2_PIN_DFE_EN_OFFSET	4
-#define SD_EXTERNAL_CONFIG2_PIN_DFE_EN_MASK	\
-	(0x1 << SD_EXTERNAL_CONFIG2_PIN_DFE_EN_OFFSET)
-#define SD_EXTERNAL_CONFIG2_SSC_ENABLE_OFFSET	7
-#define SD_EXTERNAL_CONFIG2_SSC_ENABLE_MASK	\
-	(0x1 << SD_EXTERNAL_CONFIG2_SSC_ENABLE_OFFSET)
-
-#define SD_EXTERNAL_STATUS0_REG			0x18
-#define SD_EXTERNAL_STATUS0_PLL_TX_OFFSET	2
-#define SD_EXTERNAL_STATUS0_PLL_TX_MASK		\
-	(0x1 << SD_EXTERNAL_STATUS0_PLL_TX_OFFSET)
-#define SD_EXTERNAL_STATUS0_PLL_RX_OFFSET	3
-#define SD_EXTERNAL_STATUS0_PLL_RX_MASK		\
-	(0x1 << SD_EXTERNAL_STATUS0_PLL_RX_OFFSET)
-#define SD_EXTERNAL_STATUS0_RX_INIT_OFFSET	4
-#define SD_EXTERNAL_STATUS0_RX_INIT_MASK	\
-	(0x1 << SD_EXTERNAL_STATUS0_RX_INIT_OFFSET)
-#define SD_EXTERNAL_STATUS0_RF_RESET_IN_OFFSET	6
-#define SD_EXTERNAL_STATUS0_RF_RESET_IN_MASK	\
-	(0x1 << SD_EXTERNAL_STATUS0_RF_RESET_IN_OFFSET)
-
-/* HPIPE register */
-#define HPIPE_PWR_PLL_REG			0x4
-#define HPIPE_PWR_PLL_REF_FREQ_OFFSET		0
-#define HPIPE_PWR_PLL_REF_FREQ_MASK		\
-	(0x1f << HPIPE_PWR_PLL_REF_FREQ_OFFSET)
-#define HPIPE_PWR_PLL_PHY_MODE_OFFSET		5
-#define HPIPE_PWR_PLL_PHY_MODE_MASK		\
-	(0x7 << HPIPE_PWR_PLL_PHY_MODE_OFFSET)
-
-#define HPIPE_KVCO_CALIB_CTRL_REG		0x8
-#define HPIPE_KVCO_CALIB_CTRL_MAX_PLL_OFFSET	12
-#define HPIPE_KVCO_CALIB_CTRL_MAX_PLL_MASK	\
-	(0x1 << HPIPE_KVCO_CALIB_CTRL_MAX_PLL_OFFSET)
-
-#define HPIPE_CAL_REG1_REG			0xc
-#define HPIPE_CAL_REG_1_EXT_TXIMP_OFFSET	10
-#define HPIPE_CAL_REG_1_EXT_TXIMP_MASK		\
-	(0x1f << HPIPE_CAL_REG_1_EXT_TXIMP_OFFSET)
-#define HPIPE_CAL_REG_1_EXT_TXIMP_EN_OFFSET	15
-#define HPIPE_CAL_REG_1_EXT_TXIMP_EN_MASK	\
-	(0x1 << HPIPE_CAL_REG_1_EXT_TXIMP_EN_OFFSET)
-
-#define HPIPE_SQUELCH_FFE_SETTING_REG           0x018
-
-#define HPIPE_DFE_REG0				0x01C
-#define HPIPE_DFE_RES_FORCE_OFFSET		15
-#define HPIPE_DFE_RES_FORCE_MASK		\
-	(0x1 << HPIPE_DFE_RES_FORCE_OFFSET)
-
-#define HPIPE_DFE_F3_F5_REG			0x028
-#define HPIPE_DFE_F3_F5_DFE_EN_OFFSET		14
-#define HPIPE_DFE_F3_F5_DFE_EN_MASK		\
-	(0x1 << HPIPE_DFE_F3_F5_DFE_EN_OFFSET)
-#define HPIPE_DFE_F3_F5_DFE_CTRL_OFFSET		15
-#define HPIPE_DFE_F3_F5_DFE_CTRL_MASK		\
-	(0x1 << HPIPE_DFE_F3_F5_DFE_CTRL_OFFSET)
-
-#define HPIPE_G1_SET_0_REG			0x034
-#define HPIPE_G1_SET_0_G1_TX_AMP_OFFSET		1
-#define HPIPE_G1_SET_0_G1_TX_AMP_MASK		\
-	(0x1f << HPIPE_G1_SET_0_G1_TX_AMP_OFFSET)
-#define HPIPE_G1_SET_0_G1_TX_AMP_ADJ_OFFSET	6
-#define HPIPE_G1_SET_0_G1_TX_AMP_ADJ_MASK	\
-	(0x1 << HPIPE_G1_SET_0_G1_TX_AMP_ADJ_OFFSET)
-#define HPIPE_G1_SET_0_G1_TX_EMPH1_OFFSET	7
-#define HPIPE_G1_SET_0_G1_TX_EMPH1_MASK		\
-	(0xf << HPIPE_G1_SET_0_G1_TX_EMPH1_OFFSET)
-#define HPIPE_G1_SET_0_G1_TX_EMPH1_EN_OFFSET	11
-#define HPIPE_G1_SET_0_G1_TX_EMPH1_EN_MASK	\
-	(0x1 << HPIPE_G1_SET_0_G1_TX_EMPH1_EN_OFFSET)
-
-#define HPIPE_G1_SET_1_REG			0x038
-#define HPIPE_G1_SET_1_G1_RX_SELMUPI_OFFSET	0
-#define HPIPE_G1_SET_1_G1_RX_SELMUPI_MASK	\
-	(0x7 << HPIPE_G1_SET_1_G1_RX_SELMUPI_OFFSET)
-#define HPIPE_G1_SET_1_G1_RX_SELMUPP_OFFSET	3
-#define HPIPE_G1_SET_1_G1_RX_SELMUPP_MASK	\
-	(0x7 << HPIPE_G1_SET_1_G1_RX_SELMUPP_OFFSET)
-#define HPIPE_G1_SET_1_G1_RX_SELMUFI_OFFSET	6
-#define HPIPE_G1_SET_1_G1_RX_SELMUFI_MASK	\
-	(0x3 << HPIPE_G1_SET_1_G1_RX_SELMUFI_OFFSET)
-#define HPIPE_G1_SET_1_G1_RX_SELMUFF_OFFSET	8
-#define HPIPE_G1_SET_1_G1_RX_SELMUFF_MASK	\
-	(0x3 << HPIPE_G1_SET_1_G1_RX_SELMUFF_OFFSET)
-#define HPIPE_G1_SET_1_G1_RX_DFE_EN_OFFSET	10
-#define HPIPE_G1_SET_1_G1_RX_DFE_EN_MASK	\
-	(0x1 << HPIPE_G1_SET_1_G1_RX_DFE_EN_OFFSET)
-
-#define HPIPE_G1_SET_1_G1_RX_DIGCK_DIV_OFFSET	11
-#define HPIPE_G1_SET_1_G1_RX_DIGCK_DIV_MASK	\
-	(0x3 << HPIPE_G1_SET_1_G1_RX_DIGCK_DIV_OFFSET)
-
-#define HPIPE_G2_SET_0_REG			0x3c
-#define HPIPE_G2_SET_0_G2_TX_AMP_OFFSET		1
-#define HPIPE_G2_SET_0_G2_TX_AMP_MASK		\
-	(0x1f << HPIPE_G2_SET_0_G2_TX_AMP_OFFSET)
-#define HPIPE_G2_SET_0_G2_TX_AMP_ADJ_OFFSET	6
-#define HPIPE_G2_SET_0_G2_TX_AMP_ADJ_MASK	\
-	(0x1 << HPIPE_G2_SET_0_G2_TX_AMP_ADJ_OFFSET)
-#define HPIPE_G2_SET_0_G2_TX_EMPH1_OFFSET	7
-#define HPIPE_G2_SET_0_G2_TX_EMPH1_MASK		\
-	(0xf << HPIPE_G2_SET_0_G2_TX_EMPH1_OFFSET)
-#define HPIPE_G2_SET_0_G2_TX_EMPH1_EN_OFFSET	11
-#define HPIPE_G2_SET_0_G2_TX_EMPH1_EN_MASK	\
-	(0x1 << HPIPE_G2_SET_0_G2_TX_EMPH1_EN_OFFSET)
-
-#define HPIPE_G2_SET_1_REG			0x040
-#define HPIPE_G2_SET_1_G2_RX_SELMUPI_OFFSET	0
-#define HPIPE_G2_SET_1_G2_RX_SELMUPI_MASK	\
-	(0x7 << HPIPE_G2_SET_1_G2_RX_SELMUPI_OFFSET)
-#define HPIPE_G2_SET_1_G2_RX_SELMUPP_OFFSET	3
-#define HPIPE_G2_SET_1_G2_RX_SELMUPP_MASK	\
-	(0x7 << HPIPE_G2_SET_1_G2_RX_SELMUPP_OFFSET)
-#define HPIPE_G2_SET_1_G2_RX_SELMUFI_OFFSET	6
-#define HPIPE_G2_SET_1_G2_RX_SELMUFI_MASK	\
-	(0x3 << HPIPE_G2_SET_1_G2_RX_SELMUFI_OFFSET)
-#define HPIPE_G2_SET_1_G2_RX_SELMUFF_OFFSET	8
-#define HPIPE_G2_SET_1_G2_RX_SELMUFF_MASK	\
-	(0x3 << HPIPE_G2_SET_1_G2_RX_SELMUFF_OFFSET)
-#define HPIPE_G2_SET_1_G2_RX_DFE_EN_OFFSET	10
-#define HPIPE_G2_SET_1_G2_RX_DFE_EN_MASK	\
-	(0x1 << HPIPE_G2_SET_1_G2_RX_DFE_EN_OFFSET)
-#define HPIPE_G2_SET_1_G2_RX_DIGCK_DIV_OFFSET	11
-#define HPIPE_G2_SET_1_G2_RX_DIGCK_DIV_MASK	\
-	(0x3 << HPIPE_G2_SET_1_G2_RX_DIGCK_DIV_OFFSET)
-
-#define HPIPE_G3_SET_0_REG			0x44
-#define HPIPE_G3_SET_0_G3_TX_AMP_OFFSET		1
-#define HPIPE_G3_SET_0_G3_TX_AMP_MASK		\
-	(0x1f << HPIPE_G3_SET_0_G3_TX_AMP_OFFSET)
-#define HPIPE_G3_SET_0_G3_TX_AMP_ADJ_OFFSET	6
-#define HPIPE_G3_SET_0_G3_TX_AMP_ADJ_MASK	\
-	(0x1 << HPIPE_G3_SET_0_G3_TX_AMP_ADJ_OFFSET)
-#define HPIPE_G3_SET_0_G3_TX_EMPH1_OFFSET	7
-#define HPIPE_G3_SET_0_G3_TX_EMPH1_MASK		\
-	(0xf << HPIPE_G3_SET_0_G3_TX_EMPH1_OFFSET)
-#define HPIPE_G3_SET_0_G3_TX_EMPH1_EN_OFFSET	11
-#define HPIPE_G3_SET_0_G3_TX_EMPH1_EN_MASK	\
-	(0x1 << HPIPE_G3_SET_0_G3_TX_EMPH1_EN_OFFSET)
-#define HPIPE_G3_SET_0_G3_TX_SLEW_RATE_SEL_OFFSET 12
-#define HPIPE_G3_SET_0_G3_TX_SLEW_RATE_SEL_MASK	\
-	(0x7 << HPIPE_G3_SET_0_G3_TX_SLEW_RATE_SEL_OFFSET)
-#define HPIPE_G3_SET_0_G3_TX_SLEW_CTRL_EN_OFFSET 15
-#define HPIPE_G3_SET_0_G3_TX_SLEW_CTRL_EN_MASK	\
-	(0x1 << HPIPE_G3_SET_0_G3_TX_SLEW_CTRL_EN_OFFSET)
-
-#define HPIPE_G3_SET_1_REG			0x048
-#define HPIPE_G3_SET_1_G3_RX_SELMUPI_OFFSET	0
-#define HPIPE_G3_SET_1_G3_RX_SELMUPI_MASK	\
-	(0x7 << HPIPE_G3_SET_1_G3_RX_SELMUPI_OFFSET)
-#define HPIPE_G3_SET_1_G3_RX_SELMUPF_OFFSET	3
-#define HPIPE_G3_SET_1_G3_RX_SELMUPF_MASK	\
-	(0x7 << HPIPE_G3_SET_1_G3_RX_SELMUPF_OFFSET)
-#define HPIPE_G3_SET_1_G3_RX_SELMUFI_OFFSET	6
-#define HPIPE_G3_SET_1_G3_RX_SELMUFI_MASK	\
-	(0x3 << HPIPE_G3_SET_1_G3_RX_SELMUFI_OFFSET)
-#define HPIPE_G3_SET_1_G3_RX_SELMUFF_OFFSET	8
-#define HPIPE_G3_SET_1_G3_RX_SELMUFF_MASK	\
-	(0x3 << HPIPE_G3_SET_1_G3_RX_SELMUFF_OFFSET)
-#define HPIPE_G3_SET_1_G3_RX_DFE_EN_OFFSET	10
-#define HPIPE_G3_SET_1_G3_RX_DFE_EN_MASK	\
-	(0x1 << HPIPE_G3_SET_1_G3_RX_DFE_EN_OFFSET)
-#define HPIPE_G3_SET_1_G3_RX_DIGCK_DIV_OFFSET	11
-#define HPIPE_G3_SET_1_G3_RX_DIGCK_DIV_MASK	 \
-	(0x3 << HPIPE_G3_SET_1_G3_RX_DIGCK_DIV_OFFSET)
-#define HPIPE_G3_SET_1_G3_SAMPLER_INPAIRX2_EN_OFFSET	13
-#define HPIPE_G3_SET_1_G3_SAMPLER_INPAIRX2_EN_MASK	\
-	(0x1 << HPIPE_G3_SET_1_G3_SAMPLER_INPAIRX2_EN_OFFSET)
-
-#define HPIPE_LOOPBACK_REG			0x08c
-#define HPIPE_LOOPBACK_SEL_OFFSET		1
-#define HPIPE_LOOPBACK_SEL_MASK			\
-	(0x7 << HPIPE_LOOPBACK_SEL_OFFSET)
-
-#define HPIPE_SYNC_PATTERN_REG                  0x090
-
-#define HPIPE_INTERFACE_REG			0x94
-#define HPIPE_INTERFACE_GEN_MAX_OFFSET		10
-#define HPIPE_INTERFACE_GEN_MAX_MASK		\
-	(0x3 << HPIPE_INTERFACE_GEN_MAX_OFFSET)
-#define HPIPE_INTERFACE_DET_BYPASS_OFFSET	12
-#define HPIPE_INTERFACE_DET_BYPASS_MASK		\
-	(0x1 << HPIPE_INTERFACE_DET_BYPASS_OFFSET)
-#define HPIPE_INTERFACE_LINK_TRAIN_OFFSET	14
-#define HPIPE_INTERFACE_LINK_TRAIN_MASK		\
-	(0x1 << HPIPE_INTERFACE_LINK_TRAIN_OFFSET)
-
-#define HPIPE_ISOLATE_MODE_REG			0x98
-#define HPIPE_ISOLATE_MODE_GEN_RX_OFFSET	0
-#define HPIPE_ISOLATE_MODE_GEN_RX_MASK		\
-	(0xf << HPIPE_ISOLATE_MODE_GEN_RX_OFFSET)
-#define HPIPE_ISOLATE_MODE_GEN_TX_OFFSET	4
-#define HPIPE_ISOLATE_MODE_GEN_TX_MASK		\
-	(0xf << HPIPE_ISOLATE_MODE_GEN_TX_OFFSET)
-
-#define HPIPE_G1_SET_2_REG			0xf4
-#define HPIPE_G1_SET_2_G1_TX_EMPH0_OFFSET	0
-#define HPIPE_G1_SET_2_G1_TX_EMPH0_MASK		\
-	(0xf << HPIPE_G1_SET_2_G1_TX_EMPH0_OFFSET)
-#define HPIPE_G1_SET_2_G1_TX_EMPH0_EN_OFFSET	4
-#define HPIPE_G1_SET_2_G1_TX_EMPH0_EN_MASK	\
-	(0x1 << HPIPE_G1_SET_2_G1_TX_EMPH0_MASK)
-
-#define HPIPE_VTHIMPCAL_CTRL_REG                0x104
-
-#define HPIPE_VDD_CAL_CTRL_REG			0x114
-#define HPIPE_EXT_SELLV_RXSAMPL_OFFSET		5
-#define HPIPE_EXT_SELLV_RXSAMPL_MASK		\
-	(0x1f << HPIPE_EXT_SELLV_RXSAMPL_OFFSET)
-
-#define HPIPE_VDD_CAL_0_REG			0x108
-#define HPIPE_CAL_VDD_CONT_MODE_OFFSET		15
-#define HPIPE_CAL_VDD_CONT_MODE_MASK		\
-	(0x1 << HPIPE_CAL_VDD_CONT_MODE_OFFSET)
-
-#define HPIPE_PCIE_REG0                         0x120
-#define HPIPE_PCIE_IDLE_SYNC_OFFSET		12
-#define HPIPE_PCIE_IDLE_SYNC_MASK		\
-	(0x1 << HPIPE_PCIE_IDLE_SYNC_OFFSET)
-#define HPIPE_PCIE_SEL_BITS_OFFSET		13
-#define HPIPE_PCIE_SEL_BITS_MASK		\
-	(0x3 << HPIPE_PCIE_SEL_BITS_OFFSET)
-
-#define HPIPE_LANE_ALIGN_REG			0x124
-#define HPIPE_LANE_ALIGN_OFF_OFFSET		12
-#define HPIPE_LANE_ALIGN_OFF_MASK		\
-	(0x1 << HPIPE_LANE_ALIGN_OFF_OFFSET)
-
-#define HPIPE_MISC_REG				0x13C
-#define HPIPE_MISC_CLK100M_125M_OFFSET		4
-#define HPIPE_MISC_CLK100M_125M_MASK		\
-	(0x1 << HPIPE_MISC_CLK100M_125M_OFFSET)
-#define HPIPE_MISC_ICP_FORCE_OFFSET		5
-#define HPIPE_MISC_ICP_FORCE_MASK		\
-	(0x1 << HPIPE_MISC_ICP_FORCE_OFFSET)
-#define HPIPE_MISC_TXDCLK_2X_OFFSET		6
-#define HPIPE_MISC_TXDCLK_2X_MASK		\
-	(0x1 << HPIPE_MISC_TXDCLK_2X_OFFSET)
-#define HPIPE_MISC_CLK500_EN_OFFSET		7
-#define HPIPE_MISC_CLK500_EN_MASK		\
-	(0x1 << HPIPE_MISC_CLK500_EN_OFFSET)
-#define HPIPE_MISC_REFCLK_SEL_OFFSET		10
-#define HPIPE_MISC_REFCLK_SEL_MASK		\
-	(0x1 << HPIPE_MISC_REFCLK_SEL_OFFSET)
-
-#define HPIPE_RX_CONTROL_1_REG			0x140
-#define HPIPE_RX_CONTROL_1_RXCLK2X_SEL_OFFSET	11
-#define HPIPE_RX_CONTROL_1_RXCLK2X_SEL_MASK	\
-	(0x1 << HPIPE_RX_CONTROL_1_RXCLK2X_SEL_OFFSET)
-#define HPIPE_RX_CONTROL_1_CLK8T_EN_OFFSET	12
-#define HPIPE_RX_CONTROL_1_CLK8T_EN_MASK	\
-	(0x1 << HPIPE_RX_CONTROL_1_CLK8T_EN_OFFSET)
-
-#define HPIPE_PWR_CTR_REG			0x148
-#define HPIPE_PWR_CTR_RST_DFE_OFFSET		0
-#define HPIPE_PWR_CTR_RST_DFE_MASK		\
-	(0x1 << HPIPE_PWR_CTR_RST_DFE_OFFSET)
-#define HPIPE_PWR_CTR_SFT_RST_OFFSET		10
-#define HPIPE_PWR_CTR_SFT_RST_MASK		\
-	(0x1 << HPIPE_PWR_CTR_SFT_RST_OFFSET)
-
-#define HPIPE_SPD_DIV_FORCE_REG				0x154
-#define HPIPE_TXDIGCK_DIV_FORCE_OFFSET			7
-#define HPIPE_TXDIGCK_DIV_FORCE_MASK			\
-	(0x1 << HPIPE_TXDIGCK_DIV_FORCE_OFFSET)
-#define HPIPE_SPD_DIV_FORCE_RX_SPD_DIV_OFFSET		8
-#define HPIPE_SPD_DIV_FORCE_RX_SPD_DIV_MASK		\
-	(0x3 << HPIPE_SPD_DIV_FORCE_RX_SPD_DIV_OFFSET)
-#define HPIPE_SPD_DIV_FORCE_RX_SPD_DIV_FORCE_OFFSET	10
-#define HPIPE_SPD_DIV_FORCE_RX_SPD_DIV_FORCE_MASK	\
-	(0x1 << HPIPE_SPD_DIV_FORCE_RX_SPD_DIV_FORCE_OFFSET)
-#define HPIPE_SPD_DIV_FORCE_TX_SPD_DIV_OFFSET		13
-#define HPIPE_SPD_DIV_FORCE_TX_SPD_DIV_MASK		\
-	(0x3 << HPIPE_SPD_DIV_FORCE_TX_SPD_DIV_OFFSET)
-#define HPIPE_SPD_DIV_FORCE_TX_SPD_DIV_FORCE_OFFSET	15
-#define HPIPE_SPD_DIV_FORCE_TX_SPD_DIV_FORCE_MASK	\
-	(0x1 << HPIPE_SPD_DIV_FORCE_TX_SPD_DIV_FORCE_OFFSET)
-
-#define HPIPE_PLLINTP_REG1			0x150
-
-#define HPIPE_SAMPLER_N_PROC_CALIB_CTRL_REG	0x16C
-#define HPIPE_RX_SAMPLER_OS_GAIN_OFFSET		6
-#define HPIPE_RX_SAMPLER_OS_GAIN_MASK		\
-	(0x3 << HPIPE_RX_SAMPLER_OS_GAIN_OFFSET)
-#define HPIPE_SMAPLER_OFFSET			12
-#define HPIPE_SMAPLER_MASK			\
-	(0x1 << HPIPE_SMAPLER_OFFSET)
-
-#define HPIPE_TX_REG1_REG			0x174
-#define HPIPE_TX_REG1_TX_EMPH_RES_OFFSET	5
-#define HPIPE_TX_REG1_TX_EMPH_RES_MASK		\
-	(0x3 << HPIPE_TX_REG1_TX_EMPH_RES_OFFSET)
-#define HPIPE_TX_REG1_SLC_EN_OFFSET		10
-#define HPIPE_TX_REG1_SLC_EN_MASK		\
-	(0x3f << HPIPE_TX_REG1_SLC_EN_OFFSET)
-
-#define HPIPE_PWR_CTR_DTL_REG				0x184
-#define HPIPE_PWR_CTR_DTL_SQ_DET_EN_OFFSET		0
-#define HPIPE_PWR_CTR_DTL_SQ_DET_EN_MASK		\
-	(0x1 << HPIPE_PWR_CTR_DTL_SQ_DET_EN_OFFSET)
-#define HPIPE_PWR_CTR_DTL_SQ_PLOOP_EN_OFFSET		1
-#define HPIPE_PWR_CTR_DTL_SQ_PLOOP_EN_MASK		\
-	(0x1 << HPIPE_PWR_CTR_DTL_SQ_PLOOP_EN_OFFSET)
-#define HPIPE_PWR_CTR_DTL_FLOOP_EN_OFFSET		2
-#define HPIPE_PWR_CTR_DTL_FLOOP_EN_MASK			\
-	(0x1 << HPIPE_PWR_CTR_DTL_FLOOP_EN_OFFSET)
-#define HPIPE_PWR_CTR_DTL_CLAMPING_SEL_OFFSET		4
-#define HPIPE_PWR_CTR_DTL_CLAMPING_SEL_MASK		\
-	(0x7 << HPIPE_PWR_CTR_DTL_CLAMPING_SEL_OFFSET)
-#define HPIPE_PWR_CTR_DTL_INTPCLK_DIV_FORCE_OFFSET	10
-#define HPIPE_PWR_CTR_DTL_INTPCLK_DIV_FORCE_MASK	\
-	(0x1 << HPIPE_PWR_CTR_DTL_INTPCLK_DIV_FORCE_OFFSET)
-#define HPIPE_PWR_CTR_DTL_CLK_MODE_OFFSET		12
-#define HPIPE_PWR_CTR_DTL_CLK_MODE_MASK			\
-	(0x3 << HPIPE_PWR_CTR_DTL_CLK_MODE_OFFSET)
-#define HPIPE_PWR_CTR_DTL_CLK_MODE_FORCE_OFFSET		14
-#define HPIPE_PWR_CTR_DTL_CLK_MODE_FORCE_MASK		\
-	(1 << HPIPE_PWR_CTR_DTL_CLK_MODE_FORCE_OFFSET)
-
-#define HPIPE_PHASE_CONTROL_REG			0x188
-#define HPIPE_OS_PH_OFFSET_OFFSET		0
-#define HPIPE_OS_PH_OFFSET_MASK			\
-	(0x7f << HPIPE_OS_PH_OFFSET_OFFSET)
-#define HPIPE_OS_PH_OFFSET_FORCE_OFFSET		7
-#define HPIPE_OS_PH_OFFSET_FORCE_MASK		\
-	(0x1 << HPIPE_OS_PH_OFFSET_FORCE_OFFSET)
-#define HPIPE_OS_PH_VALID_OFFSET		8
-#define HPIPE_OS_PH_VALID_MASK			\
-	(0x1 << HPIPE_OS_PH_VALID_OFFSET)
-
-#define HPIPE_FRAME_DETECT_CTRL_0_REG			0x214
-#define HPIPE_TRAIN_PAT_NUM_OFFSET			0x7
-#define HPIPE_TRAIN_PAT_NUM_MASK			\
-	(0x1FF << HPIPE_TRAIN_PAT_NUM_OFFSET)
-
-#define HPIPE_FRAME_DETECT_CTRL_3_REG			0x220
-#define HPIPE_PATTERN_LOCK_LOST_TIMEOUT_EN_OFFSET	12
-#define HPIPE_PATTERN_LOCK_LOST_TIMEOUT_EN_MASK		\
-	(0x1 << HPIPE_PATTERN_LOCK_LOST_TIMEOUT_EN_OFFSET)
-
-#define HPIPE_DME_REG					0x228
-#define HPIPE_DME_ETHERNET_MODE_OFFSET			7
-#define HPIPE_DME_ETHERNET_MODE_MASK			\
-	(0x1 << HPIPE_DME_ETHERNET_MODE_OFFSET)
-
-#define HPIPE_TX_TRAIN_CTRL_0_REG		0x268
-#define HPIPE_TX_TRAIN_P2P_HOLD_OFFSET		15
-#define HPIPE_TX_TRAIN_P2P_HOLD_MASK		\
-	(0x1 << HPIPE_TX_TRAIN_P2P_HOLD_OFFSET)
-
-#define HPIPE_TX_TRAIN_CTRL_REG			0x26C
-#define HPIPE_TX_TRAIN_CTRL_G1_OFFSET		0
-#define HPIPE_TX_TRAIN_CTRL_G1_MASK		\
-	(0x1 << HPIPE_TX_TRAIN_CTRL_G1_OFFSET)
-#define HPIPE_TX_TRAIN_CTRL_GN1_OFFSET		1
-#define HPIPE_TX_TRAIN_CTRL_GN1_MASK		\
-	(0x1 << HPIPE_TX_TRAIN_CTRL_GN1_OFFSET)
-#define HPIPE_TX_TRAIN_CTRL_G0_OFFSET		2
-#define HPIPE_TX_TRAIN_CTRL_G0_MASK		\
-	(0x1 << HPIPE_TX_TRAIN_CTRL_G0_OFFSET)
-
-#define HPIPE_TX_TRAIN_CTRL_4_REG		0x278
-#define HPIPE_TRX_TRAIN_TIMER_OFFSET		0
-#define HPIPE_TRX_TRAIN_TIMER_MASK		\
-	(0x3FF << HPIPE_TRX_TRAIN_TIMER_OFFSET)
-
-#define HPIPE_PCIE_REG1				0x288
-#define HPIPE_PCIE_REG3				0x290
-
-#define HPIPE_TX_TRAIN_CTRL_5_REG		0x2A4
-#define HPIPE_RX_TRAIN_TIMER_OFFSET		0
-#define HPIPE_RX_TRAIN_TIMER_MASK		\
-	(0x3ff << HPIPE_RX_TRAIN_TIMER_OFFSET)
-#define HPIPE_TX_TRAIN_START_SQ_EN_OFFSET	11
-#define HPIPE_TX_TRAIN_START_SQ_EN_MASK		\
-	(0x1 << HPIPE_TX_TRAIN_START_SQ_EN_OFFSET)
-#define HPIPE_TX_TRAIN_START_FRM_DET_EN_OFFSET	12
-#define HPIPE_TX_TRAIN_START_FRM_DET_EN_MASK	\
-	(0x1 << HPIPE_TX_TRAIN_START_FRM_DET_EN_OFFSET)
-#define HPIPE_TX_TRAIN_START_FRM_LOCK_EN_OFFSET	13
-#define HPIPE_TX_TRAIN_START_FRM_LOCK_EN_MASK	\
-	(0x1 << HPIPE_TX_TRAIN_START_FRM_LOCK_EN_OFFSET)
-#define HPIPE_TX_TRAIN_WAIT_TIME_EN_OFFSET	14
-#define HPIPE_TX_TRAIN_WAIT_TIME_EN_MASK	\
-	(0x1 << HPIPE_TX_TRAIN_WAIT_TIME_EN_OFFSET)
-
-#define HPIPE_TX_TRAIN_REG			0x31C
-#define HPIPE_TX_TRAIN_CHK_INIT_OFFSET		4
-#define HPIPE_TX_TRAIN_CHK_INIT_MASK		\
-	(0x1 << HPIPE_TX_TRAIN_CHK_INIT_OFFSET)
-#define HPIPE_TX_TRAIN_COE_FM_PIN_PCIE3_OFFSET	7
-#define HPIPE_TX_TRAIN_COE_FM_PIN_PCIE3_MASK	\
-	(0x1 << HPIPE_TX_TRAIN_COE_FM_PIN_PCIE3_OFFSET)
-#define HPIPE_TX_TRAIN_16BIT_AUTO_EN_OFFSET	8
-#define HPIPE_TX_TRAIN_16BIT_AUTO_EN_MASK	\
-	(0x1 << HPIPE_TX_TRAIN_16BIT_AUTO_EN_OFFSET)
-#define HPIPE_TX_TRAIN_PAT_SEL_OFFSET		9
-#define HPIPE_TX_TRAIN_PAT_SEL_MASK		\
-	(0x1 << HPIPE_TX_TRAIN_PAT_SEL_OFFSET)
-
-#define HPIPE_CDR_CONTROL_REG			0x418
-#define HPIPE_CDR_RX_MAX_DFE_ADAPT_1_OFFSET	12
-#define HPIPE_CDR_RX_MAX_DFE_ADAPT_1_MASK	\
-	(0x3 << HPIPE_CDR_RX_MAX_DFE_ADAPT_1_OFFSET)
-#define HPIPE_CDR_MAX_DFE_ADAPT_0_OFFSET	9
-#define HPIPE_CDR_MAX_DFE_ADAPT_0_MASK		\
-	(0x7 << HPIPE_CDR_MAX_DFE_ADAPT_0_OFFSET)
-#define HPIPE_CDR_MAX_DFE_ADAPT_1_OFFSET	6
-#define HPIPE_CDR_MAX_DFE_ADAPT_1_MASK		\
-	(0x7 << HPIPE_CDR_MAX_DFE_ADAPT_1_OFFSET)
-
-#define HPIPE_TX_TRAIN_CTRL_11_REG		0x438
-#define HPIPE_TX_STATUS_CHECK_MODE_OFFSET	6
-#define HPIPE_TX_TX_STATUS_CHECK_MODE_MASK	\
-	(0x1 << HPIPE_TX_STATUS_CHECK_MODE_OFFSET)
-#define HPIPE_TX_NUM_OF_PRESET_OFFSET		10
-#define HPIPE_TX_NUM_OF_PRESET_MASK		\
-	(0x7 << HPIPE_TX_NUM_OF_PRESET_OFFSET)
-#define HPIPE_TX_SWEEP_PRESET_EN_OFFSET		15
-#define HPIPE_TX_SWEEP_PRESET_EN_MASK		\
-	(0x1 << HPIPE_TX_SWEEP_PRESET_EN_OFFSET)
-
-#define HPIPE_G1_SETTINGS_3_REG				0x440
-#define HPIPE_G1_SETTINGS_3_G1_FFE_CAP_SEL_OFFSET	0
-#define HPIPE_G1_SETTINGS_3_G1_FFE_CAP_SEL_MASK		\
-	(0xf << HPIPE_G1_SETTINGS_3_G1_FFE_CAP_SEL_OFFSET)
-#define HPIPE_G1_SETTINGS_3_G1_FFE_RES_SEL_OFFSET	4
-#define HPIPE_G1_SETTINGS_3_G1_FFE_RES_SEL_MASK		\
-	(0x7 << HPIPE_G1_SETTINGS_3_G1_FFE_RES_SEL_OFFSET)
-#define HPIPE_G1_SETTINGS_3_G1_FFE_SETTING_FORCE_OFFSET	7
-#define HPIPE_G1_SETTINGS_3_G1_FFE_SETTING_FORCE_MASK	\
-	(0x1 << HPIPE_G1_SETTINGS_3_G1_FFE_SETTING_FORCE_OFFSET)
-#define HPIPE_G1_SETTINGS_3_G1_FBCK_SEL_OFFSET		9
-#define HPIPE_G1_SETTINGS_3_G1_FBCK_SEL_MASK		\
-	(0x1 << HPIPE_G1_SETTINGS_3_G1_FBCK_SEL_OFFSET)
-#define HPIPE_G1_SETTINGS_3_G1_FFE_DEG_RES_LEVEL_OFFSET	12
-#define HPIPE_G1_SETTINGS_3_G1_FFE_DEG_RES_LEVEL_MASK	\
-	(0x3 << HPIPE_G1_SETTINGS_3_G1_FFE_DEG_RES_LEVEL_OFFSET)
-#define HPIPE_G1_SETTINGS_3_G1_FFE_LOAD_RES_LEVEL_OFFSET	14
-#define HPIPE_G1_SETTINGS_3_G1_FFE_LOAD_RES_LEVEL_MASK	\
-	(0x3 << HPIPE_G1_SETTINGS_3_G1_FFE_LOAD_RES_LEVEL_OFFSET)
-
-#define HPIPE_G1_SETTINGS_4_REG			0x444
-#define HPIPE_G1_SETTINGS_4_G1_DFE_RES_OFFSET	8
-#define HPIPE_G1_SETTINGS_4_G1_DFE_RES_MASK	\
-	(0x3 << HPIPE_G1_SETTINGS_4_G1_DFE_RES_OFFSET)
-
-#define HPIPE_G2_SETTINGS_3_REG			0x448
-
-#define HPIPE_G2_SETTINGS_4_REG			0x44c
-#define HPIPE_G2_DFE_RES_OFFSET			8
-#define HPIPE_G2_DFE_RES_MASK			\
-	(0x3 << HPIPE_G2_DFE_RES_OFFSET)
-
-#define HPIPE_G3_SETTING_3_REG			0x450
-#define HPIPE_G3_FFE_CAP_SEL_OFFSET		0
-#define HPIPE_G3_FFE_CAP_SEL_MASK		\
-	(0xf << HPIPE_G3_FFE_CAP_SEL_OFFSET)
-#define HPIPE_G3_FFE_RES_SEL_OFFSET		4
-#define HPIPE_G3_FFE_RES_SEL_MASK		\
-	(0x7 << HPIPE_G3_FFE_RES_SEL_OFFSET)
-#define HPIPE_G3_FFE_SETTING_FORCE_OFFSET	7
-#define HPIPE_G3_FFE_SETTING_FORCE_MASK		\
-	(0x1 << HPIPE_G3_FFE_SETTING_FORCE_OFFSET)
-#define HPIPE_G3_FFE_DEG_RES_LEVEL_OFFSET	12
-#define HPIPE_G3_FFE_DEG_RES_LEVEL_MASK		\
-	(0x3 << HPIPE_G3_FFE_DEG_RES_LEVEL_OFFSET)
-#define HPIPE_G3_FFE_LOAD_RES_LEVEL_OFFSET	14
-#define HPIPE_G3_FFE_LOAD_RES_LEVEL_MASK	\
-	(0x3 << HPIPE_G3_FFE_LOAD_RES_LEVEL_OFFSET)
-
-#define HPIPE_G3_SETTING_4_REG			0x454
-#define HPIPE_G3_DFE_RES_OFFSET			8
-#define HPIPE_G3_DFE_RES_MASK			\
-	(0x3 << HPIPE_G3_DFE_RES_OFFSET)
-
-#define HPIPE_TX_PRESET_INDEX_REG		0x468
-#define HPIPE_TX_PRESET_INDEX_OFFSET		0
-#define HPIPE_TX_PRESET_INDEX_MASK		\
-	(0xf << HPIPE_TX_PRESET_INDEX_OFFSET)
-
-#define HPIPE_DFE_CONTROL_REG			0x470
-#define HPIPE_DFE_TX_MAX_DFE_ADAPT_OFFSET	14
-#define HPIPE_DFE_TX_MAX_DFE_ADAPT_MASK		\
-	(0x3 << HPIPE_DFE_TX_MAX_DFE_ADAPT_OFFSET)
-
-#define HPIPE_DFE_CTRL_28_REG			0x49C
-#define HPIPE_DFE_CTRL_28_PIPE4_OFFSET		7
-#define HPIPE_DFE_CTRL_28_PIPE4_MASK		\
-	(0x1 << HPIPE_DFE_CTRL_28_PIPE4_OFFSET)
-
-#define HPIPE_G1_SETTING_5_REG			0x538
-#define HPIPE_G1_SETTING_5_G1_ICP_OFFSET	0
-#define HPIPE_G1_SETTING_5_G1_ICP_MASK		\
-	(0xf << HPIPE_G1_SETTING_5_G1_ICP_OFFSET)
-
-#define HPIPE_G3_SETTING_5_REG			0x548
-#define HPIPE_G3_SETTING_5_G3_ICP_OFFSET	0
-#define HPIPE_G3_SETTING_5_G3_ICP_MASK		\
-	(0xf << HPIPE_G3_SETTING_5_G3_ICP_OFFSET)
-
-#define HPIPE_LANE_CONFIG0_REG			0x600
-#define HPIPE_LANE_CONFIG0_TXDEEMPH0_OFFSET	0
-#define HPIPE_LANE_CONFIG0_TXDEEMPH0_MASK	\
-	(0x1 << HPIPE_LANE_CONFIG0_TXDEEMPH0_OFFSET)
-
-#define HPIPE_LANE_CONFIG1_REG			0x604
-#define HPIPE_LANE_CONFIG1_MAX_PLL_OFFSET	9
-#define HPIPE_LANE_CONFIG1_MAX_PLL_MASK		\
-	(0x1 << HPIPE_LANE_CONFIG1_MAX_PLL_OFFSET)
-#define HPIPE_LANE_CONFIG1_GEN2_PLL_OFFSET	10
-#define HPIPE_LANE_CONFIG1_GEN2_PLL_MASK	\
-	(0x1 << HPIPE_LANE_CONFIG1_GEN2_PLL_OFFSET)
-
-#define HPIPE_LANE_STATUS1_REG			0x60C
-#define HPIPE_LANE_STATUS1_PCLK_EN_OFFSET	0
-#define HPIPE_LANE_STATUS1_PCLK_EN_MASK		\
-	(0x1 << HPIPE_LANE_STATUS1_PCLK_EN_OFFSET)
-
-#define HPIPE_LANE_CFG4_REG                     0x620
-#define HPIPE_LANE_CFG4_DFE_CTRL_OFFSET		0
-#define HPIPE_LANE_CFG4_DFE_CTRL_MASK		\
-	(0x7 << HPIPE_LANE_CFG4_DFE_CTRL_OFFSET)
-#define HPIPE_LANE_CFG4_DFE_EN_SEL_OFFSET	3
-#define HPIPE_LANE_CFG4_DFE_EN_SEL_MASK		\
-	(0x1 << HPIPE_LANE_CFG4_DFE_EN_SEL_OFFSET)
-#define HPIPE_LANE_CFG4_DFE_OVER_OFFSET		6
-#define HPIPE_LANE_CFG4_DFE_OVER_MASK		\
-	(0x1 << HPIPE_LANE_CFG4_DFE_OVER_OFFSET)
-#define HPIPE_LANE_CFG4_SSC_CTRL_OFFSET		7
-#define HPIPE_LANE_CFG4_SSC_CTRL_MASK		\
-	(0x1 << HPIPE_LANE_CFG4_SSC_CTRL_OFFSET)
-
-#define HPIPE_LANE_EQU_CONFIG_0_REG		0x69C
-#define HPIPE_CFG_PHY_RC_EP_OFFSET		12
-#define HPIPE_CFG_PHY_RC_EP_MASK		\
-	(0x1 << HPIPE_CFG_PHY_RC_EP_OFFSET)
-
-#define HPIPE_LANE_EQ_CFG1_REG			0x6a0
-#define HPIPE_CFG_UPDATE_POLARITY_OFFSET	12
-#define HPIPE_CFG_UPDATE_POLARITY_MASK		\
-	(0x1 << HPIPE_CFG_UPDATE_POLARITY_OFFSET)
-
-#define HPIPE_LANE_EQ_REMOTE_SETTING_REG	0x6f8
-#define HPIPE_LANE_CFG_FOM_DIRN_OVERRIDE_OFFSET	0
-#define HPIPE_LANE_CFG_FOM_DIRN_OVERRIDE_MASK	\
-	(0x1 << HPIPE_LANE_CFG_FOM_DIRN_OVERRIDE_OFFSET)
-#define HPIPE_LANE_CFG_FOM_ONLY_MODE_OFFFSET	1
-#define HPIPE_LANE_CFG_FOM_ONLY_MODE_MASK	\
-	(0x1 << HPIPE_LANE_CFG_FOM_ONLY_MODE_OFFFSET)
-#define HPIPE_LANE_CFG_FOM_PRESET_VECTOR_OFFSET	2
-#define HPIPE_LANE_CFG_FOM_PRESET_VECTOR_MASK	\
-	(0xf << HPIPE_LANE_CFG_FOM_PRESET_VECTOR_OFFSET)
-
-#define HPIPE_RST_CLK_CTRL_REG			0x704
-#define HPIPE_RST_CLK_CTRL_PIPE_RST_OFFSET	0
-#define HPIPE_RST_CLK_CTRL_PIPE_RST_MASK	\
-	(0x1 << HPIPE_RST_CLK_CTRL_PIPE_RST_OFFSET)
-#define HPIPE_RST_CLK_CTRL_FIXED_PCLK_OFFSET	2
-#define HPIPE_RST_CLK_CTRL_FIXED_PCLK_MASK	\
-	(0x1 << HPIPE_RST_CLK_CTRL_FIXED_PCLK_OFFSET)
-#define HPIPE_RST_CLK_CTRL_PIPE_WIDTH_OFFSET	3
-#define HPIPE_RST_CLK_CTRL_PIPE_WIDTH_MASK	\
-	(0x1 << HPIPE_RST_CLK_CTRL_PIPE_WIDTH_OFFSET)
-#define HPIPE_RST_CLK_CTRL_CORE_FREQ_SEL_OFFSET	9
-#define HPIPE_RST_CLK_CTRL_CORE_FREQ_SEL_MASK	\
-	(0x1 << HPIPE_RST_CLK_CTRL_CORE_FREQ_SEL_OFFSET)
-
-#define HPIPE_TST_MODE_CTRL_REG			0x708
-#define HPIPE_TST_MODE_CTRL_MODE_MARGIN_OFFSET	2
-#define HPIPE_TST_MODE_CTRL_MODE_MARGIN_MASK	\
-	(0x1 << HPIPE_TST_MODE_CTRL_MODE_MARGIN_OFFSET)
-
-#define HPIPE_CLK_SRC_LO_REG			0x70c
-#define HPIPE_CLK_SRC_LO_BUNDLE_PERIOD_SEL_OFFSET 1
-#define HPIPE_CLK_SRC_LO_BUNDLE_PERIOD_SEL_MASK	\
-	(0x1 << HPIPE_CLK_SRC_LO_BUNDLE_PERIOD_SEL_OFFSET)
-#define HPIPE_CLK_SRC_LO_BUNDLE_PERIOD_SCALE_OFFSET 2
-#define HPIPE_CLK_SRC_LO_BUNDLE_PERIOD_SCALE_MASK \
-	(0x3 << HPIPE_CLK_SRC_LO_BUNDLE_PERIOD_SCALE_OFFSET)
-#define HPIPE_CLK_SRC_LO_PLL_RDY_DL_OFFSET	5
-#define HPIPE_CLK_SRC_LO_PLL_RDY_DL_MASK	\
-	(0x7 << HPIPE_CLK_SRC_LO_PLL_RDY_DL_OFFSET)
-
-#define HPIPE_CLK_SRC_HI_REG			0x710
-#define HPIPE_CLK_SRC_HI_LANE_STRT_OFFSET	0
-#define HPIPE_CLK_SRC_HI_LANE_STRT_MASK		\
-	(0x1 << HPIPE_CLK_SRC_HI_LANE_STRT_OFFSET)
-#define HPIPE_CLK_SRC_HI_LANE_BREAK_OFFSET	1
-#define HPIPE_CLK_SRC_HI_LANE_BREAK_MASK	\
-	(0x1 << HPIPE_CLK_SRC_HI_LANE_BREAK_OFFSET)
-#define HPIPE_CLK_SRC_HI_LANE_MASTER_OFFSET	2
-#define HPIPE_CLK_SRC_HI_LANE_MASTER_MASK	\
-	(0x1 << HPIPE_CLK_SRC_HI_LANE_MASTER_OFFSET)
-#define HPIPE_CLK_SRC_HI_MODE_PIPE_OFFSET	7
-#define HPIPE_CLK_SRC_HI_MODE_PIPE_MASK		\
-	(0x1 << HPIPE_CLK_SRC_HI_MODE_PIPE_OFFSET)
-
-#define HPIPE_GLOBAL_MISC_CTRL                  0x718
-#define HPIPE_GLOBAL_PM_CTRL                    0x740
-#define HPIPE_GLOBAL_PM_RXDLOZ_WAIT_OFFSET	0
-#define HPIPE_GLOBAL_PM_RXDLOZ_WAIT_MASK	\
-	(0xFF << HPIPE_GLOBAL_PM_RXDLOZ_WAIT_OFFSET)
-
-#endif /* _COMPHY_HPIPE_H_ */
-
diff --git a/drivers/phy/marvell/comphy_mux.c b/drivers/phy/marvell/comphy_mux.c
deleted file mode 100644
index b036fb1..0000000
--- a/drivers/phy/marvell/comphy_mux.c
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * Copyright (C) 2015-2016 Marvell International Ltd.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#include <common.h>
-#include <asm/io.h>
-
-#include "comphy.h"
-#include "comphy_hpipe.h"
-
-/*
- * comphy_mux_check_config()
- * description: this function passes over the COMPHY lanes and check if the type
- *              is valid for specific lane. If the type is not valid,
- *              the function update the struct and set the type of the lane as
- *              PHY_TYPE_UNCONNECTED
- */
-static void comphy_mux_check_config(struct comphy_mux_data *mux_data,
-		struct comphy_map *comphy_map_data, int comphy_max_lanes)
-{
-	struct comphy_mux_options *mux_opt;
-	int lane, opt, valid;
-
-	debug_enter();
-
-	for (lane = 0; lane < comphy_max_lanes;
-	     lane++, comphy_map_data++, mux_data++) {
-		/* Don't check ignored COMPHYs */
-		if (comphy_map_data->type == PHY_TYPE_IGNORE)
-			continue;
-
-		mux_opt = mux_data->mux_values;
-		for (opt = 0, valid = 0; opt < mux_data->max_lane_values;
-		     opt++, mux_opt++) {
-			if (mux_opt->type == comphy_map_data->type) {
-				valid = 1;
-				break;
-			}
-		}
-		if (valid == 0) {
-			debug("lane number %d, had invalid type %d\n",
-			      lane, comphy_map_data->type);
-			debug("set lane %d as type %d\n", lane,
-			      PHY_TYPE_UNCONNECTED);
-			comphy_map_data->type = PHY_TYPE_UNCONNECTED;
-		} else {
-			debug("lane number %d, has type %d\n",
-			      lane, comphy_map_data->type);
-		}
-	}
-
-	debug_exit();
-}
-
-static u32 comphy_mux_get_mux_value(struct comphy_mux_data *mux_data,
-				    u32 type, int lane)
-{
-	struct comphy_mux_options *mux_opt;
-	int opt;
-	u32 value = 0;
-
-	debug_enter();
-
-	mux_opt = mux_data->mux_values;
-	for (opt = 0 ; opt < mux_data->max_lane_values; opt++, mux_opt++) {
-		if (mux_opt->type == type) {
-			value = mux_opt->mux_value;
-			break;
-		}
-	}
-
-	debug_exit();
-
-	return value;
-}
-
-static void comphy_mux_reg_write(struct comphy_mux_data *mux_data,
-				 struct comphy_map *comphy_map_data,
-				 int comphy_max_lanes,
-				 void __iomem *selector_base, u32 bitcount)
-{
-	u32 lane, value, offset, mask;
-
-	debug_enter();
-
-	for (lane = 0; lane < comphy_max_lanes;
-	     lane++, comphy_map_data++, mux_data++) {
-		if (comphy_map_data->type == PHY_TYPE_IGNORE)
-			continue;
-
-		offset = lane * bitcount;
-		mask = (((1 << bitcount) - 1) << offset);
-		value = (comphy_mux_get_mux_value(mux_data,
-						  comphy_map_data->type,
-						  lane) << offset);
-		reg_set(selector_base, value, mask);
-	}
-
-	debug_exit();
-}
-
-void comphy_mux_init(struct chip_serdes_phy_config *chip_cfg,
-		     struct comphy_map *comphy_map_data,
-		     void __iomem *selector_base)
-{
-	struct comphy_mux_data *mux_data;
-	u32 mux_bitcount;
-	u32 comphy_max_lanes;
-
-	debug_enter();
-
-	comphy_max_lanes = chip_cfg->comphy_lanes_count;
-	mux_data = chip_cfg->mux_data;
-	mux_bitcount = chip_cfg->comphy_mux_bitcount;
-
-	/* check if the configuration is valid */
-	comphy_mux_check_config(mux_data, comphy_map_data, comphy_max_lanes);
-	/* Init COMPHY selectors */
-	comphy_mux_reg_write(mux_data, comphy_map_data, comphy_max_lanes,
-			     selector_base, mux_bitcount);
-
-	debug_exit();
-}
diff --git a/drivers/phy/marvell/comphy_priv.h b/drivers/phy/marvell/comphy_priv.h
new file mode 100644
index 0000000..edb3b1e
--- /dev/null
+++ b/drivers/phy/marvell/comphy_priv.h
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2015-2016 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _COMPHY_PRIV_H_
+#define _COMPHY_PRIV_H_
+
+#include <dt-bindings/comphy/comphy_data.h>
+#include <fdtdec.h>
+
+#if defined(DEBUG)
+#define debug_enter()	{ printf("----> Enter %s\n", __func__); }
+#define debug_exit()	{ printf("<---- Exit  %s\n", __func__); }
+#else
+#define debug_enter()
+#define debug_exit()
+#endif
+
+
+#define MAX_LANE_OPTIONS			10
+#define MAX_UTMI_PHY_COUNT			6
+
+struct comphy_map {
+	u32 type;
+	u32 speed;
+	u32 invert;
+	bool clk_src;
+	bool end_point;
+};
+
+struct chip_serdes_phy_config {
+	int (*ptr_comphy_chip_init)(struct chip_serdes_phy_config *,
+				    struct comphy_map *);
+	int (*rx_training)(struct chip_serdes_phy_config *, u32);
+	void __iomem *comphy_base_addr;
+	void __iomem *hpipe3_base_addr;
+	u32 comphy_lanes_count;
+	u32 comphy_mux_bitcount;
+	u32 cp_index;
+	struct comphy_map comphy_map_data[MAX_LANE_OPTIONS];
+};
+
+/* Register helper functions */
+void reg_set(void __iomem *addr, u32 data, u32 mask);
+void reg_set_silent(void __iomem *addr, u32 data, u32 mask);
+void reg_set16(void __iomem *addr, u16 data, u16 mask);
+void reg_set_silent16(void __iomem *addr, u16 data, u16 mask);
+
+/* SoC specific init functions */
+#ifdef CONFIG_ARMADA_3700
+int comphy_a3700_init(struct chip_serdes_phy_config *ptr_chip_cfg,
+		      struct comphy_map *serdes_map);
+#else
+static inline int comphy_a3700_init(struct chip_serdes_phy_config *ptr_chip_cfg,
+				    struct comphy_map *serdes_map)
+{
+	/*
+	 * This function should never be called in this configuration, so
+	 * lets return an error here.
+	 */
+	return -1;
+}
+#endif
+
+#ifdef CONFIG_ARMADA_8K
+int comphy_cp110_init(struct chip_serdes_phy_config *ptr_chip_cfg,
+		      struct comphy_map *serdes_map);
+int comphy_cp110_sfi_rx_training(struct chip_serdes_phy_config *ptr_chip_cfg,
+				 u32 lane);
+
+#else
+static inline int comphy_cp110_init(struct chip_serdes_phy_config *ptr_chip_cfg,
+				    struct comphy_map *serdes_map)
+{
+	/*
+	 * This function should never be called in this configuration, so
+	 * lets return an error here.
+	 */
+	return -1;
+}
+
+static inline int comphy_cp110_sfi_rx_training(
+	struct chip_serdes_phy_config *ptr_chip_cfg,
+	u32 lane)
+{
+	/*
+	 * This function should never be called in this configuration, so
+	 * lets return an error here.
+	 */
+	return -1;
+}
+
+#endif
+
+void comphy_dedicated_phys_init(void);
+
+/* MUX function */
+void comphy_mux_init(struct chip_serdes_phy_config *ptr_chip_cfg,
+		     struct comphy_map *comphy_map_data,
+		     void __iomem *selector_base);
+
+void comphy_pcie_config_set(u32 comphy_max_count,
+			    struct comphy_map *serdes_map);
+void comphy_pcie_config_detect(u32 comphy_max_count,
+			       struct comphy_map *serdes_map);
+void comphy_pcie_unit_general_config(u32 pex_index);
+
+#endif /* _COMPHY_PRIV_H_ */
+
diff --git a/drivers/phy/marvell/utmi_phy.h b/drivers/phy/marvell/utmi_phy.h
index 01e53ba..313b843 100644
--- a/drivers/phy/marvell/utmi_phy.h
+++ b/drivers/phy/marvell/utmi_phy.h
@@ -21,6 +21,7 @@
 #define UTMI_PHY_CFG_PU_MASK			\
 	(0x1 << UTMI_PHY_CFG_PU_OFFSET)
 
+/* PLL and Calibration register are common for both UTMI ports */
 #define UTMI_PLL_CTRL_REG			0x0
 #define UTMI_PLL_CTRL_REFDIV_OFFSET		0
 #define UTMI_PLL_CTRL_REFDIV_MASK		\
@@ -39,6 +40,12 @@
 #define UTMI_CALIB_CTRL_IMPCAL_VTH_OFFSET	8
 #define UTMI_CALIB_CTRL_IMPCAL_VTH_MASK		\
 	(0x7 << UTMI_CALIB_CTRL_IMPCAL_VTH_OFFSET)
+#define UTMI_CALIB_CTRL_IMPCAL_START_OFFSET	13
+#define UTMI_CALIB_CTRL_IMPCAL_START_MASK	\
+	(0x1 << UTMI_CALIB_CTRL_IMPCAL_START_OFFSET)
+#define UTMI_CALIB_CTRL_PLLCAL_START_OFFSET	22
+#define UTMI_CALIB_CTRL_PLLCAL_START_MASK	\
+	(0x1 << UTMI_CALIB_CTRL_PLLCAL_START_OFFSET)
 #define UTMI_CALIB_CTRL_IMPCAL_DONE_OFFSET	23
 #define UTMI_CALIB_CTRL_IMPCAL_DONE_MASK	\
 	(0x1 << UTMI_CALIB_CTRL_IMPCAL_DONE_OFFSET)
@@ -46,15 +53,25 @@
 #define UTMI_CALIB_CTRL_PLLCAL_DONE_MASK	\
 	(0x1 << UTMI_CALIB_CTRL_PLLCAL_DONE_OFFSET)
 
-#define UTMI_TX_CH_CTRL_REG			0xC
+/* NOTE: all bellow are register used per UTMI port, which base address is
+ * 058x00C, so bellow offset may be misleading. E.g UTMI_TX_CH_CTRL_REG refers
+ * to 0x58x00c, UTMI_RX_CH_CTRL0_REG refers to 0x58x014 etc.
+ */
+#define UTMI_TX_CH_CTRL_REG			0x0
 #define UTMI_TX_CH_CTRL_DRV_EN_LS_OFFSET	12
 #define UTMI_TX_CH_CTRL_DRV_EN_LS_MASK		\
 	(0xf << UTMI_TX_CH_CTRL_DRV_EN_LS_OFFSET)
 #define UTMI_TX_CH_CTRL_IMP_SEL_LS_OFFSET	16
 #define UTMI_TX_CH_CTRL_IMP_SEL_LS_MASK		\
 	(0xf << UTMI_TX_CH_CTRL_IMP_SEL_LS_OFFSET)
+#define UTMI_TX_CH_CTRL_AMP_OFFSET		20
+#define UTMI_TX_CH_CTRL_AMP_MASK		\
+	(0x7 << UTMI_TX_CH_CTRL_AMP_OFFSET)
 
-#define UTMI_RX_CH_CTRL0_REG			0x14
+#define UTMI_RX_CH_CTRL0_REG			0x8
+#define UTMI_RX_CH_CTRL0_DISCON_THRESH_OFFSET	8
+#define UTMI_RX_CH_CTRL0_DISCON_THRESH_MASK	\
+	(0x3 << UTMI_RX_CH_CTRL0_DISCON_THRESH_OFFSET)
 #define UTMI_RX_CH_CTRL0_SQ_DET_OFFSET		15
 #define UTMI_RX_CH_CTRL0_SQ_DET_MASK		\
 	(0x1 << UTMI_RX_CH_CTRL0_SQ_DET_OFFSET)
@@ -62,15 +79,15 @@
 #define UTMI_RX_CH_CTRL0_SQ_ANA_DTC_MASK	\
 	(0x1 << UTMI_RX_CH_CTRL0_SQ_ANA_DTC_OFFSET)
 
-#define UTMI_RX_CH_CTRL1_REG			0x18
+#define UTMI_RX_CH_CTRL1_REG			0xc
 #define UTMI_RX_CH_CTRL1_SQ_AMP_CAL_OFFSET	0
 #define UTMI_RX_CH_CTRL1_SQ_AMP_CAL_MASK	\
-	(0x3 << UTMI_RX_CH_CTRL1_SQ_AMP_CAL_OFFSET)
+	(0x7 << UTMI_RX_CH_CTRL1_SQ_AMP_CAL_OFFSET)
 #define UTMI_RX_CH_CTRL1_SQ_AMP_CAL_EN_OFFSET	3
 #define UTMI_RX_CH_CTRL1_SQ_AMP_CAL_EN_MASK	\
 	(0x1 << UTMI_RX_CH_CTRL1_SQ_AMP_CAL_EN_OFFSET)
 
-#define UTMI_CTRL_STATUS0_REG			0x24
+#define UTMI_CTRL_STATUS0_REG			0x18
 #define UTMI_CTRL_STATUS0_SUSPENDM_OFFSET	22
 #define UTMI_CTRL_STATUS0_SUSPENDM_MASK		\
 	(0x1 << UTMI_CTRL_STATUS0_SUSPENDM_OFFSET)
@@ -78,7 +95,7 @@
 #define UTMI_CTRL_STATUS0_TEST_SEL_MASK		\
 	(0x1 << UTMI_CTRL_STATUS0_TEST_SEL_OFFSET)
 
-#define UTMI_CHGDTC_CTRL_REG			0x38
+#define UTMI_CHGDTC_CTRL_REG			0x2c
 #define UTMI_CHGDTC_CTRL_VDAT_OFFSET		8
 #define UTMI_CHGDTC_CTRL_VDAT_MASK		\
 	(0x3 << UTMI_CHGDTC_CTRL_VDAT_OFFSET)
diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
index 2bf853e..010eb20 100644
--- a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+++ b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
@@ -44,7 +44,7 @@ DECLARE_GLOBAL_DATA_PTR;
 #define IRQ_STATUS	0x10
 #define IRQ_WKUP	0x18
 
-#define NB_FUNCS 2
+#define NB_FUNCS 3
 #define GPIO_PER_REG	32
 
 /**
@@ -128,6 +128,16 @@ struct armada_37xx_pinctrl {
 		.funcs = {_func1, "gpio"}	\
 	}
 
+#define PIN_GRP_GPIO_3(_name, _start, _nr, _mask, _v1, _v2, _v3, _f1, _f2) \
+	{					\
+		.name = _name,			\
+		.start_pin = _start,		\
+		.npins = _nr,			\
+		.reg_mask = _mask,		\
+		.val = {_v1, _v2, _v3},	\
+		.funcs = {_f1, _f2, "gpio"}	\
+	}
+
 #define PIN_GRP_EXTRA(_name, _start, _nr, _mask, _v1, _v2, _start2, _nr2, \
 		      _f1, _f2)				\
 	{						\
@@ -149,8 +159,8 @@ static struct armada_37xx_pin_group armada_37xx_nb_groups[] = {
 	PIN_GRP_GPIO("pwm1", 12, 1, BIT(4), "pwm"),
 	PIN_GRP_GPIO("pwm2", 13, 1, BIT(5), "pwm"),
 	PIN_GRP_GPIO("pwm3", 14, 1, BIT(6), "pwm"),
-	PIN_GRP_GPIO("pmic1", 17, 1, BIT(7), "pmic"),
-	PIN_GRP_GPIO("pmic0", 16, 1, BIT(8), "pmic"),
+	PIN_GRP_GPIO("pmic1", 7, 1, BIT(7), "pmic"),
+	PIN_GRP_GPIO("pmic0", 6, 1, BIT(8), "pmic"),
 	PIN_GRP_GPIO("i2c2", 2, 2, BIT(9), "i2c"),
 	PIN_GRP_GPIO("i2c1", 0, 2, BIT(10), "i2c"),
 	PIN_GRP_GPIO("spi_cs1", 17, 1, BIT(12), "spi"),
@@ -172,13 +182,15 @@ static struct armada_37xx_pin_group armada_37xx_nb_groups[] = {
 static struct armada_37xx_pin_group armada_37xx_sb_groups[] = {
 	PIN_GRP_GPIO("usb32_drvvbus0", 0, 1, BIT(0), "drvbus"),
 	PIN_GRP_GPIO("usb2_drvvbus1", 1, 1, BIT(1), "drvbus"),
-	PIN_GRP_GPIO("sdio_sb", 24, 5, BIT(2), "sdio"),
-	PIN_GRP_EXTRA("rgmii", 6, 14, BIT(3), 0, BIT(3), 23, 1, "mii", "gpio"),
-	PIN_GRP_GPIO("pcie1", 3, 2, BIT(4), "pcie"),
-	PIN_GRP_GPIO("ptp", 20, 3, BIT(5), "ptp"),
+	PIN_GRP_GPIO("sdio_sb", 24, 6, BIT(2), "sdio"),
+	PIN_GRP_GPIO("rgmii", 6, 12, BIT(3), "mii"),
+	PIN_GRP_GPIO("smi", 18, 2, BIT(4), "smi"),
+	PIN_GRP_GPIO("pcie1", 3, 3, BIT(5) | BIT(9) | BIT(10), "pcie"),
+	PIN_GRP_GPIO("ptp", 20, 3, BIT(11) | BIT(12) | BIT(13), "ptp"),
 	PIN_GRP("ptp_clk", 21, 1, BIT(6), "ptp", "mii"),
 	PIN_GRP("ptp_trig", 22, 1, BIT(7), "ptp", "mii"),
-	PIN_GRP("mii_col", 23, 1, BIT(8), "mii", "mii_err"),
+	PIN_GRP_GPIO_3("mii_col", 23, 1, BIT(8) | BIT(14), 0, BIT(8), BIT(14),
+		       "mii", "mii_err"),
 };
 
 const struct armada_37xx_pin_data armada_37xx_pin_nb = {
@@ -189,18 +201,18 @@ const struct armada_37xx_pin_data armada_37xx_pin_nb = {
 };
 
 const struct armada_37xx_pin_data armada_37xx_pin_sb = {
-	.nr_pins = 29,
+	.nr_pins = 30,
 	.name = "GPIO2",
 	.groups = armada_37xx_sb_groups,
 	.ngroups = ARRAY_SIZE(armada_37xx_sb_groups),
 };
 
 static inline void armada_37xx_update_reg(unsigned int *reg,
-					  unsigned int offset)
+					  unsigned int *offset)
 {
 	/* We never have more than 2 registers */
-	if (offset >= GPIO_PER_REG) {
-		offset -= GPIO_PER_REG;
+	if (*offset >= GPIO_PER_REG) {
+		*offset -= GPIO_PER_REG;
 		*reg += sizeof(u32);
 	}
 }
@@ -210,7 +222,7 @@ static int armada_37xx_get_func_reg(struct armada_37xx_pin_group *grp,
 {
 	int f;
 
-	for (f = 0; f < NB_FUNCS; f++)
+	for (f = 0; (f < NB_FUNCS) && grp->funcs[f]; f++)
 		if (!strcmp(grp->funcs[f], func))
 			return f;
 
@@ -352,7 +364,7 @@ static int armada_37xx_fill_group(struct armada_37xx_pinctrl *info)
 		for (j = 0; j < grp->extra_npins; j++)
 			grp->pins[i+j] = grp->extra_pin + j;
 
-		for (f = 0; f < NB_FUNCS; f++) {
+		for (f = 0; (f < NB_FUNCS) && grp->funcs[f]; f++) {
 			int ret;
 			/* check for unique functions and count groups */
 			ret = armada_37xx_add_function(info->funcs, &funcsize,
@@ -404,7 +416,7 @@ static int armada_37xx_fill_func(struct armada_37xx_pinctrl *info)
 			struct armada_37xx_pin_group *gp = &info->groups[g];
 			int f;
 
-			for (f = 0; f < NB_FUNCS; f++) {
+			for (f = 0; (f < NB_FUNCS) && gp->funcs[f]; f++) {
 				if (strcmp(gp->funcs[f], name) == 0) {
 					*groups = gp->name;
 					groups++;
@@ -421,7 +433,7 @@ static int armada_37xx_gpio_get(struct udevice *dev, unsigned int offset)
 	unsigned int reg = INPUT_VAL;
 	unsigned int val, mask;
 
-	armada_37xx_update_reg(&reg, offset);
+	armada_37xx_update_reg(&reg, &offset);
 	mask = BIT(offset);
 
 	val = readl(info->base + reg);
@@ -436,7 +448,7 @@ static int armada_37xx_gpio_set(struct udevice *dev, unsigned int offset,
 	unsigned int reg = OUTPUT_VAL;
 	unsigned int mask, val;
 
-	armada_37xx_update_reg(&reg, offset);
+	armada_37xx_update_reg(&reg, &offset);
 	mask = BIT(offset);
 	val = value ? mask : 0;
 
@@ -452,7 +464,7 @@ static int armada_37xx_gpio_get_direction(struct udevice *dev,
 	unsigned int reg = OUTPUT_EN;
 	unsigned int val, mask;
 
-	armada_37xx_update_reg(&reg, offset);
+	armada_37xx_update_reg(&reg, &offset);
 	mask = BIT(offset);
 	val = readl(info->base + reg);
 
@@ -469,7 +481,7 @@ static int armada_37xx_gpio_direction_input(struct udevice *dev,
 	unsigned int reg = OUTPUT_EN;
 	unsigned int mask;
 
-	armada_37xx_update_reg(&reg, offset);
+	armada_37xx_update_reg(&reg, &offset);
 	mask = BIT(offset);
 
 	clrbits_le32(info->base + reg, mask);
@@ -484,7 +496,7 @@ static int armada_37xx_gpio_direction_output(struct udevice *dev,
 	unsigned int reg = OUTPUT_EN;
 	unsigned int mask;
 
-	armada_37xx_update_reg(&reg, offset);
+	armada_37xx_update_reg(&reg, &offset);
 	mask = BIT(offset);
 
 	setbits_le32(info->base + reg, mask);
diff --git a/drivers/pinctrl/mvebu/pinctrl-mvebu.c b/drivers/pinctrl/mvebu/pinctrl-mvebu.c
index ec19583..3bb3fee 100644
--- a/drivers/pinctrl/mvebu/pinctrl-mvebu.c
+++ b/drivers/pinctrl/mvebu/pinctrl-mvebu.c
@@ -17,8 +17,52 @@
 #include <asm/arch-armada8k/soc-info.h>
 #include "pinctrl-mvebu.h"
 
+#define AP_EMMC_PHY_CTRL_REG		0x100
+#define CP_EMMC_PHY_CTRL_REG		0x424
+#define EMMC_PHY_CTRL_SDPHY_EN		BIT(0)
+
+#define AP806_EMMC_CLK_PIN_ID		0
+#define AP806_EMMC_CLK_FUNC		0x1
+#define CP110_EMMC_CLK_PIN_ID		56
+#define CP110_EMMC_CLK_FUNC		0xe
+
 DECLARE_GLOBAL_DATA_PTR;
 
+/* mvebu_pinctl_emmc_set_mux: configure sd/mmc PHY mux
+ * To enable SDIO/eMMC in Armada-APN806/CP110, need to configure PHY mux.
+ * eMMC/SD PHY register responsible for muxing between MPPs and SD/eMMC
+ * controller:
+ * - Bit0 enabled SDIO/eMMC PHY is used as a MPP muxltiplexer,
+ * - Bit0 disabled SDIO/eMMC PHY is connected to SDIO/eMMC controller
+ * If pin function is set to eMMC/SD, then configure the eMMC/SD PHY
+ * muxltiplexer register to be on SDIO/eMMC controller
+ */
+void mvebu_pinctl_emmc_set_mux(struct udevice *dev, u32 pin, u32 func)
+{
+	const void *blob = gd->fdt_blob;
+	int node = dev_of_offset(dev);
+	struct mvebu_pinctrl_priv *priv = dev_get_priv(dev);
+
+	if (!fdt_node_check_compatible(blob, node, "marvell,ap806-pinctrl")) {
+		if ((pin == AP806_EMMC_CLK_PIN_ID) &&
+		    (func == AP806_EMMC_CLK_FUNC)) {
+			clrbits_le32(priv->base_reg + AP_EMMC_PHY_CTRL_REG,
+				     EMMC_PHY_CTRL_SDPHY_EN);
+		}
+	} else if (!fdt_node_check_compatible(blob, node,
+					"marvell,armada-8k-cpm-pinctrl") ||
+		   !fdt_node_check_compatible(blob, node,
+					"marvell,armada-7k-pinctrl") ||
+		   !fdt_node_check_compatible(blob, node,
+					"marvell,cp115-standalone-pinctrl")) {
+		if ((pin == CP110_EMMC_CLK_PIN_ID) &&
+		    (func == CP110_EMMC_CLK_FUNC)) {
+			clrbits_le32(priv->base_reg + CP_EMMC_PHY_CTRL_REG,
+				     EMMC_PHY_CTRL_SDPHY_EN);
+		}
+	}
+}
+
 /*
  * mvebu_pinctrl_set_state: configure pin functions.
  * @dev: the pinctrl device to be configured.
@@ -48,9 +92,16 @@ int mvebu_pinctrl_set_state(struct udevice *dev, struct udevice *config)
 
 	function = fdtdec_get_int(blob, node, "marvell,function", 0xff);
 
+	/*
+	 * Check if setup of PHY mux is needed for this pins group.
+	 * Only the first pin id in array is tested, all the rest use the same
+	 * pin function.
+	 */
+	mvebu_pinctl_emmc_set_mux(dev, pin_arr[0], function);
+
 	for (i = 0; i < pin_count; i++) {
-	int reg_offset;
-	int field_offset;
+		int reg_offset;
+		int field_offset;
 		int pin = pin_arr[i];
 
 		if (function > priv->max_func) {
@@ -97,6 +148,14 @@ static int mvebu_pinctrl_set_state_all(struct udevice *dev,
 		return -EINVAL;
 	}
 
+	/* Check if setup of PHY mux is needed for this pins group. */
+	if (priv->pin_cnt < CP110_EMMC_CLK_PIN_ID)
+		mvebu_pinctl_emmc_set_mux(dev, AP806_EMMC_CLK_PIN_ID,
+					  func_arr[AP806_EMMC_CLK_PIN_ID]);
+	else
+		mvebu_pinctl_emmc_set_mux(dev, CP110_EMMC_CLK_PIN_ID,
+					  func_arr[CP110_EMMC_CLK_PIN_ID]);
+
 	for (pin = 0; pin < priv->pin_cnt; pin++) {
 		int reg_offset;
 		int field_offset;
@@ -162,10 +221,11 @@ static struct pinctrl_ops mvebu_pinctrl_ops = {
 
 static const struct udevice_id mvebu_pinctrl_ids[] = {
 	{ .compatible = "marvell,mvebu-pinctrl" },
-	{ .compatible = "marvell,armada-ap806-pinctrl" },
-	{ .compatible = "marvell,a70x0-pinctrl" },
-	{ .compatible = "marvell,a80x0-cp0-pinctrl" },
-	{ .compatible = "marvell,a80x0-cp1-pinctrl" },
+	{ .compatible = "marvell,ap806-pinctrl" },
+	{ .compatible = "marvell,armada-7k-pinctrl" },
+	{ .compatible = "marvell,armada-8k-cpm-pinctrl" },
+	{ .compatible = "marvell,armada-8k-cps-pinctrl" },
+	{ .compatible = "marvell,cp115-standalone-pinctrl" },
 	{ }
 };
 
diff --git a/drivers/power/regulator/regulator-uclass.c b/drivers/power/regulator/regulator-uclass.c
index 426a933..5a7f91e 100644
--- a/drivers/power/regulator/regulator-uclass.c
+++ b/drivers/power/regulator/regulator-uclass.c
@@ -195,6 +195,17 @@ int regulator_autoset(struct udevice *dev)
 	return ret;
 }
 
+int regulator_unset(struct udevice *dev)
+{
+	struct dm_regulator_uclass_platdata *uc_pdata;
+
+	uc_pdata = dev_get_uclass_platdata(dev);
+	if (uc_pdata->force_off)
+		return regulator_set_enable(dev, false);
+
+	return -EMEDIUMTYPE;
+}
+
 static void regulator_show(struct udevice *dev, int ret)
 {
 	struct dm_regulator_uclass_platdata *uc_pdata;
@@ -322,6 +333,7 @@ static int regulator_pre_probe(struct udevice *dev)
 						-ENODATA);
 	uc_pdata->always_on = dev_read_bool(dev, "regulator-always-on");
 	uc_pdata->boot_on = dev_read_bool(dev, "regulator-boot-on");
+	uc_pdata->force_off = dev_read_bool(dev, "regulator-force-boot-off");
 
 	/* Those values are optional (-ENODATA if unset) */
 	if ((uc_pdata->min_uV != -ENODATA) &&
@@ -364,6 +376,32 @@ int regulators_enable_boot_on(bool verbose)
 	return ret;
 }
 
+int regulators_enable_boot_off(bool verbose)
+{
+	struct udevice *dev;
+	struct uclass *uc;
+	int ret;
+
+	ret = uclass_get(UCLASS_REGULATOR, &uc);
+	if (ret)
+		return ret;
+	for (uclass_first_device(UCLASS_REGULATOR, &dev);
+	     dev;
+	     uclass_next_device(&dev)) {
+		ret = regulator_unset(dev);
+		if (ret == -EMEDIUMTYPE) {
+			ret = 0;
+			continue;
+		}
+		if (verbose)
+			regulator_show(dev, ret);
+		if (ret == -ENOSYS)
+			ret = 0;
+	}
+
+	return ret;
+}
+
 UCLASS_DRIVER(regulator) = {
 	.id		= UCLASS_REGULATOR,
 	.name		= "regulator",
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index 95ac031..0e20273 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -13,6 +13,15 @@ config DM_RTC
 	  drivers to perform the actual functions. See rtc.h for a
 	  description of the API.
 
+config MARVELL_RTC
+	bool "MARVELL RTC support"
+	depends on DM_RTC
+	help
+	  Choose this option to add
+	  support for Marvell's
+	  RTC driver, which is used
+	  by Armada 7K, 8K, 3900 and OcteonTX2 CN913x.
+
 config RTC_PCF2127
 	bool "Enable PCF2127 driver"
 	depends on DM_RTC
@@ -36,6 +45,13 @@ config RTC_RX8010SJ
 	help
 	  Support for Epson RX8010SJ Real Time Clock devices.
 
+config RTC_DS1337
+	bool "Enable DS1337 driver"
+	depends on DM_RTC
+	help
+	  Support for Dallas Semiconductor (now Maxim) DS1337 and
+	  compatible Real Time Clock devices.
+
 config RTC_S35392A
 	bool "Enable S35392A driver"
 	select BITREVERSE
diff --git a/drivers/rtc/Makefile b/drivers/rtc/Makefile
index 9723fb7..b89450f 100644
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -10,6 +10,7 @@ obj-$(CONFIG_DM_RTC) += rtc-uclass.o
 
 obj-$(CONFIG_RTC_AT91SAM9_RTT) += at91sam9_rtt.o
 obj-y += date.o
+obj-$(CONFIG_MARVELL_RTC) += marvell_rtc.o
 obj-$(CONFIG_RTC_DAVINCI) += davinci.o
 obj-$(CONFIG_RTC_DS1302) += ds1302.o
 obj-$(CONFIG_RTC_DS1306) += ds1306.o
diff --git a/drivers/rtc/ds1337.c b/drivers/rtc/ds1337.c
index 4b73d17..9a4e19e 100644
--- a/drivers/rtc/ds1337.c
+++ b/drivers/rtc/ds1337.c
@@ -1,4 +1,6 @@
 /*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
  * (C) Copyright 2001-2008
  * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
  * Keith Outwater, keith_outwater@mvis.com`
@@ -15,6 +17,10 @@
 #include <command.h>
 #include <rtc.h>
 #include <i2c.h>
+#include <dm.h>
+#include <fdtdec.h>
+
+DECLARE_GLOBAL_DATA_PTR;
 
 #if defined(CONFIG_CMD_DATE)
 
@@ -62,6 +68,195 @@
 #define RTC_STAT_BIT_A2F	0x2	/* Alarm 2 flag			*/
 #define RTC_STAT_BIT_OSF	0x80	/* Oscillator stop flag		*/
 
+#ifdef CONFIG_DM_RTC
+
+enum model{
+	DS1337=1,
+	DS1337_NOOSC,
+	DS1339,
+	DS1388,
+	ISL12057
+};
+
+struct ds1337_rtc {
+	unsigned int regaddr;
+	enum model rtcmodel;
+};
+
+/*
+ * Helper functions
+ */
+static uchar dm_rtc_read (struct udevice *dev, uchar reg)
+{
+	return dm_i2c_reg_read (dev, reg);
+}
+
+static void dm_rtc_write (struct udevice *dev, uchar reg, uchar val)
+{
+	dm_i2c_reg_write (dev, reg, val);
+}
+
+static int ds1337_rtc_get(struct udevice *dev, struct rtc_time *tmp)
+{
+	int rel = 0;
+	uchar sec, min, hour, mday, wday, mon_cent, year, control, status;
+
+	control = dm_rtc_read (dev, RTC_CTL_REG_ADDR);
+	status = dm_rtc_read (dev, RTC_STAT_REG_ADDR);
+	sec = dm_rtc_read (dev, RTC_SEC_REG_ADDR);
+	min = dm_rtc_read (dev, RTC_MIN_REG_ADDR);
+	hour = dm_rtc_read (dev, RTC_HR_REG_ADDR);
+	wday = dm_rtc_read (dev, RTC_DAY_REG_ADDR);
+	mday = dm_rtc_read (dev, RTC_DATE_REG_ADDR);
+	mon_cent = dm_rtc_read (dev, RTC_MON_REG_ADDR);
+	year = dm_rtc_read (dev, RTC_YR_REG_ADDR);
+
+	/* No century bit, assume year 2000 */
+#ifdef CONFIG_RTC_DS1388
+	mon_cent |= 0x80;
+#endif
+
+	debug("Get RTC year: %02x mon/cent: %02x mday: %02x wday: %02x "
+		"hr: %02x min: %02x sec: %02x control: %02x status: %02x\n",
+		year, mon_cent, mday, wday, hour, min, sec, control, status);
+
+	if (status & RTC_STAT_BIT_OSF) {
+		printf ("### Warning: RTC oscillator has stopped\n");
+		/* clear the OSF flag */
+		dm_rtc_write (dev, RTC_STAT_REG_ADDR,
+			   dm_rtc_read (dev, RTC_STAT_REG_ADDR) & ~RTC_STAT_BIT_OSF);
+		rel = -1;
+	}
+
+	tmp->tm_sec  = bcd2bin (sec & 0x7F);
+	tmp->tm_min  = bcd2bin (min & 0x7F);
+	tmp->tm_hour = bcd2bin (hour & 0x3F);
+	tmp->tm_mday = bcd2bin (mday & 0x3F);
+	tmp->tm_mon  = bcd2bin (mon_cent & 0x1F);
+	tmp->tm_year = bcd2bin (year) + ((mon_cent & 0x80) ? 2100 : 2000);
+	tmp->tm_wday = bcd2bin ((wday - 1) & 0x07);
+	tmp->tm_yday = 0;
+	tmp->tm_isdst= 0;
+
+	debug("Get DATE: %4d-%02d-%02d (wday=%d)  TIME: %2d:%02d:%02d\n",
+		tmp->tm_year, tmp->tm_mon, tmp->tm_mday, tmp->tm_wday,
+		tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
+
+	return rel;
+}
+
+static int ds1337_rtc_set(struct udevice *dev, const struct rtc_time *tmp)
+{
+	uchar century;
+
+	debug("Set DATE: %4d-%02d-%02d (wday=%d)  TIME: %2d:%02d:%02d\n",
+		tmp->tm_year, tmp->tm_mon, tmp->tm_mday, tmp->tm_wday,
+		tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
+
+	if (tmp->tm_year < 2000 || tmp->tm_year > 2199)
+		return -1;
+
+	dm_rtc_write (dev, RTC_YR_REG_ADDR, bin2bcd (tmp->tm_year % 100));
+
+	/* Assume 20YY as base, to fix mismatch with linux */
+	century = (tmp->tm_year >= 2100) ? 0x80 : 0;
+	dm_rtc_write (dev, RTC_MON_REG_ADDR, bin2bcd (tmp->tm_mon) | century);
+
+	dm_rtc_write (dev, RTC_DAY_REG_ADDR, bin2bcd (tmp->tm_wday + 1));
+	dm_rtc_write (dev, RTC_DATE_REG_ADDR, bin2bcd (tmp->tm_mday));
+	dm_rtc_write (dev, RTC_HR_REG_ADDR, bin2bcd (tmp->tm_hour));
+	dm_rtc_write (dev, RTC_MIN_REG_ADDR, bin2bcd (tmp->tm_min));
+	dm_rtc_write (dev, RTC_SEC_REG_ADDR, bin2bcd (tmp->tm_sec));
+
+	return 0;
+}
+
+/*
+ * Reset the RTC.  We also enable the oscillator output on the
+ * SQW/INTB* pin and program it for 32,768 Hz output. Note that
+ * according to the datasheet, turning on the square wave output
+ * increases the current drain on the backup battery from about
+ * 600 nA to 2uA. Define CONFIG_SYS_RTC_DS1337_NOOSC if you wish to turn
+ * off the OSC output.
+ */
+static int ds1337_rtc_reset(struct udevice *dev)
+{
+	struct ds1337_rtc *rtcpriv = dev->priv;
+	uchar resetval = RTC_CTL_BIT_RS1 | RTC_CTL_BIT_RS2; /* Default DS1337 */
+
+	if(rtcpriv->rtcmodel == DS1337_NOOSC)
+		resetval |= RTC_CTL_BIT_INTCN;
+	if(rtcpriv->rtcmodel == DS1388)
+		resetval = 0x0;
+
+	dm_rtc_write (dev, RTC_CTL_REG_ADDR, resetval);
+
+#ifdef CONFIG_SYS_DS1339_TCR_VAL
+	dm_rtc_write (dev, RTC_TC_REG_ADDR, CONFIG_SYS_DS1339_TCR_VAL);
+#endif
+#ifdef CONFIG_SYS_DS1388_TCR_VAL
+	dm_rtc_write(dev, RTC_TC_REG_ADDR, CONFIG_SYS_DS1388_TCR_VAL);
+#endif
+	return 0;
+}
+
+static int ds1337_rtc_read8(struct udevice *dev, unsigned int reg)
+{
+	return dm_rtc_read(dev, reg);
+}
+
+static int ds1337_rtc_write8(struct udevice *dev, unsigned int reg, int val)
+{
+	dm_rtc_write(dev, reg, val);
+
+	return 0;
+}
+
+static int ds1337_ofdata_to_platdata(struct udevice *dev)
+{
+	struct ds1337_rtc *platdata = dev->priv;
+	const void *blob = gd->fdt_blob;
+	int node = dev->node.of_offset;
+
+	platdata->regaddr = fdtdec_get_int(blob, node, "reg", -1);
+	platdata->rtcmodel = fdtdec_get_int(blob, node, "rtcmodel", 1);
+
+	debug("RTC addr 0x%08x model %d\n", platdata->regaddr, platdata->rtcmodel);
+	return 0;
+}
+
+static int ds1337_rtc_probe(struct udevice *dev)
+{
+	ds1337_rtc_reset(dev);
+
+	return 0;
+}
+
+static const struct rtc_ops ds1337_rtc_ops = {
+	.get = ds1337_rtc_get,
+	.set = ds1337_rtc_set,
+	.reset = ds1337_rtc_reset,
+	.read8 = ds1337_rtc_read8,
+	.write8 = ds1337_rtc_write8,
+};
+
+static const struct udevice_id ds1337_rtc_ids[] = {
+	{ .compatible = "dallas,ds1337" },
+	{ .compatible = "isil,isl12057" },
+	{ }
+};
+
+U_BOOT_DRIVER(ds1337_rtc) = {
+	.name = "ds1337_rtc",
+	.id = UCLASS_RTC,
+	.of_match = ds1337_rtc_ids,
+	.ofdata_to_platdata = ds1337_ofdata_to_platdata,
+	.priv_auto_alloc_size = sizeof (struct ds1337_rtc),
+	.probe = ds1337_rtc_probe,
+	.ops = &ds1337_rtc_ops,
+};
+
+#else /* !CONFIG_DM_RTC */
 
 static uchar rtc_read (uchar reg);
 static void rtc_write (uchar reg, uchar val);
@@ -192,4 +387,7 @@ static void rtc_write (uchar reg, uchar val)
 	i2c_reg_write (CONFIG_SYS_I2C_RTC_ADDR, reg, val);
 }
 
-#endif
+
+#endif /* !CONFIG_DM_RTC */
+
+#endif /* CONFIG_CMD_DATE */
diff --git a/drivers/rtc/marvell_rtc.c b/drivers/rtc/marvell_rtc.c
new file mode 100644
index 0000000..9017537
--- /dev/null
+++ b/drivers/rtc/marvell_rtc.c
@@ -0,0 +1,184 @@
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <rtc.h>
+#include <dm.h>
+#include <dm/device-internal.h>
+#include "marvell_rtc.h"
+
+static int marvell_rtc_get(struct udevice *dev, struct rtc_time *time)
+{
+	struct rtc_unit_config *rtc_cfg = dev_get_priv(dev);
+	uintptr_t rtc_base = (uintptr_t)rtc_cfg->rtc_base;
+
+	rtc_to_tm(RTC_READ_REG(rtc_base, RTC_TIME_REG_OFFS), time);
+
+	return 0;
+}
+
+static int marvell_rtc_set(struct udevice *dev, const struct rtc_time *time)
+{
+	unsigned long tm;
+	struct rtc_unit_config *rtc_cfg = dev_get_priv(dev);
+	uintptr_t rtc_base = (uintptr_t)rtc_cfg->rtc_base;
+
+	tm = rtc_mktime(time);
+
+#ifdef ERRATA_FE_3124064
+	RTC_WRITE_REG(0, rtc_base, RTC_STATUS_REG_OFFS);
+	RTC_WRITE_REG(0, rtc_base, RTC_STATUS_REG_OFFS);
+#endif
+	RTC_WRITE_REG(tm, rtc_base, RTC_TIME_REG_OFFS);
+
+	/* Give registers time to stabilize */
+	mdelay(100);
+
+	return 0;
+}
+
+static int marvell_rtc_reset(struct udevice *dev)
+{
+	struct rtc_unit_config *rtc_cfg = dev_get_priv(dev);
+	uintptr_t rtc_base = (uintptr_t)rtc_cfg->rtc_base;
+
+	/* Reset Test register */
+	RTC_WRITE_REG(0, rtc_base, RTC_TEST_CONFIG_REG_OFFS);
+	/* Oscillator startup time */
+	mdelay(500);
+
+	/* Reset time register */
+#ifdef ERRATA_FE_3124064
+	RTC_WRITE_REG(0, rtc_base, RTC_STATUS_REG_OFFS);
+	RTC_WRITE_REG(0, rtc_base, RTC_STATUS_REG_OFFS);
+#endif
+	RTC_WRITE_REG(0, rtc_base, RTC_TIME_REG_OFFS);
+	udelay(62);
+
+	/* Reset Status register */
+	RTC_WRITE_REG((RTC_SZ_STATUS_ALARM1_MASK | RTC_SZ_STATUS_ALARM2_MASK),
+		      rtc_base, RTC_STATUS_REG_OFFS);
+	udelay(62);
+
+	/* Turn off Int1 and Int2 sources & clear the Alarm count */
+	RTC_WRITE_REG(0, rtc_base, RTC_IRQ_1_CONFIG_REG_OFFS);
+	RTC_WRITE_REG(0, rtc_base, RTC_IRQ_2_CONFIG_REG_OFFS);
+	RTC_WRITE_REG(0, rtc_base, RTC_ALARM_1_REG_OFFS);
+	RTC_WRITE_REG(0, rtc_base, RTC_ALARM_2_REG_OFFS);
+
+	/* Setup nominal register access timing */
+	RTC_WRITE_REG(RTC_NOMINAL_TIMING, rtc_base, RTC_CLOCK_CORR_REG_OFFS);
+
+	/* Reset time register */
+#ifdef ERRATA_FE_3124064
+	RTC_WRITE_REG(0, rtc_base, RTC_STATUS_REG_OFFS);
+	RTC_WRITE_REG(0, rtc_base, RTC_STATUS_REG_OFFS);
+#endif
+	RTC_WRITE_REG(0, rtc_base, RTC_TIME_REG_OFFS);
+	udelay(10);
+
+	/* Reset Status register */
+	RTC_WRITE_REG((RTC_SZ_STATUS_ALARM1_MASK | RTC_SZ_STATUS_ALARM2_MASK),
+		      rtc_base, RTC_STATUS_REG_OFFS);
+	udelay(50);
+
+	return 0;
+}
+
+void marvell_rtc_errata(struct udevice *dev)
+{
+	unsigned long reg;
+
+	/* Get the rtc register base address */
+	struct rtc_unit_config *rtc_cfg = dev_get_priv(dev);
+	uintptr_t rtc_base = (uintptr_t)rtc_cfg->rtc_base;
+
+	/* Update RTC-MBUS bridge timing parameters */
+	/* Functional Errata Ref #:
+	 * FE-3124064 - WA for failing time read attempts.
+	 * Description:
+	 *	The device supports CPU write and read access
+	 *	to the RTC Time register.
+	 *	However, due to this erratum,
+	 *	Write to RTC TIME register may fail.
+	 *	Read from RTC TIME register may fail.
+	 * Workaround:
+	 * 1. Configure the RTC Mbus Bridge Timing Control register
+	 *    (offset 0x284080 and 0x284084)
+	 *	- Write RTC WRCLK Period 0x3FF (default value is 0xFA)
+	 *	- Write RTC WRCLK setup to 0x29 (default value is 0x53)
+	 *	- Write RTC Read Output Delay to 0x3F (default value is 0x10)
+	 *	- Write RTC WRCLK High Time to 0x53 (default value)
+	 *	- Mbus - Read All Byte Enable to 0x1 (default value)
+	 * 2. Configure the RTC Test Configuration Register (offset 0x28401C)
+	 *    bit3 to '1' (Reserved, Marvell internal)
+	 *
+	 * RTC Time register write operation:
+	 *	- Issue two dummy writes of 0x0 to the RTC Status register
+	 *	  (offset 0x284000).
+	 *	- Write the time to the RTC Time register (offset 0x28400C).
+	 */
+	reg = RTC_READ_REG(rtc_base, MV_RTC0_SOC_OFFSET);
+	reg &= ~RTC_WRCLK_PERIOD_MASK;
+	reg |= 0x3FF << RTC_WRCLK_PERIOD_OFFS;
+	reg &= ~RTC_WRCLK_SETUP_MASK;
+	reg |= 0x29 << RTC_WRCLK_SETUP_OFFS;
+	RTC_WRITE_REG(reg, rtc_base, MV_RTC0_SOC_OFFSET);
+
+	reg = RTC_READ_REG(rtc_base, MV_RTC1_SOC_OFFSET);
+	reg &= ~RTC_READ_OUTPUT_DELAY_MASK;
+	reg |= 0x3F << RTC_READ_OUTPUT_DELAY_OFFS;
+	RTC_WRITE_REG(reg, rtc_base, MV_RTC1_SOC_OFFSET);
+
+	reg = RTC_READ_REG(rtc_base, RTC_TEST_CONFIG_REG_OFFS);
+	reg |= 0x8;
+	RTC_WRITE_REG(reg, rtc_base, RTC_TEST_CONFIG_REG_OFFS);
+}
+
+static int marvell_rtc_probe(struct udevice *dev)
+{
+#ifdef ERRATA_FE_3124064
+	marvell_rtc_errata(dev);
+#else
+	/* Get the rtc register base address */
+	struct rtc_unit_config *rtc_cfg = dev_get_priv(dev);
+	uintptr_t rtc_base;
+	unsigned long reg;
+
+	rtc_cfg->rtc_base = (void *)devfdt_get_addr_index(dev, 0);
+	rtc_base = (uintptr_t)rtc_cfg->rtc_base;
+
+	/* Update RTC-MBUS bridge timing parameters */
+	reg = RTC_READ_REG(rtc_base, MV_RTC1_SOC_OFFSET);
+	reg &= ~RTC_READ_OUTPUT_DELAY_MASK;
+	reg |= 0x1F << RTC_READ_OUTPUT_DELAY_OFFS;
+	RTC_WRITE_REG(reg, rtc_base, MV_RTC1_SOC_OFFSET);
+#endif
+
+	return 0;
+}
+
+static const struct rtc_ops marvell_rtc_ops = {
+	.get = marvell_rtc_get,
+	.set = marvell_rtc_set,
+	.reset = marvell_rtc_reset,
+};
+
+static const struct udevice_id marvell_rtc_ids[] = {
+	{ .compatible = "marvell,armada-8k-rtc" },
+	{ }
+};
+
+U_BOOT_DRIVER(marvell_rtc) = {
+	.name	= "marvell_rtc",
+	.id	= UCLASS_RTC,
+	.of_match = marvell_rtc_ids,
+	.ops	= &marvell_rtc_ops,
+	.probe = marvell_rtc_probe,
+	.priv_auto_alloc_size = sizeof(struct rtc_unit_config),
+};
diff --git a/drivers/rtc/marvell_rtc.h b/drivers/rtc/marvell_rtc.h
new file mode 100644
index 0000000..cba639a
--- /dev/null
+++ b/drivers/rtc/marvell_rtc.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#ifndef _MARVELL_RTC_H
+#define _MARVELL_RTC_H
+
+/* The RTC DRS revision 1.2 indicates that firmware should wait
+ * 5us after every register write to the RTC hard macro,
+ * so that the required update can occur without holding off the system bus
+ */
+#define RTC_READ_REG(rtc_base, reg)		readl((rtc_base) + (reg))
+#define RTC_WRITE_REG(val, rtc_base, reg)		\
+	{ writel((val), (rtc_base) + (reg)); udelay(5); }
+
+#define RTC_NOMINAL_TIMING		0x2000
+
+#define RTC_STATUS_REG_OFFS		0x0
+#define RTC_IRQ_1_CONFIG_REG_OFFS	0x4
+#define RTC_IRQ_2_CONFIG_REG_OFFS	0x8
+#define RTC_TIME_REG_OFFS		0xC
+#define RTC_ALARM_1_REG_OFFS		0x10
+#define RTC_ALARM_2_REG_OFFS		0x14
+#define RTC_CLOCK_CORR_REG_OFFS		0x18
+#define RTC_TEST_CONFIG_REG_OFFS	0x1C
+#define MV_RTC0_SOC_OFFSET		0x80
+#define MV_RTC1_SOC_OFFSET		0x84
+
+#define RTC_WRCLK_PERIOD_OFFS		0
+#define RTC_WRCLK_PERIOD_MASK		(0xFFFF << RTC_WRCLK_PERIOD_OFFS)
+#define RTC_WRCLK_SETUP_OFFS		16
+#define RTC_WRCLK_SETUP_MASK		(0xFFFF << RTC_WRCLK_SETUP_OFFS)
+
+#define RTC_READ_OUTPUT_DELAY_OFFS	0
+#define RTC_READ_OUTPUT_DELAY_MASK	(0xFFFF << RTC_READ_OUTPUT_DELAY_OFFS)
+#define RTC_WRCLK_CLOCK_HIGH_OFFS	16
+#define RTC_WRCLK_CLOCK_HIGH_MASK	(0xFFFF << RTC_WRCLK_CLOCK_HIGH_OFFS)
+
+#define RTC_SZ_STATUS_ALARM1_MASK		0x1
+#define RTC_SZ_STATUS_ALARM2_MASK		0x2
+#define RTC_SZ_TIMING_RESERVED1_MASK		0xFFFF0000
+#define RTC_SZ_INTERRUPT1_INT1AE_MASK		0x1
+#define RTC_SZ_INTERRUPT1_RESERVED1_MASK	0xFFFFFFC0
+#define RTC_SZ_INTERRUPT2_INT2FE_MASK		0x2
+#define RTC_SZ_INTERRUPT2_RESERVED1_MASK	0xFFFFFFC0
+
+struct rtc_unit_config {
+	void __iomem *rtc_base;
+};
+
+#endif /* _MARVELL_RTC_H */
diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
index df99892..487c396 100644
--- a/drivers/scsi/scsi.c
+++ b/drivers/scsi/scsi.c
@@ -597,6 +597,7 @@ static int do_scsi_scan_one(struct udevice *dev, int id, int lun, bool verbose)
 	part_init(bdesc);
 
 	if (verbose) {
+		printf("Bus %d\n", dev->seq);
 		printf("  Device %d: ", 0);
 		dev_print(bdesc);
 	}
diff --git a/drivers/serial/Kconfig b/drivers/serial/Kconfig
index 93e602e..5045935 100644
--- a/drivers/serial/Kconfig
+++ b/drivers/serial/Kconfig
@@ -561,12 +561,29 @@ config MSM_SERIAL
 	  for example APQ8016 and MSM8916.
 	  Single baudrate is supported in current implementation (115200).
 
+config OCTEONTX_SERIAL_BOOTCMD
+	bool "OcteonTX/OcteonTX2 PCI remote bootcmd input"
+	depends on DM_SERIAL
+	depends on (ARCH_OCTEONTX || ARCH_OCTEONTX2)
+	select CONSOLE_MUX
+	help
+	 This driver supports remote input over the PCIe bus from a host
+	 to U-Boot for entering commands.  It is utilized by the host
+	 commands cavm-remote-load and cavm-remote-bootcmd.  This driver
+	 should be used in addition to the standard PL011 serial driver.
+
 config PXA_SERIAL
 	bool "PXA serial port support"
 	help
 	  If you have a machine based on a Marvell XScale PXA2xx CPU you
 	  can enable its onboard serial ports by enabling this option.
 
+config PL01X_SERIAL
+	bool "ARM Primecell PL01x serial port support"
+	help
+	  If you have a machine based on ARM Primcell PL010/011 you
+	  can enable its onboard serial ports by enabling this option.
+
 config STI_ASC_SERIAL
 	bool "STMicroelectronics on-chip UART"
 	depends on DM_SERIAL && ARCH_STI
diff --git a/drivers/serial/Makefile b/drivers/serial/Makefile
index cac9a8b..064bf56 100644
--- a/drivers/serial/Makefile
+++ b/drivers/serial/Makefile
@@ -50,6 +50,7 @@ obj-$(CONFIG_BCM283X_PL011_SERIAL) += serial_bcm283x_pl011.o
 obj-$(CONFIG_MSM_SERIAL) += serial_msm.o
 obj-$(CONFIG_MVEBU_A3700_UART) += serial_mvebu_a3700.o
 obj-$(CONFIG_MPC8XX_CONS) += serial_mpc8xx.o
+obj-$(CONFIG_OCTEONTX_SERIAL_BOOTCMD) += serial_octeontx_bootcmd.o
 obj-$(CONFIG_NULLDEV_SERIAL) += serial_nulldev.o
 
 ifndef CONFIG_SPL_BUILD
diff --git a/drivers/serial/ns16550.c b/drivers/serial/ns16550.c
index 53550bf..332d75c 100644
--- a/drivers/serial/ns16550.c
+++ b/drivers/serial/ns16550.c
@@ -395,7 +395,7 @@ int ns16550_serial_ofdata_to_platdata(struct udevice *dev)
 
 	/* try Processor Local Bus device first */
 	addr = dev_read_addr(dev);
-#if defined(CONFIG_PCI) && defined(CONFIG_DM_PCI)
+#if CONFIG_IS_ENABLED(PCI) && defined(CONFIG_DM_PCI)
 	if (addr == FDT_ADDR_T_NONE) {
 		/* then try pci device */
 		struct fdt_pci_addr pci_addr;
diff --git a/drivers/serial/serial_octeontx_bootcmd.c b/drivers/serial/serial_octeontx_bootcmd.c
new file mode 100644
index 0000000..af94c1a
--- /dev/null
+++ b/drivers/serial/serial_octeontx_bootcmd.c
@@ -0,0 +1,300 @@
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:     BSD-3-Clause
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <serial.h>
+#include <linux/compiler.h>
+#include <watchdog.h>
+#include <stdio_dev.h>
+#include <input.h>
+
+#undef CONFIG_LOGLEVEL
+#define CONFIG_LOGLEVEL 10
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define OCTEONTX_BOOTCMD_BUF_SIZE		4096
+
+/** "BOOTCMD!" */
+#define OCTEONTX_PIC_IO_BUF_MAGIC		0x21444d43544f4f42
+#define OCTEONTX_PCI_IO_BUF_OWNER_INVALID	0
+#define OCTEONTX_PCI_IO_BUF_OWNER_OCTEONTX	1
+#define OCTEONTX_PCI_IO_BUF_OWNER_HOST		2
+
+#define DRIVER_NAME				"pci-bootcmd"
+
+#ifndef CONFIG_DM_SERIAL
+# error CONFIG_DM_SERIAL required
+#endif
+
+struct octeontx_pci_io_buf {
+	u64 magic;
+	u32 owner;
+	u32 len;
+	char data[0];
+};
+
+struct octeontx_bootcmd_platdata {
+	fdt_addr_t base;
+	fdt_size_t size;
+};
+
+struct octeontx_bootcmd_data {
+	struct octeontx_pci_io_buf *buf;
+	struct udevice *dev;
+	fdt_size_t size;	/** Size of buffer descriptor & data */
+	unsigned long data_size;/** Size of buffer data */
+	u32 copy_offset;
+	bool eol;
+	bool started;
+	bool unlocked;
+};
+
+static struct udevice *bootcmd_dev;
+
+static int octeontx_bootcmd_start(struct udevice *dev)
+{
+	struct octeontx_bootcmd_data *bc = dev_get_priv(dev);
+	struct octeontx_pci_io_buf *buf = bc->buf;
+	struct octeontx_bootcmd_platdata *plat = dev_get_platdata(bc->dev);
+
+	if (bc->started) {
+		debug("%s: Already started\n", __func__);
+		return 0;
+	}
+
+	dev_dbg(bc->dev, "%s(%s)\n", __func__, dev->name);
+	/* Get address of IO buffer and check it */
+	bc->size = plat->size;
+	bc->data_size = bc->size - sizeof(struct octeontx_pci_io_buf);
+	bc->copy_offset = 0;
+	bc->eol = false;
+
+	buf->len = 0;
+	buf->data[0] = '\0';
+	buf->magic = OCTEONTX_PIC_IO_BUF_MAGIC;
+	if (bc->unlocked)
+		buf->owner = OCTEONTX_PCI_IO_BUF_OWNER_HOST;
+	else
+		buf->owner = OCTEONTX_PCI_IO_BUF_OWNER_OCTEONTX;
+
+	bc->unlocked = true;
+	bc->started = true;
+	__iowmb();
+	flush_dcache_range((ulong)buf, (ulong)buf + bc->size);
+
+	return 0;
+}
+
+/**
+ * Return if there are any pending characters for input or output
+ * @param	dev	serial device
+ * @param	input	true to check for pending input
+ *
+ * @return	1 if pending data, 0 if no data available
+ */
+static int octeontx_bootcmd_pending(struct udevice *dev, bool input)
+{
+	struct octeontx_bootcmd_data *bc = dev_get_priv(dev);
+	struct octeontx_pci_io_buf *buf = bc->buf;
+
+	if (!bc->started) {
+		dev_dbg("%s: Error: not started\n", __func__);
+		return 0;
+	}
+
+	invalidate_dcache_range((ulong)buf,
+				(ulong)buf + bc->size);
+	__iormb();
+	if (input) {
+		if (bc->eol)
+			return 1;
+		if (buf->owner != OCTEONTX_PCI_IO_BUF_OWNER_OCTEONTX)
+			return 0;
+		if ((buf->len > bc->copy_offset) &&
+		    (buf->data[bc->copy_offset] != '\0'))
+			return 1;
+		return 0;
+	}
+
+	return 0;
+}
+
+static int octeontx_bootcmd_putc(struct udevice *dev, const char ch)
+{
+	return 0;
+}
+
+static int octeontx_bootcmd_getc(struct udevice *dev)
+{
+	struct octeontx_bootcmd_data *bc = dev_get_priv(dev);
+	struct octeontx_pci_io_buf *buf = bc->buf;
+	char c;
+	int end;
+
+	if (!bc->started) {
+		dev_dbg(dev, "%s: Error: start not called\n", __func__);
+		return -1;
+	}
+	/* There's no EOL for boot commands so we fake it. */
+	if (bc->eol) {
+		bc->eol = false;
+		return '\n';
+	}
+
+	while (!octeontx_bootcmd_pending(dev, true)) {
+		WATCHDOG_RESET();
+		udelay(0);
+	}
+
+	__iormb();
+	c = buf->data[bc->copy_offset];
+	buf->data[bc->copy_offset++] = '\0';
+
+	end = bc->data_size < CONFIG_SYS_CBSIZE ?
+			bc->data_size - 1 : CONFIG_SYS_CBSIZE - 1;
+	if ((bc->copy_offset >= end) || (buf->data[bc->copy_offset] == '\0')) {
+		bc->copy_offset = 0;
+		buf->len = 0;
+		buf->owner = OCTEONTX_PCI_IO_BUF_OWNER_HOST;
+		bc->eol = true;
+	}
+	__iowmb();
+	flush_dcache_range((ulong)buf, (ulong)buf + bc->size);
+
+	return c;
+}
+
+/**
+ * stdio driver getc
+ *
+ * @param	dev	stdio device
+ * @return	character returned from input
+ */
+static int bootcmd_stdio_getc(struct stdio_dev *dev)
+{
+	const struct dm_serial_ops *ops;
+
+	if (!bootcmd_dev) {
+		printf("%s(%s): Error: bootcmd_dev NULL!\n",
+		       __func__, dev->name);
+		return -1;
+	}
+	ops = device_get_ops(bootcmd_dev);
+	return ops->getc(bootcmd_dev);
+}
+
+/**
+ * stdio driver testc
+ *
+ * @param	dev	stdio device
+ *
+ * @return	-1 on error, 1 if pending data, 0 if no data
+ */
+static int bootcmd_stdio_tstc(struct stdio_dev *dev)
+{
+	const struct dm_serial_ops *ops;
+
+	if (!bootcmd_dev) {
+		printf("%s(%s): Error: bootcmd_dev NULL!\n",
+		       __func__, dev->name);
+		return -1;
+	}
+	ops = device_get_ops(bootcmd_dev);
+
+	return ops->pending(bootcmd_dev, true);
+}
+
+/**
+ * Probe function for bootcmd driver
+ *
+ * @param	dev	serial device
+ *
+ * @return	0 for success, otherwise error
+ */
+static int octeontx_bootcmd_probe(struct udevice *dev)
+{
+	struct octeontx_bootcmd_data *bc;
+	struct octeontx_pci_io_buf *buf;
+	struct octeontx_bootcmd_platdata *plat = dev_get_platdata(dev);
+	struct stdio_dev bdev;
+	int ret;
+
+	dev_dbg(dev, "%s(%s)\n", __func__, dev->name);
+	bc = dev_get_priv(dev);
+	buf = (struct octeontx_pci_io_buf *)(plat->base);
+	bc->buf = buf;
+	bc->dev = dev;
+	bc->unlocked = true;
+	dev_dbg(dev, "%s: bootcmd IO buffer: %p\n", __func__, buf);
+	ret = octeontx_bootcmd_start(dev);
+	if (!ret) {
+		bootcmd_dev = dev;
+		memset(&bdev, 0, sizeof(bdev));
+		snprintf(bdev.name, sizeof(bdev.name), DRIVER_NAME);
+		bdev.flags = DEV_FLAGS_INPUT;
+		bdev.getc = bootcmd_stdio_getc;
+		bdev.tstc = bootcmd_stdio_tstc;
+		pr_debug("%s: Registering stdin driver %s from device %s, bootcmd_dev: %p\n",
+			 __func__, bdev.name, bootcmd_dev->name, bootcmd_dev);
+		ret = stdio_register(&bdev);
+		if (ret)
+			printf("%s: Error registering stdin device %s\n",
+			       __func__, bdev.name);
+	}
+	return ret;
+}
+
+/**
+ * Extracts the platform data from the device tree
+ *
+ * @param	dev	serial device
+ *
+ * @return	0 for success, otherwise error
+ */
+static int octeontx_bootcmd_ofdata_to_platdata(struct udevice *dev)
+{
+	struct octeontx_bootcmd_platdata *plat = dev_get_platdata(dev);
+	fdt_addr_t addr;
+	fdt_size_t size;
+
+	addr = devfdt_get_addr_size_index(dev, 0, &size);
+	dev_dbg(dev, "%s(%s): base: 0x%llx, size: 0x%llx\n", __func__,
+		dev->name, addr, size);
+	if (addr == FDT_ADDR_T_NONE)
+		return -EINVAL;
+
+	plat->base = addr;
+	plat->size = size;
+	return 0;
+}
+
+static const struct dm_serial_ops octeontx_bootcmd_ops = {
+	.putc = octeontx_bootcmd_putc,
+	.pending = octeontx_bootcmd_pending,
+	.getc = octeontx_bootcmd_getc,
+};
+
+static const struct udevice_id octeontx_bootcmd_serial_id[] = {
+	{ .compatible = "marvell,pci-bootcmd", },
+	{ },
+};
+
+U_BOOT_DRIVER(octeontx_bootcmd) = {
+	.name	= DRIVER_NAME,
+	.id	= UCLASS_SERIAL,
+	.of_match = of_match_ptr(octeontx_bootcmd_serial_id),
+	.ofdata_to_platdata = of_match_ptr(octeontx_bootcmd_ofdata_to_platdata),
+	.platdata_auto_alloc_size = sizeof(struct octeontx_bootcmd_platdata),
+	.probe = octeontx_bootcmd_probe,
+	.ops = &octeontx_bootcmd_ops,
+	.priv_auto_alloc_size = sizeof(struct octeontx_bootcmd_data),
+	.flags = DM_FLAG_PRE_RELOC,
+};
diff --git a/drivers/serial/serial_pl01x.c b/drivers/serial/serial_pl01x.c
index 45f1282..85259b8 100644
--- a/drivers/serial/serial_pl01x.c
+++ b/drivers/serial/serial_pl01x.c
@@ -41,6 +41,9 @@ static int pl01x_putc(struct pl01x_regs *regs, char c)
 	/* Send the character */
 	writel(c, &regs->dr);
 
+	while (!(readl(&regs->fr) & UART_PL01x_FR_TXFE))
+		WATCHDOG_RESET();
+
 	return 0;
 }
 
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 235a8c7..d86267d 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -63,6 +63,12 @@ config CADENCE_QSPI
 	  used to access the SPI NOR flash on platforms embedding this
 	  Cadence IP core.
 
+config OCTEONTX_SPI
+	bool "OcteonTX SPI driver"
+	help
+	  Enable the OcteonTX SPI driver. This driver can be used to
+	  access the SPI NOR flash on OcteonTX SoC platforms.
+
 config DESIGNWARE_SPI
 	bool "Designware SPI driver"
 	help
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 4b6000f..bd02fb7 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -21,6 +21,7 @@ obj-$(CONFIG_ATMEL_SPI) += atmel_spi.o
 obj-$(CONFIG_BCM63XX_HSSPI) += bcm63xx_hsspi.o
 obj-$(CONFIG_BCM63XX_SPI) += bcm63xx_spi.o
 obj-$(CONFIG_CADENCE_QSPI) += cadence_qspi.o cadence_qspi_apb.o
+obj-$(CONFIG_OCTEONTX_SPI) += octeontx_spi.o
 obj-$(CONFIG_CF_SPI) += cf_spi.o
 obj-$(CONFIG_DAVINCI_SPI) += davinci_spi.o
 obj-$(CONFIG_DESIGNWARE_SPI) += designware_spi.o
diff --git a/drivers/spi/kirkwood_spi.c b/drivers/spi/kirkwood_spi.c
index 1ad8cde..e5a4ef8 100644
--- a/drivers/spi/kirkwood_spi.c
+++ b/drivers/spi/kirkwood_spi.c
@@ -18,6 +18,15 @@
 #include <asm/arch/mpp.h>
 #endif
 #include <asm/arch-mvebu/spi.h>
+#include <mach/clock.h>
+
+/* This weak implementation is for handling older platforms (A38x, A39x)
+ * with pre-defined core clock value
+ */
+__weak u32 soc_tclk_get(void)
+{
+	return CONFIG_SYS_TCLK;
+}
 
 static void _spi_cs_activate(struct kwspi_registers *reg)
 {
@@ -29,6 +38,33 @@ static void _spi_cs_deactivate(struct kwspi_registers *reg)
 	clrbits_le32(&reg->ctrl, KWSPI_CSN_ACT);
 }
 
+static int _spi_direct_write(struct kwspi_registers *reg, unsigned int bitlen,
+			     const void *dout, void *din, unsigned long flags,
+			     void *direct_addr)
+{
+	unsigned int count = bitlen / 8;
+	unsigned int words = count / 4;
+	unsigned int rem = count % 4;
+
+	if (flags & SPI_XFER_BEGIN)
+		_spi_cs_activate(reg);
+
+	clrsetbits_le32(&reg->cfg, KWSPI_XFERLEN_MASK, KWSPI_XFERLEN_1BYTE);
+
+	if (words)
+		writesl(direct_addr, dout, words);
+	if (rem) {
+		u32 *buf = (u32 *)dout;
+
+		writesb(direct_addr, &buf[words], rem);
+	}
+
+	if (flags & SPI_XFER_END)
+		_spi_cs_deactivate(reg);
+
+	return 0;
+}
+
 static int _spi_xfer(struct kwspi_registers *reg, unsigned int bitlen,
 		     const void *dout, void *din, unsigned long flags)
 {
@@ -240,15 +276,24 @@ int spi_xfer(struct spi_slave *slave, unsigned int bitlen,
 }
 
 #else
+DECLARE_GLOBAL_DATA_PTR;
 
 /* Here now the DM part */
+#define CHIPSELECTS_NUM		8
+
+struct mvebu_spi_direct_acc {
+	void __iomem		*addr;
+	u32			size;
+};
 
 struct mvebu_spi_dev {
 	bool			is_errata_50mhz_ac;
 };
 
 struct mvebu_spi_platdata {
-	struct kwspi_registers *spireg;
+	struct kwspi_registers		*spireg;
+	struct mvebu_spi_direct_acc	direct_access[CHIPSELECTS_NUM];
+	bool is_errata_50mhz_ac;
 };
 
 struct mvebu_spi_priv {
@@ -259,16 +304,67 @@ static int mvebu_spi_set_speed(struct udevice *bus, uint hz)
 {
 	struct mvebu_spi_platdata *plat = dev_get_platdata(bus);
 	struct kwspi_registers *reg = plat->spireg;
-	u32 data;
+	u32 data, divider;
+	unsigned int spr, sppr;
 
-	/* calculate spi clock prescaller using max_hz */
-	data = ((CONFIG_SYS_TCLK / 2) / hz) + 0x10;
-	data = data < KWSPI_CLKPRESCL_MIN ? KWSPI_CLKPRESCL_MIN : data;
-	data = data > KWSPI_CLKPRESCL_MASK ? KWSPI_CLKPRESCL_MASK : data;
+	/*
+	 * Calculate spi clock prescaller using max_hz.
+	 * SPPR is SPI Baud Rate Pre-selection, it holds bits 5 and 7:6 in
+	 * SPI Interface Configuration Register;
+	 * SPR is SPI Baud Rate Selection, it holds bits 3:0 in SPI Interface
+	 * Configuration Register.
+	 * The SPR together with the SPPR define the SPI CLK frequency as
+	 * follows:
+	 * SPI actual frequency = core_clk / (SPR * (2 ^ SPPR))
+	 */
+	divider = DIV_ROUND_UP(soc_tclk_get(), hz);
+	if (divider < 16) {
+		/* This is the easy case, divider is less than 16 */
+		spr = divider;
+		sppr = 0;
+
+	} else {
+		unsigned int two_pow_sppr;
+		/*
+		 * Find the highest bit set in divider. This and the
+		 * three next bits define SPR (apart from rounding).
+		 * SPPR is then the number of zero bits that must be
+		 * appended:
+		 */
+		sppr = fls(divider) - 4;
+
+		/*
+		 * As SPR only has 4 bits, we have to round divider up
+		 * to the next multiple of 2 ** sppr.
+		 */
+		two_pow_sppr = 1 << sppr;
+		divider = (divider + two_pow_sppr - 1) & -two_pow_sppr;
+
+		/*
+		 * recalculate sppr as rounding up divider might have
+		 * increased it enough to change the position of the
+		 * highest set bit. In this case the bit that now
+		 * doesn't make it into SPR is 0, so there is no need to
+		 * round again.
+		 */
+		sppr = fls(divider) - 4;
+		spr = divider >> sppr;
+
+		/*
+		 * Now do range checking. SPR is constructed to have a
+		 * width of 4 bits, so this is fine for sure. So we
+		 * still need to check for sppr to fit into 3 bits:
+		 */
+		if (sppr > 7)
+			return -EINVAL;
+	}
+
+	data = ((sppr & 0x6) << 5) | ((sppr & 0x1) << 4) | spr;
 
 	/* program spi clock prescaler using max_hz */
 	writel(KWSPI_ADRLEN_3BYTE | data, &reg->cfg);
-	debug("data = 0x%08x\n", data);
+	debug("Core clock %d Hz, SPI CTRL data = 0x%08x\n",
+	      soc_tclk_get(), data);
 
 	return 0;
 }
@@ -310,7 +406,6 @@ static int mvebu_spi_set_mode(struct udevice *bus, uint mode)
 {
 	struct mvebu_spi_platdata *plat = dev_get_platdata(bus);
 	struct kwspi_registers *reg = plat->spireg;
-	const struct mvebu_spi_dev *drvdata;
 	u32 data = readl(&reg->cfg);
 
 	data &= ~(KWSPI_CPHA | KWSPI_CPOL | KWSPI_RXLSBF | KWSPI_TXLSBF);
@@ -324,8 +419,7 @@ static int mvebu_spi_set_mode(struct udevice *bus, uint mode)
 
 	writel(data, &reg->cfg);
 
-	drvdata = (struct mvebu_spi_dev *)dev_get_driver_data(bus);
-	if (drvdata->is_errata_50mhz_ac)
+	if (plat->is_errata_50mhz_ac)
 		mvebu_spi_50mhz_ac_timing_erratum(bus, mode);
 
 	return 0;
@@ -336,8 +430,13 @@ static int mvebu_spi_xfer(struct udevice *dev, unsigned int bitlen,
 {
 	struct udevice *bus = dev->parent;
 	struct mvebu_spi_platdata *plat = dev_get_platdata(bus);
+	void *direct_addr = plat->direct_access[spi_chip_select(dev)].addr;
 
-	return _spi_xfer(plat->spireg, bitlen, dout, din, flags);
+	if (dout && direct_addr)
+		return _spi_direct_write(plat->spireg, bitlen, dout,
+					 din, flags, direct_addr);
+	else
+		return _spi_xfer(plat->spireg, bitlen, dout, din, flags);
 }
 
 static int mvebu_spi_claim_bus(struct udevice *dev)
@@ -362,14 +461,57 @@ static int mvebu_spi_probe(struct udevice *bus)
 	writel(KWSPI_SMEMRDIRQ, &reg->irq_cause);
 	writel(KWSPI_IRQMASK, &reg->irq_mask);
 
+	/* Don't deassert CS between the direct mapped SPI transfers */
+	writel(0, &reg->dw_cfg);
+
 	return 0;
 }
 
 static int mvebu_spi_ofdata_to_platdata(struct udevice *bus)
 {
 	struct mvebu_spi_platdata *plat = dev_get_platdata(bus);
+	struct udevice *child_dev;
+	const struct mvebu_spi_dev *drvdata =
+		(struct mvebu_spi_dev *)dev_get_driver_data(bus);
 
 	plat->spireg = (struct kwspi_registers *)devfdt_get_addr(bus);
+	plat->is_errata_50mhz_ac = drvdata->is_errata_50mhz_ac;
+
+	list_for_each_entry(child_dev, &bus->child_head, sibling_node) {
+		int cs;
+		fdt_addr_t direct_addr;
+		fdt_size_t size;
+
+		/* Get chip-select number from the "reg" property */
+		cs = fdtdec_get_int(gd->fdt_blob, dev_of_offset(child_dev),
+				    "reg", -1);
+		if (cs == -1) {
+			printf("%s has no valid 'reg' property\n",
+			       child_dev->name);
+			continue;
+		}
+
+		/*
+		 * Check if an address is configured for this SPI device. If
+		 * not, the MBus mapping via the 'ranges' property in the 'soc'
+		 * node is not configured and this device should not use the
+		 * direct mode. In this case, just continue with the next
+		 * device.
+		 */
+		direct_addr = devfdt_get_addr_size_index(bus, cs + 1, &size);
+		if (direct_addr == FDT_ADDR_T_NONE) {
+			printf("\nBus %s CS%d address is not set correct.\n",
+			       bus->name, cs);
+			plat->direct_access[cs].addr = NULL;
+			continue;
+		}
+		plat->direct_access[cs].addr = (void *)direct_addr;
+		plat->direct_access[cs].size = size;
+		printf("\nBus %s CS%d configured for direct access %p:0x%x\n",
+		       bus->name, cs,
+		       plat->direct_access[cs].addr,
+		       plat->direct_access[cs].size);
+	}
 
 	return 0;
 }
@@ -385,6 +527,10 @@ static const struct dm_spi_ops mvebu_spi_ops = {
 	 */
 };
 
+static const struct mvebu_spi_dev armada_spi_dev_data = {
+	.is_errata_50mhz_ac = false,
+};
+
 static const struct mvebu_spi_dev armada_xp_spi_dev_data = {
 	.is_errata_50mhz_ac = false,
 };
@@ -399,6 +545,10 @@ static const struct mvebu_spi_dev armada_380_spi_dev_data = {
 
 static const struct udevice_id mvebu_spi_ids[] = {
 	{
+		.compatible = "marvell,orion-spi",
+		.data = (ulong)&armada_spi_dev_data,
+	},
+	{
 		.compatible = "marvell,armada-375-spi",
 		.data = (ulong)&armada_375_spi_dev_data
 	},
diff --git a/drivers/spi/mvebu_a3700_spi.c b/drivers/spi/mvebu_a3700_spi.c
index d1708a8..3e89abf 100644
--- a/drivers/spi/mvebu_a3700_spi.c
+++ b/drivers/spi/mvebu_a3700_spi.c
@@ -20,8 +20,24 @@ DECLARE_GLOBAL_DATA_PTR;
 #define MVEBU_SPI_A3700_BYTE_LEN		BIT(5)
 #define MVEBU_SPI_A3700_CLK_PHA			BIT(6)
 #define MVEBU_SPI_A3700_CLK_POL			BIT(7)
+#define MVEBU_SPI_A3700_DATA_PIN_DUAL		BIT(10)
+#define MVEBU_SPI_A3700_DATA_PIN_QUAD		BIT(11)
+#define MVEBU_SPI_A3700_ADDR_PIN		BIT(12)
 #define MVEBU_SPI_A3700_FIFO_EN			BIT(17)
 #define MVEBU_SPI_A3700_SPI_EN_0		BIT(16)
+#define MVEBU_SPI_A3700_WFIFO_FULL		BIT(7)
+#define MVEBU_SPI_A3700_WFIFO_EMPTY		BIT(6)
+#define MVEBU_SPI_A3700_RFIFO_EMPTY		BIT(4)
+#define MVEBU_SPI_A3700_WFIFO_RDY		BIT(3)
+#define MVEBU_SPI_A3700_RFIFO_RDY		BIT(2)
+#define MVEBU_SPI_A3700_XFER_START		BIT(15)
+#define MVEBU_SPI_A3700_XFER_STOP		BIT(14)
+#define MVEBU_SPI_A3700_RW_EN			BIT(8)
+#define MVEBU_SPI_A3700_WFIFO_THRS_BIT		28
+#define MVEBU_SPI_A3700_RFIFO_THRS_BIT		24
+#define MVEBU_SPI_A3700_FIFO_THRS_MASK		0x7
+#define MVEBU_SPI_A3700_ADDR_CNT_BIT		4
+#define MVEBU_SPI_A3700_ADDR_CNT_MASK		0x7
 #define MVEBU_SPI_A3700_CLK_PRESCALE_BIT	0
 #define MVEBU_SPI_A3700_CLK_PRESCALE_MASK	\
 	(0x1f << MVEBU_SPI_A3700_CLK_PRESCALE_BIT)
@@ -32,6 +48,11 @@ struct spi_reg {
 	u32 cfg;	/* 0x10604 */
 	u32 dout;	/* 0x10608 */
 	u32 din;	/* 0x1060c */
+	u32 inst_addr;	/* 0x10610 */
+	u32 addr;	/* 0x10614 */
+	u32 rmode;	/* 0x10618 */
+	u32 hdr_cnt;	/* 0x1061c */
+	u32 din_cnt;	/* 0x10620 */
 };
 
 struct mvebu_spi_platdata {
@@ -50,86 +71,282 @@ static void spi_cs_deactivate(struct spi_reg *reg, int cs)
 	clrbits_le32(&reg->ctrl, MVEBU_SPI_A3700_SPI_EN_0 << cs);
 }
 
-/**
- * spi_legacy_shift_byte() - triggers the real SPI transfer
- * @bytelen:	Indicate how many bytes to transfer.
- * @dout:	Buffer address of what to send.
- * @din:	Buffer address of where to receive.
- *
- * This function triggers the real SPI transfer in legacy mode. It
- * will shift out char buffer from @dout, and shift in char buffer to
- * @din, if necessary.
- *
- * This function assumes that only one byte is shifted at one time.
- * However, it is not its responisbility to set the transfer type to
- * one-byte. Also, it does not guarantee that it will work if transfer
- * type becomes two-byte. See spi_set_legacy() for details.
- *
- * In legacy mode, simply write to the SPI_DOUT register will trigger
- * the transfer.
- *
- * If @dout == NULL, which means no actual data needs to be sent out,
- * then the function will shift out 0x00 in order to shift in data.
- * The XFER_RDY flag is checked every time before accessing SPI_DOUT
- * and SPI_DIN register.
- *
- * The number of transfers to be triggerred is decided by @bytelen.
- *
- * Return:	0 - cool
- *		-ETIMEDOUT - XFER_RDY flag timeout
- */
-static int spi_legacy_shift_byte(struct spi_reg *reg, unsigned int bytelen,
-				 const void *dout, void *din)
+static void spi_pin_mode_set(struct spi_reg *reg, unsigned long flags)
 {
-	const u8 *dout_8;
-	u8 *din_8;
-	int ret;
+	unsigned int data;
+
+	data = readl(&reg->cfg);
+	data &= ~(MVEBU_SPI_A3700_DATA_PIN_DUAL |
+		  MVEBU_SPI_A3700_DATA_PIN_QUAD);
+
+	if (flags & SPI_XFER_DUAL)
+		data = data | MVEBU_SPI_A3700_DATA_PIN_DUAL;
+	else if (flags & SPI_XFER_QUAD)
+		data = data | MVEBU_SPI_A3700_DATA_PIN_QUAD;
+
+	writel(data, &reg->cfg);
+}
+
+static inline void spi_bytelen_set(struct spi_reg *reg, unsigned int len)
+{
+	unsigned int data;
+
+	data = readl(&reg->cfg);
+	if (len == 4)
+		data = data | MVEBU_SPI_A3700_BYTE_LEN;
+	else
+		data = data & (~MVEBU_SPI_A3700_BYTE_LEN);
 
-	/* Use 0x00 as dummy dout */
-	const u8 dummy_dout = 0x0;
-	u32 pending_dout = 0x0;
+	writel(data, &reg->cfg);
+}
+
+static inline int spi_is_wfifo_full(struct spi_reg *reg)
+{
+	u32 val;
 
-	/* dout_8: pointer of current dout */
-	dout_8 = dout;
-	/* din_8: pointer of current din */
-	din_8 = din;
+	val = readl(&reg->ctrl);
+	return val & MVEBU_SPI_A3700_WFIFO_FULL;
+}
+
+static inline int spi_is_wfifo_empty(struct spi_reg *reg)
+{
+	u32 val;
+
+	val = readl(&reg->ctrl);
+	return val & MVEBU_SPI_A3700_WFIFO_EMPTY;
+}
+
+static int spi_fifo_out(struct spi_reg *reg, unsigned int buf_len,
+			unsigned char *tx_buf)
+{
+	unsigned int val = 0;
+
+	while (!spi_is_wfifo_full(reg) && buf_len) {
+		val = (tx_buf[3] << 24) | (tx_buf[2] << 16) |
+				 (tx_buf[1] << 8) | tx_buf[0];
+
+		writel(val, &reg->dout);
+
+		buf_len -= 4;
+		tx_buf += 4;
+	}
+
+	/* Return the unwritten bytes number */
+	return buf_len;
+}
+
+static inline int spi_is_rfifo_empty(struct spi_reg *reg)
+{
+	u32 val;
+
+	val = readl(&reg->ctrl);
+	return val & MVEBU_SPI_A3700_RFIFO_EMPTY;
+}
+
+static int spi_fifo_in(struct spi_reg *reg, unsigned int buf_len,
+		       unsigned char *rx_buf)
+{
+	unsigned int val;
+
+	while (!spi_is_rfifo_empty(reg)) {
+		val = readl(&reg->din);
+		if (buf_len >= 4) {
+			rx_buf[0] = val & 0xff;
+			rx_buf[1] = (val >> 8) & 0xff;
+			rx_buf[2] = (val >> 16) & 0xff;
+			rx_buf[3] = (val >> 24) & 0xff;
+			buf_len -= 4;
+			rx_buf += 4;
+		} else {
+			/*
+			 * When remain bytes is smaller than 4, we should
+			 * avoid memory overwriting and and just write the
+			 * left rx buffer bytes.
+			 */
+			while (buf_len) {
+				*rx_buf++ = val & 0xff;
+				val >>= 8;
+				buf_len--;
+			}
+			break;
+		}
+	}
+
+	/* Return the unread bytes number */
+	return buf_len;
+}
+
+static int spi_fifo_xfer_finisher(struct spi_reg *reg, bool force_stop)
+{
+	unsigned int val;
+	int ret = 0;
+
+	val = readl(&reg->cfg);
+	if (force_stop) {
+		val |= MVEBU_SPI_A3700_XFER_STOP;
+		writel(val, &reg->cfg);
+	}
+
+	ret = wait_for_bit_le32(&reg->ctrl,
+				MVEBU_SPI_A3700_XFER_START, false, 100, false);
+	if (ret) {
+		printf("spi_fifo_abort_xfer timeout\n");
+		return ret;
+	}
+
+	val = readl(&reg->cfg);
+	if (force_stop) {
+		val &= ~MVEBU_SPI_A3700_XFER_STOP;
+		writel(val, &reg->cfg);
+	}
+
+	return ret;
+}
+
+static unsigned int spi_fifo_header_set(struct spi_reg *reg,
+					unsigned int bytelen, const void *dout)
+{
+	unsigned int addr_cnt = 0, val = 0, done_len = 0;
+	unsigned char *dout_ptr = (unsigned char *)dout;
 
+	/*
+	 * Clean number of bytes for instruction, address,
+	 * dummy field and read mode
+	 */
+	writel(0x0, &reg->inst_addr);
+	writel(0x0, &reg->addr);
+	writel(0x0, &reg->rmode);
+	writel(0x0, &reg->hdr_cnt);
+
+	if (bytelen % 4) {
+		addr_cnt = bytelen % 4;
+		val = ((addr_cnt & MVEBU_SPI_A3700_ADDR_CNT_MASK)
+			<< MVEBU_SPI_A3700_ADDR_CNT_BIT);
+
+		writel(val, &reg->hdr_cnt);
+		done_len = addr_cnt;
+
+		/* transfer 1~3 bytes by address count */
+		val = 0;
+		while (addr_cnt--) {
+			val = (val << 8) | dout_ptr[0];
+			dout_ptr++;
+		}
+		writel(val, &reg->addr);
+	}
+	return done_len;
+}
+
+static int spi_fifo_write(struct spi_reg *reg, unsigned int bytelen,
+			  const void *dout)
+{
+	unsigned int val;
+	int ret = 0;
+	unsigned char *char_p;
+	unsigned int len_done;
+	int remain_len;
+
+	/* when tx data is not 4 bytes aligned, there will be unexpected
+	 * MSB bytes of SPI output register, since it always shifts out
+	 * as whole 4 bytes. Which might causes incorrect transaction with
+	 * some device and flash. To fix this, Serial Peripheral Interface
+	 * Address (0xd0010614) in header count is used to transfer
+	 * 1 to 3 bytes to make the rest of data 4 bytes aligned.
+	 */
+	len_done = spi_fifo_header_set(reg, bytelen, dout);
+	bytelen -= len_done;
+
+	/* Start Write transfer */
+	val = readl(&reg->cfg);
+	val |= (MVEBU_SPI_A3700_XFER_START | MVEBU_SPI_A3700_RW_EN);
+	writel(val, &reg->cfg);
+
+	/* Write data to spi */
+	char_p = (unsigned char *)dout + len_done;
 	while (bytelen) {
 		ret = wait_for_bit_le32(&reg->ctrl,
-					MVEBU_SPI_A3700_XFER_RDY,
-					true,100, false);
-		if (ret)
+					MVEBU_SPI_A3700_WFIFO_RDY, true, 100,
+					false);
+		if (ret) {
+			printf("SPI: waiting write_fifo_ready timeout.n");
 			return ret;
+		}
 
-		if (dout)
-			pending_dout = (u32)*dout_8;
-		else
-			pending_dout = (u32)dummy_dout;
+		ret = wait_for_bit_le32(&reg->ctrl,
+					MVEBU_SPI_A3700_WFIFO_FULL,
+					false, 100, false);
+		if (ret) {
+			printf("SPI: write fifo is full.\n");
+			return ret;
+		}
 
-		/* Trigger the xfer */
-		writel(pending_dout, &reg->dout);
+		remain_len = spi_fifo_out(reg, bytelen, char_p);
+		/* move fifo out pointer to unfinished data for next shift */
+		char_p += bytelen - remain_len;
+		bytelen = remain_len;
+	}
 
-		if (din) {
-			ret = wait_for_bit_le32(&reg->ctrl,
-						MVEBU_SPI_A3700_XFER_RDY,
-						true, 100, false);
-			if (ret)
-				return ret;
+	ret = wait_for_bit_le32(&reg->ctrl,
+				MVEBU_SPI_A3700_WFIFO_EMPTY, true, 100, false);
+	if (ret) {
+		printf("SPI: waiting write_fifo_empty timeout.\n");
+		return ret;
+	}
 
-			/* Read what is transferred in */
-			*din_8 = (u8)readl(&reg->din);
-		}
+	/* When write xfer finishes, force stop is needed */
+	ret = spi_fifo_xfer_finisher(reg, true);
+
+	return ret;
+}
+
+static int spi_fifo_read(struct spi_reg *reg, unsigned int bytelen,
+			 void *din)
+{
+	unsigned int val;
+	int ret = 0;
+	unsigned char *char_p;
+	int remain_len;
 
-		/* Don't increment the current pointer if NULL */
-		if (dout)
-			dout_8++;
-		if (din)
-			din_8++;
+	/*
+	 * Clean number of bytes for instruction, address,
+	 * dummy field and read mode
+	 */
+	writel(0x0, &reg->inst_addr);
+	writel(0x0, &reg->addr);
+	writel(0x0, &reg->rmode);
+	writel(0x0, &reg->hdr_cnt);
+
+	/* Set read data length */
+	writel(bytelen, &reg->din_cnt);
+	/* Start READ transfer */
+	val = readl(&reg->cfg);
+	val &= ~MVEBU_SPI_A3700_RW_EN;
+	val |= MVEBU_SPI_A3700_XFER_START;
+
+	writel(val, &reg->cfg);
+
+	/* Read data from spi */
+	char_p = (unsigned char *)din;
+
+	while (bytelen) {
+		ret = wait_for_bit_le32(&reg->ctrl,
+					MVEBU_SPI_A3700_RFIFO_RDY,
+					true, 100, false);
+		if (ret) {
+			printf("SPI: read fifo ready is timeout.\n");
+			return ret;
+		}
 
-		bytelen--;
+		remain_len = spi_fifo_in(reg, bytelen, char_p);
+		/* Move fifo in pointer to unfinished data for next shift */
+		char_p += bytelen - remain_len;
+		bytelen = remain_len;
 	}
 
-	return 0;
+	/* When read xfer finishes, force stop is not needed. */
+	ret = spi_fifo_xfer_finisher(reg, false);
+
+	return ret;
 }
 
 static int mvebu_spi_xfer(struct udevice *dev, unsigned int bitlen,
@@ -139,7 +356,8 @@ static int mvebu_spi_xfer(struct udevice *dev, unsigned int bitlen,
 	struct mvebu_spi_platdata *plat = dev_get_platdata(bus);
 	struct spi_reg *reg = plat->spireg;
 	unsigned int bytelen;
-	int ret;
+	int ret = 0;
+	u32 data;
 
 	bytelen = bitlen / 8;
 
@@ -152,26 +370,39 @@ static int mvebu_spi_xfer(struct udevice *dev, unsigned int bitlen,
 		spi_cs_activate(reg, spi_chip_select(dev));
 	}
 
-	/* Send and/or receive */
-	if (dout || din) {
-		ret = spi_legacy_shift_byte(reg, bytelen, dout, din);
-		if (ret)
-			return ret;
+	/* Set data transfer pins number */
+	spi_pin_mode_set(reg, flags);
+
+	/* Flush read/write FIFO */
+	data = readl(&reg->cfg);
+	writel(data | MVEBU_SPI_A3700_FIFO_FLUSH, &reg->cfg);
+	ret = wait_for_bit_le32(&reg->cfg, MVEBU_SPI_A3700_FIFO_FLUSH,
+				false, 1000, false);
+	if (ret) {
+		printf("SPI: fifo flush action is timeout.\n");
+		return ret;
 	}
 
+	/* Send and/or receive */
+	if (dout)
+		ret = spi_fifo_write(reg, bytelen, dout);
+	else if (din)
+		ret = spi_fifo_read(reg, bytelen, din);
+
 	/* Deactivate CS */
 	if (flags & SPI_XFER_END) {
-		ret = wait_for_bit_le32(&reg->ctrl,
-					MVEBU_SPI_A3700_XFER_RDY,
+		ret = wait_for_bit_le32(&reg->ctrl, MVEBU_SPI_A3700_XFER_RDY,
 					true, 100, false);
-		if (ret)
+		if (ret) {
+			printf("SPI: spi transfer data ready timeout\n");
 			return ret;
+		}
 
 		debug("SPI: deactivate cs.\n");
 		spi_cs_deactivate(reg, spi_chip_select(dev));
 	}
 
-	return 0;
+	return ret;
 }
 
 static int mvebu_spi_set_speed(struct udevice *bus, uint hz)
@@ -224,11 +455,6 @@ static int mvebu_spi_probe(struct udevice *bus)
 	u32 data;
 	int ret;
 
-	/*
-	 * Settings SPI controller to be working in legacy mode, which
-	 * means use only DO pin (I/O 1) for Data Out, and DI pin (I/O 0)
-	 * for Data In.
-	 */
 
 	/* Flush read/write FIFO */
 	data = readl(&reg->cfg);
@@ -238,14 +464,33 @@ static int mvebu_spi_probe(struct udevice *bus)
 	if (ret)
 		return ret;
 
-	/* Disable FIFO mode */
-	data &= ~MVEBU_SPI_A3700_FIFO_EN;
+	/* Enable FIFO mode */
+	data |= MVEBU_SPI_A3700_FIFO_EN;
 
-	/* Always shift 1 byte at a time */
-	data &= ~MVEBU_SPI_A3700_BYTE_LEN;
+	/*
+	 * Set FIFO threshold
+	 * For read FIFO threshold, value 0 presents 1 data entry, which means
+	 * when data in the read FIFO is equal to or greater than 1 entry,
+	 * flag RFIFO_RDY_IS will be set;
+	 * For write FIFO threshold, value 7 presents 7 data entry, which means
+	 * when data in the write FIFO is less than or equal to 7 entry,
+	 * flag WFIFO_RDY_IS will be set;
+	 */
+	data |= 0 << MVEBU_SPI_A3700_RFIFO_THRS_BIT;
+	data |= 7 << MVEBU_SPI_A3700_WFIFO_THRS_BIT;
+
+	/*
+	 * Address Register is used to send none 4 byte aligned
+	 * header data at first while Data Out/In register is used to
+	 * send remain 4 byte aligned data, so address transfer pins
+	 * number should be same as data pins;
+	 */
+	data |= MVEBU_SPI_A3700_ADDR_PIN;
 
 	writel(data, &reg->cfg);
 
+	/* set shift 4 bytes for writing and reading */
+	spi_bytelen_set(reg, 4);
 	return 0;
 }
 
diff --git a/drivers/spi/octeontx_spi.c b/drivers/spi/octeontx_spi.c
new file mode 100755
index 0000000..9fbbdef
--- /dev/null
+++ b/drivers/spi/octeontx_spi.c
@@ -0,0 +1,675 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <spi.h>
+#include <asm/io.h>
+#include <malloc.h>
+#include <dm.h>
+#include <asm/arch/clock.h>
+#include <asm/unaligned.h>
+#include <watchdog.h>
+
+#if defined(CONFIG_ARCH_OCTEONTX2)
+#include <asm/arch/octeontx2.h>
+#define USE_TBI_CLK
+#endif
+
+#define OCTEONTX_SPI_MAX_BYTES		9
+#define OCTEONTX_SPI_MAX_CLOCK_HZ	50000000
+
+#define OCTEONTX2_TBI_CLK		100000000
+
+#define OCTEONTX_SPI_NUM_CS		4
+
+#define OCTEONTX_SPI_CS_VALID(cs)	((cs) < OCTEONTX_SPI_NUM_CS)
+
+#define MPI_CFG				0x1000
+#define MPI_STS				0x1008
+#define MPI_TX				0x1010
+#define MPI_XMIT			0x1018
+#define MPI_WIDE_DAT			0x1040
+#define MPI_IO_CTL			0x1048
+#define MPI_DAT(X)			(0x1080 + ((X) << 3))
+#define MPI_WIDE_BUF(X)			(0x1800 + ((X) << 3))
+#define MPI_CYA_CFG			0x2000
+#define MPI_CLKEN			0x2080
+
+union mpi_cfg {
+	uint64_t u;
+	struct mpi_cfg_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t		:14;
+		uint64_t tb100_en	:1;
+		uint64_t		:1;
+		uint64_t cs_espi_en	:4;
+		uint64_t		:8;
+		uint64_t iomode		:2;
+		uint64_t		:2;
+		uint64_t legacy_dis	:1;
+		uint64_t		:2;
+		uint64_t clkdiv		:13;	/** clock divisor */
+		uint64_t csena3		:1;	/** cs enable 3. */
+		uint64_t csena2		:1;	/** cs enable 2 */
+		uint64_t csena1		:1;	/** cs enable 1 */
+		uint64_t csena0		:1;	/** cs enable 0 */
+		/**
+		 * 0 = SPI_CSn asserts 1/2 coprocessor-clock cycle before
+		 *     transaction
+		 * 1 = SPI_CSn asserts coincident with transaction
+		 */
+		uint64_t cslate		:1;
+		/**
+		 * Tristate TX.  Set to 1 to tristate SPI_DO when not
+		 * transmitting.
+		 */
+		uint64_t tritx		:1;
+		/**
+		 * When set, guarantees idle coprocessor-clock cycles between
+		 * commands.
+		 */
+		uint64_t idleclks	:2;
+		/**
+		 * SPI_CSn_L high.  1 = SPI_CSn_L is asserted high,
+		 * 0 = SPI_CS_n asserted low.
+		 */
+		uint64_t cshi		:1;
+		uint64_t rsvd		:1;	/** Reserved */
+		uint64_t cs_sticky	:1;	/** cs sticky bit */
+		/** 0 = shift MSB first, 1 = shift LSB first */
+		uint64_t lsbfirst	:1;
+		/**
+		 * Wire-or DO and DI.
+		 * 0 = SPI_DO and SPI_DI are separate wires (SPI).  SPI_DO pin
+		 *     is always driven.
+		 * 1 = SPI_DO/DI is all from SPI_DO pin (MPI).  SPI_DO pin is
+		 *     tristated when not transmitting.  If WIREOR = 1, SPI_DI
+		 *     pin is not used by the MPI/SPI engine.
+		 */
+		uint64_t wireor		:1;
+		/**
+		 * Clock control.
+		 * 0 = Clock idles to value given by IDLELO after completion of
+		 *     MPI/SPI transaction.
+		 * 1 = Clock never idles, requires SPI_CSn_L
+		 *     deassertion/assertion between commands.
+		 */
+		uint64_t clk_cont	:1;
+		/**
+		 * Clock idle low/clock invert
+		 * 0 = SPI_CLK idles high, first transition is high-to-low.
+		 *     This correspondes to SPI Block Guide options CPOL = 1,
+		 *     CPHA = 0.
+		 * 1 = SPI_CLK idles low, first transition is low-to-high.  This
+		 *     corresponds to SPI Block Guide options CPOL = 0, CPHA = 0.
+		 */
+		uint64_t idlelo		:1;
+		/** MPI/SPI enable, 0 = pins are tristated, 1 = pins driven */
+		uint64_t enable		:1;
+#else /* Word 0 - Little Endian */
+		uint64_t enable		:1;
+		uint64_t idlelo		:1;
+		uint64_t clk_cont	:1;
+		uint64_t wireor		:1;
+		uint64_t lsbfirst	:1;
+		uint64_t cs_sticky	:1;
+		uint64_t rsvd		:1;
+		uint64_t cshi		:1;
+		uint64_t idleclks	:2;
+		uint64_t tritx		:1;
+		uint64_t cslate		:1;
+		uint64_t csena0		:1;
+		uint64_t csena1		:1;
+		uint64_t csena2		:1;
+		uint64_t csena3		:1;
+		uint64_t clkdiv		:13;
+		uint64_t		:2;
+		uint64_t legacy_dis	:1;
+		uint64_t		:2;
+		uint64_t iomode		:2;
+		uint64_t		:8;
+		uint64_t cs_espi_en	:4;
+		uint64_t		:1;
+		uint64_t tb100_en	:1;
+		uint64_t		:14;
+#endif /* Word 0 - End */
+	} s;
+	/* struct mpi_cfg_s cn; */
+};
+
+/**
+ * Register (NCB) mpi_dat#
+ *
+ * MPI/SPI Data Registers
+ */
+union mpi_dat {
+	uint64_t u;
+	struct mpi_datx_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t reserved_8_63	:56;
+		/**< [  7:  0](R/W/H) Data to transmit/receive. */
+		uint64_t data		:8;
+#else /* Word 0 - Little Endian */
+		uint64_t data		:8;
+		uint64_t reserved_8_63	:56;
+#endif /* Word 0 - End */
+	} s;
+	/* struct mpi_datx_s cn; */
+};
+
+/**
+ * Register (NCB) mpi_sts
+ *
+ * MPI/SPI STS Register
+ */
+union mpi_sts {
+	uint64_t u;
+	struct mpi_sts_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t reserved_40_63	:24;
+		uint64_t crc		:8;
+		uint64_t		:5;
+		uint64_t crc_err	:1;
+		uint64_t		:6;
+		uint64_t rxnum		:5;	/** Number of bytes */
+		uint64_t reserved_2_7	:6;
+		uint64_t mpi_intr	:1;	/** Transaction done int */
+		uint64_t busy		:1;	/** SPI engine busy */
+#else /* Word 0 - Little Endian */
+		uint64_t busy		:1;
+		uint64_t mpi_intr	:1;
+		uint64_t reserved_2_7	:6;
+		uint64_t rxnum		:5;
+		uint64_t		:6;
+		uint64_t crc_err	:1;
+		uint64_t		:5;
+		uint64_t crc		:8;
+		uint64_t reserved_40_63	:24;
+#endif /* Word 0 - End */
+	} s;
+	/* struct mpi_sts_s cn; */
+};
+
+/**
+ * Register (NCB) mpi_tx
+ *
+ * MPI/SPI Transmit Register
+ */
+union mpi_tx {
+	uint64_t u;
+	struct mpi_tx_s {
+#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
+		uint64_t		:42;	/* Reserved */
+		uint64_t csid 		:2;	/** Which CS to assert */
+		uint64_t		:3;	/* Reserved */
+		uint64_t leavecs	:1;	/** Leave CSn asserted */
+		uint64_t 		:3;	/* Reserved */
+		uint64_t txnum		:5;	/** Number of words to tx */
+		uint64_t		:3;	/* Reserved */
+		uint64_t totnum		:5;	/** Total bytes to shift */
+#else /* Word 0 - Little Endian */
+		uint64_t totnum		:5;
+		uint64_t 		:3;
+		uint64_t txnum		:5;
+		uint64_t		:3;
+		uint64_t leavecs	:1;
+		uint64_t		:3;
+		uint64_t csid		:2;
+		uint64_t		:42;
+#endif /* Word 0 - End */
+	} s;
+	/* struct mpi_tx_s cn; */
+};
+
+#if defined(CONFIG_ARCH_OCTEONTX2)
+/**
+ * Register (NCB) mpi#_xmit
+ *
+ * MPI/SPI Transmit Register
+ */
+union mpi_xmit {
+	u64 u;
+	struct mpi_xmit_s {
+		u64 totnum		: 11;
+		u64 reserved_11_19	: 9;
+		u64 txnum		: 11;
+		u64 reserved_31_59	: 29;
+		u64 leavecs		: 1;
+		u64 csid		: 2;
+		u64 reserved_63		: 1;
+	} s;
+};
+#endif
+
+/** Local driver data structure */
+struct octeontx_spi {
+	void *baseaddr;		/** Register base address */
+	u32 clkdiv;		/** Clock divisor for device speed */
+	bool is_otx2;		/** Gen 2 SoC */
+};
+
+static union mpi_cfg octeontx_spi_set_mpicfg(struct udevice *dev)
+{
+	struct dm_spi_slave_platdata *slave = dev_get_parent_platdata(dev);
+	struct udevice *bus = dev_get_parent(dev);
+	struct octeontx_spi *priv = dev_get_priv(bus);
+	union mpi_cfg mpi_cfg;
+	uint max_speed = slave->max_hz;
+	bool cpha, cpol;
+
+	if (!max_speed)
+		max_speed = 12500000;
+	if (max_speed > OCTEONTX_SPI_MAX_CLOCK_HZ)
+		max_speed = OCTEONTX_SPI_MAX_CLOCK_HZ;
+
+	debug ("\n slave params %d %d %d \n", slave->cs,
+		slave->max_hz, slave->mode);
+	cpha = !!(slave->mode & SPI_CPHA);
+	cpol = !!(slave->mode & SPI_CPOL);
+
+	mpi_cfg.u = 0;
+	mpi_cfg.s.clkdiv = priv->clkdiv & 0x1fff;
+	mpi_cfg.s.cshi = !!(slave->mode & SPI_CS_HIGH);
+	mpi_cfg.s.lsbfirst = !!(slave->mode & SPI_LSB_FIRST);
+	mpi_cfg.s.wireor = !!(slave->mode & SPI_3WIRE);
+	mpi_cfg.s.idlelo = cpha != cpol;
+	mpi_cfg.s.cslate = cpha;
+	mpi_cfg.s.enable = 1;
+	mpi_cfg.s.csena0 = 1;
+	mpi_cfg.s.csena1 = 1;
+	mpi_cfg.s.csena2 = 1;
+	mpi_cfg.s.csena3 = 1;
+
+	debug("\n mpi_cfg %llx\n",mpi_cfg.u);
+	return mpi_cfg;
+}
+
+/**
+ * Wait until the SPI bus is ready
+ *
+ * @param	dev	SPI device to wait for
+ */
+static void octeontx_spi_wait_ready(struct udevice *dev)
+{
+	struct udevice *bus = dev_get_parent(dev);
+	struct octeontx_spi *priv = dev_get_priv(bus);
+	void *baseaddr = priv->baseaddr;
+	union mpi_sts mpi_sts;
+
+	do {
+		mpi_sts.u = readq(baseaddr + MPI_STS);
+		WATCHDOG_RESET();
+	} while (mpi_sts.s.busy);
+	debug("%s(%s)\n", __func__, dev->name);
+}
+/**
+ * Claim the bus for a slave device
+ *
+ * @param	dev	SPI bus
+ *
+ * @return	0 for success, -EINVAL if chip select is invalid
+ */
+static int octeontx_spi_claim_bus(struct udevice *dev)
+{
+	struct udevice *bus = dev_get_parent(dev);
+	struct octeontx_spi *priv = dev_get_priv(bus);
+	void *baseaddr = priv->baseaddr;
+	union mpi_cfg mpi_cfg;
+
+	debug("\n\n%s(%s)\n", __func__, dev->name);
+	if (!OCTEONTX_SPI_CS_VALID(spi_chip_select(dev)))
+		return -EINVAL;
+
+#if defined(CONFIG_ARCH_OCTEONTX2)
+	acquire_flash_arb(true);
+#endif
+
+	mpi_cfg.u = readq(baseaddr + MPI_CFG);
+	mpi_cfg.s.tritx = 0;
+	mpi_cfg.s.enable = 1;
+	writeq(mpi_cfg.u, baseaddr + MPI_CFG);
+
+	return 0;
+}
+
+/**
+ * Release the bus to a slave device
+ *
+ * @param	dev	SPI bus
+ *
+ * @return	0 for success, -EINVAL if chip select is invalid
+ */
+static int octeontx_spi_release_bus(struct udevice *dev)
+{
+	struct udevice *bus = dev_get_parent(dev);
+	struct octeontx_spi *priv = dev_get_priv(bus);
+	void *baseaddr = priv->baseaddr;
+	union mpi_cfg mpi_cfg;
+
+	debug("%s(%s)\n\n", __func__, dev->name);
+	if (!OCTEONTX_SPI_CS_VALID(spi_chip_select(dev)))
+		return -EINVAL;
+
+#if defined(CONFIG_ARCH_OCTEONTX2)
+	acquire_flash_arb(false);
+#endif
+
+	mpi_cfg.u = readq(baseaddr + MPI_CFG);
+	mpi_cfg.s.enable = 0;
+	writeq(mpi_cfg.u, baseaddr + MPI_CFG);
+
+	return 0;
+}
+
+#if defined(CONFIG_ARCH_OCTEONTX)
+static int octeontx_spi_xfer(struct udevice *dev, unsigned int bitlen,
+			     const void *dout, void *din, unsigned long flags)
+{
+	struct udevice *bus = dev_get_parent(dev);
+	struct octeontx_spi *priv = dev_get_priv(bus);
+	void *baseaddr = priv->baseaddr;
+	union mpi_tx mpi_tx;
+	union mpi_cfg mpi_cfg;
+	uint64_t wide_dat = 0;
+	int len = bitlen / 8;
+	int i;
+	const uint8_t *tx_data = dout;
+	uint8_t *rx_data = din;
+	int cs = spi_chip_select(dev);
+
+	if (!OCTEONTX_SPI_CS_VALID(cs))
+		return -EINVAL;
+
+	debug("\n %s(%s, %u, %p, %p, 0x%lx), cs: %d\n",
+	      __func__, dev->name, bitlen, dout, din, flags, cs);
+
+	mpi_cfg = octeontx_spi_set_mpicfg(dev);
+
+	if (mpi_cfg.u != readq(baseaddr + MPI_CFG))
+		writeq(mpi_cfg.u, baseaddr + MPI_CFG);
+
+	debug("\n mpi_cfg upd %llx\n", mpi_cfg.u);
+
+	/* Start by writing and reading 8 bytes at a time.  While we can support
+	 * up to 10, it's easier to just use 8 with the MPI_WIDE_DAT register.
+	 */
+	while (len > 8) {
+		if (tx_data) {
+			wide_dat = get_unaligned((uint64_t *)tx_data);
+			debug("  tx: %016llx \t", (unsigned long long)wide_dat);
+			tx_data += 8;
+			writeq(wide_dat, baseaddr + MPI_WIDE_DAT);
+		}
+
+		mpi_tx.u = 0;
+		mpi_tx.s.csid = cs;
+		mpi_tx.s.leavecs = 1;
+		mpi_tx.s.txnum = tx_data ? 8 : 0;
+		mpi_tx.s.totnum = 8;
+		writeq(mpi_tx.u, baseaddr + MPI_TX);
+
+		octeontx_spi_wait_ready(dev);
+
+		debug("\n ");
+
+		if (rx_data) {
+			wide_dat = readq(baseaddr + MPI_WIDE_DAT);
+			debug("  rx: %016llx\t", (unsigned long long)wide_dat);
+			*(uint64_t *)rx_data = wide_dat;
+			rx_data += 8;
+		}
+		len -= 8;
+	}
+
+	debug("\n ");
+
+	/* Write and read the rest of the data */
+	if (tx_data) {
+		for (i = 0; i < len; i++) {
+			debug("  tx: %02x\n", *tx_data);
+			writeq(*tx_data++, baseaddr + MPI_DAT(i));
+		}
+	}
+	mpi_tx.u = 0;
+	mpi_tx.s.csid = cs;
+	mpi_tx.s.leavecs = !(flags & SPI_XFER_END);
+	mpi_tx.s.txnum = tx_data ? len : 0;
+	mpi_tx.s.totnum = len;
+	writeq(mpi_tx.u, baseaddr + MPI_TX);
+
+	octeontx_spi_wait_ready(dev);
+
+	debug("\n ");
+
+	if (rx_data) {
+		for (i = 0; i < len; i++) {
+			*rx_data = readq(baseaddr + MPI_DAT(i)) & 0xff;
+			debug("  rx: %02x\n", *rx_data);
+			rx_data++;
+		}
+	}
+
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_ARCH_OCTEONTX2)
+static int octeontx_spi_xfer(struct udevice *dev, unsigned int bitlen,
+			     const void *dout, void *din, unsigned long flags)
+{
+	struct udevice *bus = dev_get_parent(dev);
+	struct octeontx_spi *priv = dev_get_priv(bus);
+	void *baseaddr = priv->baseaddr;
+	union mpi_xmit mpi_xmit;
+	union mpi_cfg mpi_cfg;
+	u64 wide_dat = 0;
+	int len = bitlen / 8;
+	int rem;
+	int i;
+	const u8 *tx_data = dout;
+	u8 *rx_data = din;
+	int cs = spi_chip_select(dev);
+
+	if (!OCTEONTX_SPI_CS_VALID(cs))
+		return -EINVAL;
+
+	debug("\n %s(%s, %u, %p, %p, 0x%lx), cs: %d\n",
+	      __func__, dev->name, bitlen, dout, din, flags, cs);
+
+	mpi_cfg = octeontx_spi_set_mpicfg(dev);
+
+	mpi_cfg.s.legacy_dis = 1;
+	mpi_cfg.s.cs_sticky = 1;
+#ifdef USE_TBI_CLK
+	mpi_cfg.s.tb100_en = 1;
+#endif
+	mpi_cfg.s.iomode = 0;
+	if (flags & SPI_XFER_DUAL)
+		mpi_cfg.s.iomode = 2;
+	if (flags & SPI_XFER_QUAD)
+		mpi_cfg.s.iomode = 3;
+
+	if (mpi_cfg.u != readq(baseaddr + MPI_CFG))
+		writeq(mpi_cfg.u, baseaddr + MPI_CFG);
+
+	debug("\n mpi_cfg upd %llx\n\n", mpi_cfg.u);
+
+	/* Start by writing or reading 1024 bytes at a time. */
+	while (len > 1024) {
+		if (tx_data) {
+			/* 8 bytes per iteration */
+			for (i = 0; i < 128; i++) {
+				wide_dat = get_unaligned((uint64_t *)tx_data);
+				debug("  tx: %016llx \t",
+				      (unsigned long long)wide_dat);
+				if ((i % 4) == 3)
+					debug("\n");
+				tx_data += 8;
+				writeq(wide_dat, baseaddr + MPI_WIDE_BUF(i));
+			}
+		}
+
+		mpi_xmit.u = 0;
+		mpi_xmit.s.csid = cs;
+		mpi_xmit.s.leavecs = 1;
+		mpi_xmit.s.txnum = tx_data ? 1024 : 0;
+		mpi_xmit.s.totnum = 1024;
+		writeq(mpi_xmit.u, baseaddr + MPI_XMIT);
+
+		octeontx_spi_wait_ready(dev);
+
+		debug("\n ");
+
+		if (rx_data) {
+			/* 8 bytes per iteration */
+			for (i = 0; i < 128; i++) {
+				wide_dat = readq(baseaddr + MPI_WIDE_BUF(i));
+				debug("  rx: %016llx\t",
+				      (unsigned long long)wide_dat);
+				if ((i % 4) == 3)
+					debug("\n");
+				*(uint64_t *)rx_data = wide_dat;
+				rx_data += 8;
+			}
+		}
+		len -= 1024;
+	}
+
+	if (tx_data) {
+		rem = len % 8;
+		/* 8 bytes per iteration */
+		for (i = 0; i < len / 8; i++) {
+			wide_dat = get_unaligned((uint64_t *)tx_data);
+			debug("  tx: %016llx \t",
+			      (unsigned long long)wide_dat);
+			if ((i % 4) == 3)
+				debug("\n");
+			tx_data += 8;
+			writeq(wide_dat, baseaddr + MPI_WIDE_BUF(i));
+		}
+		if (rem) {
+			memcpy(&wide_dat, tx_data, rem);
+			debug("  rtx: %016llx\t", wide_dat);
+			writeq(wide_dat, baseaddr + MPI_WIDE_BUF(i));
+		}
+	}
+
+	mpi_xmit.u = 0;
+	mpi_xmit.s.csid = cs;
+	mpi_xmit.s.leavecs = !(flags & SPI_XFER_END);
+	mpi_xmit.s.txnum = tx_data ? len : 0;
+	mpi_xmit.s.totnum = len;
+	writeq(mpi_xmit.u, baseaddr + MPI_XMIT);
+
+	octeontx_spi_wait_ready(dev);
+
+	debug("\n ");
+
+	if (rx_data) {
+		rem = len % 8;
+		/* 8 bytes per iteration */
+		for (i = 0; i < len / 8; i++) {
+			wide_dat = readq(baseaddr + MPI_WIDE_BUF(i));
+			debug("  rx: %016llx\t",
+			      (unsigned long long)wide_dat);
+			if ((i % 4) == 3)
+				debug("\n");
+			*(uint64_t *)rx_data = wide_dat;
+			rx_data += 8;
+		}
+		if (rem) {
+			wide_dat = readq(baseaddr + MPI_WIDE_BUF(i));
+			debug("  rrx: %016llx\t",
+			      (unsigned long long)wide_dat);
+			memcpy(rx_data, &wide_dat, rem);
+			rx_data += rem;
+		}
+	}
+
+	return 0;
+}
+#endif
+
+/**
+ * Set the speed of the SPI bus
+ *
+ * @param	bus	bus to set
+ * @param	max_hz	maximum speed supported
+ */
+static int octeontx_spi_set_speed(struct udevice *bus, uint max_hz)
+{
+	struct octeontx_spi *priv = dev_get_priv(bus);
+	u64 refclk = octeontx_get_io_clock();
+	u32 calc_hz;
+
+	debug("%s(%s, %u, %llu)\n", __func__, bus->name, max_hz, refclk);
+
+	if (max_hz > OCTEONTX_SPI_MAX_CLOCK_HZ)
+		max_hz = OCTEONTX_SPI_MAX_CLOCK_HZ;
+
+#ifdef USE_TBI_CLK
+	refclk = OCTEONTX2_TBI_CLK;
+#endif
+	priv->clkdiv = refclk / (2 * max_hz);
+	while (1) {
+		calc_hz = refclk / (2 * priv->clkdiv);
+		if (calc_hz <= max_hz)
+			break;
+		priv->clkdiv += 1;
+	}
+	if (priv->clkdiv > 8191)
+		return -1;
+
+	debug("%s %d\n", __func__, priv->clkdiv);
+
+	return 0;
+}
+
+static int octeontx_spi_set_mode(struct udevice *bus, uint mode)
+{
+	/* We don't set it here */
+	return 0;
+}
+
+static int octeontx_pci_spi_probe(struct udevice *dev)
+{
+	struct octeontx_spi *priv = dev_get_priv(dev);
+	pci_dev_t bdf = dm_pci_get_bdf(dev);
+	size_t size;
+
+	debug("SPI PCI device: %x\n", bdf);
+	dev->req_seq = PCI_FUNC(bdf);
+	priv->baseaddr = dm_pci_map_bar(dev, 0, &size, PCI_REGION_MEM);
+
+	debug("SPI bus %s %d at %p\n",dev->name, dev->seq, priv->baseaddr);
+
+	return 0;
+}
+
+static const struct dm_spi_ops octeontx_spi_ops = {
+	.claim_bus	= octeontx_spi_claim_bus,
+	.release_bus	= octeontx_spi_release_bus,
+	.xfer		= octeontx_spi_xfer,
+	.set_speed	= octeontx_spi_set_speed,
+	.set_mode	= octeontx_spi_set_mode,
+};
+
+static const struct udevice_id octeontx_spi_ids[] = {
+	{ .compatible	= "cavium,thunder-8890-spi" },
+	{ .compatible	= "cavium,thunder-8190-spi" },
+	{ }
+};
+
+U_BOOT_DRIVER(octeontx_pci_spi) = {
+	.name			= "spi_octeontx",
+	.id			= UCLASS_SPI,
+	.of_match 		= octeontx_spi_ids,
+	.probe			= octeontx_pci_spi_probe,
+	.priv_auto_alloc_size 	= sizeof(struct octeontx_spi),
+	.ops			= &octeontx_spi_ops,
+};
+
diff --git a/drivers/spi/spi-uclass.c b/drivers/spi/spi-uclass.c
index 15d90a5..3b51401 100644
--- a/drivers/spi/spi-uclass.c
+++ b/drivers/spi/spi-uclass.c
@@ -91,6 +91,30 @@ int dm_spi_xfer(struct udevice *dev, unsigned int bitlen,
 	return spi_get_ops(bus)->xfer(dev, bitlen, dout, din, flags);
 }
 
+bool dm_spi_is_flash_command_supported(struct udevice *dev,
+				       const struct spi_flash_command *cmd)
+{
+	struct udevice *bus = dev->parent;
+	struct dm_spi_ops *ops = spi_get_ops(bus);
+
+	if (ops->is_flash_command_supported)
+		return ops->is_flash_command_supported(dev, cmd);
+
+	return false;
+}
+
+int dm_spi_exec_flash_command(struct udevice *dev,
+			      const struct spi_flash_command *cmd)
+{
+	struct udevice *bus = dev->parent;
+	struct dm_spi_ops *ops = spi_get_ops(bus);
+
+	if (ops->exec_flash_command)
+		return ops->exec_flash_command(dev, cmd);
+
+	return -EINVAL;
+}
+
 int spi_claim_bus(struct spi_slave *slave)
 {
 	return dm_spi_claim_bus(slave->dev);
@@ -107,6 +131,18 @@ int spi_xfer(struct spi_slave *slave, unsigned int bitlen,
 	return dm_spi_xfer(slave->dev, bitlen, dout, din, flags);
 }
 
+bool spi_is_flash_command_supported(struct spi_slave *slave,
+				    const struct spi_flash_command *cmd)
+{
+	return dm_spi_is_flash_command_supported(slave->dev, cmd);
+}
+
+int spi_exec_flash_command(struct spi_slave *slave,
+			   const struct spi_flash_command *cmd)
+{
+	return dm_spi_exec_flash_command(slave->dev, cmd);
+}
+
 #if !CONFIG_IS_ENABLED(OF_PLATDATA)
 static int spi_child_post_bind(struct udevice *dev)
 {
@@ -143,6 +179,10 @@ static int spi_post_probe(struct udevice *bus)
 		ops->set_mode += gd->reloc_off;
 	if (ops->cs_info)
 		ops->cs_info += gd->reloc_off;
+	if (ops->is_flash_command_supported)
+		ops->is_flash_command_supported += gd->reloc_off;
+	if (ops->exec_flash_command)
+		ops->exec_flash_command += gd->reloc_off;
 #endif
 
 	return 0;
@@ -271,6 +311,7 @@ int spi_get_bus_and_cs(int busnum, int cs, int speed, int mode,
 {
 	struct udevice *bus, *dev;
 	struct dm_spi_slave_platdata *plat;
+	struct dm_spi_bus *spi;
 	bool created = false;
 	int ret;
 
@@ -284,6 +325,7 @@ int spi_get_bus_and_cs(int busnum, int cs, int speed, int mode,
 		return ret;
 	}
 	ret = spi_find_chip_select(bus, cs, &dev);
+	spi = dev_get_uclass_priv(bus);
 
 	/*
 	 * If there is no such device, create one automatically. This means
@@ -325,6 +367,9 @@ int spi_get_bus_and_cs(int busnum, int cs, int speed, int mode,
 		speed = plat->max_hz;
 		mode = plat->mode;
 	}
+	if (spi->max_hz)
+		speed = min(speed, (int)spi->max_hz);
+
 	ret = spi_set_speed_mode(bus, speed, mode);
 	if (ret)
 		goto err;
diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 45e73d2..94aae98 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -5,6 +5,7 @@
  */
 
 #include <common.h>
+#include <errno.h>
 #include <fdtdec.h>
 #include <malloc.h>
 #include <spi.h>
diff --git a/drivers/thermal/Kconfig b/drivers/thermal/Kconfig
index a71b9be..96b648a 100644
--- a/drivers/thermal/Kconfig
+++ b/drivers/thermal/Kconfig
@@ -8,6 +8,37 @@ config DM_THERMAL
 
 if DM_THERMAL
 
+menu "Thermal Sensor driver"
+
+config MVEBU_THERMAL_SENSOR
+        bool "Enable Thermal Sensor Core driver"
+	depends on MVEBU_THERMAL_SENSOR_28NM || MVEBU_THERMAL_EXT_SENSOR_28NM
+        help
+          This config enables thermal sensor core driver.
+          This driver scans for thermal sensor units,
+          and initializes them.
+	  The config is enabled once one of the thermal
+	  sensors drive is enabled.
+
+config MVEBU_THERMAL_SENSOR_28NM
+	bool "Enable Thermal Sensor 28NM driver"
+	select MVEBU_THERMAL_SENSOR
+	help
+	  Choose this option to add support for
+	  thermal sensor 28nm driver.
+	  This driver init the thermal sensor unit,
+	  and read the tempreture from the unit.
+
+config MVEBU_THERMAL_EXT_SENSOR_28NM
+	bool "Enable Thermal External Sensor 28NM driver"
+	select MVEBU_THERMAL_SENSOR
+	help
+	  Choose this option to add support for
+	  thermal external sensor 28nm driver.
+	  This driver init the External thermal sensor unit,
+	  and read the tempreture from the unit.
+endmenu
+
 config IMX_THERMAL
 	bool "Temperature sensor driver for Freescale i.MX SoCs"
 	depends on MX6 || MX7
diff --git a/drivers/thermal/Makefile b/drivers/thermal/Makefile
index f6271a5..146c5a9 100644
--- a/drivers/thermal/Makefile
+++ b/drivers/thermal/Makefile
@@ -8,3 +8,6 @@
 obj-$(CONFIG_DM_THERMAL) += thermal-uclass.o
 obj-$(CONFIG_IMX_THERMAL) += imx_thermal.o
 obj-$(CONFIG_TI_DRA7_THERMAL) += ti-bandgap.o
+obj-$(CONFIG_MVEBU_THERMAL_SENSOR) += mvebu_thermal_core.o
+obj-$(CONFIG_MVEBU_THERMAL_SENSOR_28NM) += mvebu_thermal_28nm.o
+obj-$(CONFIG_MVEBU_THERMAL_EXT_SENSOR_28NM) += mvebu_ext_thermal_28nm.o
diff --git a/drivers/thermal/mvebu_ext_thermal_28nm.c b/drivers/thermal/mvebu_ext_thermal_28nm.c
new file mode 100644
index 0000000..b12c114
--- /dev/null
+++ b/drivers/thermal/mvebu_ext_thermal_28nm.c
@@ -0,0 +1,95 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/* #define DEBUG */
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch-mvebu/thermal.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define THERMAL_TIMEOUT					1200
+
+#define THERMAL_SEN_CTRL_LSB				0x0
+#define THERMAL_SEN_CTRL_LSB_STRT_OFFSET		0
+#define THERMAL_SEN_CTRL_LSB_STRT_MASK			\
+	(0x1 << THERMAL_SEN_CTRL_LSB_STRT_OFFSET)
+#define THERMAL_SEN_CTRL_LSB_RST_OFFSET			1
+#define THERMAL_SEN_CTRL_LSB_RST_MASK			\
+	(0x1 << THERMAL_SEN_CTRL_LSB_RST_OFFSET)
+#define THERMAL_SEN_CTRL_LSB_EN_OFFSET			2
+#define THERMAL_SEN_CTRL_LSB_EN_MASK			\
+	(0x1 << THERMAL_SEN_CTRL_LSB_EN_OFFSET)
+
+#define THERMAL_SEN_CTRL_STATS				0x8
+#define THERMAL_SEN_CTRL_STATS_VALID_OFFSET		16
+#define THERMAL_SEN_CTRL_STATS_VALID_MASK		\
+	(0x1 << THERMAL_SEN_CTRL_STATS_VALID_OFFSET)
+#define THERMAL_SEN_CTRL_STATS_TEMP_OUT_OFFSET		0
+#define THERMAL_SEN_CTRL_STATS_TEMP_OUT_MASK		\
+	(0x3FF << THERMAL_SEN_CTRL_STATS_TEMP_OUT_OFFSET)
+
+#define THERMAL_SEN_OUTPUT_MSB				512
+#define THERMAL_SEN_OUTPUT_COMP				1024
+
+s32 mvebu_thermal_ext_sensor_read(struct thermal_unit_config *tsen)
+{
+	u32 reg;
+
+	if (!tsen->tsen_ready) {
+		printf("External Thermal Sensor was not initialized\n");
+		return 0;
+	}
+
+	reg = readl(tsen->regs_base + THERMAL_SEN_CTRL_STATS);
+	reg = ((reg & THERMAL_SEN_CTRL_STATS_TEMP_OUT_MASK) >>
+	      THERMAL_SEN_CTRL_STATS_TEMP_OUT_OFFSET);
+
+	/*
+	 * TSEN output format is signed as a 2s complement number
+	 * ranging from-512 to +511. when MSB is set, need to
+	 * calculate the complement number
+	 */
+	if (reg >= THERMAL_SEN_OUTPUT_MSB)
+		reg -= THERMAL_SEN_OUTPUT_COMP;
+
+	return ((tsen->tsen_gain * ((s32)reg)) + tsen->tsen_offset) /
+	       tsen->tsen_divisor;
+}
+
+u32 mvebu_thermal_ext_sensor_probe(struct thermal_unit_config *tsen)
+{
+	u32 reg, timeout = 0;
+
+	debug("thermal.%lx Initializing sensor unit\n",
+	      (uintptr_t)tsen->regs_base);
+
+	/* Initialize thermal sensor hardware reset once */
+	reg = readl(tsen->regs_base + THERMAL_SEN_CTRL_LSB);
+	/* De-assert TSEN_RESET */
+	reg &= ~THERMAL_SEN_CTRL_LSB_RST_OFFSET;
+	/* Set TSEN_EN to 1 */
+	reg |= THERMAL_SEN_CTRL_LSB_EN_MASK;
+	/* Set TSEN_START to 1 */
+	reg |= THERMAL_SEN_CTRL_LSB_STRT_MASK;
+	writel(reg, tsen->regs_base + THERMAL_SEN_CTRL_LSB);
+
+	reg = readl(tsen->regs_base + THERMAL_SEN_CTRL_STATS);
+	while ((reg & THERMAL_SEN_CTRL_STATS_VALID_MASK) == 0 &&
+	       timeout < THERMAL_TIMEOUT) {
+		udelay(10);
+		reg = readl(tsen->regs_base + THERMAL_SEN_CTRL_STATS);
+		timeout++;
+	}
+	if ((reg & THERMAL_SEN_CTRL_STATS_VALID_MASK) == 0) {
+		pr_err("%s: thermal.%lx: external sensor is not ready\n",
+		       __func__, (uintptr_t)tsen->regs_base);
+		return -1;
+	}
+
+	debug("thermal.%lx: Initialization done\n", (uintptr_t)tsen->regs_base);
+
+	return 0;
+}
diff --git a/drivers/thermal/mvebu_thermal_28nm.c b/drivers/thermal/mvebu_thermal_28nm.c
new file mode 100644
index 0000000..0a6e36b
--- /dev/null
+++ b/drivers/thermal/mvebu_thermal_28nm.c
@@ -0,0 +1,85 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/* #define DEBUG */
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch-mvebu/thermal.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define THERMAL_SEN_CTRL			0x0
+#define THERMAL_SEN_TC_TRIM_OFFSET		0
+#define THERMAL_SEN_TC_TRIM_MASK		\
+	(0x7 << THERMAL_SEN_TC_TRIM_OFFSET)
+
+#define THERMAL_SEN_CTRL_MSB			0x4
+#define THERMAL_SEN_CTRL_MSB_RST_OFFSET		8
+#define THERMAL_SEN_CTRL_MSB_RST_MASK		\
+	(0x1 << THERMAL_SEN_CTRL_MSB_RST_OFFSET)
+
+#define THERMAL_SEN_CTRL_STATS			0x8
+#define THERMAL_SEN_CTRL_STATS_VALID_OFFSET	10
+#define THERMAL_SEN_CTRL_STATS_VALID_MASK	\
+	(0x1 << THERMAL_SEN_CTRL_STATS_VALID_OFFSET)
+
+#define THERMAL_SEN_CTRL_STATS_TEMP_OUT_OFFSET	0
+#define THERMAL_SEN_CTRL_STATS_TEMP_OUT_MASK	\
+	(0x3FF << THERMAL_SEN_CTRL_STATS_TEMP_OUT_OFFSET)
+
+s32 mvebu_thermal_sensor_read(struct thermal_unit_config *tsen)
+{
+	u32 reg;
+
+	if (!tsen->tsen_ready) {
+		printf("Thermal Sensor was not initialized\n");
+		return 0;
+	}
+
+	reg = readl(tsen->regs_base + THERMAL_SEN_CTRL_STATS);
+	reg = ((reg & THERMAL_SEN_CTRL_STATS_TEMP_OUT_MASK) >>
+	      THERMAL_SEN_CTRL_STATS_TEMP_OUT_OFFSET);
+
+	return ((tsen->tsen_gain * ((s32)reg)) - tsen->tsen_offset) /
+	       tsen->tsen_divisor;
+}
+
+u32 mvebu_thermal_sensor_probe(struct thermal_unit_config *tsen)
+{
+	u32 reg, timeout = 0;
+
+	debug("thermal.%lx Initializing sensor unit\n",
+	      (uintptr_t)tsen->regs_base);
+
+	/* Initialize thermal sensor hardware reset once */
+	reg = readl(tsen->regs_base + THERMAL_SEN_CTRL_MSB);
+	reg |= THERMAL_SEN_CTRL_MSB_RST_MASK;
+	writel(reg, tsen->regs_base + THERMAL_SEN_CTRL_MSB);
+
+	/* set Tsen Tc Trim to correct default value (errata #132698) */
+	reg = readl(tsen->regs_base + THERMAL_SEN_CTRL);
+	reg &= ~THERMAL_SEN_TC_TRIM_MASK;
+	reg |= 0x3;
+	writel(reg, tsen->regs_base + THERMAL_SEN_CTRL);
+
+	/* Check that Sensor is ready */
+	reg = readl(tsen->regs_base + THERMAL_SEN_CTRL_STATS);
+	while ((reg & THERMAL_SEN_CTRL_STATS_VALID_MASK) == 0 &&
+	       timeout < 300) {
+		udelay(1);
+		reg = readl(tsen->regs_base + THERMAL_SEN_CTRL_STATS);
+		timeout++;
+	}
+
+	if ((reg & THERMAL_SEN_CTRL_STATS_VALID_MASK) == 0) {
+		pr_err("%s: thermal.%lx: sensor is not ready\n", __func__,
+		       (uintptr_t)tsen->regs_base);
+		return -1;
+	}
+
+	debug("thermal.%lx: Initialization done\n", (uintptr_t)tsen->regs_base);
+
+	return 0;
+}
diff --git a/drivers/thermal/mvebu_thermal_core.c b/drivers/thermal/mvebu_thermal_core.c
new file mode 100644
index 0000000..15c6865
--- /dev/null
+++ b/drivers/thermal/mvebu_thermal_core.c
@@ -0,0 +1,145 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+/* #define DEBUG */
+#include <common.h>
+#include <malloc.h>
+#include <fdtdec.h>
+#include <asm/io.h>
+#include <asm/arch-mvebu/thermal.h>
+#include <dm.h>
+#include <thermal.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static struct thermal_unit_config *init_thermal_config(struct udevice *dev)
+{
+	struct thermal_unit_config *thermal_cfg = dev_get_priv(dev);
+	void *blob = (void *)gd->fdt_blob;
+	int node = dev_of_offset(dev);
+
+	/* Read register base */
+	thermal_cfg->regs_base = (void *)devfdt_get_addr_index(dev, 0);
+
+	if (thermal_cfg->regs_base == 0) {
+		pr_err("thermal: base address is missing in device-tree\n");
+		return NULL;
+	}
+
+	/* Register functions (according to compatible) */
+	if (device_is_compatible(dev, "marvell,thermal-sensor")) {
+		thermal_cfg->ptr_thermal_sensor_probe =
+			mvebu_thermal_sensor_probe;
+		thermal_cfg->ptr_thermal_sensor_read =
+			mvebu_thermal_sensor_read;
+	}
+
+	if (device_is_compatible(dev, "marvell,thermal-ext-sensor")) {
+		thermal_cfg->ptr_thermal_sensor_probe =
+			mvebu_thermal_ext_sensor_probe;
+		thermal_cfg->ptr_thermal_sensor_read =
+			mvebu_thermal_ext_sensor_read;
+	}
+
+	if (!thermal_cfg->ptr_thermal_sensor_probe ||
+	    !thermal_cfg->ptr_thermal_sensor_read) {
+		pr_err("thermal.%lx: compatible is not supported\n",
+		       (uintptr_t)thermal_cfg->regs_base);
+		return NULL;
+	}
+
+	/* Read temperature calculation parameters */
+	thermal_cfg->tsen_gain = fdtdec_get_int(blob, node, "gain", 0);
+	if (thermal_cfg->tsen_gain <= 0) {
+		pr_err("thermal%lx: gain is missing in device-tree\n",
+		       (uintptr_t)thermal_cfg->regs_base);
+		return NULL;
+	}
+
+	thermal_cfg->tsen_offset = fdtdec_get_int(blob, node, "offset", 0);
+	if (thermal_cfg->tsen_offset <= 0) {
+		pr_err("thermal%lx: offset is missing in device-tree\n",
+		       (uintptr_t)thermal_cfg->regs_base);
+		return NULL;
+	}
+
+	thermal_cfg->tsen_divisor = fdtdec_get_int(blob, node, "divisor", 0);
+	if (thermal_cfg->tsen_divisor <= 0) {
+		pr_err("thermal%lx: divisor is missing in device-tree\n",
+		       (uintptr_t)thermal_cfg->regs_base);
+		return NULL;
+	}
+
+	return thermal_cfg;
+}
+
+int mvebu_thermal_read(struct udevice *dev, int *temp)
+{
+	struct thermal_unit_config *thermal_cfg;
+
+	if (!temp) {
+		pr_err("NULL pointer for temperature read\n");
+		return -1;
+	}
+
+	thermal_cfg = dev_get_priv(dev);
+
+	if (thermal_cfg->ptr_thermal_sensor_read == 0 ||
+	    thermal_cfg->tsen_ready == 0) {
+		debug("Thermal unit was not initialized\n");
+		return -1;
+	}
+
+	*temp = thermal_cfg->ptr_thermal_sensor_read(thermal_cfg);
+
+	return 0;
+}
+
+static const struct dm_thermal_ops mvebu_thermal_ops = {
+	.get_temp	= mvebu_thermal_read,
+};
+
+static int mvebu_thermal_probe(struct udevice *dev)
+{
+	struct thermal_unit_config *thermal_cfg = dev_get_priv(dev);
+
+	/* Init Sensor data structure */
+	thermal_cfg = init_thermal_config(dev);
+	if (!thermal_cfg) {
+		pr_err("Thermal: failed to initialize thermal data structure\n");
+		return -1;
+	}
+
+	/* set flag to indicate that Thermal Sensor is not ready */
+	thermal_cfg->tsen_ready = 0;
+
+	/* Sensor init */
+	if (thermal_cfg->ptr_thermal_sensor_probe(thermal_cfg)) {
+		pr_err("thermal.%lx: failed to initialize thermal info\n",
+		       (uintptr_t)thermal_cfg->regs_base);
+		return -1; /* initialization failed */
+	}
+
+	/* Thermal Sensor is ready to use */
+	thermal_cfg->tsen_ready = 1;
+
+	debug("thermal.%lx: Initialized\n", (uintptr_t)thermal_cfg->regs_base);
+
+	return 0;
+}
+
+static const struct udevice_id mvebu_thermal_ids[] = {
+	{ .compatible = "marvell,mvebu-thermal" },
+	{ }
+};
+
+U_BOOT_DRIVER(mvebu_thermal) = {
+	.name	= "mvebu-thermal",
+	.id	= UCLASS_THERMAL,
+	.ops	= &mvebu_thermal_ops,
+	.of_match = mvebu_thermal_ids,
+	.probe	= mvebu_thermal_probe,
+	.priv_auto_alloc_size = sizeof(struct thermal_unit_config),
+};
diff --git a/drivers/usb/eth/usb_ether.c b/drivers/usb/eth/usb_ether.c
index 36734e2..e316b55 100644
--- a/drivers/usb/eth/usb_ether.c
+++ b/drivers/usb/eth/usb_ether.c
@@ -241,6 +241,7 @@ static void probe_valid_drivers(struct usb_device *dev)
 			if (eth_write_hwaddr(eth, "usbeth",
 					usb_max_eth_dev - 1))
 				puts("Warning: failed to set MAC address\n");
+			printf("	%s ", eth->name);
 			break;
 			}
 		}
diff --git a/drivers/usb/host/ehci-marvell.c b/drivers/usb/host/ehci-marvell.c
index 7a0f208..9bca1d4 100644
--- a/drivers/usb/host/ehci-marvell.c
+++ b/drivers/usb/host/ehci-marvell.c
@@ -13,6 +13,7 @@
 #include <linux/mbus.h>
 #include <asm/arch/cpu.h>
 #include <dm.h>
+#include <power/regulator.h>
 
 #if defined(CONFIG_KIRKWOOD)
 #include <asm/arch/soc.h>
@@ -104,6 +105,10 @@ static int ehci_mvebu_probe(struct udevice *dev)
 	struct ehci_mvebu_priv *priv = dev_get_priv(dev);
 	struct ehci_hccr *hccr;
 	struct ehci_hcor *hcor;
+#ifdef CONFIG_DM_REGULATOR
+	struct udevice *regulator;
+	int ret;
+#endif
 
 	/*
 	 * Get the base address for EHCI controller from the device node
@@ -126,6 +131,18 @@ static int ehci_mvebu_probe(struct udevice *dev)
 	else
 		usb_brg_adrdec_setup((void *)priv->hcd_base);
 
+	/* Enable VBUS */
+#ifdef CONFIG_DM_REGULATOR
+	ret = device_get_supply_regulator(dev, "vbus-supply", &regulator);
+	if (!ret) {
+		ret = regulator_set_enable(regulator, true);
+		if (ret) {
+			printf("Failed to turn ON the VBUS regulator\n");
+			return ret;
+		}
+	}
+#endif
+
 	hccr = (struct ehci_hccr *)(priv->hcd_base + 0x100);
 	hcor = (struct ehci_hcor *)
 		((uintptr_t)hccr + HC_LENGTH(ehci_readl(&hccr->cr_capbase)));
@@ -138,6 +155,32 @@ static int ehci_mvebu_probe(struct udevice *dev)
 			     USB_INIT_HOST);
 }
 
+static int ehci_usb_remove(struct udevice *dev)
+{
+	int ret;
+#ifdef CONFIG_DM_REGULATOR
+	struct udevice *regulator;
+#endif
+
+	ret = ehci_deregister(dev);
+	if (ret)
+		return ret;
+
+	/* Disable VBUS */
+#ifdef CONFIG_DM_REGULATOR
+	ret = device_get_supply_regulator(dev, "vbus-supply", &regulator);
+	if (!ret) {
+		ret = regulator_set_enable(regulator, false);
+		if (ret) {
+			printf("Failed to turn OFF the VBUS regulator\n");
+			return ret;
+		}
+	}
+#endif
+
+	return 0;
+}
+
 static const struct udevice_id ehci_usb_ids[] = {
 	{ .compatible = "marvell,orion-ehci", },
 	{ .compatible = "marvell,armada3700-ehci", },
@@ -149,7 +192,7 @@ U_BOOT_DRIVER(ehci_mvebu) = {
 	.id	= UCLASS_USB,
 	.of_match = ehci_usb_ids,
 	.probe = ehci_mvebu_probe,
-	.remove = ehci_deregister,
+	.remove = ehci_usb_remove,
 	.ops	= &ehci_usb_ops,
 	.platdata_auto_alloc_size = sizeof(struct usb_platdata),
 	.priv_auto_alloc_size = sizeof(struct ehci_mvebu_priv),
diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c
index 0582a9b..53c8ab3 100644
--- a/drivers/usb/host/xhci-mem.c
+++ b/drivers/usb/host/xhci-mem.c
@@ -178,6 +178,9 @@ void xhci_cleanup(struct xhci_ctrl *ctrl)
 	xhci_free_virt_devices(ctrl);
 	free(ctrl->erst.entries);
 	free(ctrl->dcbaa);
+#if defined(CONFIG_ARCH_OCTEONTX2)
+	free(ctrl->rx_bounce_buffer);
+#endif
 	memset(ctrl, '\0', sizeof(struct xhci_ctrl));
 }
 
@@ -507,6 +510,13 @@ int xhci_mem_init(struct xhci_ctrl *ctrl, struct xhci_hccr *hccr,
 	int i;
 	struct xhci_segment *seg;
 
+#if defined(CONFIG_ARCH_OCTEONTX2)
+	ctrl->rx_bounce_buffer = memalign(65536, 65536);
+	if (!ctrl->rx_bounce_buffer) {
+		puts("unable to allocate OcteonTX2 RX bounce buffer\n");
+		return -ENOMEM;
+	}
+#endif
 	/* DCBAA initialization */
 	ctrl->dcbaa = (struct xhci_device_context_array *)
 			xhci_malloc(sizeof(struct xhci_device_context_array));
diff --git a/drivers/usb/host/xhci-mvebu.c b/drivers/usb/host/xhci-mvebu.c
index dbdfce3..da94255 100644
--- a/drivers/usb/host/xhci-mvebu.c
+++ b/drivers/usb/host/xhci-mvebu.c
@@ -61,12 +61,53 @@ static int xhci_usb_probe(struct udevice *dev)
 		}
 	}
 
+	ret = device_get_supply_regulator(dev, "current-limiter", &regulator);
+	if (!ret) {
+		ret = regulator_set_enable(regulator, true);
+		if (ret) {
+			printf("Failed to turn ON the %s regulator\n",
+			       regulator->name);
+			return ret;
+		}
+	}
+
 	/* Enable USB xHCI (VBUS, reset etc) in board specific code */
 	board_xhci_enable(devfdt_get_addr_index(dev, 1));
 
 	return xhci_register(dev, ctx->hcd, hcor);
 }
 
+static int xhci_usb_remove(struct udevice *dev)
+{
+	int ret;
+	struct udevice *regulator;
+
+	ret = xhci_deregister(dev);
+	if (ret)
+		return ret;
+
+	ret = device_get_supply_regulator(dev, "vbus-supply", &regulator);
+	if (!ret) {
+		ret = regulator_set_enable(regulator, false);
+		if (ret) {
+			printf("Failed to turn OFF the VBUS regulator\n");
+			return ret;
+		}
+	}
+
+	ret = device_get_supply_regulator(dev, "current-limiter", &regulator);
+	if (!ret) {
+		ret = regulator_set_enable(regulator, false);
+		if (ret) {
+			printf("Failed to turn OFF the %s regulator\n",
+			       regulator->name);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
 static int xhci_usb_ofdata_to_platdata(struct udevice *dev)
 {
 	struct mvebu_xhci_platdata *plat = dev_get_platdata(dev);
@@ -96,7 +137,7 @@ U_BOOT_DRIVER(usb_xhci) = {
 	.of_match = xhci_usb_ids,
 	.ofdata_to_platdata = xhci_usb_ofdata_to_platdata,
 	.probe = xhci_usb_probe,
-	.remove = xhci_deregister,
+	.remove = xhci_usb_remove,
 	.ops	= &xhci_usb_ops,
 	.platdata_auto_alloc_size = sizeof(struct mvebu_xhci_platdata),
 	.priv_auto_alloc_size = sizeof(struct mvebu_xhci),
diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index e4a0ef4..3b17b44 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -18,14 +18,15 @@ static void xhci_pci_init(struct udevice *dev, struct xhci_hccr **ret_hccr,
 	struct xhci_hccr *hccr;
 	struct xhci_hcor *hcor;
 	u32 cmd;
+	size_t size;
 
 	hccr = (struct xhci_hccr *)dm_pci_map_bar(dev,
-			PCI_BASE_ADDRESS_0, PCI_REGION_MEM);
+			0, &size, PCI_REGION_MEM);
 	hcor = (struct xhci_hcor *)((uintptr_t) hccr +
 			HC_LENGTH(xhci_readl(&hccr->cr_capbase)));
 
-	debug("XHCI-PCI init hccr 0x%x and hcor 0x%x hc_length %d\n",
-	      (u32)hccr, (u32)hcor,
+	debug("XHCI-PCI init hccr 0x%p and hcor 0x%p hc_length %d\n",
+	      hccr, hcor,
 	      (u32)HC_LENGTH(xhci_readl(&hccr->cr_capbase)));
 
 	*ret_hccr = hccr;
diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
index 7599c91..e64eef1 100644
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@ -576,6 +576,10 @@ int xhci_bulk_tx(struct usb_device *udev, unsigned long pipe,
 	int ret;
 	u32 trb_fields[4];
 	u64 val_64 = (uintptr_t)buffer;
+#if defined(CONFIG_ARCH_OCTEONTX2)
+	void *orig_buffer = buffer;
+	bool use_rx_bounce = false;
+#endif
 
 	debug("dev=%p, pipe=%lx, buffer=%p, length=%d\n",
 		udev, pipe, buffer, length);
@@ -595,6 +599,21 @@ int xhci_bulk_tx(struct usb_device *udev, unsigned long pipe,
 	 * that the buffer should not span 64KB boundary. if so
 	 * we send request in more than 1 TRB by chaining them.
 	 */
+#if defined(CONFIG_ARCH_OCTEONTX2)
+	/* There is a bug in the designware core used in the OcteonTX2 where
+	 * buffers that cross TRB boundaries cause an extra event to be
+	 * generated and the lengths reported by those events are corrupt.
+	 * In order to work around this, a 64K bounce buffer is used.
+	 */
+	if (usb_pipein(pipe) && (length <= TRB_MAX_BUFF_SIZE) &&
+	    (((uintptr_t)buffer & ~(TRB_MAX_BUFF_SIZE - 1)) !=
+	     (((uintptr_t)buffer + length) & ~(TRB_MAX_BUFF_SIZE - 1)))) {
+		use_rx_bounce = true;
+		orig_buffer = buffer;
+		buffer = ctrl->rx_bounce_buffer;
+		val_64 = (uintptr_t)buffer;
+	}
+#endif
 	running_total = TRB_MAX_BUFF_SIZE -
 			(lower_32_bits(val_64) & (TRB_MAX_BUFF_SIZE - 1));
 	trb_buff_len = running_total;
@@ -731,6 +750,10 @@ int xhci_bulk_tx(struct usb_device *udev, unsigned long pipe,
 	xhci_acknowledge_event(ctrl);
 	xhci_inval_cache((uintptr_t)buffer, length);
 
+#if defined(CONFIG_ARCH_OCTEONTX2)
+	if (use_rx_bounce)
+		memcpy(orig_buffer, buffer, udev->act_len);
+#endif
 	return (udev->status != USB_ST_NOT_PROC) ? 0 : -1;
 }
 
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index 4673738..7ce28a8 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -537,7 +537,7 @@ static int xhci_set_configuration(struct usb_device *udev)
 	/* slot context */
 	xhci_slot_copy(ctrl, in_ctx, out_ctx);
 	slot_ctx = xhci_get_slot_ctx(ctrl, in_ctx);
-	slot_ctx->dev_info &= ~(LAST_CTX_MASK);
+	slot_ctx->dev_info &= ~(cpu_to_le32(LAST_CTX_MASK));
 	slot_ctx->dev_info |= cpu_to_le32(LAST_CTX(max_ep_flag + 1) | 0);
 
 	xhci_endpoint_copy(ctrl, in_ctx, out_ctx, 0);
@@ -1164,6 +1164,8 @@ static int _xhci_submit_control_msg(struct usb_device *udev, unsigned long pipe,
 	struct xhci_ctrl *ctrl = xhci_get_ctrl(udev);
 	int ret = 0;
 
+	udelay(100);
+
 	if (usb_pipetype(pipe) != PIPE_CONTROL) {
 		printf("non-control pipe (type=%lu)", usb_pipetype(pipe));
 		return -EINVAL;
@@ -1425,7 +1427,7 @@ static int xhci_update_hub_device(struct udevice *dev, struct usb_device *udev)
 
 	ctrl_ctx = xhci_get_input_control_ctx(in_ctx);
 	/* Initialize the input context control */
-	ctrl_ctx->add_flags |= cpu_to_le32(SLOT_FLAG);
+	ctrl_ctx->add_flags = cpu_to_le32(SLOT_FLAG);
 	ctrl_ctx->drop_flags = 0;
 
 	xhci_inval_cache((uintptr_t)out_ctx->bytes, out_ctx->size);
@@ -1436,8 +1438,15 @@ static int xhci_update_hub_device(struct udevice *dev, struct usb_device *udev)
 
 	/* Update hub related fields */
 	slot_ctx->dev_info |= cpu_to_le32(DEV_HUB);
-	if (hub->tt.multi && udev->speed == USB_SPEED_HIGH)
+	/*
+	 * refer to section 6.2.2: MTT should be 0 for full speed hub,
+	 * but it may be already set to 1 when setup an xHCI virtual
+	 * device, so clear it anyway.
+	 */
+	if (hub->tt.multi)
 		slot_ctx->dev_info |= cpu_to_le32(DEV_MTT);
+	else if (udev->speed == USB_SPEED_FULL)
+		slot_ctx->dev_info &= cpu_to_le32(~DEV_MTT);
 	slot_ctx->dev_info2 |= cpu_to_le32(XHCI_MAX_PORTS(udev->maxchild));
 	/*
 	 * Set TT think time - convert from ns to FS bit times.
@@ -1453,6 +1462,7 @@ static int xhci_update_hub_device(struct udevice *dev, struct usb_device *udev)
 		think_time = (think_time / 666) - 1;
 	if (udev->speed == USB_SPEED_HIGH)
 		slot_ctx->tt_info |= cpu_to_le32(TT_THINK_TIME(think_time));
+	slot_ctx->dev_state = 0;
 
 	return xhci_configure_endpoints(udev, false);
 }
@@ -1503,7 +1513,6 @@ int xhci_register(struct udevice *dev, struct xhci_hccr *hccr,
 
 	return 0;
 err:
-	free(ctrl);
 	debug("%s: failed, ret=%d\n", __func__, ret);
 	return ret;
 }
diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index ba5f650..fca49ad 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1231,6 +1231,16 @@ struct xhci_ctrl {
 	struct xhci_scratchpad *scratchpad;
 	struct xhci_virt_device *devs[MAX_HC_SLOTS];
 	int rootdev;
+#if defined(CONFIG_ARCH_OCTEONTX2)
+	/* The Marvell OcteonTX2 SOCs have a problem where if the receive
+	 * buffer crosses a 64K boundary then the response events get
+	 * corrupted.  In this case, a 64K bounce buffer is used instead,
+	 * guaranteeing that this case will never happen.  It introduces
+	 * a slight performance penalty since all received data must be
+	 * copied from the bounce buffer to the user-supplied buffer.
+	 */
+	void *rx_bounce_buffer;
+#endif
 };
 
 unsigned long trb_addr(struct xhci_segment *seg, union xhci_trb *trb);
diff --git a/env/common.c b/env/common.c
index f21ff70..6da5dc5 100644
--- a/env/common.c
+++ b/env/common.c
@@ -88,6 +88,18 @@ void set_default_env(const char *s)
 
 	gd->flags |= GD_FLG_ENV_READY;
 	gd->flags |= GD_FLG_ENV_DEFAULT;
+
+#ifdef CONFIG_CMD_MVEBU_HW_INFO
+		/* load the HW configuration from EEPROM to env variables and
+		 * saveenv.
+		 * This is because when the env varibles are reset, need to
+		 * recover the HW configuration related env varibles from
+		 * EEPROM.
+		 * The only generic U-Boot env variable that will be overwrote
+		 * here will be the Marvell specific variables
+		 */
+		cmd_hw_info_load(NULL, 1);
+#endif /* CONFIG_CMD_MVEBU_HW_INFO */
 }
 
 
diff --git a/env/mmc.c b/env/mmc.c
index 6f11dec..c8aaee7 100644
--- a/env/mmc.c
+++ b/env/mmc.c
@@ -142,7 +142,12 @@ static int mmc_set_env_part(struct mmc *mmc)
 	int dev = mmc_get_env_dev();
 	int ret = 0;
 
-	env_mmc_orig_hwpart = mmc_get_blk_desc(mmc)->hwpart;
+	env_mmc_orig_hwpart =
+#ifdef CONFIG_MMC_OCTEONTX
+		mmc_get_blk_desc(mmc, CONFIG_SYS_MMC_ENV_DEV)->hwpart;
+#else
+		mmc_get_blk_desc(mmc)->hwpart;
+#endif
 	ret = blk_select_hwpart_devnum(IF_TYPE_MMC, dev, part);
 	if (ret)
 		puts("MMC partition switch failed\n");
@@ -187,8 +192,11 @@ static inline int write_env(struct mmc *mmc, unsigned long size,
 			    unsigned long offset, const void *buffer)
 {
 	uint blk_start, blk_cnt, n;
+#ifdef CONFIG_MMC_OCTEONTX
+	struct blk_desc *desc = mmc_get_blk_desc(mmc, CONFIG_SYS_MMC_ENV_DEV);
+#else
 	struct blk_desc *desc = mmc_get_blk_desc(mmc);
-
+#endif
 	blk_start	= ALIGN(offset, mmc->write_bl_len) / mmc->write_bl_len;
 	blk_cnt		= ALIGN(size, mmc->write_bl_len) / mmc->write_bl_len;
 
@@ -249,8 +257,11 @@ static inline int read_env(struct mmc *mmc, unsigned long size,
 			   unsigned long offset, const void *buffer)
 {
 	uint blk_start, blk_cnt, n;
+#ifdef CONFIG_MMC_OCTEONTX
+	struct blk_desc *desc = mmc_get_blk_desc(mmc, CONFIG_SYS_MMC_ENV_DEV);
+#else
 	struct blk_desc *desc = mmc_get_blk_desc(mmc);
-
+#endif
 	blk_start	= ALIGN(offset, mmc->read_bl_len) / mmc->read_bl_len;
 	blk_cnt		= ALIGN(size, mmc->read_bl_len) / mmc->read_bl_len;
 
diff --git a/env/sf.c b/env/sf.c
index 6326b37..013f3ab 100644
--- a/env/sf.c
+++ b/env/sf.c
@@ -57,14 +57,36 @@ static int setup_flash_device(void)
 	struct udevice *new;
 	int	ret;
 
+#ifdef CONFIG_ARCH_OCTEONTX2
+	int bus, cs;
+extern void board_get_env_spi_bus_cs(int *bus, int *cs);
+
+	board_get_env_spi_bus_cs(&bus, &cs);
+	if (bus < 0) {
+		/* Default to config */
+		bus = CONFIG_ENV_SPI_BUS;
+		cs = CONFIG_ENV_SPI_CS;
+	}
+
 	/* speed and mode will be read from DT */
-	ret = spi_flash_probe_bus_cs(CONFIG_ENV_SPI_BUS, CONFIG_ENV_SPI_CS,
-				     0, 0, &new);
+	ret = spi_flash_probe_bus_cs(bus, cs,
+				     CONFIG_ENV_SPI_MAX_HZ, CONFIG_ENV_SPI_MODE,
+				     &new);
 	if (ret) {
 		set_default_env("!spi_flash_probe_bus_cs() failed");
 		return ret;
 	}
 
+#else
+	/* speed and mode will be read from DT */
+	ret = spi_flash_probe_bus_cs(CONFIG_ENV_SPI_BUS, CONFIG_ENV_SPI_CS,
+				     CONFIG_ENV_SPI_MAX_HZ, CONFIG_ENV_SPI_MODE,
+				     &new);
+	if (ret) {
+		set_default_env("!spi_flash_probe_bus_cs() failed");
+		return ret;
+	}
+#endif
 	env_flash = dev_get_uclass_priv(new);
 #else
 
diff --git a/examples/standalone/stubs.c b/examples/standalone/stubs.c
index fadde66..854cc86 100644
--- a/examples/standalone/stubs.c
+++ b/examples/standalone/stubs.c
@@ -284,3 +284,14 @@ void app_startup(char * const *argv)
 }
 
 #undef EXPORT_FUNC
+
+#include <common.h>
+
+const unsigned long __stack_chk_guard = 0xDEADBEEF0C0FFEE0UL;
+const char message[] = "stack-protector: U-Boot stack is corrupted\n";
+
+void __stack_chk_fail(void)
+{
+	puts(message);
+}
+
diff --git a/fs/ext4/ext4_common.c b/fs/ext4/ext4_common.c
index e3cc30a..ed6ebcc 100644
--- a/fs/ext4/ext4_common.c
+++ b/fs/ext4/ext4_common.c
@@ -28,6 +28,7 @@
 #include <stddef.h>
 #include <linux/stat.h>
 #include <linux/time.h>
+#include <u-boot/crc.h>
 #include <asm/byteorder.h>
 #include "ext4_common.h"
 
@@ -107,6 +108,15 @@ static inline void ext4fs_bg_itable_unused_dec
 		bg->bg_itable_unused_high = cpu_to_le16(free_inodes >> 16);
 }
 
+static inline void ext4fs_bg_itable_unused_set(struct ext2_block_group *bg,
+					       const struct ext_filesystem *fs,
+					       uint32_t free_inodes)
+{
+	bg->bg_itable_unused = cpu_to_le16(free_inodes & 0xffff);
+	if (fs->gdsize == 64)
+		bg->bg_itable_unused_high = cpu_to_le16(free_inodes >> 16);
+}
+
 uint64_t ext4fs_sb_get_free_blocks(const struct ext2_sblock *sb)
 {
 	uint64_t free_blocks = le32_to_cpu(sb->free_blocks);
@@ -415,27 +425,48 @@ void ext4fs_reset_inode_bmap(int inode_no, unsigned char *buffer, int index)
 		*ptr = *ptr & ~(operand);
 }
 
+static inline uint32_t ext4_chksum(uint32_t crc, const void *address,
+				   uint32_t length)
+{
+	return crc32(crc, address, length);
+}
+
 uint16_t ext4fs_checksum_update(uint32_t i)
 {
 	struct ext2_block_group *desc;
 	struct ext_filesystem *fs = get_fs();
 	uint16_t crc = 0;
 	__le32 le32_i = cpu_to_le32(i);
+	int offset = offsetof(struct ext2_block_group, bg_checksum);
 
 	desc = ext4fs_get_group_descriptor(fs, i);
 	if (le32_to_cpu(fs->sb->feature_ro_compat) & EXT4_FEATURE_RO_COMPAT_GDT_CSUM) {
-		int offset = offsetof(struct ext2_block_group, bg_checksum);
 
 		crc = ext2fs_crc16(~0, fs->sb->unique_id,
 				   sizeof(fs->sb->unique_id));
 		crc = ext2fs_crc16(crc, &le32_i, sizeof(le32_i));
 		crc = ext2fs_crc16(crc, desc, offset);
 		offset += sizeof(desc->bg_checksum);	/* skip checksum */
-		assert(offset == sizeof(*desc));
+		/*assert(offset == sizeof(*desc));*/
 		if (offset < fs->gdsize) {
 			crc = ext2fs_crc16(crc, (__u8 *)desc + offset,
 					   fs->gdsize - offset);
 		}
+	} else if (le32_to_cpu(fs->sb->feature_ro_compat) &
+		   EXT4_FEATURE_RO_COMPAT_METADATA_CSUM) {
+		uint32_t crc32;
+		uint16_t dummy_csum = 0;
+
+		crc32 = ext4_chksum(~0, fs->sb->unique_id,
+				    sizeof(fs->sb->unique_id));
+		crc32 = ext4_chksum(crc32, &le32_i, sizeof(le32_i));
+		crc32 = ext4_chksum(crc32, desc, offset);
+		offset += sizeof(dummy_csum);
+		crc32 = ext4_chksum(crc32, &dummy_csum, sizeof(dummy_csum));
+		if (offset < fs->gdsize)
+			crc32 = ext4_chksum(crc32, (uint8_t *)desc + offset,
+					    fs->gdsize - offset);
+		crc = crc32 & 0xffff;
 	}
 
 	return crc;
@@ -764,7 +795,8 @@ int ext4fs_get_parent_inode_num(const char *dirname, char *dname, int flags)
 	struct ext2_inode temp_inode;
 
 	if (*dirname != '/') {
-		printf("Please supply Absolute path\n");
+		printf("Please supply Absolute path, \"%s\" invalid\n",
+		       dirname);
 		return -1;
 	}
 
@@ -1111,7 +1143,8 @@ int ext4fs_get_new_inode_no(void)
 				uint64_t i_bitmap_blk =
 					ext4fs_bg_get_inode_id(bgd, fs);
 				if (has_gdt_chksum)
-					bgd->bg_itable_unused = free_inodes;
+					ext4fs_bg_itable_unused_set(bgd, fs,
+								free_inodes);
 				if (bg_flags & EXT4_BG_INODE_UNINIT) {
 					put_ext4(i_bitmap_blk * fs->blksz,
 						 zero_buffer, fs->blksz);
diff --git a/fs/ext4/ext4_write.c b/fs/ext4/ext4_write.c
index d710a86..b6e3e78 100644
--- a/fs/ext4/ext4_write.c
+++ b/fs/ext4/ext4_write.c
@@ -893,7 +893,7 @@ int ext4fs_write(const char *fname, unsigned char *buffer,
 	blks_reqd_for_file = lldiv(bytes_reqd_for_file, fs->blksz);
 	if (do_div(bytes_reqd_for_file, fs->blksz) != 0) {
 		blks_reqd_for_file++;
-		debug("total bytes for a file %u\n", blks_reqd_for_file);
+		debug("total blocks for a file %u\n", blks_reqd_for_file);
 	}
 	blocks_remaining = blks_reqd_for_file;
 	/* test for available space in partition */
diff --git a/fs/ext4/ext4fs.c b/fs/ext4/ext4fs.c
index 9ee2caf..8b7d012 100644
--- a/fs/ext4/ext4fs.c
+++ b/fs/ext4/ext4fs.c
@@ -165,7 +165,7 @@ int ext4fs_read_file(struct ext2fs_node *node, loff_t pos,
 
 int ext4fs_ls(const char *dirname)
 {
-	struct ext2fs_node *dirnode;
+	struct ext2fs_node *dirnode = NULL;
 	int status;
 
 	if (dirname == NULL)
@@ -175,7 +175,8 @@ int ext4fs_ls(const char *dirname)
 				  FILETYPE_DIRECTORY);
 	if (status != 1) {
 		printf("** Can not find directory. **\n");
-		ext4fs_free_node(dirnode, &ext4fs_root->diropen);
+		if (dirnode)
+			ext4fs_free_node(dirnode, &ext4fs_root->diropen);
 		return 1;
 	}
 
diff --git a/include/ahci.h b/include/ahci.h
index cc36d81..f4a9efe 100644
--- a/include/ahci.h
+++ b/include/ahci.h
@@ -41,6 +41,9 @@
 #define HOST_IRQ_EN		(1 << 1)  /* global IRQ enable */
 #define HOST_AHCI_EN		(1 << 31) /* AHCI enabled */
 
+/* HOST_CAP bits */
+#define HOST_64BIT		(1 << 31) /* 64-Bit Addressing */
+
 /* Registers for each SATA port */
 #define PORT_LST_ADDR		0x00 /* command list DMA addr */
 #define PORT_LST_ADDR_HI	0x04 /* command list DMA addr hi */
@@ -140,8 +143,8 @@ struct ahci_ioports {
 	void __iomem	*port_mmio;
 	struct ahci_cmd_hdr	*cmd_slot;
 	struct ahci_sg		*cmd_tbl_sg;
-	ulong	cmd_tbl;
-	u32	rx_fis;
+	u64	cmd_tbl;
+	u64	rx_fis;
 };
 
 /**
diff --git a/include/cavium/atf.h b/include/cavium/atf.h
deleted file mode 100644
index 0a53c2f..0000000
--- a/include/cavium/atf.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/**
- * (C) Copyright 2014, Cavium Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
-**/
-#ifndef __ATF_H__
-#define __ATF_H__
-#include <cavium/atf_part.h>
-
-ssize_t atf_read_mmc(uintptr_t offset, void *buffer, size_t size);
-ssize_t atf_read_nor(uintptr_t offset, void *buffer, size_t size);
-ssize_t atf_get_pcount(void);
-ssize_t atf_get_part(struct storage_partition *part, unsigned int index);
-ssize_t atf_erase_nor(uintptr_t offset, size_t size);
-ssize_t atf_write_nor(uintptr_t offset, const void *buffer, size_t size);
-ssize_t atf_write_mmc(uintptr_t offset, const void *buffer, size_t size);
-ssize_t atf_dram_size(unsigned int node);
-ssize_t atf_node_count(void);
-ssize_t atf_env_count(void);
-ssize_t atf_env_string(size_t index, char *str);
-
-#endif
diff --git a/include/cavium/atf_part.h b/include/cavium/atf_part.h
deleted file mode 100644
index 182f6f4..0000000
--- a/include/cavium/atf_part.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/**
- * (C) Copyright 2014, Cavium Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
-**/
-
-#ifndef __ATF_PART_H__
-#define __ATF_PART_H__
-
-struct storage_partition {
-	unsigned int type;
-	unsigned int size;
-	unsigned long offset;
-};
-
-enum {
-	PARTITION_NBL1FW_REST = 0,
-	PARTITION_BL2_BL31 = 1,
-	PARTITION_UBOOT = 2,
-	PARTITION_UEFI = 2,
-	PARTITION_KERNEL = 3,
-	PARTITION_DEVICE_TREE = 4,
-	PARTITION_LAST,
-};
-
-#endif
diff --git a/include/cavium/thunderx_svc.h b/include/cavium/thunderx_svc.h
deleted file mode 100644
index 416ce3c..0000000
--- a/include/cavium/thunderx_svc.h
+++ /dev/null
@@ -1,67 +0,0 @@
-/**
- * (C) Copyright 2014, Cavium Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
-**/
-
-#ifndef __THUNDERX_SVC_H__
-#define __THUNDERX_SVC_H__
-
-/* SMC function IDs for general purpose queries */
-
-#define THUNDERX_SVC_CALL_COUNT		0x4300ff00
-#define THUNDERX_SVC_UID		0x4300ff01
-
-#define THUNDERX_SVC_VERSION		0x4300ff03
-
-#define ARM_STD_SVC_VERSION		0x8400ff03
-
-/* ThunderX Service Calls version numbers */
-#define THUNDERX_VERSION_MAJOR	0x0
-#define THUNDERX_VERSION_MINOR	0x1
-
-#define THUNDERX_MMC_READ		0x43000101
-/* x1 - block address
- * x2 - size
- * x3 - buffer address
- */
-#define THUNDERX_MMC_WRITE		0x43000102
-/* x1 - block address
- * x2 - size
- * x3 - buffer address
- */
-
-#define THUNDERX_NOR_READ		0x43000111
-/* x1 - block address
- * x2 - size
- * x3 - buffer address
- */
-#define THUNDERX_NOR_WRITE		0x43000112
-/* x1 - block address
- * x2 - size
- * x3 - buffer address
- */
-#define THUNDERX_NOR_ERASE		0x43000113
-/* x1 - block address
- */
-
-#define THUNDERX_PART_COUNT		0x43000201
-#define THUNDERX_GET_PART		0x43000202
-/* x1 - pointer to the buffer
- * x2 - index
- */
-
-#define THUNDERX_DRAM_SIZE		0x43000301
-/* x1 - node number
- */
-
-#define THUNDERX_GTI_SYNC		0x43000401
-
-#define THUNDERX_ENV_COUNT		0x43000501
-#define THUNDERX_ENV_STRING		0x43000502
-/* x1 - index
- */
-
-#define THUNDERX_NODE_COUNT		0x43000601
-
-#endif /* __THUNDERX_SVC_H__ */
diff --git a/include/common.h b/include/common.h
index 0fe9439..8763ccf 100644
--- a/include/common.h
+++ b/include/common.h
@@ -252,6 +252,7 @@ int do_ext2load(cmd_tbl_t *, int, int, char * const []);
 int	env_init     (void);
 void	env_relocate (void);
 int	envmatch     (uchar *, int);
+int	env_set_force(const char *varname, const char *varvalue);
 
 /**
  * env_get() - Look up the value of an environment variable
@@ -338,6 +339,8 @@ int env_set_ulong(const char *varname, ulong value);
  */
 int env_set_hex(const char *varname, ulong value);
 
+int setenv_force (const char *, const char *);
+
 /**
  * env_set_addr - Set an environment variable to an address in hex
  *
@@ -423,6 +426,7 @@ int board_late_init (void);
 int board_postclk_init (void); /* after clocks/timebase, before env/serial */
 int board_early_init_r (void);
 void board_poweroff (void);
+bool alternate_pkg (void);
 
 #if defined(CONFIG_SYS_DRAM_TEST)
 int testdram(void);
diff --git a/include/configs/armada8k.h b/include/configs/armada8k.h
new file mode 100644
index 0000000..4de3c2d
--- /dev/null
+++ b/include/configs/armada8k.h
@@ -0,0 +1,131 @@
+opyright (C) 2015 Marvell International Ltd.
+ * ***************************************************************************
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * ***************************************************************************
+ */
+
+#ifndef __ARMADA_8K_H
+#define __ARMADA_8K_H
+
+#include "common_config.h"
+
+/* Version */
+#define CONFIG_BOOTP_VCI_STRING         "U-boot.armv8.armada8k"
+
+/*
+#define MV_INCLUDE_SDIO
+#define MV_INCLUDE_INTEG_SATA
+#define MV_INCLUDE_CLK_PWR_CNTRL
+
+#define MV_INCLUDE_RCVR
+#define MV_INCLUDE_NAND
+#define MV_INCLUDE_SPI
+#define MV_INCLUDE_XOR
+#define MV_INCLUDE_SATA
+#define MV_INCLUDE_USB
+#define CONFIG_MV_ETH_NETA
+#define MV_INCLUDE_GPIO
+#define MV_INCLUDE_I2C
+#define MV_INCLUDE_PEX
+*/
+#define CONFIG_GZIP_COMPRESSED
+
+#undef CONFIG_GICV3
+#define CONFIG_GICV2
+
+#define CONFIG_GENERIC_TIMER
+#define CONFIG_REMAKE_ELF
+
+/* Clock Definitions */
+#ifndef CONFIG_PALLADIUM
+#define COUNTER_FREQUENCY	(25 * 1000000)
+#define CONFIG_MSS_FREQUENCY	(200 * 1000000)
+#else
+#define COUNTER_FREQUENCY	(48000)
+#define CONFIG_MSS_FREQUENCY	(384000)
+#endif
+#if defined(CONFIG_MVEBU_RTC)
+#define ERRATA_FE_3124064
+#endif
+
+#ifdef CONFIG_SPL_BUILD
+/* SPL */
+/* Defines for SPL */
+#define CONFIG_SPL_TEXT_BASE		0xFFE1C048
+#define CONFIG_SPL_MAX_SIZE		(0x27000)
+
+#ifndef __ASSEMBLY__
+extern char __end_of_spl[];
+#endif /* __ASSEMBLY__ */
+#define CONFIG_SYS_SPL_MALLOC_START	((ulong)__end_of_spl)
+#define CONFIG_SYS_SPL_MALLOC_SIZE	(0x4000)
+#endif /* CONFIG_SPL_BUILD */
+#define CONFIG_SPL_LDSCRIPT		"arch/arm/cpu/mvebu-common/u-boot-armv8-spl.lds"
+
+#define CONFIG_SYS_NS16550
+/*
+ * Include the generic MVEBU configuration file.
+ * The generic file is affected by the defines above.
+ */
+#include "mvebu-common.h"
+
+#undef CONFIG_MVEBU_UBOOT_DFLT_NAME
+#define CONFIG_MVEBU_UBOOT_DFLT_NAME	"flash-image.bin"
+
+#define CONFIG_SYS_PCI_64BIT	/* enable 64-bit PCI resources */
+
+/* Platform environment variables needed by the common env infrastructure */
+/* 	"onie_start=0xe8020000\0" \
+ */
+#define CONFIG_PLATFORM_ENV    \
+	"onie_sz.b=0x00800000\0"
+#ifndef CONFIG_ONIE_COMMON_UBOOT_ENV
+#define CONFIG_ONIE_COMMON_UBOOT_ENV ""
+#endif
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_PLATFORM_ENV       \
+	CONFIG_EXTRA_ENV_CFG      \
+	CONFIG_ONIE_COMMON_UBOOT_ENV
+
+/*
+ * SOC specific overrides
+ * Add here all config values that differ
+ * from the generic value in mvebu-common.h
+ */
+
+/* Emulation specific setting */
+#ifdef CONFIG_PALLADIUM
+
+#undef CONFIG_BOOTDELAY
+#define CONFIG_BOOTDELAY                -1
+
+#undef CONFIG_BAUDRATE
+#define CONFIG_BAUDRATE                 24000
+
+#undef CONFIG_BOOTARGS
+#define CONFIG_BOOTARGS		"console=ttyS0,24000 earlycon=uart8250,mmio32,0xf0512000 " \
+				"mem=256M init=/bin/sh root=/dev/ram0 rw"
+
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#define CONFIG_EXTRA_ENV_SETTINGS	"kernel_addr=0x180000\0"	\
+					"fdt_addr=0x1000000\0"		\
+					"ramfs_addr=0x3000000\0"	\
+					"fdt_high=0xa0000000\0"		\
+					"initrd_high=0xffffffffffffffff\0"
+
+#undef CONFIG_BOOTCOMMAND
+#define CONFIG_BOOTCOMMAND		"booti $kernel_addr $ramfs_addr $fdt_addr"
+
+#endif /*CONFIG_PALLADIUM*/
+
+#endif /* __ARMADA_8K_H */
diff --git a/include/configs/clearfog.h b/include/configs/clearfog.h
index 7089bc4..3e689b6 100644
--- a/include/configs/clearfog.h
+++ b/include/configs/clearfog.h
@@ -62,7 +62,6 @@
 
 /* PCIe support */
 #ifndef CONFIG_SPL_BUILD
-#define CONFIG_PCI_MVEBU
 #define CONFIG_PCI_SCAN_SHOW
 #endif
 
diff --git a/include/configs/controlcenterdc.h b/include/configs/controlcenterdc.h
index e34b08e..6c04f05 100644
--- a/include/configs/controlcenterdc.h
+++ b/include/configs/controlcenterdc.h
@@ -67,9 +67,6 @@
 
 /* PCIe support */
 #ifndef CONFIG_SPL_BUILD
-#define CONFIG_PCI
-#define CONFIG_PCI_MVEBU
-#define CONFIG_PCI_PNP
 #define CONFIG_PCI_SCAN_SHOW
 #endif
 
diff --git a/include/configs/db-88f6820-amc.h b/include/configs/db-88f6820-amc.h
index f039f0b..17f7e47 100644
--- a/include/configs/db-88f6820-amc.h
+++ b/include/configs/db-88f6820-amc.h
@@ -43,7 +43,6 @@
 
 /* PCIe support */
 #ifndef CONFIG_SPL_BUILD
-#define CONFIG_PCI_MVEBU
 #define CONFIG_PCI_SCAN_SHOW
 #endif
 
diff --git a/include/configs/db-88f6820-gp.h b/include/configs/db-88f6820-gp.h
index db7346a..663e98a 100644
--- a/include/configs/db-88f6820-gp.h
+++ b/include/configs/db-88f6820-gp.h
@@ -31,6 +31,12 @@
 #define CONFIG_SYS_I2C_SLAVE		0x0
 #define CONFIG_SYS_I2C_SPEED		100000
 
+/*
+ * SPI Flash configuration for the environemnt access
+ */
+#define CONFIG_ENV_SPI_BUS		0
+#define CONFIG_ENV_SPI_CS		0
+
 /* SPI NOR flash default params, used by sf commands */
 #define CONFIG_SF_DEFAULT_SPEED		1000000
 #define CONFIG_SF_DEFAULT_MODE		SPI_MODE_3
@@ -62,16 +68,13 @@
 
 /* PCIe support */
 #ifndef CONFIG_SPL_BUILD
-#define CONFIG_PCI_MVEBU
 #define CONFIG_PCI_SCAN_SHOW
 #endif
 
 #define CONFIG_SYS_ALT_MEMTEST
 
-/* Keep device tree and initrd in lower memory so the kernel can access them */
-#define CONFIG_EXTRA_ENV_SETTINGS	\
-	"fdt_high=0x10000000\0"		\
-	"initrd_high=0x10000000\0"
+#define CONFIG_DEFAULT_CONSOLE		"console=ttyS0,115200 "\
+					"earlyprintk=ttyS0,115200"
 
 /* SPL */
 /*
diff --git a/include/configs/db-mv784mp-gp.h b/include/configs/db-mv784mp-gp.h
index 115b593..c9cf039 100644
--- a/include/configs/db-mv784mp-gp.h
+++ b/include/configs/db-mv784mp-gp.h
@@ -52,7 +52,6 @@
 
 /* PCIe support */
 #ifndef CONFIG_SPL_BUILD
-#define CONFIG_PCI_MVEBU
 #define CONFIG_PCI_SCAN_SHOW
 #endif
 
diff --git a/include/configs/ds414.h b/include/configs/ds414.h
index 6921714..ecece8e 100644
--- a/include/configs/ds414.h
+++ b/include/configs/ds414.h
@@ -47,7 +47,6 @@
 
 /* PCIe support */
 #ifndef CONFIG_SPL_BUILD
-#define CONFIG_PCI_MVEBU
 #define CONFIG_PCI_SCAN_SHOW
 #endif
 
diff --git a/include/configs/mv-common.h b/include/configs/mv-common.h
index 3035a11..7e09ed1 100644
--- a/include/configs/mv-common.h
+++ b/include/configs/mv-common.h
@@ -117,4 +117,61 @@
 #define CONFIG_MTD_PARTITIONS
 #endif
 
+/* Default Env vars */
+#define CONFIG_IPADDR			0.0.0.0	/* In order to cause an error */
+#define CONFIG_SERVERIP			0.0.0.0	/* In order to cause an error */
+#define CONFIG_NETMASK			255.255.255.0
+#define CONFIG_GATEWAYIP		10.4.50.254
+#define CONFIG_HAS_ETH1
+#define CONFIG_ETHPRIME			"eth0"
+#define CONFIG_ROOTPATH                 "/srv/nfs/" /* Default Dir for NFS */
+#define CONFIG_ENV_OVERWRITE		/* ethaddr can be reprogrammed */
+#define CONFIG_EXTRA_ENV_SETTINGS	"bootcmd=run get_images; " \
+						"run set_bootargs; " \
+						"bootz $kernel_addr_r " \
+						"$ramdisk_addr_r " \
+						"$fdt_addr_r\0" \
+					"extra_params=pci=pcie_bus_safe\0" \
+					"kernel_addr_r=0x7000000\0"	\
+					"initrd_addr=0xa00000\0"	\
+					"initrd_size=0x2000000\0"	\
+					"fdt_addr_r=0x6f00000\0"	\
+					"loadaddr=0x6000000\0"		\
+					"fdt_high=0xffffffffffffffff\0"	\
+					"hostname=marvell\0"		\
+					"ramdisk_addr_r=0x8000000\0"	\
+					"ramfs_name=-\0"		\
+					"cpuidle=cpuidle.off=1\0"	\
+					"fdt_name=fdt.dtb\0"		\
+					"netdev=eth0\0"			\
+					"ethaddr=00:51:82:11:22:00\0"	\
+					"eth1addr=00:51:82:11:22:01\0"	\
+					"eth2addr=00:51:82:11:22:02\0"	\
+					"eth3addr=00:51:82:11:22:03\0"	\
+					"image_name=zImage\0"		\
+					"get_ramfs=if test \"${ramfs_name}\"" \
+						" != \"-\"; then setenv " \
+						"ramdisk_addr_r 0x8000000; " \
+						"tftpboot $ramdisk_addr_r " \
+						"$ramfs_name; else setenv " \
+						"ramdisk_addr_r -;fi\0"	\
+					"get_images=tftpboot $kernel_addr_r " \
+						"$image_name; tftpboot " \
+						"$fdt_addr_r $fdt_name; " \
+						"run get_ramfs\0"	\
+					"console=" CONFIG_DEFAULT_CONSOLE "\0"\
+					"root=root=/dev/nfs rw\0"	\
+					"set_bootargs=setenv bootargs $console"\
+						" $root ip=$ipaddr:$serverip:" \
+						"$gatewayip:$netmask:$hostname"\
+						":$netdev:none nfsroot="\
+						"$serverip:$rootpath,tcp,v3 " \
+						"$extra_params " \
+						"$cpuidle\0"
+
+/*
+ * PCI
+ */
+#define CONFIG_PCIAUTO_SKIP_HOST_BRIDGE     1
+
 #endif /* _MV_COMMON_H */
diff --git a/include/configs/mvebu_armada-37xx.h b/include/configs/mvebu_armada-37xx.h
index 52f8c5d..cf8a77a 100644
--- a/include/configs/mvebu_armada-37xx.h
+++ b/include/configs/mvebu_armada-37xx.h
@@ -7,52 +7,15 @@
 #ifndef _CONFIG_MVEBU_ARMADA_37XX_H
 #define _CONFIG_MVEBU_ARMADA_37XX_H
 
-/*
- * High Level Configuration Options (easy to change)
- */
-#define CONFIG_DISPLAY_BOARDINFO_LATE
-
-/* additions for new ARM relocation support */
-#define CONFIG_SYS_SDRAM_BASE	0x00000000
+#define CONFIG_DEFAULT_CONSOLE		"console=ttyMV0,115200 "\
+					"earlycon=ar3700_uart,0xd0012000"
 
-#define CONFIG_NR_DRAM_BANKS	1
-
-/* auto boot */
-#define CONFIG_PREBOOT
-
-#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, \
-					  115200, 230400, 460800, 921600 }
+#include <configs/mvebu_armada-common.h>
 
 /*
- * For booting Linux, the board info and command line data
- * have to be in the first 8 MB of memory, since this is
- * the maximum mapped by the Linux kernel during initialization.
- */
-#define CONFIG_CMDLINE_TAG		/* enable passing of ATAGs  */
-#define CONFIG_INITRD_TAG		/* enable INITRD tag */
-#define CONFIG_SETUP_MEMORY_TAGS	/* enable memory tag */
-
-#define	CONFIG_SYS_CBSIZE	1024	/* Console I/O Buff Size */
-
-/*
- * Size of malloc() pool
+ * High Level Configuration Options (easy to change)
  */
-#define CONFIG_SYS_MALLOC_LEN	(4 << 20) /* 4MiB for malloc() */
-
-/*
- * Other required minimal configurations
- */
-#define CONFIG_ARCH_CPU_INIT		/* call arch_cpu_init() */
-#define CONFIG_SYS_LOAD_ADDR	0x00800000	/* default load adr- 8M */
-#define CONFIG_SYS_MEMTEST_START 0x00800000	/* 8M */
-#define CONFIG_SYS_MEMTEST_END	0x00ffffff	/*(_16M -1) */
-#define CONFIG_SYS_RESET_ADDRESS 0xffff0000	/* Rst Vector Adr */
-#define CONFIG_SYS_MAXARGS	32	/* max number of command args */
-
-#define CONFIG_SYS_ALT_MEMTEST
-
-/* End of 16M scrubbed by training in bootrom */
-#define CONFIG_SYS_INIT_SP_ADDR         (CONFIG_SYS_TEXT_BASE + 0xFF0000)
+#define CONFIG_NR_DRAM_BANKS	4
 
 /*
  * I2C
@@ -61,61 +24,10 @@
 #define CONFIG_SYS_I2C_SLAVE		0x0
 
 /*
- * SPI Flash configuration
- */
-#define CONFIG_ENV_SPI_BUS		0
-#define CONFIG_ENV_SPI_CS		0
-
-/* SPI NOR flash default params, used by sf commands */
-#define CONFIG_SF_DEFAULT_SPEED		1000000
-#define CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
-#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
-
-/* Environment in SPI NOR flash */
-#define CONFIG_ENV_OFFSET		0x180000 /* as Marvell U-Boot version */
-#define CONFIG_ENV_SIZE			(64 << 10) /* 64KiB */
-#define CONFIG_ENV_SECT_SIZE		(64 << 10) /* 64KiB sectors */
-
-/*
  * Ethernet Driver configuration
  */
-#define CONFIG_ENV_OVERWRITE	/* ethaddr can be reprogrammed */
-#define CONFIG_ARP_TIMEOUT	200
-#define CONFIG_NET_RETRY_COUNT	50
 #define CONFIG_PHY_MARVELL
 
-#define CONFIG_USB_MAX_CONTROLLER_COUNT (3 + 3)
-
-/* USB ethernet */
-
-/*
- * SATA/SCSI/AHCI configuration
- */
-#define CONFIG_SCSI_AHCI_PLAT
-#define CONFIG_LBA48
-#define CONFIG_SYS_64BIT_LBA
-
-#define CONFIG_SYS_SCSI_MAX_SCSI_ID	2
-#define CONFIG_SYS_SCSI_MAX_LUN		1
-#define CONFIG_SYS_SCSI_MAX_DEVICE	(CONFIG_SYS_SCSI_MAX_SCSI_ID * \
-					 CONFIG_SYS_SCSI_MAX_LUN)
-
-#define BOOT_TARGET_DEVICES(func) \
-	func(MMC, mmc, 1) \
-	func(MMC, mmc, 0) \
-	func(USB, usb, 0) \
-	func(SCSI, scsi, 0) \
-	func(PXE, pxe, na) \
-	func(DHCP, dhcp, na)
-
-#include <config_distro_bootcmd.h>
-
-#define CONFIG_EXTRA_ENV_SETTINGS	\
-	"scriptaddr=0x4d00000\0"	\
-	"pxefile_addr_r=0x4e00000\0"	\
-	"fdt_addr_r=0x4f00000\0"	\
-	"kernel_addr_r=0x5000000\0"	\
-	"ramdisk_addr_r=0x8000000\0"	\
-	BOOTENV
+#define CONFIG_USB_MAX_CONTROLLER_COUNT (1 + 2)
 
 #endif /* _CONFIG_MVEBU_ARMADA_37XX_H */
diff --git a/include/configs/mvebu_armada-8k.h b/include/configs/mvebu_armada-8k.h
index f288cf5..daac8ba 100644
--- a/include/configs/mvebu_armada-8k.h
+++ b/include/configs/mvebu_armada-8k.h
@@ -7,103 +7,30 @@
 #ifndef _CONFIG_MVEBU_ARMADA_8K_H
 #define _CONFIG_MVEBU_ARMADA_8K_H
 
-/*
- * High Level Configuration Options (easy to change)
- */
-#define CONFIG_SYS_TCLK		250000000	/* 250MHz */
-
-#define CONFIG_DISPLAY_BOARDINFO_LATE
-
-/* additions for new ARM relocation support */
-#define CONFIG_SYS_SDRAM_BASE	0x00000000
-
-#define CONFIG_NR_DRAM_BANKS	1
-
-/* auto boot */
-#define CONFIG_PREBOOT
-
-#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, \
-					  115200, 230400, 460800, 921600 }
-
-/*
- * For booting Linux, the board info and command line data
- * have to be in the first 8 MB of memory, since this is
- * the maximum mapped by the Linux kernel during initialization.
- */
-#define CONFIG_CMDLINE_TAG		/* enable passing of ATAGs  */
-#define CONFIG_INITRD_TAG		/* enable INITRD tag */
-#define CONFIG_SETUP_MEMORY_TAGS	/* enable memory tag */
-
-#define	CONFIG_SYS_CBSIZE	1024	/* Console I/O Buff Size */
-
-/*
- * Size of malloc() pool
- */
-#define CONFIG_SYS_MALLOC_LEN	(4 << 20) /* 4MiB for malloc() */
+#define CONFIG_DEFAULT_CONSOLE		"console=ttyS0,115200 "\
+					"earlycon=uart8250,mmio32,0xf0512000"
 
-/*
- * Other required minimal configurations
- */
-#define CONFIG_ARCH_CPU_INIT		/* call arch_cpu_init() */
-#define CONFIG_SYS_LOAD_ADDR	0x00800000	/* default load adr- 8M */
-#define CONFIG_SYS_MEMTEST_START 0x00800000	/* 8M */
-#define CONFIG_SYS_MEMTEST_END	0x00ffffff	/*(_16M -1) */
-#define CONFIG_SYS_RESET_ADDRESS 0xffff0000	/* Rst Vector Adr */
-#define CONFIG_SYS_MAXARGS	32	/* max number of command args */
-
-#define CONFIG_SYS_ALT_MEMTEST
-
-/* End of 16M scrubbed by training in bootrom */
-#define CONFIG_SYS_INIT_SP_ADDR         (CONFIG_SYS_TEXT_BASE + 0xFF0000)
+#include <configs/mvebu_armada-common.h>
 
 /*
- * SPI Flash configuration
+ * High Level Configuration Options (easy to change)
  */
-#define CONFIG_ENV_SPI_BUS		0
-#define CONFIG_ENV_SPI_CS		0
+#define CONFIG_SYS_TCLK		250000000	/* 250MHz */
 
-/* SPI NOR flash default params, used by sf commands */
-#define CONFIG_SF_DEFAULT_SPEED		1000000
-#define CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
-#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+#define CONFIG_NR_DRAM_BANKS	2
 
-#define CONFIG_ENV_OFFSET		0x180000 /* as Marvell U-Boot version */
-#define CONFIG_ENV_SIZE			(64 << 10) /* 64KiB */
-#define CONFIG_ENV_SECT_SIZE		(64 << 10) /* 64KiB sectors */
+#define CONFIG_BOARD_EARLY_INIT_R
 
 #define CONFIG_SYS_MAX_NAND_DEVICE	1
 #define CONFIG_SYS_NAND_MAX_CHIPS	1
 #define CONFIG_SYS_NAND_ONFI_DETECTION
 #define CONFIG_SYS_NAND_USE_FLASH_BBT
 
-/*
- * Ethernet Driver configuration
- */
-#define CONFIG_ENV_OVERWRITE	/* ethaddr can be reprogrammed */
-#define CONFIG_ARP_TIMEOUT	200
-#define CONFIG_NET_RETRY_COUNT	50
-
 #define CONFIG_USB_MAX_CONTROLLER_COUNT (3 + 3)
 
-/* USB ethernet */
-
-/*
- * SATA/SCSI/AHCI configuration
- */
-#define CONFIG_SCSI_AHCI_PLAT
-#define CONFIG_LBA48
-#define CONFIG_SYS_64BIT_LBA
-
-#define CONFIG_SYS_SCSI_MAX_SCSI_ID	2
-#define CONFIG_SYS_SCSI_MAX_LUN		1
-#define CONFIG_SYS_SCSI_MAX_DEVICE	(CONFIG_SYS_SCSI_MAX_SCSI_ID * \
-					 CONFIG_SYS_SCSI_MAX_LUN)
-
-/*
- * PCI configuration
- */
-#ifdef CONFIG_PCIE_DW_MVEBU
-#define CONFIG_E1000
+/* RTC configuration */
+#ifdef CONFIG_MARVELL_RTC
+#define ERRATA_FE_3124064
 #endif
 
 #endif /* _CONFIG_MVEBU_ARMADA_8K_H */
diff --git a/include/configs/mvebu_armada-common.h b/include/configs/mvebu_armada-common.h
new file mode 100644
index 0000000..f87552b
--- /dev/null
+++ b/include/configs/mvebu_armada-common.h
@@ -0,0 +1,178 @@
+/*
+ * Copyright (C) 2016 Stefan Roese <sr@denx.de>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _CONFIG_MVEBU_ARMADA_H
+#define _CONFIG_MVEBU_ARMADA_H
+
+#include <asm/arch/soc.h>
+
+/*
+ * High Level Configuration Options (easy to change)
+ */
+#define CONFIG_DISPLAY_BOARDINFO_LATE
+
+/* additions for new ARM relocation support */
+#define CONFIG_SYS_SDRAM_BASE	0x00000000
+
+/* auto boot */
+#define CONFIG_PREBOOT
+
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, \
+					  115200, 230400, 460800, 921600 }
+
+/* Default Env vars */
+#define CONFIG_IPADDR			0.0.0.0	/* In order to cause an error */
+#define CONFIG_SERVERIP			0.0.0.0	/* In order to cause an error */
+#define CONFIG_NETMASK			255.255.255.0
+#define CONFIG_GATEWAYIP		10.4.50.254
+#define CONFIG_HAS_ETH1
+#define CONFIG_HAS_ETH2
+#define CONFIG_ETHPRIME			"eth0"
+#define CONFIG_ROOTPATH                 "/srv/nfs/" /* Default Dir for NFS */
+#define CONFIG_ENV_OVERWRITE		/* ethaddr can be reprogrammed */
+#define CONFIG_EXTRA_ENV_SETTINGS	"bootcmd=run get_images; " \
+						"run set_bootargs; " \
+						"booti $kernel_addr_r " \
+						"$ramdisk_addr_r " \
+						"$fdt_addr_r\0" \
+					"extra_params=pci=pcie_bus_safe\0" \
+					"kernel_addr_r=0x7000000\0"	\
+					"initrd_addr=0xa00000\0"	\
+					"initrd_size=0x2000000\0"	\
+					"fdt_addr_r=0x6f00000\0"	\
+					"loadaddr=0x6000000\0"		\
+					"fdt_high=0xffffffffffffffff\0"	\
+					"hostname=marvell\0"		\
+					"ramdisk_addr_r=0x8000000\0"	\
+					"ramfs_name=-\0"		\
+					"cpuidle=cpuidle.off=1\0"	\
+					"fdt_name=fdt.dtb\0"		\
+					"netdev=eth0\0"			\
+					"ethaddr=00:51:82:11:22:00\0"	\
+					"eth1addr=00:51:82:11:22:01\0"	\
+					"eth2addr=00:51:82:11:22:02\0"	\
+					"eth3addr=00:51:82:11:22:03\0"	\
+					"eth4addr=00:51:82:11:22:04\0"	\
+					"image_name=Image\0"		\
+					"get_ramfs=if test \"${ramfs_name}\"" \
+						" != \"-\"; then setenv " \
+						"ramdisk_addr_r 0x8000000; " \
+						"tftpboot $ramdisk_addr_r " \
+						"$ramfs_name; else setenv " \
+						"ramdisk_addr_r -;fi\0"	\
+					"get_images=tftpboot $kernel_addr_r " \
+						"$image_name; tftpboot " \
+						"$fdt_addr_r $fdt_name; " \
+						"run get_ramfs\0"	\
+					"console=" CONFIG_DEFAULT_CONSOLE "\0"\
+					"root=root=/dev/nfs rw\0"	\
+					"set_bootargs=setenv bootargs $console"\
+						" $root ip=$ipaddr:$serverip:" \
+						"$gatewayip:$netmask:$hostname"\
+						":$netdev:none nfsroot="\
+						"$serverip:$rootpath,tcp,v3 " \
+						"$extra_params " \
+						"$cpuidle\0" \
+					"usb_pgood_delay=5000"
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 8 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CONFIG_CMDLINE_TAG		/* enable passing of ATAGs  */
+#define CONFIG_INITRD_TAG		/* enable INITRD tag */
+#define CONFIG_SETUP_MEMORY_TAGS	/* enable memory tag */
+
+#define	CONFIG_SYS_CBSIZE	1024	/* Console I/O Buff Size */
+#define	CONFIG_SYS_PBSIZE	(CONFIG_SYS_CBSIZE \
+		+ sizeof(CONFIG_SYS_PROMPT) + 16)	/* Print Buff */
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN	(9 << 20) /* 16MiB for malloc() */
+
+/*
+ * Other required minimal configurations
+ */
+#define CONFIG_ARCH_CPU_INIT		/* call arch_cpu_init() */
+#define CONFIG_SYS_LOAD_ADDR	0x00800000	/* default load adr- 8M */
+#define CONFIG_SYS_MEMTEST_START 0x00800000	/* 8M */
+#define CONFIG_SYS_MEMTEST_END	0x00ffffff	/*(_16M -1) */
+#define CONFIG_SYS_RESET_ADDRESS 0xffff0000	/* Rst Vector Adr */
+#define CONFIG_SYS_MAXARGS	32	/* max number of command args */
+
+#define CONFIG_SYS_ALT_MEMTEST
+
+/* End of 16M scrubbed by training in bootrom */
+#define CONFIG_SYS_INIT_SP_ADDR         (CONFIG_SYS_TEXT_BASE + 0xFF0000)
+
+/*
+ * SPI Flash configuration
+ */
+#define CONFIG_ENV_SPI_BUS		0
+#define CONFIG_ENV_SPI_CS		0
+
+/* SPI NOR flash default params, used by sf commands */
+#define CONFIG_SF_DEFAULT_SPEED		40000000
+#define CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+
+/*
+ * Assume minimum flash/eMMC boot partition size of 4MB
+ * and save the environment at the end of the boot device
+ * There is one exclusion from this rule - the EspressoBIN board with eMMC.
+ * The eMMC device found on some EspressoBIN V7 boards has 2MB boot partition.
+ */
+#define CONFIG_ENV_SIZE			(64 << 10) /* 64KiB */
+#define CONFIG_ENV_SECT_SIZE		(64 << 10) /* 64KiB sectors */
+
+#ifdef CONFIG_MVEBU_NAND_BOOT
+/* In case of NAND, we want to start the environment on page boundary */
+#define CONFIG_ENV_OFFSET		0x400000
+#else
+#if defined(CONFIG_ENV_IS_IN_MMC) && \
+defined(CONFIG_TARGET_MVEBU_ARMADA_37XX) && defined(CONFIG_MV88E6XXX_SWITCH)
+/* This one should be EspressoBin, since A3700 DB does not have
+ * MV88E6XXX switch enabled. Is there any other way to detect it?
+ */
+#define CONFIG_ENV_OFFSET		(0x200000 - CONFIG_ENV_SIZE)
+#else
+#define CONFIG_ENV_OFFSET		(0x400000 - CONFIG_ENV_SIZE)
+#endif
+#endif
+
+/*
+ * Device ID and Boot partition defined in external script
+ */
+#define CONFIG_SYS_MMC_ENV_DEV		(CONFIG_MVEBU_BOOT_DEVICE)
+#define CONFIG_SYS_MMC_ENV_PART		(CONFIG_MVEBU_BOOT_PART)
+
+/*
+ * SATA/SCSI/AHCI configuration
+ */
+#define CONFIG_SCSI_AHCI_PLAT
+#define CONFIG_LBA48
+#define CONFIG_SYS_64BIT_LBA
+
+#define CONFIG_SYS_SCSI_MAX_SCSI_ID	2
+#define CONFIG_SYS_SCSI_MAX_LUN		1
+#define CONFIG_SYS_SCSI_MAX_DEVICE	(CONFIG_SYS_SCSI_MAX_SCSI_ID * \
+					 CONFIG_SYS_SCSI_MAX_LUN)
+
+/*
+ * Ethernet Driver configuration
+ */
+#define CONFIG_ARP_TIMEOUT	200
+#define CONFIG_NET_RETRY_COUNT	50
+
+/*
+ * The EEPROM ST M24C64 has 32 byte page write mode and takes up to 10 msec.
+ */
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS 10
+
+#endif /* _CONFIG_MVEBU_ARMADA_H */
diff --git a/include/configs/octeontx2_95xx.h b/include/configs/octeontx2_95xx.h
new file mode 100644
index 0000000..5bdb6a1
--- /dev/null
+++ b/include/configs/octeontx2_95xx.h
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#ifndef __OCTEONTX2_95XX_H__
+#define __OCTEONTX2_95XX_H__
+
+/* Generic Interrupt Controller Definitions */
+#define GICD_BASE			(0x801000000000)
+#define GICR_BASE			(0x801000002000)
+
+/* Generic Timer Definitions */
+#define COUNTER_FREQUENCY		(0x1800000)	/* 24MHz */
+
+#define CONFIG_SUPPORT_RAW_INITRD
+
+/** Maximum size of image supported for bootm (and bootable FIT images) */
+#define CONFIG_SYS_BOOTM_LEN		(256 << 20)
+
+/** Memory base address */
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_TEXT_BASE
+
+/** Stack starting address */
+#define CONFIG_SYS_INIT_SP_ADDR		(CONFIG_SYS_SDRAM_BASE + 0xffff0)
+
+/** Memory test starting address */
+#define CONFIG_SYS_MEMTEST_START	CONFIG_SYS_SDRAM_BASE
+
+/** Memory test end address */
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_SDRAM_BASE + 0xf0000)
+
+/** Heap size for U-Boot */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 64 * 1024 * 1024)
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_SYS_SDRAM_BASE
+
+#define CONFIG_NR_DRAM_BANKS		1
+
+#define CONFIG_MISC_INIT_R
+
+#define CONFIG_LAST_STAGE_INIT
+/* #define CONFIG_CMD_MDIO_DBG */
+
+/**
+ * Only allow the Ethernet MAC address environment variable to be
+ * overwritten once.
+ */
+#define CONFIG_OVERWRITE_ETHADDR_ONCE
+
+/** Reduce hashes printed out */
+#define CONFIG_TFTP_TSIZE
+
+/* BOOTP options */
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+#define CONFIG_BOOTP_PXE
+#define CONFIG_BOOTP_TFTP_SERVERIP
+
+/***** SPI Defines *********/
+#ifdef CONFIG_DM_SPI_FLASH
+#define CONFIG_SF_DEFAULT_SPEED 12500000
+#define CONFIG_SF_DEFAULT_MODE	0
+#define CONFIG_SF_DEFAULT_BUS	0
+#define CONFIG_SF_DEFAULT_CS	0
+#endif
+
+/** Extra environment settings */
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+					"loadaddr=040080000\0"	\
+					"autoload=0\0"
+
+/** Environment defines */
+#define CONFIG_ENV_SIZE			0x8000
+#define CONFIG_ENV_OFFSET		0xf00000
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_SYS_MMC_ENV_DEV		0
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_SECT_SIZE		(64*1024)
+#define CONFIG_ENV_SPI_MAX_HZ		12500000
+#define CONFIG_ENV_SPI_MODE		0
+#define CONFIG_ENV_SPI_BUS		0
+#define CONFIG_ENV_SPI_CS		0
+#endif
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE		1024	/** Console I/O Buffer Size */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+
+#define CONFIG_SYS_MAXARGS		64	/** max command args */
+
+#define CONFIG_SYS_MMC_MAX_BLK_COUNT	8191
+
+#undef CONFIG_SYS_PROMPT
+#define CONFIG_SYS_PROMPT		env_get("prompt")
+
+#define CONFIG_CMD_BKOPS_ENABLE
+#define CONFIG_SUPPORT_EMMC_RPMB
+#define CONFIG_SUPPORT_EMMC_BOOT
+
+#define CONFIG_MMC_OCTEONTX
+#ifndef CONFIG_BLK
+# define CONFIG_BLK
+#endif
+
+#endif /* __OCTEONTX2_95XX_H__ */
diff --git a/include/configs/octeontx2_96xx.h b/include/configs/octeontx2_96xx.h
new file mode 100644
index 0000000..79a0b2f
--- /dev/null
+++ b/include/configs/octeontx2_96xx.h
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#ifndef __OCTEONTX2_96XX_H__
+#define __OCTEONTX2_96XX_H__
+
+/* Generic Interrupt Controller Definitions */
+#define GICD_BASE			(0x801000000000)
+#define GICR_BASE			(0x801000002000)
+
+/* Generic Timer Definitions */
+#define COUNTER_FREQUENCY		(0x1800000)	/* 24MHz */
+
+#define CONFIG_SUPPORT_RAW_INITRD
+
+/** Maximum size of image supported for bootm (and bootable FIT images) */
+#define CONFIG_SYS_BOOTM_LEN		(256 << 20)
+
+/** Memory base address */
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_TEXT_BASE
+
+/** Stack starting address */
+#define CONFIG_SYS_INIT_SP_ADDR		(CONFIG_SYS_SDRAM_BASE + 0xffff0)
+
+/** Memory test starting address */
+#define CONFIG_SYS_MEMTEST_START	CONFIG_SYS_SDRAM_BASE
+
+/** Memory test end address */
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_SDRAM_BASE + 0xf0000)
+
+/** Heap size for U-Boot */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 64 * 1024 * 1024)
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_SYS_SDRAM_BASE
+
+#define CONFIG_NR_DRAM_BANKS		1
+
+#define CONFIG_MISC_INIT_R
+
+#define CONFIG_LAST_STAGE_INIT
+/* #define CONFIG_CMD_MDIO_DBG */
+
+/**
+ * Only allow the Ethernet MAC address environment variable to be
+ * overwritten once.
+ */
+#define CONFIG_OVERWRITE_ETHADDR_ONCE
+
+/** Reduce hashes printed out */
+#define CONFIG_TFTP_TSIZE
+
+/* BOOTP options */
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+#define CONFIG_BOOTP_PXE
+#define CONFIG_BOOTP_TFTP_SERVERIP
+
+/* AHCI support Definitions */
+#ifdef CONFIG_DM_SCSI
+/** Maximum number of SATA devices per controller*/
+#define CONFIG_SYS_SCSI_MAX_SCSI_ID	1
+/** Enable 48-bit SATA addressing */
+# define CONFIG_LBA48
+/** Enable 64-bit addressing */
+# define CONFIG_SYS_64BIT_LBA
+#endif
+
+/***** SPI Defines *********/
+#ifdef CONFIG_DM_SPI_FLASH
+#define CONFIG_SF_DEFAULT_SPEED 12500000
+#define CONFIG_SF_DEFAULT_MODE	0
+#define CONFIG_SF_DEFAULT_BUS	0
+#define CONFIG_SF_DEFAULT_CS	0
+#endif
+
+/** Extra environment settings */
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+					"loadaddr=040080000\0"	\
+					"ethrotate=yes\0"	\
+					"autoload=0\0"
+
+/** Environment defines */
+#define CONFIG_ENV_SIZE			0x8000
+#define CONFIG_ENV_OFFSET		0xf00000
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_SYS_MMC_ENV_DEV		0
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_SECT_SIZE		(64*1024)
+#define CONFIG_ENV_SPI_MAX_HZ		12500000
+#define CONFIG_ENV_SPI_MODE		0
+#define CONFIG_ENV_SPI_BUS		0
+#define CONFIG_ENV_SPI_CS		0
+#endif
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE		1024	/** Console I/O Buffer Size */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+
+#define CONFIG_SYS_MAXARGS		64	/** max command args */
+
+#define CONFIG_SYS_MMC_MAX_BLK_COUNT	8191
+
+#undef CONFIG_SYS_PROMPT
+#define CONFIG_SYS_PROMPT		env_get("prompt")
+
+/** EMMC specific defines */
+#define CONFIG_SUPPORT_EMMC_BOOT
+#define CONFIG_SUPPORT_EMMC_RPMB
+#define CONFIG_CMD_BKOPS_ENABLE
+
+#define CONFIG_MMC_OCTEONTX
+#ifndef CONFIG_BLK
+# define CONFIG_BLK
+#endif
+
+#endif /* __OCTEONTX2_96XX_H__ */
diff --git a/include/configs/octeontx2_98xx.h b/include/configs/octeontx2_98xx.h
new file mode 100644
index 0000000..5f57ef2
--- /dev/null
+++ b/include/configs/octeontx2_98xx.h
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#ifndef __OCTEONTX2_98XX_H__
+#define __OCTEONTX2_98XX_H__
+
+/* Generic Interrupt Controller Definitions */
+#define GICD_BASE			(0x801000000000)
+#define GICR_BASE			(0x801000002000)
+
+/* Generic Timer Definitions */
+#define COUNTER_FREQUENCY		(0x1800000)	/* 24MHz */
+
+#define CONFIG_SUPPORT_RAW_INITRD
+
+/** Maximum size of image supported for bootm (and bootable FIT images) */
+#define CONFIG_SYS_BOOTM_LEN		(256 << 20)
+
+/** Memory base address */
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_TEXT_BASE
+
+/** Stack starting address */
+#define CONFIG_SYS_INIT_SP_ADDR		(CONFIG_SYS_SDRAM_BASE + 0xffff0)
+
+/** Memory test starting address */
+#define CONFIG_SYS_MEMTEST_START	CONFIG_SYS_SDRAM_BASE
+
+/** Memory test end address */
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_SDRAM_BASE + 0xf0000)
+
+/** Heap size for U-Boot */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 64 * 1024 * 1024)
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_SYS_SDRAM_BASE
+
+#define CONFIG_NR_DRAM_BANKS		1
+
+#define CONFIG_MISC_INIT_R
+
+/*#define CONFIG_LAST_STAGE_INIT */
+
+/**
+ * Only allow the Ethernet MAC address environment variable to be
+ * overwritten once.
+ */
+#define CONFIG_OVERWRITE_ETHADDR_ONCE
+
+/** Reduce hashes printed out */
+#define CONFIG_TFTP_TSIZE
+
+/* BOOTP options */
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+#define CONFIG_BOOTP_PXE
+#define CONFIG_BOOTP_TFTP_SERVERIP
+
+/* AHCI support Definitions */
+#ifdef CONFIG_DM_SCSI
+/** Maximum number of SATA devices per controller*/
+#define CONFIG_SYS_SCSI_MAX_SCSI_ID	1
+/** Enable 48-bit SATA addressing */
+# define CONFIG_LBA48
+/** Enable 64-bit addressing */
+# define CONFIG_SYS_64BIT_LBA
+#endif
+
+/***** SPI Defines *********/
+#ifdef CONFIG_DM_SPI_FLASH
+#define CONFIG_SF_DEFAULT_SPEED 12500000
+#define CONFIG_SF_DEFAULT_MODE	0
+#define CONFIG_SF_DEFAULT_BUS	0
+#define CONFIG_SF_DEFAULT_CS	0
+#endif
+
+/** Extra environment settings */
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+					"loadaddr=040080000\0"	\
+					"ethrotate=yes\0"	\
+					"autoload=0\0"
+
+/** Environment defines */
+#define CONFIG_ENV_SIZE			0x8000
+#define CONFIG_ENV_OFFSET		0xf00000
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_SYS_MMC_ENV_DEV		0
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_SECT_SIZE		(64*1024)
+#define CONFIG_ENV_SPI_MAX_HZ		12500000
+#define CONFIG_ENV_SPI_MODE		0
+#define CONFIG_ENV_SPI_BUS		0
+#define CONFIG_ENV_SPI_CS		0
+#endif
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE		1024	/** Console I/O Buffer Size */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+
+#define CONFIG_SYS_MAXARGS		64	/** max command args */
+
+#define CONFIG_SYS_MMC_MAX_BLK_COUNT	8191
+
+#undef CONFIG_SYS_PROMPT
+#define CONFIG_SYS_PROMPT		env_get("prompt")
+
+/** EMMC specific defines */
+#define CONFIG_SUPPORT_EMMC_BOOT
+#define CONFIG_SUPPORT_EMMC_RPMB
+#define CONFIG_CMD_BKOPS_ENABLE
+
+#define CONFIG_MMC_OCTEONTX
+#ifndef CONFIG_BLK
+# define CONFIG_BLK
+#endif
+
+#endif /* __OCTEONTX2_98XX_H__ */
diff --git a/include/configs/octeontx2_cn913x.h b/include/configs/octeontx2_cn913x.h
new file mode 100644
index 0000000..a5487db
--- /dev/null
+++ b/include/configs/octeontx2_cn913x.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2016 Stefan Roese <sr@denx.de>
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _CONFIG_OCTEONTX2_CN913X_H
+#define _CONFIG_OCTEONTX2_CN913X_H
+
+#define CONFIG_DEFAULT_CONSOLE		"console=ttyS0,115200 "\
+					"earlycon=uart8250,mmio32,0xf0512000"
+
+#include <configs/mvebu_armada-common.h>
+
+/*
+ * High Level Configuration Options (easy to change)
+ */
+#define CONFIG_SYS_TCLK		250000000	/* 250MHz */
+
+#define CONFIG_NR_DRAM_BANKS	2
+
+#define CONFIG_BOARD_EARLY_INIT_R
+
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_MAX_CHIPS	1
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+#define CONFIG_SYS_NAND_USE_FLASH_BBT
+
+#define CONFIG_USB_MAX_CONTROLLER_COUNT (3 + 3)
+
+/* RTC configuration */
+#ifdef CONFIG_MARVELL_RTC
+#define ERRATA_FE_3124064
+#endif
+
+#endif /* _CONFIG_OCTEONTX2_CN913X_H */
diff --git a/include/configs/octeontx2_loki.h b/include/configs/octeontx2_loki.h
new file mode 100644
index 0000000..dc4f62b
--- /dev/null
+++ b/include/configs/octeontx2_loki.h
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2019 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#ifndef __OCTEONTX2_LOKI_H__
+#define __OCTEONTX2_LOKI_H__
+
+/* Generic Interrupt Controller Definitions */
+#define GICD_BASE			(0x801000000000)
+#define GICR_BASE			(0x801000002000)
+
+/* Generic Timer Definitions */
+#define COUNTER_FREQUENCY		(0x1800000)	/* 24MHz */
+
+#define CONFIG_SUPPORT_RAW_INITRD
+
+/** Maximum size of image supported for bootm (and bootable FIT images) */
+#define CONFIG_SYS_BOOTM_LEN		(256 << 20)
+
+/** Memory base address */
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_TEXT_BASE
+
+/** Stack starting address */
+#define CONFIG_SYS_INIT_SP_ADDR		(CONFIG_SYS_SDRAM_BASE + 0xffff0)
+
+/** Memory test starting address */
+#define CONFIG_SYS_MEMTEST_START	CONFIG_SYS_SDRAM_BASE
+
+/** Memory test end address */
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_SDRAM_BASE + 0xf0000)
+
+/** Heap size for U-Boot */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 64 * 1024 * 1024)
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_SYS_SDRAM_BASE
+
+#define CONFIG_NR_DRAM_BANKS		1
+
+#define CONFIG_MISC_INIT_R
+
+#define CONFIG_LAST_STAGE_INIT
+/* #define CONFIG_CMD_MDIO_DBG */
+
+/**
+ * Only allow the Ethernet MAC address environment variable to be
+ * overwritten once.
+ */
+#define CONFIG_OVERWRITE_ETHADDR_ONCE
+
+/** Reduce hashes printed out */
+#define CONFIG_TFTP_TSIZE
+
+/* BOOTP options */
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+#define CONFIG_BOOTP_PXE
+#define CONFIG_BOOTP_TFTP_SERVERIP
+
+/***** SPI Defines *********/
+#ifdef CONFIG_DM_SPI_FLASH
+#define CONFIG_SF_DEFAULT_SPEED 12500000
+#define CONFIG_SF_DEFAULT_MODE	0
+#define CONFIG_SF_DEFAULT_BUS	0
+#define CONFIG_SF_DEFAULT_CS	0
+#endif
+
+/** Extra environment settings */
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+					"loadaddr=040080000\0"	\
+					"autoload=0\0"
+
+/** Environment defines */
+#define CONFIG_ENV_SIZE			0x8000
+#define CONFIG_ENV_OFFSET		0xf00000
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_SYS_MMC_ENV_DEV		0
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#define CONFIG_ENV_SPI_MAX_HZ		12500000
+#define CONFIG_ENV_SPI_MODE		0
+#define CONFIG_ENV_SPI_BUS		0
+#define CONFIG_ENV_SPI_CS		0
+#endif
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE		1024	/** Console I/O Buffer Size */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+
+#define CONFIG_SYS_MAXARGS		64	/** max command args */
+
+#define CONFIG_SYS_MMC_MAX_BLK_COUNT	8191
+
+#undef CONFIG_SYS_PROMPT
+#define CONFIG_SYS_PROMPT		env_get("prompt")
+
+#define CONFIG_CMD_BKOPS_ENABLE
+#define CONFIG_SUPPORT_EMMC_RPMB
+#define CONFIG_SUPPORT_EMMC_BOOT
+
+#define CONFIG_MMC_OCTEONTX
+#ifndef CONFIG_BLK
+# define CONFIG_BLK
+#endif
+
+#endif /* __OCTEONTX2_LOKI_H__ */
diff --git a/include/configs/octeontx_81xx.h b/include/configs/octeontx_81xx.h
new file mode 100644
index 0000000..22543e9
--- /dev/null
+++ b/include/configs/octeontx_81xx.h
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#ifndef __OCTEONTX_81XX_H__
+#define __OCTEONTX_81XX_H__
+
+/* Generic Interrupt Controller Definitions */
+#define GICD_BASE			(0x801000000000)
+#define GICR_BASE			(0x801000002000)
+
+/* Generic Timer Definitions */
+#define COUNTER_FREQUENCY		(0x1800000)	/* 24MHz */
+
+#define CONFIG_SUPPORT_RAW_INITRD
+
+/** Maximum size of image supported for bootm (and bootable FIT images) */
+#define CONFIG_SYS_BOOTM_LEN		(256 << 20)
+
+/** Memory base address */
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_TEXT_BASE
+
+/** Stack starting address */
+#define CONFIG_SYS_INIT_SP_ADDR		(CONFIG_SYS_SDRAM_BASE + 0xffff0)
+
+/** Memory test starting address */
+#define CONFIG_SYS_MEMTEST_START	CONFIG_SYS_SDRAM_BASE
+
+/** Memory test end address */
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_SDRAM_BASE + 0xf0000)
+
+/** Heap size for U-Boot */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 64 * 1024 * 1024)
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_SYS_SDRAM_BASE
+
+#define CONFIG_NR_DRAM_BANKS		1
+
+/**
+ * Only allow the Ethernet MAC address environment variable to be
+ * overwritten once.
+ */
+#define CONFIG_OVERWRITE_ETHADDR_ONCE
+
+/** Maximum number of BGX interfaces per CPU node */
+#define CONFIG_MAX_BGX_PER_NODE		3
+
+/** Maximum total number of BGX interfaces across all nodes */
+#define CONFIG_MAX_BGX			3
+#define CONFIG_OCTEONTX_XCV
+
+#define CONFIG_MISC_INIT_R
+
+/** Reduce hashes printed out */
+#define CONFIG_TFTP_TSIZE
+
+/* BOOTP options */
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+#define CONFIG_BOOTP_PXE
+#define CONFIG_BOOTP_TFTP_SERVERIP
+
+/* AHCI support Definitions */
+#ifdef CONFIG_DM_SCSI
+/** Maximum number of SATA devices per controller*/
+#define CONFIG_SYS_SCSI_MAX_SCSI_ID	1
+/** Enable 48-bit SATA addressing */
+# define CONFIG_LBA48
+/** Enable 64-bit addressing */
+# define CONFIG_SYS_64BIT_LBA
+#endif
+
+/***** SPI Defines *********/
+#ifdef CONFIG_DM_SPI_FLASH
+# define CONFIG_SF_DEFAULT_SPEED 12500000
+# define CONFIG_SF_DEFAULT_MODE	0
+# define CONFIG_SF_DEFAULT_BUS	0
+# define CONFIG_SF_DEFAULT_CS	0
+#endif
+
+/** Extra environment settings */
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+					"loadaddr=040080000\0"	\
+					"autoload=0\0"
+
+/** Environment defines */
+#define CONFIG_ENV_SIZE			0x8000
+#define CONFIG_ENV_OFFSET		0xf00000
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_SYS_MMC_ENV_DEV		0
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_SECT_SIZE		(64*1024)
+#define CONFIG_ENV_SPI_MAX_HZ		12500000
+#define CONFIG_ENV_SPI_MODE		0
+#define CONFIG_ENV_SPI_BUS		0
+#define CONFIG_ENV_SPI_CS		0
+#endif
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE		1024	/** Console I/O Buffer Size */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+
+#define CONFIG_SYS_MAXARGS		64	/** max command args */
+
+#define CONFIG_SYS_MMC_MAX_BLK_COUNT	8191
+
+#undef CONFIG_SYS_PROMPT
+#define CONFIG_SYS_PROMPT		env_get("prompt")
+
+#define CONFIG_HW_WATCHDOG
+
+/** EMMC specific defines */
+#define CONFIG_SUPPORT_EMMC_BOOT
+#define CONFIG_SUPPORT_EMMC_RPMB
+#define CONFIG_CMD_BKOPS_ENABLE
+
+#define CONFIG_MMC_OCTEONTX
+#ifndef CONFIG_BLK
+# define CONFIG_BLK
+#endif
+
+#endif /* __OCTEONTX_81XX_H__ */
diff --git a/include/configs/octeontx_83xx.h b/include/configs/octeontx_83xx.h
new file mode 100644
index 0000000..691448a
--- /dev/null
+++ b/include/configs/octeontx_83xx.h
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:    GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+
+#ifndef __OCTEONTX_83XX_H__
+#define __OCTEONTX_83XX_H__
+
+/* Generic Interrupt Controller Definitions */
+#define GICD_BASE			(0x801000000000)
+#define GICR_BASE			(0x801000002000)
+
+/* Generic Timer Definitions */
+#define COUNTER_FREQUENCY		(0x1800000)	/* 24MHz */
+
+#define CONFIG_SUPPORT_RAW_INITRD
+
+/** Maximum size of image supported for bootm (and bootable FIT images) */
+#define CONFIG_SYS_BOOTM_LEN		(256 << 20)
+
+/** Memory base address */
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_TEXT_BASE
+
+/** Stack starting address */
+#define CONFIG_SYS_INIT_SP_ADDR		(CONFIG_SYS_SDRAM_BASE + 0xffff0)
+
+/** Memory test starting address */
+#define CONFIG_SYS_MEMTEST_START	CONFIG_SYS_SDRAM_BASE
+
+/** Memory test end address */
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_SDRAM_BASE + 0xf0000)
+
+/** Heap size for U-Boot */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 64 * 1024 * 1024)
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_SYS_SDRAM_BASE
+
+#define CONFIG_NR_DRAM_BANKS		1
+
+/**
+ * Only allow the Ethernet MAC address environment variable to be
+ * overwritten once.
+ */
+#define CONFIG_OVERWRITE_ETHADDR_ONCE
+
+/** Maximum number of BGX interfaces per CPU node */
+#define CONFIG_MAX_BGX_PER_NODE		4
+
+/** Maximum total number of BGX interfaces across all nodes */
+#define CONFIG_MAX_BGX			4
+
+#define CONFIG_MISC_INIT_R
+
+/** Reduce hashes printed out */
+#define CONFIG_TFTP_TSIZE
+
+/* BOOTP options */
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+#define CONFIG_BOOTP_PXE
+#define CONFIG_BOOTP_TFTP_SERVERIP
+
+/* AHCI support Definitions */
+#ifdef CONFIG_DM_SCSI
+/** Maximum number of SATA devices per controller*/
+#define CONFIG_SYS_SCSI_MAX_SCSI_ID	1
+/** Enable 48-bit SATA addressing */
+# define CONFIG_LBA48
+/** Enable 64-bit addressing */
+# define CONFIG_SYS_64BIT_LBA
+#endif
+
+/***** SPI Defines *********/
+#ifdef CONFIG_DM_SPI_FLASH
+#define CONFIG_SF_DEFAULT_SPEED 12500000
+#define CONFIG_SF_DEFAULT_MODE	0
+#define CONFIG_SF_DEFAULT_BUS	0
+#define CONFIG_SF_DEFAULT_CS	0
+#endif
+
+/** Extra environment settings */
+#define CONFIG_EXTRA_ENV_SETTINGS	\
+					"loadaddr=040080000\0"	\
+					"autoload=0\0"
+
+/** Environment defines */
+#define CONFIG_ENV_SIZE			0x8000
+#define CONFIG_ENV_OFFSET		0xf00000
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_SYS_MMC_ENV_DEV		0
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_SECT_SIZE		(64*1024)
+#define CONFIG_ENV_SPI_MAX_HZ		12500000
+#define CONFIG_ENV_SPI_MODE		0
+#define CONFIG_ENV_SPI_BUS		0
+#define CONFIG_ENV_SPI_CS		0
+#endif
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE		1024	/** Console I/O Buffer Size */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+
+#define CONFIG_SYS_MAXARGS		64	/** max command args */
+
+#define CONFIG_SYS_MMC_MAX_BLK_COUNT	8191
+
+#undef CONFIG_SYS_PROMPT
+#define CONFIG_SYS_PROMPT		env_get("prompt")
+
+#define CONFIG_HW_WATCHDOG
+
+/** EMMC specific defines */
+#define CONFIG_SUPPORT_EMMC_BOOT
+#define CONFIG_SUPPORT_EMMC_RPMB
+#define CONFIG_CMD_BKOPS_ENABLE
+
+#define CONFIG_MMC_OCTEONTX
+#ifndef CONFIG_BLK
+# define CONFIG_BLK
+#endif
+
+#endif /* __OCTEONTX_83XX_H__ */
diff --git a/include/configs/theadorable.h b/include/configs/theadorable.h
index e4ec2c0..02446f6 100644
--- a/include/configs/theadorable.h
+++ b/include/configs/theadorable.h
@@ -66,13 +66,6 @@
 #define CONFIG_SYS_SATA_MAX_DEVICE	1
 #define CONFIG_LBA48
 
-/* PCIe support */
-#ifdef CONFIG_CMD_PCI
-#ifndef CONFIG_SPL_BUILD
-#define CONFIG_PCI_MVEBU
-#endif
-#endif
-
 /* Enable LCD and reserve 512KB from top of memory*/
 #define CONFIG_SYS_MEM_TOP_HIDE		0x80000
 
diff --git a/include/configs/thunderx_88xx.h b/include/configs/thunderx_88xx.h
deleted file mode 100644
index 51e1e4e..0000000
--- a/include/configs/thunderx_88xx.h
+++ /dev/null
@@ -1,76 +0,0 @@
-/**
- * (C) Copyright 2014, Cavium Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
-**/
-
-#ifndef __THUNDERX_88XX_H__
-#define __THUNDERX_88XX_H__
-
-#define CONFIG_REMAKE_ELF
-
-#define CONFIG_THUNDERX
-
-#define CONFIG_SYS_64BIT
-
-#define MEM_BASE			0x00500000
-
-#define CONFIG_SYS_LOWMEM_BASE		MEM_BASE
-
-/* Link Definitions */
-#define CONFIG_SYS_INIT_SP_ADDR		(CONFIG_SYS_SDRAM_BASE + 0x7fff0)
-
-/* SMP Spin Table Definitions */
-#define CPU_RELEASE_ADDR		(CONFIG_SYS_SDRAM_BASE + 0x7fff0)
-
-/* Generic Timer Definitions */
-#define COUNTER_FREQUENCY		(0x1800000)	/* 24MHz */
-
-#define CONFIG_SYS_MEMTEST_START	MEM_BASE
-#define CONFIG_SYS_MEMTEST_END		(MEM_BASE + PHYS_SDRAM_1_SIZE)
-
-/* Size of malloc() pool */
-#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 1024 * 1024)
-
-/* PL011 Serial Configuration */
-
-#define CONFIG_PL011_CLOCK		24000000
-#define CONFIG_CONS_INDEX		1
-
-/* Generic Interrupt Controller Definitions */
-#define GICD_BASE			(0x801000000000)
-#define GICR_BASE			(0x801000002000)
-#define CONFIG_SYS_SERIAL0		0x87e024000000
-#define CONFIG_SYS_SERIAL1		0x87e025000000
-
-/* BOOTP options */
-#define CONFIG_BOOTP_BOOTFILESIZE
-
-/* Miscellaneous configurable options */
-#define CONFIG_SYS_LOAD_ADDR		(MEM_BASE)
-
-/* Physical Memory Map */
-#define CONFIG_NR_DRAM_BANKS		1
-#define PHYS_SDRAM_1			(MEM_BASE)	  /* SDRAM Bank #1 */
-#define PHYS_SDRAM_1_SIZE		(0x80000000-MEM_BASE)	/* 2048 MB */
-#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM_1
-
-/* Initial environment variables */
-#define UBOOT_IMG_HEAD_SIZE		0x40
-/* C80000 - 0x40 */
-#define CONFIG_EXTRA_ENV_SETTINGS	\
-					"kernel_addr=08007ffc0\0"	\
-					"fdt_addr=0x94C00000\0"		\
-					"fdt_high=0x9fffffff\0"
-
-/* Do not preserve environment */
-#define CONFIG_ENV_SIZE			0x1000
-
-/* Monitor Command Prompt */
-#define CONFIG_SYS_CBSIZE		512	/* Console I/O Buffer Size */
-#define CONFIG_SYS_MAXARGS		64		/* max command args */
-#define CONFIG_NO_RELOCATION		1
-#define PLL_REF_CLK			50000000	/* 50 MHz */
-#define NS_PER_REF_CLK_TICK		(1000000000/PLL_REF_CLK)
-
-#endif /* __THUNDERX_88XX_H__ */
diff --git a/include/configs/turris_omnia.h b/include/configs/turris_omnia.h
index 94a3be6..052ee66 100644
--- a/include/configs/turris_omnia.h
+++ b/include/configs/turris_omnia.h
@@ -71,7 +71,6 @@
 
 /* PCIe support */
 #ifndef CONFIG_SPL_BUILD
-#define CONFIG_PCI_MVEBU
 #define CONFIG_PCI_SCAN_SHOW
 #endif
 
diff --git a/include/ddr_spd.h b/include/ddr_spd.h
index 20dc9ea..b14270c 100644
--- a/include/ddr_spd.h
+++ b/include/ddr_spd.h
@@ -505,6 +505,8 @@ extern void ddr2_spd_dump(const ddr2_spd_eeprom_t *spd);
 extern unsigned int ddr3_spd_check(const ddr3_spd_eeprom_t *spd);
 unsigned int ddr4_spd_check(const struct ddr4_spd_eeprom_s *spd);
 
+const char *ddr3_modtype_str(const ddr3_spd_eeprom_t *spd);
+
 /*
  * Byte 2 Fundamental Memory Types.
  */
diff --git a/include/dm/device-internal.h b/include/dm/device-internal.h
index eaeadd4..28f1137 100644
--- a/include/dm/device-internal.h
+++ b/include/dm/device-internal.h
@@ -41,6 +41,10 @@ int device_bind(struct udevice *parent, const struct driver *drv,
 		const char *name, void *platdata, int of_offset,
 		struct udevice **devp);
 
+int device_bind_ofnode(struct udevice *parent, const struct driver *drv,
+		       const char *name, void *platdata, ofnode node,
+		       struct udevice **devp);
+
 /**
  * device_bind_with_driver_data() - Create a device and bind it to a driver
  *
diff --git a/include/dm/ofnode.h b/include/dm/ofnode.h
index 0d00840..8df0072 100644
--- a/include/dm/ofnode.h
+++ b/include/dm/ofnode.h
@@ -575,6 +575,19 @@ int ofnode_read_pci_addr(ofnode node, enum fdt_pci_space type,
 			 const char *propname, struct fdt_pci_addr *addr);
 
 /**
+ * ofnode_read_pci_vendev() - look up PCI vendor and device id
+ *
+ * Look at the compatible property of a device node that represents a PCI
+ * device and extract pci vendor id and device id from it.
+ *
+ * @param node		node to examine
+ * @param vendor	vendor id of the pci device
+ * @param device	device id of the pci device
+ * @return 0 if ok, negative on error
+ */
+int ofnode_read_pci_vendev(ofnode node, u16 *vendor, u16 *device);
+
+/**
  * ofnode_read_addr_cells() - Get the number of address cells for a node
  *
  * This walks back up the tree to find the closest #address-cells property
diff --git a/include/dm/uclass-id.h b/include/dm/uclass-id.h
index 07fabc3..7ccb2a9 100644
--- a/include/dm/uclass-id.h
+++ b/include/dm/uclass-id.h
@@ -49,6 +49,7 @@ enum uclass_id {
 	UCLASS_LPC,		/* x86 'low pin count' interface */
 	UCLASS_MAILBOX,		/* Mailbox controller */
 	UCLASS_MASS_STORAGE,	/* Mass storage device */
+	UCLASS_MDIO,		/* MDIO device */
 	UCLASS_MISC,		/* Miscellaneous device */
 	UCLASS_MMC,		/* SD / MMC card or chip */
 	UCLASS_MOD_EXP,		/* RSA Mod Exp device */
@@ -71,6 +72,7 @@ enum uclass_id {
 	UCLASS_REGULATOR,	/* Regulator device */
 	UCLASS_REMOTEPROC,	/* Remote Processor device */
 	UCLASS_RESET,		/* Reset controller device */
+	UCLASS_SAR,		/* Reset Sample Configuration */
 	UCLASS_RTC,		/* Real time clock device */
 	UCLASS_SCSI,		/* SCSI device */
 	UCLASS_SERIAL,		/* Serial UART */
diff --git a/include/dt-bindings/comphy/comphy_data.h b/include/dt-bindings/comphy/comphy_data.h
index 0983116..7736bb0 100644
--- a/include/dt-bindings/comphy/comphy_data.h
+++ b/include/dt-bindings/comphy/comphy_data.h
@@ -7,52 +7,44 @@
 #ifndef _COMPHY_DATA_H_
 #define _COMPHY_DATA_H_
 
-#define PHY_SPEED_1_25G			0
-#define PHY_SPEED_1_5G			1
-#define PHY_SPEED_2_5G			2
-#define PHY_SPEED_3G			3
-#define PHY_SPEED_3_125G		4
-#define PHY_SPEED_5G			5
-#define PHY_SPEED_5_15625G		6
-#define PHY_SPEED_6G			7
-#define PHY_SPEED_6_25G			8
-#define PHY_SPEED_10_3125G		9
-#define PHY_SPEED_MAX			10
-#define PHY_SPEED_INVALID		0xff
+#define COMPHY_SPEED_1_25G		0
+#define COMPHY_SPEED_2_5G		1
+#define COMPHY_SPEED_3_125G		2
+#define COMPHY_SPEED_5G			3
+#define COMPHY_SPEED_5_15625G		4
+#define COMPHY_SPEED_6G			5
+#define COMPHY_SPEED_10_3125G		6
+#define COMPHY_SPEED_MAX		7
+#define COMPHY_SPEED_INVALID		0xff
 
-#define PHY_TYPE_UNCONNECTED		0
-#define PHY_TYPE_PEX0			1
-#define PHY_TYPE_PEX1			2
-#define PHY_TYPE_PEX2			3
-#define PHY_TYPE_PEX3			4
-#define PHY_TYPE_SATA0			5
-#define PHY_TYPE_SATA1			6
-#define PHY_TYPE_SATA2			7
-#define PHY_TYPE_SATA3			8
-#define PHY_TYPE_SGMII0			9
-#define PHY_TYPE_SGMII1			10
-#define PHY_TYPE_SGMII2			11
-#define PHY_TYPE_SGMII3			12
-#define PHY_TYPE_QSGMII			13
-#define PHY_TYPE_USB3_HOST0		14
-#define PHY_TYPE_USB3_HOST1		15
-#define PHY_TYPE_USB3_DEVICE		16
-#define PHY_TYPE_XAUI0			17
-#define PHY_TYPE_XAUI1			18
-#define PHY_TYPE_XAUI2			19
-#define PHY_TYPE_XAUI3			20
-#define PHY_TYPE_RXAUI0			21
-#define PHY_TYPE_RXAUI1			22
-#define PHY_TYPE_SFI			23
-#define PHY_TYPE_IGNORE			24
-#define PHY_TYPE_MAX			25
-#define PHY_TYPE_INVALID		0xff
+#define COMPHY_TYPE_UNCONNECTED		0
+#define COMPHY_TYPE_PEX0		1
+#define COMPHY_TYPE_PEX1		2
+#define COMPHY_TYPE_PEX2		3
+#define COMPHY_TYPE_PEX3		4
+#define COMPHY_TYPE_SATA0		5
+#define COMPHY_TYPE_SATA1		6
+#define COMPHY_TYPE_SGMII0		7
+#define COMPHY_TYPE_SGMII1		8
+#define COMPHY_TYPE_SGMII2		9
+#define COMPHY_TYPE_USB3		10
+#define COMPHY_TYPE_USB3_HOST0		11
+#define COMPHY_TYPE_USB3_HOST1		12
+#define COMPHY_TYPE_USB3_DEVICE		13
+#define COMPHY_TYPE_RXAUI0		14
+#define COMPHY_TYPE_RXAUI1		15
+#define COMPHY_TYPE_SFI0		16
+#define COMPHY_TYPE_SFI1		17
+#define COMPHY_TYPE_AP			18
+#define COMPHY_TYPE_IGNORE		19
+#define COMPHY_TYPE_MAX			20
+#define COMPHY_TYPE_INVALID		0xff
 
-#define PHY_POLARITY_NO_INVERT		0
-#define PHY_POLARITY_TXD_INVERT		1
-#define PHY_POLARITY_RXD_INVERT		2
-#define PHY_POLARITY_ALL_INVERT		\
-	(PHY_POLARITY_TXD_INVERT | PHY_POLARITY_RXD_INVERT)
+#define COMPHY_POLARITY_NO_INVERT	0
+#define COMPHY_POLARITY_TXD_INVERT	1
+#define COMPHY_POLARITY_RXD_INVERT	2
+#define COMPHY_POLARITY_ALL_INVERT	\
+	(COMPHY_POLARITY_TXD_INVERT | COMPHY_POLARITY_RXD_INVERT)
 
 #define UTMI_PHY_TO_USB3_HOST0		0
 #define UTMI_PHY_TO_USB3_HOST1		1
diff --git a/include/elf.h b/include/elf.h
index fe2128f..04572d0 100644
--- a/include/elf.h
+++ b/include/elf.h
@@ -114,6 +114,24 @@ typedef struct elfhdr{
 					   header string table" entry offset */
 } Elf32_Ehdr;
 
+
+typedef struct elf64hdr {
+	unsigned char e_ident[EI_NIDENT];
+	Elf64_Half    e_type;
+	Elf64_Half    e_machine;
+	Elf64_Word    e_version;
+	Elf64_Addr    e_entry;
+	Elf64_Off     e_phoff;
+	Elf64_Off     e_shoff;
+	Elf64_Word    e_flags;
+	Elf64_Half    e_ehsize;
+	Elf64_Half    e_phentsize;
+	Elf64_Half    e_phnum;
+	Elf64_Half    e_shentsize;
+	Elf64_Half    e_shnum;
+	Elf64_Half    e_shstrndx;
+} Elf64_Ehdr;
+
 /* e_type */
 #define ET_NONE		0		/* No file type */
 #define ET_REL		1		/* relocatable file */
@@ -231,6 +249,21 @@ typedef struct {
 	Elf32_Word	sh_entsize;	/* section entry size */
 } Elf32_Shdr;
 
+
+typedef struct {
+	Elf64_Word    sh_name;
+	Elf64_Word    sh_type;
+	Elf64_Xword   sh_flags;
+	Elf64_Addr    sh_addr;
+	Elf64_Off     sh_offset;
+	Elf64_Xword   sh_size;
+	Elf64_Word    sh_link;
+	Elf64_Word    sh_info;
+	Elf64_Xword   sh_addralign;
+	Elf64_Xword   sh_entsize;
+} Elf64_Shdr;
+
+
 /* Special Section Indexes */
 #define SHN_UNDEF	0		/* undefined */
 #define SHN_LORESERVE	0xff00		/* lower bounds of reserved indexes */
@@ -336,6 +369,16 @@ typedef struct elf32_sym {
 	Elf32_Half	st_shndx;	/* section header index */
 } Elf32_Sym;
 
+typedef struct {
+	Elf64_Word    st_name;
+	unsigned char st_info;
+	unsigned char st_other;
+	Elf64_Half    st_shndx;
+	Elf64_Addr    st_value;
+	Elf64_Xword   st_size;
+} Elf64_Sym;
+
+
 /* Symbol table index */
 #define STN_UNDEF	0		/* undefined */
 
@@ -418,6 +461,18 @@ typedef struct {
 	Elf32_Word	p_align;	/* memory alignment */
 } Elf32_Phdr;
 
+typedef struct {
+	Elf64_Word    p_type;
+	Elf64_Word    p_flags;
+	Elf64_Off     p_offset;
+	Elf64_Addr    p_vaddr;
+	Elf64_Addr    p_paddr;
+	Elf64_Xword   p_filesz;
+	Elf64_Xword   p_memsz;
+	Elf64_Xword   p_align;
+} Elf64_Phdr;
+
+
 /* Segment types - p_type */
 #define PT_NULL		0		/* unused */
 #define PT_LOAD		1		/* loadable segment */
diff --git a/include/environment.h b/include/environment.h
index 7986a24..b8448f8 100644
--- a/include/environment.h
+++ b/include/environment.h
@@ -272,6 +272,11 @@ void env_crc_update(void);
 /* Look up the variable from the default environment */
 char *env_get_default(const char *name);
 
+/* load box information to environment */
+#ifdef CONFIG_CMD_MVEBU_HW_INFO
+int cmd_hw_info_load(char *name, int silence);
+#endif /* CONFIG_CMD_MVEBU_HW_INFO */
+
 /* [re]set to the default environment */
 void set_default_env(const char *s);
 
diff --git a/include/ext4fs.h b/include/ext4fs.h
index bb55639..3e00f5f 100644
--- a/include/ext4fs.h
+++ b/include/ext4fs.h
@@ -31,11 +31,13 @@
 #define EXT4_INDEX_FL		0x00001000 /* Inode uses hash tree index */
 #define EXT4_EXTENTS_FL		0x00080000 /* Inode uses extents */
 #define EXT4_EXT_MAGIC			0xf30a
-#define EXT4_FEATURE_RO_COMPAT_GDT_CSUM	0x0010
 #define EXT4_FEATURE_INCOMPAT_EXTENTS	0x0040
 #define EXT4_FEATURE_INCOMPAT_64BIT	0x0080
 #define EXT4_INDIRECT_BLOCKS		12
 
+#define EXT4_FEATURE_RO_COMPAT_GDT_CSUM		0x0010
+#define EXT4_FEATURE_RO_COMPAT_METADATA_CSUM	0x0400
+
 #define EXT4_BG_INODE_UNINIT		0x0001
 #define EXT4_BG_BLOCK_UNINIT		0x0002
 #define EXT4_BG_INODE_ZEROED		0x0004
diff --git a/include/fdtdec.h b/include/fdtdec.h
index 2941a2e..0f6d436 100644
--- a/include/fdtdec.h
+++ b/include/fdtdec.h
@@ -161,7 +161,10 @@ enum fdt_compat_id {
 	COMPAT_ALTERA_SOCFPGA_F2SDR2,           /* SoCFPGA fpga2SDRAM2 bridge */
 	COMPAT_ALTERA_SOCFPGA_FPGA0,		/* SOCFPGA FPGA manager */
 	COMPAT_ALTERA_SOCFPGA_NOC,		/* SOCFPGA Arria 10 NOC */
-
+	COMPAT_MVEBU_SAR,
+	COMPAT_MVEBU_SAR_REG_COMMON,
+	COMPAT_MVEBU_SAR_REG_AP806,
+	COMPAT_MVEBU_SAR_REG_CP110,
 	COMPAT_COUNT,
 };
 
@@ -455,6 +458,17 @@ int fdtdec_get_pci_bar32(struct udevice *dev, struct fdt_pci_addr *addr,
 			 u32 *bar);
 
 /**
+ * Look at the bus range property of a device node and return the pci bus
+ * range for this node.
+ * The property must hold one fdt_pci_addr with a lengh.
+ * @param blob		FDT blob
+ * @param node		node to examine
+ * @param res		the resource structure to return the bus range
+ */
+
+int fdtdec_get_pci_bus_range(const void *blob, int node,
+			     struct fdt_resource *res);
+/**
  * Look up a 32-bit integer property in a node and return it. The property
  * must have at least 4 bytes of data. The value of the first cell is
  * returned.
diff --git a/include/linux/ethtool.h b/include/linux/ethtool.h
index f6dbdb0..a97bde4 100644
--- a/include/linux/ethtool.h
+++ b/include/linux/ethtool.h
@@ -614,11 +614,12 @@ enum ethtool_sfeatures_retval_bits {
  * it was foced up into this mode or autonegotiated.
  */
 
-/* The forced speed, 10Mb, 100Mb, gigabit, 2.5Gb, 10GbE. */
+/* The forced speed, 10Mb, 100Mb, gigabit, 2.5Gb,  5Gb, 10GbE. */
 #define SPEED_10		10
 #define SPEED_100		100
 #define SPEED_1000		1000
 #define SPEED_2500		2500
+#define SPEED_5000		5000
 #define SPEED_10000		10000
 
 /* Duplex, half or full. */
diff --git a/include/linux/sizes.h b/include/linux/sizes.h
index ce3e815..71f3d58 100644
--- a/include/linux/sizes.h
+++ b/include/linux/sizes.h
@@ -43,5 +43,9 @@
 
 #define SZ_1G				0x40000000
 #define SZ_2G				0x80000000
+#define SZ_4G				0x100000000ULL
+#define SZ_8G				0x200000000ULL
+#define SZ_16G				0x400000000ULL
+#define SZ_32G				0x800000000ULL
 
 #endif /* __LINUX_SIZES_H__ */
diff --git a/include/mdio.h b/include/mdio.h
new file mode 100644
index 0000000..8a228db
--- /dev/null
+++ b/include/mdio.h
@@ -0,0 +1,62 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ * Author: Ken Ma<make@marvell.com>
+ */
+
+#ifndef _MDIO_H_
+#define _MDIO_H_
+
+#include <dm.h>	/* Because we dereference struct udevice here */
+#include <phy.h>
+
+/**
+ * mdio_mii_bus_get() - Get mii bus from mdio udevice
+ *
+ * @mdio_dev:	mdio udevice
+ * @bus:	mii bus
+ * @returns 0 on success, error code otherwise.
+ */
+int mdio_mii_bus_get(struct udevice *mdio_dev, struct mii_dev **bus);
+
+/**
+ * mdio_device_get_from_phy() - Get the mdio udevice which the phy belongs to
+ *
+ * @phy_node:	phy node offset
+ * @devp:	mdio udevice
+ * @returns 0 on success, error code otherwise.
+ */
+int mdio_device_get_from_phy(int phy_node, struct udevice **devp);
+
+/**
+ * mdio_mii_bus_get_from_phy() - Get the mii bus which the phy belongs to
+ *
+ * @phy_node:	phy node offset
+ * @bus:	mii bus
+ * @returns 0 on success, error code otherwise.
+ */
+int mdio_mii_bus_get_from_phy(int phy_node, struct mii_dev **bus);
+
+/**
+ * mdio_device_get_from_eth() - When there is a phy reference of "phy = <&...>"
+ *                      under a ethernet udevice fdt node, this function can
+ *                      get the mdio udevice which the phy belongs to
+ *
+ * @dev:	the ethernet udevice which contains the phy reference
+ * @devp:	mdio udevice
+ * @returns 0 on success, error code otherwise.
+ */
+int mdio_device_get_from_eth(struct udevice *eth, struct udevice **devp);
+
+/**
+ * mdio_mii_bus_get_from_eth() - When there is a phy reference of
+ *                      "phy = <&...>" under a ethernet udevice fdt node, this
+ *                      function can get the mii bus which the phy belongs to
+ *
+ * @eth:	the ethernet udevice which contains the phy reference
+ * @bus:	mii bus
+ * @returns 0 on success, error code otherwise.
+ */
+int mdio_mii_bus_get_from_eth(struct udevice *eth, struct mii_dev **bus);
+
+#endif /* _MDIO_H_ */
diff --git a/include/miiphy.h b/include/miiphy.h
index fe8928a..2c237a0 100644
--- a/include/miiphy.h
+++ b/include/miiphy.h
@@ -118,4 +118,8 @@ int bb_miiphy_write(struct mii_dev *miidev, int addr, int devad, int reg,
 #define ESTATUS_1000XF		0x8000
 #define ESTATUS_1000XH		0x4000
 
+#ifdef CONFIG_CMD_MVEBU_PHY_FW_DOWNLOAD
+u32 mvebu_phy_firmware_download(u16 port, u8 app_data[], u32 app_size,
+				u8 salve_data[], u32 slave_size);
+#endif
 #endif
diff --git a/include/mmc.h b/include/mmc.h
index 86f885b..d8cb5df 100644
--- a/include/mmc.h
+++ b/include/mmc.h
@@ -40,6 +40,7 @@
 #define EXTRACT_SDMMC_CHANGE_VERSION(x)	\
 	((u32)(x) & 0xff)
 
+#define SD_VERSION_4		MAKE_SD_VERSION(4, 0, 0)
 #define SD_VERSION_3		MAKE_SD_VERSION(3, 0, 0)
 #define SD_VERSION_2		MAKE_SD_VERSION(2, 0, 0)
 #define SD_VERSION_1_0		MAKE_SD_VERSION(1, 0, 0)
@@ -65,6 +66,7 @@
 #define MMC_MODE_HS_52MHz	MMC_CAP(MMC_HS_52)
 #define MMC_MODE_DDR_52MHz	MMC_CAP(MMC_DDR_52)
 #define MMC_MODE_HS200		MMC_CAP(MMC_HS_200)
+#define MMC_MODE_HS400		MMC_CAP(MMC_HS_400)
 
 #define MMC_MODE_8BIT		BIT(30)
 #define MMC_MODE_4BIT		BIT(29)
@@ -152,6 +154,13 @@ static inline bool mmc_is_tuning_cmd(uint cmdidx)
 #define OCR_BUSY		0x80000000
 #define OCR_HCS			0x40000000
 #define OCR_S18R		0x1000000
+#define MMC_HS_TIMING		0x00000100
+#define MMC_HS_DDR_52MHz_12V	0x8
+#define MMC_HS_DDR_52MHz_18_3V	0x4
+#define MMC_HS_52MHZ		0x2
+#define MMC_HS_26MHz		0x1
+
+#define OCR_XPC			0x10000000
 #define OCR_VOLTAGE_MASK	0x007FFF80
 #define OCR_ACCESS_MODE		0x60000000
 
@@ -220,13 +229,23 @@ static inline bool mmc_is_tuning_cmd(uint cmdidx)
 #define EXT_CSD_PART_CONF		179	/* R/W */
 #define EXT_CSD_BUS_WIDTH		183	/* R/W */
 #define EXT_CSD_HS_TIMING		185	/* R/W */
+#define EXT_CSD_POWER_CLASS		187	/* R/W */
 #define EXT_CSD_REV			192	/* RO */
 #define EXT_CSD_CARD_TYPE		196	/* RO */
+#define EXT_CSD_PWR_CL_52_195		200	/* RO */
+#define EXT_CSD_PWR_CL_26_195		201	/* RO */
+#define EXT_CSD_PWR_CL_52_360		202	/* RO */
+#define EXT_CSD_PWR_CL_26_360		203	/* RO */
 #define EXT_CSD_SEC_CNT			212	/* RO, 4 bytes */
 #define EXT_CSD_HC_WP_GRP_SIZE		221	/* RO */
 #define EXT_CSD_HC_ERASE_GRP_SIZE	224	/* RO */
 #define EXT_CSD_BOOT_MULT		226	/* RO */
 #define EXT_CSD_BKOPS_SUPPORT		502	/* RO */
+#define EXT_CSD_PWR_CL_200_195		236	/* RO */
+#define EXT_CSD_PWR_CL_200_360		237	/* RO */
+#define EXT_CSD_PWR_CL_DDR_52_195	238	/* RO */
+#define EXT_CSD_PWR_CL_DDR_52_360	239	/* RO */
+#define EXT_CSD_GENERIC_CMD6_TIME	248	/* RO in 10ms increments */
 
 /*
  * EXT_CSD field definitions
@@ -249,6 +268,10 @@ static inline bool mmc_is_tuning_cmd(uint cmdidx)
 						/* SDR mode @1.2V I/O */
 #define EXT_CSD_CARD_TYPE_HS200		(EXT_CSD_CARD_TYPE_HS200_1_8V | \
 					 EXT_CSD_CARD_TYPE_HS200_1_2V)
+#define EXT_CSD_CARD_TYPE_HS400_1_8V	BIT(6)
+#define EXT_CSD_CARD_TYPE_HS400_1_2V	BIT(7)
+#define EXT_CSD_CARD_TYPE_HS400		(EXT_CSD_CARD_TYPE_HS400_1_8V | \
+					 EXT_CSD_CARD_TYPE_HS400_1_2V)
 
 #define EXT_CSD_BUS_WIDTH_1	0	/* Card is in 1 bit mode */
 #define EXT_CSD_BUS_WIDTH_4	1	/* Card is in 4 bit mode */
@@ -260,6 +283,7 @@ static inline bool mmc_is_tuning_cmd(uint cmdidx)
 #define EXT_CSD_TIMING_LEGACY	0	/* no high speed */
 #define EXT_CSD_TIMING_HS	1	/* HS */
 #define EXT_CSD_TIMING_HS200	2	/* HS200 */
+#define EXT_CSD_TIMING_HS400	3	/* HS400 */
 
 #define EXT_CSD_BOOT_ACK_ENABLE			(1 << 6)
 #define EXT_CSD_BOOT_PARTITION_ENABLE		(1 << 3)
@@ -520,6 +544,7 @@ enum bus_mode {
 	UHS_DDR50,
 	UHS_SDR104,
 	MMC_HS_200,
+	MMC_HS_400,
 	MMC_MODES_END
 };
 
@@ -534,6 +559,10 @@ static inline bool mmc_is_mode_ddr(enum bus_mode mode)
 	else if (mode == UHS_DDR50)
 		return true;
 #endif
+#if CONFIG_IS_ENABLED(MMC_HS400_SUPPORT)
+	else if (mode == MMC_HS_400)
+		return true;
+#endif
 	else
 		return false;
 }
@@ -708,6 +737,9 @@ int mmc_voltage_to_mv(enum mmc_voltage voltage);
  */
 int mmc_set_clock(struct mmc *mmc, uint clock, bool disable);
 
+#define MMC_CLK_ENABLE		false
+#define MMC_CLK_DISABLE		true
+
 struct mmc *find_mmc_device(int dev_num);
 int mmc_set_dev(int dev_num);
 void print_mmc_devices(char separator);
@@ -752,6 +784,16 @@ int mmc_set_bkops_enable(struct mmc *mmc);
 
 /**
  * Start device initialization and return immediately; it does not block on
+ * polling OCR (operation condition register) status. Useful for checking
+ * the presence of SD/eMMC when no card detect logic is available.
+ *
+ * @param mmc	Pointer to a MMC device struct
+ * @return 0 on success, <0 on error.
+ */
+int mmc_get_op_cond(struct mmc *mmc);
+
+/**
+ * Start device initialization and return immediately; it does not block on
  * polling OCR (operation condition register) status.  Then you should call
  * mmc_init, which would block on polling OCR status and complete the device
  * initializatin.
@@ -787,7 +829,7 @@ int board_mmc_init(bd_t *bis);
 int cpu_mmc_init(bd_t *bis);
 int mmc_get_env_addr(struct mmc *mmc, int copy, u32 *env_addr);
 int mmc_get_env_dev(void);
-
+int mmc_power_init(struct mmc *mmc);
 /* Set block count limit because of 16 bit register limit on some hardware*/
 #ifndef CONFIG_SYS_MMC_MAX_BLK_COUNT
 #define CONFIG_SYS_MMC_MAX_BLK_COUNT 65535
@@ -797,8 +839,8 @@ int mmc_get_env_dev(void);
  * mmc_get_blk_desc() - Get the block descriptor for an MMC device
  *
  * @mmc:	MMC device
+ * @devnum:	device number
  * @return block device if found, else NULL
  */
 struct blk_desc *mmc_get_blk_desc(struct mmc *mmc);
-
 #endif /* _MMC_H_ */
diff --git a/include/mvebu/cfg_eeprom.h b/include/mvebu/cfg_eeprom.h
new file mode 100644
index 0000000..d4fb8f9
--- /dev/null
+++ b/include/mvebu/cfg_eeprom.h
@@ -0,0 +1,95 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ */
+
+#ifndef _MCEBU_CFG_EEPROM_H_
+#define _MVEBU_CFG_EEPROM_H_
+#include <common.h>
+#include <i2c.h>
+#include <errno.h>
+#include <asm/io.h>
+
+#define BOARD_DEV_TWSI_INIT_EEPROM		0x57
+#define BOARD_HW_INFO_EEPROM_ADDR_LEN		2
+#define BOARD_HW_INFO_EEPROM_DEV		0
+
+enum mv_config_type_id {
+	MV_CONFIG_CHECKSUM,
+	MV_CONFIG_PATTERN,
+	MV_CONFIG_LENGTH,
+	MV_CONFIG_HW_INFO,
+	MV_CONFIG_TYPE_MAX_OPTION,  /* limit for user read/write routines */
+};
+
+/* #pragma pack(1) */
+#define MVEBU_HW_INFO_LEN			512
+struct manufacturing_information_struct {
+	u8 hw_info[MVEBU_HW_INFO_LEN];
+};
+
+/* #pragma pack(1) */
+struct eeprom_struct {
+	u32 checksum;
+	u32 pattern;
+	u16 length;
+	struct manufacturing_information_struct man_info;
+};
+
+struct config_types_info {
+	enum mv_config_type_id config_id;
+	char name[30];
+	u32 byte_num;
+	u32 byte_cnt;
+};
+
+#define I2C_PAGE_WRITE_SIZE			32
+#define EEPROM_STRUCT_SIZE			(sizeof(struct eeprom_struct))
+#define HW_INFO_MAX_PARAM_NUM			32
+
+struct hw_info_point_struct {
+	char *name;
+	char *value;
+};
+
+#define READ_SPECIFIC_FIELD			-1
+#define HW_INFO_MAX_NAME_LEN			32
+#define HW_INFO_MAX_VALUE_LEN			32
+struct hw_info_data_struct {
+	char name[HW_INFO_MAX_NAME_LEN];
+	char value[HW_INFO_MAX_VALUE_LEN];
+};
+
+#define offset_in_eeprom(a)	((u32)(offsetof(struct eeprom_struct, a)))
+
+/* MV_CONFIG_TYPE_ID */
+/* {{configId,		name,		byte_num,	byte_cnt}} */
+#define MV_EEPROM_CONFIG_INFO { \
+{ MV_CONFIG_CHECKSUM,	"Checksum",	offset_in_eeprom(checksum),	   \
+				sizeof(board_config_val.checksum)},	   \
+{ MV_CONFIG_PATTERN,	"Pattern",	offset_in_eeprom(pattern),	   \
+				sizeof(board_config_val.pattern)},	   \
+{ MV_CONFIG_LENGTH,	"Data length",	offset_in_eeprom(length),	   \
+				sizeof(board_config_val.length)},	   \
+{ MV_CONFIG_HW_INFO,	"Box Info",	offset_in_eeprom(man_info.hw_info),\
+				sizeof(board_config_val.man_info.hw_info)} \
+}
+
+#define CFG_DEFAULT_VALUE  {						     \
+	0x00000000,				     /* checksum */	     \
+	0xfecadefa,				     /* EEPROM pattern */    \
+	EEPROM_STRUCT_SIZE,			     /* length = 0x10A B */  \
+	{{[0 ... (MVEBU_HW_INFO_LEN - 1)] = 0x00} }   /* man info */	     \
+}
+
+int cfg_eeprom_init(void);
+void cfg_eeprom_save(int length);
+struct eeprom_struct *cfg_eeprom_get_board_config(void);
+void cfg_eeprom_get_hw_info_str(uchar *hw_info_str);
+void cfg_eeprom_set_hw_info_str(uchar *hw_info_str);
+int cfg_eeprom_parse_hw_info(struct hw_info_data_struct *hw_info_data_array);
+int cfg_eeprom_parse_env(struct hw_info_data_struct *data_array,
+			 int size);
+int cfg_eeprom_validate_name(char *name);
+
+#endif /* _MVEBU_CFG_EEPROM_H_ */
diff --git a/include/mvebu/comphy.h b/include/mvebu/comphy.h
new file mode 100644
index 0000000..022cd61
--- /dev/null
+++ b/include/mvebu/comphy.h
@@ -0,0 +1,13 @@
+/*
+ * Copyright (C) 2017 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#ifndef _COMPHY_H_
+#define _COMPHY_H_
+
+int comphy_rx_training(struct udevice *dev, u32 lane);
+
+#endif /* _COMPHY_H_ */
diff --git a/include/mvebu/fuse-mvebu.h b/include/mvebu/fuse-mvebu.h
new file mode 100644
index 0000000..b31577e
--- /dev/null
+++ b/include/mvebu/fuse-mvebu.h
@@ -0,0 +1,55 @@
+/* SPDX-License-Identifier: GPL-2.0+
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * https://spdx.org/licenses
+ */
+
+#ifndef _MVEBU_EFUSE_H
+#define _MVEBU_EFUSE_H
+
+#include <common.h>
+
+#if defined(CONFIG_MVEBU_EFUSE_READ_ONLY)
+#define EFUSE_READ_ONLY
+#else
+#undef EFUSE_READ_ONLY
+#endif
+
+#define MVEBU_EFUSE_SRV_CTRL_LD_SEL_USER	BIT(6)
+#define MVEBU_EFUSE_CTRL_LD_SEC_EN_MASK		BIT(7)
+#define MVEBU_EFUSE_CTRL_PROGRAM_ENABLE		BIT(31)
+
+struct mvebu_fuse_platform_data {
+	unsigned int row_bit_width;
+	unsigned int row_step;
+};
+
+struct mvebu_fuse_block_data {
+	struct mvebu_fuse_platform_data	*pdata;
+	unsigned int	row_base;
+	unsigned int	row_num;
+	void	*control_reg;
+	void	*target_otp_mem;
+	bool	hd_ld_flag;
+	char	block_name[64];
+};
+
+struct fuse_ops {
+	int (*fuse_init)(struct udevice *dev);
+	int (*fuse_hd_read)(struct udevice *dev, int row_id, u32 *val);
+	int (*fuse_hd_prog)(struct udevice *dev, int word, int row_id,
+			    u32 new_val);
+	int (*fuse_ld_read)(struct udevice *dev, int row_id, u32 *val);
+	int (*fuse_ld_prog)(struct udevice *dev, int word, int row_id,
+			    u32 new_val);
+};
+
+int mvebu_efuse_hd_read(struct udevice *dev, int row_id, u32 *val);
+int mvebu_efuse_hd_prog(struct udevice *dev, int word, int row_id, u32 new_val);
+int mvebu_efuse_ld_read(struct udevice *dev, int row_id, u32 *val);
+int mvebu_efuse_ld_prog(struct udevice *dev, int word, int row_id, u32 new_val);
+int reg_fuse_ops(struct fuse_ops *ops);
+int mvebu_efuse_init_hw(struct udevice *dev);
+
+#endif
+
diff --git a/include/mvebu/mvebu_chip_sar.h b/include/mvebu/mvebu_chip_sar.h
new file mode 100644
index 0000000..cd78aa5
--- /dev/null
+++ b/include/mvebu/mvebu_chip_sar.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#ifndef _MVEBU_CHIP_SAR_H_
+#define _MVEBU_CHIP_SAR_H_
+
+#include <asm/types.h>
+
+/*
+ * List of boot source options.
+ * Return value for each of the options:
+ *  - SAR_CPU_FREQ: Frequency (Hz)
+ *  - SAR_DDR_FREQ: Frequency (Hz)
+ *  - SAR_AP_FABRIC_FREQ: Frequency (Hz)
+ *  - SAR_CP_FABRIC_FREQ: Frequency (Hz)
+ *  - SAR_BOOT_SRC: Boot source type (see mvebu_bootsrc_type)
+ */
+enum mvebu_sar_opts {
+	SAR_CPU_FREQ = 0,
+	SAR_DDR_FREQ,
+	SAR_AP_FABRIC_FREQ,
+	SAR_CP_FABRIC_FREQ,
+	SAR_CP0_PCIE0_CLK,
+	SAR_CP0_PCIE1_CLK,
+	SAR_CP1_PCIE0_CLK,
+	SAR_CP1_PCIE1_CLK,
+	SAR_BOOT_SRC,
+	SAR_MAX_IDX
+};
+
+enum mvebu_bootsrc_type {
+	BOOTSRC_NAND,
+	BOOTSRC_SPI,
+	BOOTSRC_AP_SPI,
+	BOOTSRC_SD_EMMC,
+	BOOTSRC_AP_SD_EMMC,
+	BOOTSRC_NOR,
+	BOOTSRC_MAX_IDX
+};
+
+/*
+ * sample-at-reset information
+ *  raw_sar_val: Raw value out of the sample-at-reset register.
+ *		This is hw dependent and should not be used for comparison
+ *		purposes (useful for debug, or verbose information).
+ *  bootsrc (SAR_BOOT_SRC):
+ *	type: Boot source interface type.
+ *	index: When applicable, indicates the interface index (e.g. SPI #1,
+ *		NAND #0).
+ *	width: When applicable, indicates the interface bus width (e.g. NAND
+ *	8-bit).
+ *  freq: Frequency in Hz.
+ */
+struct sar_val {
+	u32 raw_sar_val;
+	union {
+		struct {
+			enum mvebu_bootsrc_type type;
+			int index;
+		} bootsrc;
+		u32 freq;
+		u32 clk_direction; /* input = 0 */
+	};
+};
+
+int mvebu_sar_init(void);
+int mvebu_sar_value_get(enum mvebu_sar_opts opt, struct sar_val *val);
+void mvebu_sar_dump(struct udevice *dev);
+char *mvebu_sar_bootsrc_to_name(enum mvebu_bootsrc_type src);
+
+#endif	/* _MVEBU_CHIP_SAR_H_ */
diff --git a/include/mvebu/sar.h b/include/mvebu/sar.h
new file mode 100644
index 0000000..82ec543
--- /dev/null
+++ b/include/mvebu/sar.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:       GPL-2.0+
+ * https://spdx.org/licenses
+ */
+
+#ifndef _SAR_H_
+#define _SAR_H_
+
+#include <common.h>
+#include <linux/compiler.h>
+#include <mvebu/var.h>
+
+#define MAX_SAR_CHIPS	4
+#define MAX_SAR 8
+
+enum sar_variables {
+	CPUS_NUM_SAR = 0,
+	CPU0_ENDIANES_SAR,
+	FREQ_SAR,
+	CPU_FREQ_SAR,
+	FAB_REQ_SAR,
+	BOOT_SRC_SAR,
+	BOOT_WIDTH_SAR,
+	PEX_MODE_SAR,
+	L2_SIZE_SAR,
+	DRAM_ECC_SAR,
+	DRAM_BUS_WIDTH_SAR,
+};
+
+struct sar_var {
+	u8 start_bit;
+	u8 bit_length;
+	u8 option_cnt;
+	u8 active;
+	bool swap_bit;
+	char *desc;
+	char *key;
+	struct var_opts option_desc[MAX_VAR_OPTIONS];
+};
+
+struct sar_data {
+	u32	chip_addr[MAX_SAR_CHIPS];
+	u8	chip_count;
+	u8	bit_width;
+	struct sar_var sar_lookup[MAX_SAR];
+};
+
+int  sar_read_all(void);
+int  sar_default_key(const char *key);
+int  sar_default_all(void);
+int  sar_write_key(const char *key, int val);
+int  sar_print_key(const char *key);
+void sar_list_keys(void);
+int  sar_list_key_opts(const char *key);
+int  sar_is_available(void);
+void sar_init(void);
+
+#endif /* _SAR_H_ */
diff --git a/include/mvebu/var.h b/include/mvebu/var.h
new file mode 100644
index 0000000..419eeda
--- /dev/null
+++ b/include/mvebu/var.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:       GPL-2.0+
+ * https://spdx.org/licenses
+ */
+
+#ifndef _VAR_H_
+#define _VAR_H_
+
+#include <common.h>
+#include <linux/compiler.h>
+
+#define INVALID_KEY	0xFF
+#define MAX_VAR_OPTIONS	10
+
+#define VAR_IS_DEFAULT	0x1
+#define VAR_IS_LAST	0x2
+
+struct var_opts {
+	u8 value;
+	char *desc;
+	u8 flags;
+};
+
+struct var_desc {
+	char *key;
+	char *description;
+};
+
+#endif /* _VAR_H_ */
diff --git a/include/net.h b/include/net.h
index 455b48f..80190f3 100644
--- a/include/net.h
+++ b/include/net.h
@@ -237,6 +237,10 @@ int eth_initialize(void);		/* Initialize network subsystem */
 void eth_try_another(int first_restart);	/* Change the device */
 void eth_set_current(void);		/* set nterface to ethcur var */
 
+#ifdef CONFIG_MV88E6XXX_SWITCH
+int mv88e6xxx_initialize(const void *blob);
+#endif
+
 int eth_get_dev_index(void);		/* get the device index */
 void eth_parse_enetaddr(const char *addr, uchar *enetaddr);
 int eth_env_get_enetaddr(const char *name, uchar *enetaddr);
diff --git a/include/pci.h b/include/pci.h
index 7adc043..64da9f3 100644
--- a/include/pci.h
+++ b/include/pci.h
@@ -335,6 +335,7 @@
 #define  PCI_CAP_ID_MSI		0x05	/* Message Signalled Interrupts */
 #define  PCI_CAP_ID_CHSWP	0x06	/* CompactPCI HotSwap */
 #define  PCI_CAP_ID_EXP 	0x10	/* PCI Express */
+#define  PCI_CAP_ID_EA		0x14	/* Enhanced Allocation */
 #define PCI_CAP_LIST_NEXT	1	/* Next capability in the list */
 #define PCI_CAP_FLAGS		2	/* Capability defined flags (16 bits) */
 #define PCI_CAP_SIZEOF		4
@@ -412,6 +413,262 @@
 #define PCI_MSI_DATA_32		8	/* 16 bits of data for 32-bit devices */
 #define PCI_MSI_DATA_64		12	/* 16 bits of data for 64-bit devices */
 
+/* PCI Express capability registers */
+
+#define PCI_EXP_FLAGS		2	/* Capabilities register */
+#define PCI_EXP_FLAGS_VERS	0x000f	/* Capability version */
+#define PCI_EXP_FLAGS_TYPE	0x00f0	/* Device/Port type */
+#define  PCI_EXP_TYPE_ENDPOINT	0x0	/* Express Endpoint */
+#define  PCI_EXP_TYPE_LEG_END	0x1	/* Legacy Endpoint */
+#define  PCI_EXP_TYPE_ROOT_PORT 0x4	/* Root Port */
+#define  PCI_EXP_TYPE_UPSTREAM	0x5	/* Upstream Port */
+#define  PCI_EXP_TYPE_DOWNSTREAM 0x6	/* Downstream Port */
+#define  PCI_EXP_TYPE_PCI_BRIDGE 0x7	/* PCIe to PCI/PCI-X Bridge */
+#define  PCI_EXP_TYPE_PCIE_BRIDGE 0x8	/* PCI/PCI-X to PCIe Bridge */
+#define  PCI_EXP_TYPE_RC_END	0x9	/* Root Complex Integrated Endpoint */
+#define  PCI_EXP_TYPE_RC_EC	0xa	/* Root Complex Event Collector */
+#define PCI_EXP_FLAGS_SLOT	0x0100	/* Slot implemented */
+#define PCI_EXP_FLAGS_IRQ	0x3e00	/* Interrupt message number */
+#define PCI_EXP_DEVCAP		4	/* Device capabilities */
+#define  PCI_EXP_DEVCAP_PAYLOAD	0x00000007 /* Max_Payload_Size */
+#define  PCI_EXP_DEVCAP_PHANTOM	0x00000018 /* Phantom functions */
+#define  PCI_EXP_DEVCAP_EXT_TAG	0x00000020 /* Extended tags */
+#define  PCI_EXP_DEVCAP_L0S	0x000001c0 /* L0s Acceptable Latency */
+#define  PCI_EXP_DEVCAP_L1	0x00000e00 /* L1 Acceptable Latency */
+#define  PCI_EXP_DEVCAP_ATN_BUT	0x00001000 /* Attention Button Present */
+#define  PCI_EXP_DEVCAP_ATN_IND	0x00002000 /* Attention Indicator Present */
+#define  PCI_EXP_DEVCAP_PWR_IND	0x00004000 /* Power Indicator Present */
+#define  PCI_EXP_DEVCAP_RBER	0x00008000 /* Role-Based Error Reporting */
+#define  PCI_EXP_DEVCAP_PWR_VAL	0x03fc0000 /* Slot Power Limit Value */
+#define  PCI_EXP_DEVCAP_PWR_SCL	0x0c000000 /* Slot Power Limit Scale */
+#define  PCI_EXP_DEVCAP_FLR     0x10000000 /* Function Level Reset */
+#define PCI_EXP_DEVCTL		8	/* Device Control */
+#define  PCI_EXP_DEVCTL_CERE	0x0001	/* Correctable Error Reporting En. */
+#define  PCI_EXP_DEVCTL_NFERE	0x0002	/* Non-Fatal Error Reporting Enable */
+#define  PCI_EXP_DEVCTL_FERE	0x0004	/* Fatal Error Reporting Enable */
+#define  PCI_EXP_DEVCTL_URRE	0x0008	/* Unsupported Request Reporting En. */
+#define  PCI_EXP_DEVCTL_RELAX_EN 0x0010 /* Enable relaxed ordering */
+#define  PCI_EXP_DEVCTL_PAYLOAD	0x00e0	/* Max_Payload_Size */
+#define  PCI_EXP_DEVCTL_EXT_TAG	0x0100	/* Extended Tag Field Enable */
+#define  PCI_EXP_DEVCTL_PHANTOM	0x0200	/* Phantom Functions Enable */
+#define  PCI_EXP_DEVCTL_AUX_PME	0x0400	/* Auxiliary Power PM Enable */
+#define  PCI_EXP_DEVCTL_NOSNOOP_EN 0x0800  /* Enable No Snoop */
+#define  PCI_EXP_DEVCTL_READRQ	0x7000	/* Max_Read_Request_Size */
+#define  PCI_EXP_DEVCTL_BCR_FLR 0x8000  /* Bridge Configuration Retry / FLR */
+#define PCI_EXP_DEVSTA		10	/* Device Status */
+#define  PCI_EXP_DEVSTA_CED	0x0001	/* Correctable Error Detected */
+#define  PCI_EXP_DEVSTA_NFED	0x0002	/* Non-Fatal Error Detected */
+#define  PCI_EXP_DEVSTA_FED	0x0004	/* Fatal Error Detected */
+#define  PCI_EXP_DEVSTA_URD	0x0008	/* Unsupported Request Detected */
+#define  PCI_EXP_DEVSTA_AUXPD	0x0010	/* AUX Power Detected */
+#define  PCI_EXP_DEVSTA_TRPND	0x0020	/* Transactions Pending */
+#define PCI_EXP_LNKCAP		12	/* Link Capabilities */
+#define  PCI_EXP_LNKCAP_SLS	0x0000000f /* Supported Link Speeds */
+#define  PCI_EXP_LNKCAP_SLS_2_5GB 0x00000001 /* LNKCAP2 SLS Vector bit 0 */
+#define  PCI_EXP_LNKCAP_SLS_5_0GB 0x00000002 /* LNKCAP2 SLS Vector bit 1 */
+#define  PCI_EXP_LNKCAP_MLW	0x000003f0 /* Maximum Link Width */
+#define  PCI_EXP_LNKCAP_ASPMS	0x00000c00 /* ASPM Support */
+#define  PCI_EXP_LNKCAP_L0SEL	0x00007000 /* L0s Exit Latency */
+#define  PCI_EXP_LNKCAP_L1EL	0x00038000 /* L1 Exit Latency */
+#define  PCI_EXP_LNKCAP_CLKPM	0x00040000 /* Clock Power Management */
+#define  PCI_EXP_LNKCAP_SDERC	0x00080000 /* Surprise Down Error Reporting Capable */
+#define  PCI_EXP_LNKCAP_DLLLARC	0x00100000 /* Data Link Layer Link Active Reporting Capable */
+#define  PCI_EXP_LNKCAP_LBNC	0x00200000 /* Link Bandwidth Notification Capability */
+#define  PCI_EXP_LNKCAP_PN	0xff000000 /* Port Number */
+#define PCI_EXP_LNKCTL		16	/* Link Control */
+#define  PCI_EXP_LNKCTL_ASPMC	0x0003	/* ASPM Control */
+#define  PCI_EXP_LNKCTL_ASPM_L0S 0x0001	/* L0s Enable */
+#define  PCI_EXP_LNKCTL_ASPM_L1  0x0002	/* L1 Enable */
+#define  PCI_EXP_LNKCTL_RCB	0x0008	/* Read Completion Boundary */
+#define  PCI_EXP_LNKCTL_LD	0x0010	/* Link Disable */
+#define  PCI_EXP_LNKCTL_RL	0x0020	/* Retrain Link */
+#define  PCI_EXP_LNKCTL_CCC	0x0040	/* Common Clock Configuration */
+#define  PCI_EXP_LNKCTL_ES	0x0080	/* Extended Synch */
+#define  PCI_EXP_LNKCTL_CLKREQ_EN 0x0100 /* Enable clkreq */
+#define  PCI_EXP_LNKCTL_HAWD	0x0200	/* Hardware Autonomous Width Disable */
+#define  PCI_EXP_LNKCTL_LBMIE	0x0400	/* Link Bandwidth Management Interrupt Enable */
+#define  PCI_EXP_LNKCTL_LABIE	0x0800	/* Link Autonomous Bandwidth Interrupt Enable */
+#define PCI_EXP_LNKSTA		18	/* Link Status */
+#define  PCI_EXP_LNKSTA_CLS	0x000f	/* Current Link Speed */
+#define  PCI_EXP_LNKSTA_CLS_2_5GB 0x0001 /* Current Link Speed 2.5GT/s */
+#define  PCI_EXP_LNKSTA_CLS_5_0GB 0x0002 /* Current Link Speed 5.0GT/s */
+#define  PCI_EXP_LNKSTA_CLS_8_0GB 0x0003 /* Current Link Speed 8.0GT/s */
+#define  PCI_EXP_LNKSTA_NLW	0x03f0	/* Negotiated Link Width */
+#define  PCI_EXP_LNKSTA_NLW_X1	0x0010	/* Current Link Width x1 */
+#define  PCI_EXP_LNKSTA_NLW_X2	0x0020	/* Current Link Width x2 */
+#define  PCI_EXP_LNKSTA_NLW_X4	0x0040	/* Current Link Width x4 */
+#define  PCI_EXP_LNKSTA_NLW_X8	0x0080	/* Current Link Width x8 */
+#define  PCI_EXP_LNKSTA_NLW_SHIFT 4	/* start of NLW mask in link status */
+#define  PCI_EXP_LNKSTA_LT	0x0800	/* Link Training */
+#define  PCI_EXP_LNKSTA_SLC	0x1000	/* Slot Clock Configuration */
+#define  PCI_EXP_LNKSTA_DLLLA	0x2000	/* Data Link Layer Link Active */
+#define  PCI_EXP_LNKSTA_LBMS	0x4000	/* Link Bandwidth Management Status */
+#define  PCI_EXP_LNKSTA_LABS	0x8000	/* Link Autonomous Bandwidth Status */
+#define PCI_CAP_EXP_ENDPOINT_SIZEOF_V1	20	/* v1 endpoints end here */
+#define PCI_EXP_SLTCAP		20	/* Slot Capabilities */
+#define  PCI_EXP_SLTCAP_ABP	0x00000001 /* Attention Button Present */
+#define  PCI_EXP_SLTCAP_PCP	0x00000002 /* Power Controller Present */
+#define  PCI_EXP_SLTCAP_MRLSP	0x00000004 /* MRL Sensor Present */
+#define  PCI_EXP_SLTCAP_AIP	0x00000008 /* Attention Indicator Present */
+#define  PCI_EXP_SLTCAP_PIP	0x00000010 /* Power Indicator Present */
+#define  PCI_EXP_SLTCAP_HPS	0x00000020 /* Hot-Plug Surprise */
+#define  PCI_EXP_SLTCAP_HPC	0x00000040 /* Hot-Plug Capable */
+#define  PCI_EXP_SLTCAP_SPLV	0x00007f80 /* Slot Power Limit Value */
+#define  PCI_EXP_SLTCAP_SPLS	0x00018000 /* Slot Power Limit Scale */
+#define  PCI_EXP_SLTCAP_EIP	0x00020000 /* Electromechanical Interlock Present */
+#define  PCI_EXP_SLTCAP_NCCS	0x00040000 /* No Command Completed Support */
+#define  PCI_EXP_SLTCAP_PSN	0xfff80000 /* Physical Slot Number */
+#define PCI_EXP_SLTCTL		24	/* Slot Control */
+#define  PCI_EXP_SLTCTL_ABPE	0x0001	/* Attention Button Pressed Enable */
+#define  PCI_EXP_SLTCTL_PFDE	0x0002	/* Power Fault Detected Enable */
+#define  PCI_EXP_SLTCTL_MRLSCE	0x0004	/* MRL Sensor Changed Enable */
+#define  PCI_EXP_SLTCTL_PDCE	0x0008	/* Presence Detect Changed Enable */
+#define  PCI_EXP_SLTCTL_CCIE	0x0010	/* Command Completed Interrupt Enable */
+#define  PCI_EXP_SLTCTL_HPIE	0x0020	/* Hot-Plug Interrupt Enable */
+#define  PCI_EXP_SLTCTL_AIC	0x00c0	/* Attention Indicator Control */
+#define  PCI_EXP_SLTCTL_ATTN_IND_ON    0x0040 /* Attention Indicator on */
+#define  PCI_EXP_SLTCTL_ATTN_IND_BLINK 0x0080 /* Attention Indicator blinking */
+#define  PCI_EXP_SLTCTL_ATTN_IND_OFF   0x00c0 /* Attention Indicator off */
+#define  PCI_EXP_SLTCTL_PIC	0x0300	/* Power Indicator Control */
+#define  PCI_EXP_SLTCTL_PWR_IND_ON     0x0100 /* Power Indicator on */
+#define  PCI_EXP_SLTCTL_PWR_IND_BLINK  0x0200 /* Power Indicator blinking */
+#define  PCI_EXP_SLTCTL_PWR_IND_OFF    0x0300 /* Power Indicator off */
+#define  PCI_EXP_SLTCTL_PCC	0x0400	/* Power Controller Control */
+#define  PCI_EXP_SLTCTL_PWR_ON         0x0000 /* Power On */
+#define  PCI_EXP_SLTCTL_PWR_OFF        0x0400 /* Power Off */
+#define  PCI_EXP_SLTCTL_EIC	0x0800	/* Electromechanical Interlock Control */
+#define  PCI_EXP_SLTCTL_DLLSCE	0x1000	/* Data Link Layer State Changed Enable */
+#define PCI_EXP_SLTSTA		26	/* Slot Status */
+#define  PCI_EXP_SLTSTA_ABP	0x0001	/* Attention Button Pressed */
+#define  PCI_EXP_SLTSTA_PFD	0x0002	/* Power Fault Detected */
+#define  PCI_EXP_SLTSTA_MRLSC	0x0004	/* MRL Sensor Changed */
+#define  PCI_EXP_SLTSTA_PDC	0x0008	/* Presence Detect Changed */
+#define  PCI_EXP_SLTSTA_CC	0x0010	/* Command Completed */
+#define  PCI_EXP_SLTSTA_MRLSS	0x0020	/* MRL Sensor State */
+#define  PCI_EXP_SLTSTA_PDS	0x0040	/* Presence Detect State */
+#define  PCI_EXP_SLTSTA_EIS	0x0080	/* Electromechanical Interlock Status */
+#define  PCI_EXP_SLTSTA_DLLSC	0x0100	/* Data Link Layer State Changed */
+#define PCI_EXP_RTCTL		28	/* Root Control */
+#define  PCI_EXP_RTCTL_SECEE	0x0001	/* System Error on Correctable Error */
+#define  PCI_EXP_RTCTL_SENFEE	0x0002	/* System Error on Non-Fatal Error */
+#define  PCI_EXP_RTCTL_SEFEE	0x0004	/* System Error on Fatal Error */
+#define  PCI_EXP_RTCTL_PMEIE	0x0008	/* PME Interrupt Enable */
+#define  PCI_EXP_RTCTL_CRSSVE	0x0010	/* CRS Software Visibility Enable */
+#define PCI_EXP_RTCAP		30	/* Root Capabilities */
+#define PCI_EXP_RTSTA		32	/* Root Status */
+#define PCI_EXP_RTSTA_PME	0x00010000 /* PME status */
+#define PCI_EXP_RTSTA_PENDING	0x00020000 /* PME pending */
+/*
+ * The Device Capabilities 2, Device Status 2, Device Control 2,
+ * Link Capabilities 2, Link Status 2, Link Control 2,
+ * Slot Capabilities 2, Slot Status 2, and Slot Control 2 registers
+ * are only present on devices with PCIe Capability version 2.
+ * Use pcie_capability_read_word() and similar interfaces to use them
+ * safely.
+ */
+#define PCI_EXP_DEVCAP2		36	/* Device Capabilities 2 */
+#define  PCI_EXP_DEVCAP2_ARI		0x00000020 /* Alternative Routing-ID */
+#define  PCI_EXP_DEVCAP2_LTR		0x00000800 /* Latency tolerance reporting */
+#define  PCI_EXP_DEVCAP2_OBFF_MASK	0x000c0000 /* OBFF support mechanism */
+#define  PCI_EXP_DEVCAP2_OBFF_MSG	0x00040000 /* New message signaling */
+#define  PCI_EXP_DEVCAP2_OBFF_WAKE	0x00080000 /* Re-use WAKE# for OBFF */
+#define PCI_EXP_DEVCTL2		40	/* Device Control 2 */
+#define  PCI_EXP_DEVCTL2_COMP_TIMEOUT	0x000f	/* Completion Timeout Value */
+#define  PCI_EXP_DEVCTL2_ARI		0x0020	/* Alternative Routing-ID */
+#define  PCI_EXP_DEVCTL2_IDO_REQ_EN	0x0100	/* Allow IDO for requests */
+#define  PCI_EXP_DEVCTL2_IDO_CMP_EN	0x0200	/* Allow IDO for completions */
+#define  PCI_EXP_DEVCTL2_LTR_EN		0x0400	/* Enable LTR mechanism */
+#define  PCI_EXP_DEVCTL2_OBFF_MSGA_EN	0x2000	/* Enable OBFF Message type A */
+#define  PCI_EXP_DEVCTL2_OBFF_MSGB_EN	0x4000	/* Enable OBFF Message type B */
+#define  PCI_EXP_DEVCTL2_OBFF_WAKE_EN	0x6000	/* OBFF using WAKE# signaling */
+#define PCI_EXP_DEVSTA2		42	/* Device Status 2 */
+#define PCI_CAP_EXP_ENDPOINT_SIZEOF_V2	44	/* v2 endpoints end here */
+#define PCI_EXP_LNKCAP2		44	/* Link Capabilities 2 */
+#define  PCI_EXP_LNKCAP2_SLS_2_5GB	0x00000002 /* Supported Speed 2.5GT/s */
+#define  PCI_EXP_LNKCAP2_SLS_5_0GB	0x00000004 /* Supported Speed 5.0GT/s */
+#define  PCI_EXP_LNKCAP2_SLS_8_0GB	0x00000008 /* Supported Speed 8.0GT/s */
+#define  PCI_EXP_LNKCAP2_CROSSLINK	0x00000100 /* Crosslink supported */
+#define PCI_EXP_LNKCTL2		48	/* Link Control 2 */
+#define PCI_EXP_LNKSTA2		50	/* Link Status 2 */
+#define PCI_EXP_SLTCAP2		52	/* Slot Capabilities 2 */
+#define PCI_EXP_SLTCTL2		56	/* Slot Control 2 */
+#define PCI_EXP_SLTSTA2		58	/* Slot Status 2 */
+
+
+/* PCI Enhanced Allocation registers */
+
+#define PCI_EA_NUM_ENT		2	/* Number of Capability Entries */
+#define PCI_EA_NUM_ENT_MASK	0x3f	/* Num Entries Mask */
+#define PCI_EA_FIRST_ENT	4	/* First EA Entry in List */
+#define PCI_EA_FIRST_ENT_BRIDGE	8	/* First EA Entry for Bridges */
+#define PCI_EA_ES		0x7	/* Entry Size */
+#define PCI_EA_BEI(x)  (((x) >> 4) & 0xf) /* BAR Equivalent Indicator */
+/* 0-5 map to BARs 0-5 respectively */
+#define  PCI_EA_BEI_BAR0	0
+#define  PCI_EA_BEI_BAR5	5
+#define  PCI_EA_BEI_BRIDGE	6	/* Resource behind bridge */
+#define  PCI_EA_BEI_ENI		7	/* Equivalent Not Indicated */
+#define  PCI_EA_BEI_ROM		8	/* Expansion ROM */
+/* 9-14 map to VF BARs 0-5 respectively */
+#define  PCI_EA_BEI_VF_BAR0	9
+#define  PCI_EA_BEI_VF_BAR5	14
+#define  PCI_EA_BEI_RESERVED	15	/* Reserved - Treat like ENI */
+
+#define PCI_EA_PP(x)   (((x) >>  8) & 0xff)	/* Primary Properties */
+#define PCI_EA_SP(x)   (((x) >> 16) & 0xff)	/* Secondary Properties */
+#define  PCI_EA_P_MEM			0x00	/* Non-Prefetch Memory */
+#define  PCI_EA_P_MEM_PREFETCH		0x01	/* Prefetchable Memory */
+#define  PCI_EA_P_IO			0x02	/* I/O Space */
+#define  PCI_EA_P_VIRT_MEM_PREFETCH	0x03	/* VF Prefetchable Memory */
+#define  PCI_EA_P_VIRT_MEM		0x04	/* VF Non-Prefetch Memory */
+#define  PCI_EA_P_BRIDGE_MEM		0x05	/* Bridge Non-Prefetch Memory */
+#define  PCI_EA_P_BRIDGE_MEM_PREFETCH	0x06	/* Bridge Prefetchable Memory */
+#define  PCI_EA_P_BRIDGE_IO		0x07	/* Bridge I/O Space */
+/* 0x08-0xfc reserved */
+#define  PCI_EA_P_MEM_RESERVED		0xfd	/* Reserved Memory */
+#define  PCI_EA_P_IO_RESERVED		0xfe	/* Reserved I/O Space */
+#define  PCI_EA_P_UNAVAILABLE		0xff	/* Entry Unavailable */
+#define PCI_EA_WRITEABLE		(1 << 30) /* Writable, 1 = RW, 0 = HwInit */
+#define PCI_EA_ENABLE			(1 << 31) /* Enable for this entry */
+#define PCI_EA_BASE			4	/* Base Address Offset */
+#define PCI_EA_MAX_OFFSET		8	/* MaxOffset (resource length) */
+/* bit 0 is reserved */
+#define PCI_EA_IS_64			(1 << 1)	/* 64-bit field flag */
+#define PCI_EA_FIELD_MASK		0xfffffffc	/* For Base & Max Offset */
+
+/* Single Root I/O Virtualization */
+#define PCI_SRIOV_CAP		0x04	/* SR-IOV Capabilities */
+#define  PCI_SRIOV_CAP_VFM	0x01	/* VF Migration Capable */
+#define  PCI_SRIOV_CAP_INTR(x)	((x) >> 21) /* Interrupt Message Number */
+#define PCI_SRIOV_CTRL		0x08	/* SR-IOV Control */
+#define  PCI_SRIOV_CTRL_VFE	0x01	/* VF Enable */
+#define  PCI_SRIOV_CTRL_VFM	0x02	/* VF Migration Enable */
+#define  PCI_SRIOV_CTRL_INTR	0x04	/* VF Migration Interrupt Enable */
+#define  PCI_SRIOV_CTRL_MSE	0x08	/* VF Memory Space Enable */
+#define  PCI_SRIOV_CTRL_ARI	0x10	/* ARI Capable Hierarchy */
+#define PCI_SRIOV_STATUS	0x0a	/* SR-IOV Status */
+#define  PCI_SRIOV_STATUS_VFM	0x01	/* VF Migration Status */
+#define PCI_SRIOV_INITIAL_VF	0x0c	/* Initial VFs */
+#define PCI_SRIOV_TOTAL_VF	0x0e	/* Total VFs */
+#define PCI_SRIOV_NUM_VF	0x10	/* Number of VFs */
+#define PCI_SRIOV_FUNC_LINK	0x12	/* Function Dependency Link */
+#define PCI_SRIOV_VF_OFFSET	0x14	/* First VF Offset */
+#define PCI_SRIOV_VF_STRIDE	0x16	/* Following VF Stride */
+#define PCI_SRIOV_VF_DID	0x1a	/* VF Device ID */
+#define PCI_SRIOV_SUP_PGSIZE	0x1c	/* Supported Page Sizes */
+#define PCI_SRIOV_SYS_PGSIZE	0x20	/* System Page Size */
+#define PCI_SRIOV_BAR		0x24	/* VF BAR0 */
+#define  PCI_SRIOV_NUM_BARS	6	/* Number of VF BARs */
+#define PCI_SRIOV_VFM		0x3c	/* VF Migration State Array Offset*/
+#define  PCI_SRIOV_VFM_BIR(x)	((x) & 7)	/* State BIR */
+#define  PCI_SRIOV_VFM_OFFSET(x) ((x) & ~7)	/* State Offset */
+#define  PCI_SRIOV_VFM_UA	0x0	/* Inactive.Unavailable */
+#define  PCI_SRIOV_VFM_MI	0x1	/* Dormant.MigrateIn */
+#define  PCI_SRIOV_VFM_MO	0x2	/* Active.MigrateOut */
+#define  PCI_SRIOV_VFM_AV	0x3	/* Active.Available */
+#define PCI_EXT_CAP_SRIOV_SIZEOF 64
+
+
 #define PCI_MAX_PCI_DEVICES	32
 #define PCI_MAX_PCI_FUNCTIONS	8
 
@@ -531,7 +788,7 @@ extern void pci_cfgfunc_do_nothing(struct pci_controller* hose, pci_dev_t dev,
 extern void pci_cfgfunc_config_device(struct pci_controller* hose, pci_dev_t dev,
 				      struct pci_config_table *);
 
-#define MAX_PCI_REGIONS		7
+#define MAX_PCI_REGIONS		10
 
 #define INDIRECT_TYPE_NO_PCIE_LINK	1
 
@@ -734,8 +991,6 @@ extern int pci_hose_find_cap_start(struct pci_controller *hose, pci_dev_t dev,
 extern int pci_find_cap(struct pci_controller *hose, pci_dev_t dev, int pos,
 			int cap);
 
-int pci_find_next_ext_capability(struct pci_controller *hose,
-				 pci_dev_t dev, int start, int cap);
 int pci_hose_find_ext_capability(struct pci_controller *hose,
 				 pci_dev_t dev, int cap);
 
@@ -821,12 +1076,19 @@ struct udevice;
  * @vendor:	PCI vendor ID (see pci_ids.h)
  * @device:	PCI device ID (see pci_ids.h)
  * @class:	PCI class, 3 bytes: (base, sub, prog-if)
+ * @is_phys:	Whether device is a physical or virtual function
+ * @pdev:	Physical function for VFs
+ * @vf_id:	VF identifier
  */
 struct pci_child_platdata {
 	int devfn;
 	unsigned short vendor;
 	unsigned short device;
 	unsigned int class;
+
+	bool is_phys;
+	struct udevice *pdev;
+	int vf_id;
 };
 
 /* PCI bus operations */
@@ -1137,6 +1399,9 @@ int pci_generic_mmap_read_config(
 	ulong *valuep,
 	enum pci_size_t size);
 
+int pci_sriov_init(struct udevice *pdev, int vf_en);
+int pci_sriov_get_totalvfs(struct udevice *pdev);
+
 #ifdef CONFIG_DM_PCI_COMPAT
 /* Compatibility with old naming */
 static inline int pci_write_config_dword(pci_dev_t pcidev, int offset,
@@ -1293,10 +1558,11 @@ pci_addr_t dm_pci_phys_to_bus(struct udevice *dev, phys_addr_t addr,
  *
  * @dev:	Device to check
  * @bar:	Bar number to read (numbered from 0)
+ * @size:	BAR size
  * @flags:	Flags for the region type (PCI_REGION_...)
  * @return: pointer to the virtual address to use
  */
-void *dm_pci_map_bar(struct udevice *dev, int bar, int flags);
+void *dm_pci_map_bar(struct udevice *dev, int bar, size_t *size, int flags);
 
 #define dm_pci_virt_to_bus(dev, addr, flags) \
 	dm_pci_phys_to_bus(dev, (virt_to_phys(addr)), (flags))
@@ -1323,6 +1589,25 @@ void *dm_pci_map_bar(struct udevice *dev, int bar, int flags);
 	dm_pci_bus_to_virt((dev), (addr), PCI_REGION_IO, (len), (map_flags))
 
 /**
+ * dm_pci_find_capability() - find a capability offset for a given device
+ *
+ * @dev: 	Device to check
+ * @cap:	Capability ID
+ * @return: capability offset if found, 0 otherwise
+ */
+int dm_pci_find_capability(struct udevice *dev, int cap);
+
+/**
+ * dm_pci_find_ext_capability() - find an extended capability
+ * 		offset for a given device
+ *
+ * @dev: 	Device to check
+ * @cap:	Capability ID
+ * @return: capability offset if found, 0 otherwise
+ */
+int dm_pci_find_ext_capability(struct udevice *dev, int cap);
+
+/**
  * dm_pci_find_device() - find a device by vendor/device ID
  *
  * @vendor:	Vendor ID
@@ -1452,6 +1737,16 @@ struct dm_pci_emul_ops {
 int sandbox_pci_get_emul(struct udevice *bus, pci_dev_t find_devfn,
 			 struct udevice **emulp);
 
+/**
+ * pci_get_devfn() - Extract the devfn from fdt_pci_addr of the device
+ *
+ * Get devfn from fdt_pci_addr of the specifified device
+ *
+ * @dev:	PCI device
+ * @return devfn in bits 15...8 if found, -ENODEV if not found
+ */
+int pci_get_devfn(struct udevice *dev);
+
 #endif /* CONFIG_DM_PCI */
 
 /**
diff --git a/include/pci_ids.h b/include/pci_ids.h
index fdda679..bdf56ea 100644
--- a/include/pci_ids.h
+++ b/include/pci_ids.h
@@ -3129,3 +3129,6 @@
 #define PCI_DEVICE_ID_XEN_PLATFORM	0x0001
 
 #define PCI_VENDOR_ID_OCZ		0x1b85
+
+#define PCI_VENDOR_ID_CAVIUM		0x177d
+
diff --git a/include/phy.h b/include/phy.h
index 0543ec1..9d3b094 100644
--- a/include/phy.h
+++ b/include/phy.h
@@ -15,6 +15,10 @@
 #include <linux/ethtool.h>
 #include <linux/mdio.h>
 
+#ifdef CONFIG_DM_ETH
+#include <dm/device.h>
+#endif
+
 #define PHY_FIXED_ID		0xa5a55a5a
 
 #define PHY_MAX_ADDR 32
@@ -45,7 +49,7 @@
 				SUPPORTED_10000baseT_Full)
 
 #ifndef PHY_ANEG_TIMEOUT
-#define PHY_ANEG_TIMEOUT	4000
+#define PHY_ANEG_TIMEOUT	8000
 #endif
 
 
@@ -63,9 +67,13 @@ typedef enum {
 	PHY_INTERFACE_MODE_RGMII_TXID,
 	PHY_INTERFACE_MODE_RTBI,
 	PHY_INTERFACE_MODE_XGMII,
+	PHY_INTERFACE_MODE_1000BASEX,
+	PHY_INTERFACE_MODE_2500BASEX,
 	PHY_INTERFACE_MODE_XAUI,
 	PHY_INTERFACE_MODE_RXAUI,
 	PHY_INTERFACE_MODE_SFI,
+	PHY_INTERFACE_MODE_XLAUI,
+	PHY_INTERFACE_MODE_AP,
 	PHY_INTERFACE_MODE_NONE,	/* Must be last */
 
 	PHY_INTERFACE_MODE_COUNT,
@@ -84,10 +92,14 @@ static const char *phy_interface_strings[] = {
 	[PHY_INTERFACE_MODE_RGMII_RXID]		= "rgmii-rxid",
 	[PHY_INTERFACE_MODE_RGMII_TXID]		= "rgmii-txid",
 	[PHY_INTERFACE_MODE_RTBI]		= "rtbi",
+	[PHY_INTERFACE_MODE_1000BASEX]		= "1000base-x",
+	[PHY_INTERFACE_MODE_2500BASEX]		= "2500base-x",
 	[PHY_INTERFACE_MODE_XGMII]		= "xgmii",
 	[PHY_INTERFACE_MODE_XAUI]		= "xaui",
 	[PHY_INTERFACE_MODE_RXAUI]		= "rxaui",
 	[PHY_INTERFACE_MODE_SFI]		= "sfi",
+	[PHY_INTERFACE_MODE_XLAUI]		= "xlaui",
+	[PHY_INTERFACE_MODE_AP]			= "ap",
 	[PHY_INTERFACE_MODE_NONE]		= "",
 };
 
@@ -220,7 +232,10 @@ extern struct phy_driver gen10g_driver;
 /* For now, XGMII is the only 10G interface */
 static inline int is_10g_interface(phy_interface_t interface)
 {
-	return interface == PHY_INTERFACE_MODE_XGMII;
+	return (interface == PHY_INTERFACE_MODE_XGMII) ||
+	       (interface == PHY_INTERFACE_MODE_XAUI)  ||
+	       (interface == PHY_INTERFACE_MODE_XLAUI) ||
+	       (interface == PHY_INTERFACE_MODE_RXAUI);
 }
 
 #endif
diff --git a/include/power/regulator.h b/include/power/regulator.h
index 2bbc1e5..3592b94 100644
--- a/include/power/regulator.h
+++ b/include/power/regulator.h
@@ -150,6 +150,7 @@ enum regulator_flag {
  * @max_uA*    - maximum amperage (micro Amps)
  * @always_on* - bool type, true or false
  * @boot_on*   - bool type, true or false
+ * @force_off* - bool type, true or false
  * TODO(sjg@chromium.org): Consider putting the above two into @flags
  * @flags:     - flags value (see REGULATOR_FLAG_...)
  * @name**     - fdt regulator name - should be taken from the device tree
@@ -172,6 +173,7 @@ struct dm_regulator_uclass_platdata {
 	int max_uA;
 	bool always_on;
 	bool boot_on;
+	bool force_off;
 	const char *name;
 	int flags;
 	u8 ctrl_reg;
@@ -343,6 +345,15 @@ int regulator_set_mode(struct udevice *dev, int mode_id);
 int regulators_enable_boot_on(bool verbose);
 
 /**
+ * regulators_enable_boot_off() - disable regulators needed for boot
+ *
+ * This disables all regulators which are marked to be off at boot time.
+ *
+ * This effectively calls regulator_unset() for every regulator.
+ */
+int regulators_enable_boot_off(bool verbose);
+
+/**
  * regulator_autoset: setup the voltage/current on a regulator
  *
  * The setup depends on constraints found in device's uclass's platform data
@@ -362,6 +373,18 @@ int regulators_enable_boot_on(bool verbose);
 int regulator_autoset(struct udevice *dev);
 
 /**
+ * regulator_unset: turn off a regulator
+ *
+ * The setup depends on constraints found in device's uclass's platform data
+ * (struct dm_regulator_uclass_platdata):
+ *
+ * - Disable - will set - if  'force_off' is set to true,
+ *
+ * The function returns on the first-encountered error.
+  */
+int regulator_unset(struct udevice *dev);
+
+/**
  * regulator_autoset_by_name: setup the regulator given by its uclass's
  * platform data name field. The setup depends on constraints found in device's
  * uclass's platform data (struct dm_regulator_uclass_platdata):
diff --git a/include/sar-uclass.h b/include/sar-uclass.h
new file mode 100644
index 0000000..35de57d
--- /dev/null
+++ b/include/sar-uclass.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2018 Marvell International Ltd.
+ *
+ * SPDX-License-Identifier:	GPL-2.0
+ * https://spdx.org/licenses
+ */
+
+#include <common.h>
+#include <mvebu/mvebu_chip_sar.h>
+#include <fdtdec.h>
+#include <dm.h>
+#include <dm/device-internal.h>
+
+struct sar_ops {
+	int (*sar_init_func)(struct udevice *dev);
+	int (*sar_dump_func)(struct udevice *dev);
+	int (*sar_value_get_func)(struct udevice *dev, enum mvebu_sar_opts sar,
+				  struct sar_val *val);
+	int (*sar_bootsrc_get)(struct udevice *dev, u32 *idx);
+};
+
+struct dm_sar_pdata {
+	void __iomem *sar_base;
+	const char *sar_name;
+};
+
+int mvebu_sar_id_register(struct udevice *dev, u32 sar_id);
diff --git a/include/scsi.h b/include/scsi.h
index 7173912..573007b 100644
--- a/include/scsi.h
+++ b/include/scsi.h
@@ -232,6 +232,26 @@ void scsi_low_level_init(int busdevfunc);
 void scsi_init(void);
 #endif
 
+/**
+ * scsi_bus_reset() - reset the bus
+ *
+ * @dev:	SCSI bus to reset
+ * @return 0 if OK, -ve on error
+ */
+int scsi_bus_reset(struct udevice *dev);
+
+/**
+ * scsi_scan() - Scan all SCSI controllers for available devices
+ *
+ * @vebose: true to show information about each device found
+ */
+int scsi_scan(bool verbose);
+
+#ifndef CONFIG_DM_SCSI
+void scsi_low_level_init(int busdevfunc);
+void scsi_init(void);
+#endif
+
 #define SCSI_IDENTIFY					0xC0  /* not used */
 
 /* Hardware errors  */
diff --git a/include/sdhci.h b/include/sdhci.h
index 7e84012..1fefeab 100644
--- a/include/sdhci.h
+++ b/include/sdhci.h
@@ -237,6 +237,10 @@ struct sdhci_ops {
 	void	(*set_control_reg)(struct sdhci_host *host);
 	void	(*set_ios_post)(struct sdhci_host *host);
 	void	(*set_clock)(struct sdhci_host *host, u32 div);
+#ifdef MMC_SUPPORTS_TUNING
+	int	(*execute_tuning_pre)(struct sdhci_host *host, u32 opcode);
+	int	(*execute_tuning_post)(struct sdhci_host *host, u32 opcode);
+#endif
 };
 
 struct sdhci_host {
diff --git a/include/spi.h b/include/spi.h
index f5bac8d..b87336f 100644
--- a/include/spi.h
+++ b/include/spi.h
@@ -10,6 +10,8 @@
 #ifndef _SPI_H_
 #define _SPI_H_
 
+#include <linux/string.h> /* memset() */
+
 /* SPI mode flags */
 #define SPI_CPHA	BIT(0)			/* clock phase */
 #define SPI_CPOL	BIT(1)			/* clock polarity */
@@ -64,6 +66,116 @@ struct dm_spi_slave_platdata {
 #endif /* CONFIG_DM_SPI */
 
 /**
+ * enum spi_flash_protocol - SPI flash command protocol
+ */
+#define SPI_FPROTO_INST_SHIFT	16
+#define SPI_FPROTO_INST_MASK	GENMASK(23, 16)
+#define SPI_FPROTO_INST(nbits)					\
+	((((unsigned long)(nbits)) << SPI_FPROTO_INST_SHIFT) &	\
+	 SPI_FPROTO_INST_MASK)
+
+#define SPI_FPROTO_ADDR_SHIFT	8
+#define SPI_FPROTO_ADDR_MASK	GENMASK(15, 8)
+#define SPI_FPROTO_ADDR(nbits)					\
+	((((unsigned long)(nbits)) << SPI_FPROTO_ADDR_SHIFT) &	\
+	 SPI_FPROTO_ADDR_MASK)
+
+#define SPI_FPROTO_DATA_SHIFT	0
+#define SPI_FPROTO_DATA_MASK	GENMASK(7, 0)
+#define SPI_FPROTO_DATA(nbits)					\
+	((((unsigned long)(nbits)) << SPI_FPROTO_DATA_SHIFT) &	\
+	 SPI_FPROTO_DATA_MASK)
+
+#define SPI_FPROTO(inst_nbits, addr_nbits, data_nbits)	\
+	(SPI_FPROTO_INST(inst_nbits) |			\
+	 SPI_FPROTO_ADDR(addr_nbits) |			\
+	 SPI_FPROTO_DATA(data_nbits))
+
+enum spi_flash_protocol {
+	SPI_FPROTO_1_1_1 = SPI_FPROTO(1, 1, 1),
+	SPI_FPROTO_1_1_2 = SPI_FPROTO(1, 1, 2),
+	SPI_FPROTO_1_1_4 = SPI_FPROTO(1, 1, 4),
+	SPI_FPROTO_1_2_2 = SPI_FPROTO(1, 2, 2),
+	SPI_FPROTO_1_4_4 = SPI_FPROTO(1, 4, 4),
+	SPI_FPROTO_2_2_2 = SPI_FPROTO(2, 2, 2),
+	SPI_FPROTO_4_4_4 = SPI_FPROTO(4, 4, 4),
+};
+
+static inline
+u8 spi_flash_protocol_get_inst_nbits(enum spi_flash_protocol proto)
+{
+	return ((unsigned long)(proto & SPI_FPROTO_INST_MASK)) >>
+		SPI_FPROTO_INST_SHIFT;
+}
+
+static inline
+u8 spi_flash_protocol_get_addr_nbits(enum spi_flash_protocol proto)
+{
+	return ((unsigned long)(proto & SPI_FPROTO_ADDR_MASK)) >>
+		SPI_FPROTO_ADDR_SHIFT;
+}
+
+static inline
+u8 spi_flash_protocol_get_data_nbits(enum spi_flash_protocol proto)
+{
+	return ((unsigned long)(proto & SPI_FPROTO_DATA_MASK)) >>
+		SPI_FPROTO_DATA_SHIFT;
+}
+
+/**
+ * struct spi_flash_command - SPI flash command structure
+ *
+ * @instr:		Opcode sent to the SPI slave during instr clock cycles.
+ * @mode:		Value sent to the SPI slave during mode clock cycles.
+ * @num_mode_cycles:	Number of mode clock cycles.
+ * @num_wait_states:	Number of wait-state clock cycles.
+ * @addr_len:		Number of bytes sent during address clock cycles:
+ *			should be 0, 3, or 4.
+ * @addr:		Value sent to the SPI slave during address clock cycles.
+ * @data_len:		Number of bytes to be sent during data clock cycles.
+ * @tx_data:		Data sent to the SPI slave during data clock cycles.
+ * @rx_data:		Data read from the SPI slave during data clock cycles.
+ */
+struct spi_flash_command {
+	enum spi_flash_protocol proto;
+	u8 flags;
+#define SPI_FCMD_TYPE		GENMASK(2, 0)
+#define SPI_FCMD_READ		(0x0U << 0)
+#define SPI_FCMD_WRITE		(0x1U << 0)
+#define SPI_FCMD_ERASE		(0x2U << 0)
+#define SPI_FCMD_READ_REG	(0x3U << 0)
+#define SPI_FCMD_WRITE_REG	(0x4U << 0)
+
+	u8 inst;
+	u8 mode;
+	u8 num_mode_cycles;
+	u8 num_wait_states;
+	u8 addr_len;
+	u32 addr;
+	size_t data_len;
+	const void *tx_data;
+	void *rx_data;
+};
+
+/**
+ * Initialize a 'struct spi_flash_command'.
+ *
+ * @cmd:		Pointer to the 'struct spi_flash_command' to initialize.
+ * @instr:		Instruction opcode.
+ * @addr_len:		Number of address bytes.
+ */
+static inline void
+spi_flash_command_init(struct spi_flash_command *cmd,
+		       u8 inst, u8 addr_len, u8 flags)
+{
+	memset(cmd, 0, sizeof(*cmd));
+	cmd->proto = SPI_FPROTO_1_1_1;
+	cmd->inst = inst;
+	cmd->addr_len = addr_len;
+	cmd->flags = flags;
+}
+
+/**
  * struct spi_slave - Representation of a SPI slave
  *
  * For driver model this is the per-child data used by the SPI bus. It can
@@ -114,6 +226,8 @@ struct spi_slave {
 #define SPI_XFER_ONCE		(SPI_XFER_BEGIN | SPI_XFER_END)
 #define SPI_XFER_MMAP		BIT(2)	/* Memory Mapped start */
 #define SPI_XFER_MMAP_END	BIT(3)	/* Memory Mapped End */
+#define SPI_XFER_DUAL		BIT(30)
+#define SPI_XFER_QUAD		BIT(31)
 };
 
 /**
@@ -254,6 +368,24 @@ int spi_set_wordlen(struct spi_slave *slave, unsigned int wordlen);
 int  spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
 		void *din, unsigned long flags);
 
+/**
+ * Check whether the given SPI flash command is supported
+ *
+ * @slave:	The SPI slave
+ * @cmd:	The SPI flash command to check.
+ */
+bool spi_is_flash_command_supported(struct spi_slave *slave,
+				    const struct spi_flash_command *cmd);
+
+/**
+ * Execute SPI flash command
+ *
+ * @slave:	The SPI slave which will execute the give SPI flash command.
+ * @cmd:	The SPI flash command to execute.
+ */
+int spi_exec_flash_command(struct spi_slave *slave,
+			   const struct spi_flash_command *cmd);
+
 /* Copy memory mapped data */
 void spi_flash_copy_mmap(void *data, void *offset, size_t len);
 
@@ -439,6 +571,26 @@ struct dm_spi_ops {
 	 *	   is invalid, other -ve value on error
 	 */
 	int (*cs_info)(struct udevice *bus, uint cs, struct spi_cs_info *info);
+
+	/**
+	 * Check whether the given SPI flash command is supported.
+	 *
+	 * @bus:	The SPI bus
+	 * @cmd:	The SPI flash command to check.
+	 * @return:	true if supported, false otherwise
+	 */
+	bool (*is_flash_command_supported)(struct udevice *bus,
+					   const struct spi_flash_command *cmd);
+
+	/**
+	 * Execute a SPI flash command
+	 *
+	 * @bus:	The SPI bus
+	 * @cmd:	The SPI flash command to execute.
+	 * @return 0 if OK, -ve on error
+	 */
+	int (*exec_flash_command)(struct udevice *bus,
+				  const struct spi_flash_command *cmd);
 };
 
 struct dm_spi_emul_ops {
@@ -626,6 +778,24 @@ void dm_spi_release_bus(struct udevice *dev);
 int dm_spi_xfer(struct udevice *dev, unsigned int bitlen,
 		const void *dout, void *din, unsigned long flags);
 
+/**
+ * Check whether the given SPI flash command is supported.
+ *
+ * @dev:	The SPI slave device
+ * @cmd:	The SPI flash command
+ */
+bool dm_spi_is_flash_command_supported(struct udevice *dev,
+				       const struct spi_flash_command *cmd);
+
+/**
+ * Execute the given SPI flash command.
+ *
+ * @dev:	The SPI slave device
+ * @cmd:	The SPI flash command
+ */
+int dm_spi_exec_flash_command(struct udevice *dev,
+			      const struct spi_flash_command *cmd);
+
 /* Access the operations for a SPI device */
 #define spi_get_ops(dev)	((struct dm_spi_ops *)(dev)->driver->ops)
 #define spi_emul_get_ops(dev)	((struct dm_spi_emul_ops *)(dev)->driver->ops)
diff --git a/include/spi_flash.h b/include/spi_flash.h
index f3c4e83..a7c6ae7 100644
--- a/include/spi_flash.h
+++ b/include/spi_flash.h
@@ -11,6 +11,7 @@
 #define _SPI_FLASH_H_
 
 #include <dm.h>	/* Because we dereference struct udevice here */
+#include <spi.h>
 #include <linux/types.h>
 
 #ifndef CONFIG_SF_DEFAULT_SPEED
@@ -44,10 +45,13 @@ struct spi_slave;
  * @bank_read_cmd:	Bank read cmd
  * @bank_write_cmd:	Bank write cmd
  * @bank_curr:		Current flash bank
+ * @addr_len:		Number of bytes for the address
  * @erase_cmd:		Erase cmd 4K, 32K, 64K
  * @read_cmd:		Read cmd - Array Fast, Extn read and quad read.
  * @write_cmd:		Write cmd - page and quad program.
  * @dummy_byte:		Dummy cycles for read operation.
+ * @read_proto:		SPI x-y-z protocol for flash read ops
+ * @write_proto:	SPI x-y-z protocol for flash write ops
  * @memory_map:		Address of read-only SPI flash access
  * @flash_lock:		lock a region of the SPI Flash
  * @flash_unlock:	unlock a region of the SPI Flash
@@ -79,10 +83,13 @@ struct spi_flash {
 	u8 bank_write_cmd;
 	u8 bank_curr;
 #endif
+	u8 addr_len;
 	u8 erase_cmd;
 	u8 read_cmd;
 	u8 write_cmd;
 	u8 dummy_byte;
+	enum spi_flash_protocol read_proto;
+	enum spi_flash_protocol write_proto;
 
 	void *memory_map;
 
diff --git a/lib/Makefile b/lib/Makefile
index 0db41c1..04dbbd4 100644
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -81,6 +81,7 @@ obj-y += linux_compat.o
 obj-y += linux_string.o
 obj-y += membuff.o
 obj-$(CONFIG_REGEX) += slre.o
+obj-y += ssp.o
 obj-y += string.o
 obj-y += tables_csum.o
 obj-y += time.o
diff --git a/lib/fdtdec.c b/lib/fdtdec.c
index 320ee1d..333fdca 100644
--- a/lib/fdtdec.c
+++ b/lib/fdtdec.c
@@ -73,6 +73,11 @@ static const char * const compat_names[COMPAT_COUNT] = {
 	COMPAT(ALTERA_SOCFPGA_F2SDR2, "altr,socfpga-fpga2sdram2-bridge"),
 	COMPAT(ALTERA_SOCFPGA_FPGA0, "altr,socfpga-a10-fpga-mgr"),
 	COMPAT(ALTERA_SOCFPGA_NOC, "altr,socfpga-a10-noc"),
+	COMPAT(MVEBU_SAR, "marvell,sample-at-reset"),
+	COMPAT(MVEBU_SAR_REG_COMMON, "marvell,sample-at-reset-common"),
+	COMPAT(MVEBU_SAR_REG_AP806, "marvell,sample-at-reset-ap806"),
+	COMPAT(MVEBU_SAR_REG_CP110, "marvell,sample-at-reset-cp110"),
+
 };
 
 const char *fdtdec_get_compatible(enum fdt_compat_id id)
@@ -199,7 +204,7 @@ fdt_addr_t fdtdec_get_addr(const void *blob, int node, const char *prop_name)
 	return fdtdec_get_addr_size(blob, node, prop_name, NULL);
 }
 
-#if defined(CONFIG_PCI) && defined(CONFIG_DM_PCI)
+#if CONFIG_IS_ENABLED(PCI) && defined(CONFIG_DM_PCI)
 int fdtdec_get_pci_addr(const void *blob, int node, enum fdt_pci_space type,
 			const char *prop_name, struct fdt_pci_addr *addr)
 {
@@ -305,6 +310,23 @@ int fdtdec_get_pci_bar32(struct udevice *dev, struct fdt_pci_addr *addr,
 
 	return 0;
 }
+
+int fdtdec_get_pci_bus_range(const void *blob, int node,
+			     struct fdt_resource *res)
+{
+	const u32 *values;
+	int len;
+
+	values = fdt_getprop(blob, node, "bus-range", &len);
+	if (!values || len < sizeof(*values) * 2)
+		return -EINVAL;
+
+	res->start = be32_to_cpup(values++);
+	res->end = be32_to_cpup(values);
+
+	return 0;
+}
+
 #endif
 
 uint64_t fdtdec_get_uint64(const void *blob, int node, const char *prop_name,
diff --git a/lib/ssp.c b/lib/ssp.c
new file mode 100644
index 0000000..10518f4
--- /dev/null
+++ b/lib/ssp.c
@@ -0,0 +1,10 @@
+#include <common.h>
+
+const unsigned long __stack_chk_guard = 0xDEADBEEF0C0FFEE0UL;
+const char message[] = "stack-protector: U-Boot stack is corrupted\n";
+
+void __stack_chk_fail(void)
+{
+	puts(message);
+	panic("Resetting CPU ...\n");
+}
diff --git a/localversion b/localversion
new file mode 100644
index 0000000..98a1d9e
--- /dev/null
+++ b/localversion
@@ -0,0 +1 @@
+-7.0.0
diff --git a/net/Kconfig b/net/Kconfig
index 143c441..e1fc614 100644
--- a/net/Kconfig
+++ b/net/Kconfig
@@ -58,6 +58,10 @@ config BOOTP_SUBNETMASK
 	depends on CMD_NET
 	depends on CMD_NET
 
+config BOOTP_TFTP_SERVERIP
+	bool "Enable BOOTP TFTP serverip"
+	depends on CMD_NET
+
 config BOOTP_PXE_CLIENTARCH
 	hex
 	depends on CMD_NET
diff --git a/net/bootp.c b/net/bootp.c
index efa9599..04191f9 100644
--- a/net/bootp.c
+++ b/net/bootp.c
@@ -589,6 +589,10 @@ static int dhcp_extended(u8 *e, int message_type, struct in_addr server_ip,
 	*e++  = 42;
 	*cnt += 1;
 #endif
+#if defined(CONFIG_BOOTP_TFTP_SERVERIP)
+	*e++ = 150;
+	*cnt += 1;
+#endif
 	/* no options, so back up to avoid sending an empty request list */
 	if (*cnt == 0)
 		e -= 2;
@@ -894,6 +898,11 @@ static void dhcp_process_options(uchar *popt, uchar *end)
 			memcpy(&net_boot_file_name, popt + 2, size);
 			net_boot_file_name[size] = 0;
 			break;
+#if defined(CONFIG_BOOTP_TFTP_SERVERIP)
+		case 150:
+			net_copy_ip(&net_server_ip, (u32 *)(popt + 2));
+			break;
+#endif
 		default:
 #if defined(CONFIG_BOOTP_VENDOREX)
 			if (dhcp_vendorex_proc(popt))
diff --git a/net/eth-uclass.c b/net/eth-uclass.c
index d30b04b..45ddd5a 100644
--- a/net/eth-uclass.c
+++ b/net/eth-uclass.c
@@ -388,15 +388,16 @@ int eth_initialize(void)
 	int num_devices = 0;
 	struct udevice *dev;
 
+#ifndef CONFIG_MISC_INIT_R
 	eth_common_init();
-
+#endif
 	/*
 	 * Devices need to write the hwaddr even if not started so that Linux
 	 * will have access to the hwaddr that u-boot stored for the device.
 	 * This is accomplished by attempting to probe each device and calling
 	 * their write_hwaddr() operation.
 	 */
-	uclass_first_device(UCLASS_ETH, &dev);
+	uclass_first_device_check(UCLASS_ETH, &dev);
 	if (!dev) {
 		printf("No ethernet found.\n");
 		bootstage_error(BOOTSTAGE_ID_NET_ETH_START);
@@ -425,7 +426,7 @@ int eth_initialize(void)
 
 			eth_write_hwaddr(dev);
 
-			uclass_next_device(&dev);
+			uclass_next_device_check(&dev);
 			num_devices++;
 		} while (dev);
 
diff --git a/net/eth_legacy.c b/net/eth_legacy.c
index be0cf64..fe990aa 100644
--- a/net/eth_legacy.c
+++ b/net/eth_legacy.c
@@ -239,9 +239,12 @@ int eth_initialize(void)
 {
 	int num_devices = 0;
 
+#ifndef CONFIG_BOARD_EARLY_INIT_R
 	eth_devices = NULL;
 	eth_current = NULL;
 	eth_common_init();
+#endif
+
 	/*
 	 * If board-specific initialization exists, call it.
 	 * If not, call a CPU-specific one
diff --git a/scripts/checkpatch.pl b/scripts/checkpatch.pl
index e450826..5b75627 100755
--- a/scripts/checkpatch.pl
+++ b/scripts/checkpatch.pl
@@ -1,9 +1,11 @@
 #!/usr/bin/env perl
+# SPDX-License-Identifier: GPL-2.0
+#
 # (c) 2001, Dave Jones. (the file handling bit)
 # (c) 2005, Joel Schopp <jschopp@austin.ibm.com> (the ugly bit)
 # (c) 2007,2008, Andy Whitcroft <apw@uk.ibm.com> (new conditions, test suite)
 # (c) 2008-2010 Andy Whitcroft <apw@canonical.com>
-# Licensed under the terms of the GNU GPL License version 2
+# (c) 2010-2018 Joe Perches <joe@perches.com>
 
 use strict;
 use warnings;
@@ -11,6 +13,7 @@ use POSIX;
 use File::Basename;
 use Cwd 'abs_path';
 use Term::ANSIColor qw(:constants);
+use Encode qw(decode encode);
 
 my $P = $0;
 my $D = dirname(abs_path($P));
@@ -58,7 +61,7 @@ my $codespellfile = "/usr/share/codespell/dictionary.txt";
 my $conststructsfile = "$D/const_structs.checkpatch";
 my $typedefsfile = "";
 my $color = "auto";
-my $allow_c99_comments = 1;
+my $allow_c99_comments = 1; # Can be overridden by --ignore C99_COMMENT_TOLERANCE
 
 sub help {
 	my ($exitcode) = @_;
@@ -145,7 +148,8 @@ sub list_types {
 	close($script);
 
 	my @types = ();
-	for ($text =~ /\b(?:(?:CHK|WARN|ERROR)\s*\(\s*"([^"]+)")/g) {
+	# Also catch when type or level is passed through a variable
+	for ($text =~ /(?:(?:\bCHK|\bWARN|\bERROR|&\{\$msg_level})\s*\(|\$msg_type\s*=)\s*"([^"]+)"/g) {
 		push (@types, $_);
 	}
 	@types = sort(uniq(@types));
@@ -237,11 +241,11 @@ $check_orig = $check;
 
 my $exit = 0;
 
+my $perl_version_ok = 1;
 if ($^V && $^V lt $minimum_perl_version) {
+	$perl_version_ok = 0;
 	printf "$P: requires at least perl version %vd\n", $minimum_perl_version;
-	if (!$ignore_perl_version) {
-		exit(1);
-	}
+	exit(1) if (!$ignore_perl_version);
 }
 
 #if no filenames are given, push '-' to read patch from stdin
@@ -343,9 +347,10 @@ our $Sparse	= qr{
 			__force|
 			__iomem|
 			__must_check|
-			__init_refok|
 			__kprobes|
 			__ref|
+			__refconst|
+			__refdata|
 			__rcu|
 			__private
 		}x;
@@ -375,6 +380,7 @@ our $Attribute	= qr{
 			__noclone|
 			__deprecated|
 			__read_mostly|
+			__ro_after_init|
 			__kprobes|
 			$InitAttribute|
 			____cacheline_aligned|
@@ -392,7 +398,7 @@ our $Binary	= qr{(?i)0b[01]+$Int_type?};
 our $Hex	= qr{(?i)0x[0-9a-f]+$Int_type?};
 our $Int	= qr{[0-9]+$Int_type?};
 our $Octal	= qr{0[0-7]+$Int_type?};
-our $String	= qr{(?:\bL)?"[X\t]*"};
+our $String	= qr{"[X\t]*"};
 our $Float_hex	= qr{(?i)0x[0-9a-f]+p-?[0-9]+[fl]?};
 our $Float_dec	= qr{(?i)(?:[0-9]+\.[0-9]*|[0-9]*\.[0-9]+)(?:e-?[0-9]+)?[fl]?};
 our $Float_int	= qr{(?i)[0-9]+e-?[0-9]+[fl]?};
@@ -453,14 +459,26 @@ our $zero_initializer = qr{(?:(?:0[xX])?0+$Int_type?|NULL|false)\b};
 our $logFunctions = qr{(?x:
 	printk(?:_ratelimited|_once|_deferred_once|_deferred|)|
 	(?:[a-z0-9]+_){1,2}(?:printk|emerg|alert|crit|err|warning|warn|notice|info|debug|dbg|vdbg|devel|cont|WARN)(?:_ratelimited|_once|)|
+	TP_printk|
 	WARN(?:_RATELIMIT|_ONCE|)|
 	panic|
 	MODULE_[A-Z_]+|
 	seq_vprintf|seq_printf|seq_puts
 )};
 
+our $allocFunctions = qr{(?x:
+	(?:(?:devm_)?
+		(?:kv|k|v)[czm]alloc(?:_node|_array)? |
+		kstrdup(?:_const)? |
+		kmemdup(?:_nul)?) |
+	(?:\w+)?alloc_skb(?:ip_align)? |
+				# dev_alloc_skb/netdev_alloc_skb, et al
+	dma_alloc_coherent
+)};
+
 our $signature_tags = qr{(?xi:
 	Signed-off-by:|
+	Co-developed-by:|
 	Acked-by:|
 	Tested-by:|
 	Reviewed-by:|
@@ -564,6 +582,28 @@ foreach my $entry (@mode_permission_funcs) {
 	$mode_perms_search .= '|' if ($mode_perms_search ne "");
 	$mode_perms_search .= $entry->[0];
 }
+$mode_perms_search = "(?:${mode_perms_search})";
+
+our %deprecated_apis = (
+	"synchronize_rcu_bh"			=> "synchronize_rcu",
+	"synchronize_rcu_bh_expedited"		=> "synchronize_rcu_expedited",
+	"call_rcu_bh"				=> "call_rcu",
+	"rcu_barrier_bh"			=> "rcu_barrier",
+	"synchronize_sched"			=> "synchronize_rcu",
+	"synchronize_sched_expedited"		=> "synchronize_rcu_expedited",
+	"call_rcu_sched"			=> "call_rcu",
+	"rcu_barrier_sched"			=> "rcu_barrier",
+	"get_state_synchronize_sched"		=> "get_state_synchronize_rcu",
+	"cond_synchronize_sched"		=> "cond_synchronize_rcu",
+);
+
+#Create a search pattern for all these strings to speed up a loop below
+our $deprecated_apis_search = "";
+foreach my $entry (keys %deprecated_apis) {
+	$deprecated_apis_search .= '|' if ($deprecated_apis_search ne "");
+	$deprecated_apis_search .= $entry;
+}
+$deprecated_apis_search = "(?:${deprecated_apis_search})";
 
 our $mode_perms_world_writable = qr{
 	S_IWUGO		|
@@ -598,6 +638,37 @@ foreach my $entry (keys %mode_permission_string_types) {
 	$mode_perms_string_search .= '|' if ($mode_perms_string_search ne "");
 	$mode_perms_string_search .= $entry;
 }
+our $single_mode_perms_string_search = "(?:${mode_perms_string_search})";
+our $multi_mode_perms_string_search = qr{
+	${single_mode_perms_string_search}
+	(?:\s*\|\s*${single_mode_perms_string_search})*
+}x;
+
+sub perms_to_octal {
+	my ($string) = @_;
+
+	return trim($string) if ($string =~ /^\s*0[0-7]{3,3}\s*$/);
+
+	my $val = "";
+	my $oval = "";
+	my $to = 0;
+	my $curpos = 0;
+	my $lastpos = 0;
+	while ($string =~ /\b(($single_mode_perms_string_search)\b(?:\s*\|\s*)?\s*)/g) {
+		$curpos = pos($string);
+		my $match = $2;
+		my $omatch = $1;
+		last if ($lastpos > 0 && ($curpos - length($omatch) != $lastpos));
+		$lastpos = $curpos;
+		$to |= $mode_permission_string_types{$match};
+		$val .= '\s*\|\s*' if ($val ne "");
+		$val .= $match;
+		$oval .= $omatch;
+	}
+	$oval =~ s/^\s*\|\s*//;
+	$oval =~ s/\s*\|\s*$//;
+	return sprintf("%04o", $to);
+}
 
 our $allowed_asm_includes = qr{(?x:
 	irq|
@@ -757,7 +828,8 @@ our $FuncArg = qr{$Typecast{0,1}($LvalOrFunc|$Constant|$String)};
 our $declaration_macros = qr{(?x:
 	(?:$Storage\s+)?(?:[A-Z_][A-Z0-9]*_){0,2}(?:DEFINE|DECLARE)(?:_[A-Z0-9]+){1,6}\s*\(|
 	(?:$Storage\s+)?[HLP]?LIST_HEAD\s*\(|
-	(?:$Storage\s+)?${Type}\s+uninitialized_var\s*\(
+	(?:$Storage\s+)?${Type}\s+uninitialized_var\s*\(|
+	(?:SKCIPHER_REQUEST|SHASH_DESC|AHASH_REQUEST)_ON_STACK\s*\(
 )};
 
 sub deparenthesize {
@@ -810,6 +882,17 @@ sub is_maintained_obsolete {
 	return $status =~ /obsolete/i;
 }
 
+sub is_SPDX_License_valid {
+	my ($license) = @_;
+
+	return 1 if (!$tree || which("python") eq "" || !(-e "$root/scripts/spdxcheck.py") || !(-e "$root/.git"));
+
+	my $root_path = abs_path($root);
+	my $status = `cd "$root_path"; echo "$license" | python scripts/spdxcheck.py -`;
+	return 0 if ($status ne "");
+	return 1;
+}
+
 my $camelcase_seeded = 0;
 sub seed_camelcase_includes {
 	return if ($camelcase_seeded);
@@ -938,6 +1021,7 @@ if ($git) {
 }
 
 my $vname;
+$allow_c99_comments = !defined $ignore_type{"C99_COMMENT_TOLERANCE"};
 for my $filename (@ARGV) {
 	my $FILE;
 	if ($git) {
@@ -989,11 +1073,11 @@ if (!$quiet) {
 	hash_show_words(\%use_type, "Used");
 	hash_show_words(\%ignore_type, "Ignored");
 
-	if ($^V lt 5.10.0) {
+	if (!$perl_version_ok) {
 		print << "EOM"
 
 NOTE: perl $^V is not modern enough to detect all possible issues.
-      An upgrade to at least perl v5.10.0 is suggested.
+      An upgrade to at least perl $minimum_perl_version is suggested.
 EOM
 	}
 	if ($exit) {
@@ -1041,7 +1125,7 @@ sub parse_email {
 	} elsif ($formatted_email =~ /(\S+\@\S+)(.*)$/) {
 		$address = $1;
 		$comment = $2 if defined $2;
-		$formatted_email =~ s/$address.*$//;
+		$formatted_email =~ s/\Q$address\E.*$//;
 		$name = $formatted_email;
 		$name = trim($name);
 		$name =~ s/^\"|\"$//g;
@@ -1183,7 +1267,7 @@ sub sanitise_line {
 	for ($off = 1; $off < length($line); $off++) {
 		$c = substr($line, $off, 1);
 
-		# Comments we are wacking completly including the begin
+		# Comments we are whacking completely including the begin
 		# and end, all to $;.
 		if ($sanitise_quote eq '' && substr($line, $off, 2) eq '/*') {
 			$sanitise_quote = '*/';
@@ -1263,6 +1347,7 @@ sub sanitise_line {
 sub get_quoted_string {
 	my ($line, $rawline) = @_;
 
+	return "" if (!defined($line) || !defined($rawline));
 	return "" if ($line !~ m/($String)/g);
 	return substr($rawline, $-[0], $+[0] - $-[0]);
 }
@@ -1610,6 +1695,28 @@ sub raw_line {
 	return $line;
 }
 
+sub get_stat_real {
+	my ($linenr, $lc) = @_;
+
+	my $stat_real = raw_line($linenr, 0);
+	for (my $count = $linenr + 1; $count <= $lc; $count++) {
+		$stat_real = $stat_real . "\n" . raw_line($count, 0);
+	}
+
+	return $stat_real;
+}
+
+sub get_stat_here {
+	my ($linenr, $cnt, $here) = @_;
+
+	my $herectx = $here . "\n";
+	for (my $n = 0; $n < $cnt; $n++) {
+		$herectx .= raw_line($linenr, $n) . "\n";
+	}
+
+	return $herectx;
+}
+
 sub cat_vet {
 	my ($vet) = @_;
 	my ($res, $coded);
@@ -2175,10 +2282,14 @@ sub process {
 
 	our $clean = 1;
 	my $signoff = 0;
+	my $author = '';
+	my $authorsignoff = 0;
 	my $is_patch = 0;
+	my $is_binding_patch = -1;
 	my $in_header_lines = $file ? 0 : 1;
 	my $in_commit_log = 0;		#Scanning lines before patch
 	my $has_commit_log = 0;		#Encountered lines before patch
+	my $commit_log_lines = 0;	#Number of commit log lines
 	my $commit_log_possible_stack_dump = 0;
 	my $commit_log_long_line = 0;
 	my $commit_log_has_diff = 0;
@@ -2223,6 +2334,8 @@ sub process {
 
 	my $camelcase_file_seeded = 0;
 
+	my $checklicenseline = 1;
+
 	sanitise_line_reset();
 	my $line;
 	foreach my $rawline (@rawlines) {
@@ -2315,6 +2428,14 @@ sub process {
 
 		my $rawline = $rawlines[$linenr - 1];
 
+# check if it's a mode change, rename or start of a patch
+		if (!$in_commit_log &&
+		    ($line =~ /^ mode change [0-7]+ => [0-7]+ \S+\s*$/ ||
+		    ($line =~ /^rename (?:from|to) \S+\s*$/ ||
+		     $line =~ /^diff --git a\/[\w\/\.\_\-]+ b\/\S+\s*$/))) {
+			$is_patch = 1;
+		}
+
 #extract the line range in the file after the patch is applied
 		if (!$in_commit_log &&
 		    $line =~ /^\@\@ -\d+(?:,\d+)? \+(\d+)(,(\d+))? \@\@(.*)/) {
@@ -2414,6 +2535,20 @@ sub process {
 			} else {
 				$check = $check_orig;
 			}
+			$checklicenseline = 1;
+
+			if ($realfile !~ /^MAINTAINERS/) {
+				my $last_binding_patch = $is_binding_patch;
+
+				$is_binding_patch = () = $realfile =~ m@^(?:Documentation/devicetree/|include/dt-bindings/)@;
+
+				if (($last_binding_patch != -1) &&
+				    ($last_binding_patch ^ $is_binding_patch)) {
+					WARN("DT_SPLIT_BINDING_PATCH",
+					     "DT binding docs and includes should be a separate patch. See: Documentation/devicetree/bindings/submitting-patches.txt\n");
+				}
+			}
+
 			next;
 		}
 
@@ -2425,6 +2560,18 @@ sub process {
 
 		$cnt_lines++ if ($realcnt != 0);
 
+# Verify the existence of a commit log if appropriate
+# 2 is used because a $signature is counted in $commit_log_lines
+		if ($in_commit_log) {
+			if ($line !~ /^\s*$/) {
+				$commit_log_lines++;	#could be a $signature
+			}
+		} elsif ($has_commit_log && $commit_log_lines < 2) {
+			WARN("COMMIT_MESSAGE",
+			     "Missing commit description - Add an appropriate one\n");
+			$commit_log_lines = 2;	#warn only once
+		}
+
 # Check if the commit log has what seems like a diff which can confuse patch
 		if ($in_commit_log && !$commit_log_has_diff &&
 		    (($line =~ m@^\s+diff\b.*a/[\w/]+@ &&
@@ -2446,10 +2593,24 @@ sub process {
 			}
 		}
 
+# Check the patch for a From:
+		if (decode("MIME-Header", $line) =~ /^From:\s*(.*)/) {
+			$author = $1;
+			$author = encode("utf8", $author) if ($line =~ /=\?utf-8\?/i);
+			$author =~ s/"//g;
+		}
+
 # Check the patch for a signoff:
 		if ($line =~ /^\s*signed-off-by:/i) {
 			$signoff++;
 			$in_commit_log = 0;
+			if ($author ne '') {
+				my $l = $line;
+				$l =~ s/"//g;
+				if ($l =~ /^\s*signed-off-by:\s*\Q$author\E/i) {
+				    $authorsignoff = 1;
+				}
+			}
 		}
 
 # Check if MAINTAINERS is being updated.  If so, there's probably no need to
@@ -2535,12 +2696,6 @@ sub process {
 			     "A patch subject line should describe the change not the tool that found it\n" . $herecurr);
 		}
 
-# Check for old stable address
-		if ($line =~ /^\s*cc:\s*.*<?\bstable\@kernel\.org\b>?.*$/i) {
-			ERROR("STABLE_ADDRESS",
-			      "The 'stable' address should be 'stable\@vger.kernel.org'\n" . $herecurr);
-		}
-
 # Check for unwanted Gerrit info
 		if ($in_commit_log && $line =~ /^\s*change-id:/i) {
 			ERROR("GERRIT_CHANGE_ID",
@@ -2715,10 +2870,10 @@ sub process {
 				my $typo_fix = $spelling_fix{lc($typo)};
 				$typo_fix = ucfirst($typo_fix) if ($typo =~ /^[A-Z]/);
 				$typo_fix = uc($typo_fix) if ($typo =~ /^[A-Z]+$/);
-				my $msg_type = \&WARN;
-				$msg_type = \&CHK if ($file);
-				if (&{$msg_type}("TYPO_SPELLING",
-						 "'$typo' may be misspelled - perhaps '$typo_fix'?\n" . $herecurr) &&
+				my $msg_level = \&WARN;
+				$msg_level = \&CHK if ($file);
+				if (&{$msg_level}("TYPO_SPELLING",
+						  "'$typo' may be misspelled - perhaps '$typo_fix'?\n" . $herecurr) &&
 				    $fix) {
 					$fixed[$fixlinenr] =~ s/(^|[^A-Za-z@])($typo)($|[^A-Za-z@])/$1$typo_fix$3/;
 				}
@@ -2753,17 +2908,20 @@ sub process {
 		    $rawline =~ /\b59\s+Temple\s+Pl/i ||
 		    $rawline =~ /\b51\s+Franklin\s+St/i) {
 			my $herevet = "$here\n" . cat_vet($rawline) . "\n";
-			my $msg_type = \&ERROR;
-			$msg_type = \&CHK if ($file);
-			&{$msg_type}("FSF_MAILING_ADDRESS",
-				     "Do not include the paragraph about writing to the Free Software Foundation's mailing address from the sample GPL notice. The FSF has changed addresses in the past, and may do so again. Linux already includes a copy of the GPL.\n" . $herevet)
+			my $msg_level = \&ERROR;
+			$msg_level = \&CHK if ($file);
+			&{$msg_level}("FSF_MAILING_ADDRESS",
+				      "Do not include the paragraph about writing to the Free Software Foundation's mailing address from the sample GPL notice. The FSF has changed addresses in the past, and may do so again. Linux already includes a copy of the GPL.\n" . $herevet)
 		}
 
 # check for Kconfig help text having a real description
 # Only applies when adding the entry originally, after that we do not have
 # sufficient context to determine whether it is indeed long enough.
 		if ($realfile =~ /Kconfig/ &&
-		    $line =~ /^\+\s*config\s+/) {
+		    # 'choice' is usually the last thing on the line (though
+		    # Kconfig supports named choices), so use a word boundary
+		    # (\b) rather than a whitespace character (\s)
+		    $line =~ /^\+\s*(?:config|menuconfig|choice)\b/) {
 			my $length = 0;
 			my $cnt = $realcnt;
 			my $ln = $linenr + 1;
@@ -2778,9 +2936,13 @@ sub process {
 				next if ($f =~ /^-/);
 				last if (!$file && $f =~ /^\@\@/);
 
-				if ($lines[$ln - 1] =~ /^\+\s*(?:bool|tristate)\s*\"/) {
+				if ($lines[$ln - 1] =~ /^\+\s*(?:bool|tristate|prompt)\s*["']/) {
 					$is_start = 1;
-				} elsif ($lines[$ln - 1] =~ /^\+\s*(?:---)?help(?:---)?$/) {
+				} elsif ($lines[$ln - 1] =~ /^\+\s*(?:help|---help---)\s*$/) {
+					if ($lines[$ln - 1] =~ "---help---") {
+						WARN("CONFIG_DESCRIPTION",
+						     "prefer 'help' over '---help---' for new help texts\n" . $herecurr);
+					}
 					$length = -1;
 				}
 
@@ -2788,7 +2950,13 @@ sub process {
 				$f =~ s/#.*//;
 				$f =~ s/^\s+//;
 				next if ($f =~ /^$/);
-				if ($f =~ /^\s*config\s/) {
+
+				# This only checks context lines in the patch
+				# and so hopefully shouldn't trigger false
+				# positives, even though some of these are
+				# common words in help texts
+				if ($f =~ /^\s*(?:config|menuconfig|choice|endchoice|
+						  if|endif|menu|endmenu|source)\b/x) {
 					$is_end = 1;
 					last;
 				}
@@ -2864,18 +3032,65 @@ sub process {
 			}
 		}
 
+# check for using SPDX license tag at beginning of files
+		if ($realline == $checklicenseline) {
+			if ($rawline =~ /^[ \+]\s*\#\!\s*\//) {
+				$checklicenseline = 2;
+			} elsif ($rawline =~ /^\+/) {
+				my $comment = "";
+				if ($realfile =~ /\.(h|s|S)$/) {
+					$comment = '/*';
+				} elsif ($realfile =~ /\.(c|dts|dtsi)$/) {
+					$comment = '//';
+				} elsif (($checklicenseline == 2) || $realfile =~ /\.(sh|pl|py|awk|tc)$/) {
+					$comment = '#';
+				} elsif ($realfile =~ /\.rst$/) {
+					$comment = '..';
+				}
+
+# check SPDX comment style for .[chsS] files
+				if ($realfile =~ /\.[chsS]$/ &&
+				    $rawline =~ /SPDX-License-Identifier:/ &&
+				    $rawline !~ /^\+\s*\Q$comment\E\s*/) {
+					WARN("SPDX_LICENSE_TAG",
+					     "Improper SPDX comment style for '$realfile', please use '$comment' instead\n" . $herecurr);
+				}
+
+				if ($comment !~ /^$/ &&
+				    $rawline !~ /^\+\Q$comment\E SPDX-License-Identifier: /) {
+					 WARN("SPDX_LICENSE_TAG",
+					      "Missing or malformed SPDX-License-Identifier tag in line $checklicenseline\n" . $herecurr);
+				} elsif ($rawline =~ /(SPDX-License-Identifier: .*)/) {
+					 my $spdx_license = $1;
+					 if (!is_SPDX_License_valid($spdx_license)) {
+						  WARN("SPDX_LICENSE_TAG",
+						       "'$spdx_license' is not supported in LICENSES/...\n" . $herecurr);
+					 }
+				}
+			}
+		}
+
 # check we are in a valid source file if not then ignore this hunk
 		next if ($realfile !~ /\.(h|c|s|S|sh|dtsi|dts)$/);
 
+# check for using SPDX-License-Identifier on the wrong line number
+		if ($realline != $checklicenseline &&
+		    $rawline =~ /\bSPDX-License-Identifier:/ &&
+		    substr($line, @-, @+ - @-) eq "$;" x (@+ - @-)) {
+			WARN("SPDX_LICENSE_TAG",
+			     "Misplaced SPDX-License-Identifier tag - use line $checklicenseline instead\n" . $herecurr);
+		}
+
 # line length limit (with some exclusions)
 #
 # There are a few types of lines that may extend beyond $max_line_length:
 #	logging functions like pr_info that end in a string
 #	lines with a single string
 #	#defines that are a single string
+#	lines with an RFC3986 like URL
 #
 # There are 3 different line length message types:
-# LONG_LINE_COMMENT	a comment starts before but extends beyond $max_linelength
+# LONG_LINE_COMMENT	a comment starts before but extends beyond $max_line_length
 # LONG_LINE_STRING	a string starts before but extends beyond $max_line_length
 # LONG_LINE		all other lines longer than $max_line_length
 #
@@ -2899,8 +3114,13 @@ sub process {
 				 $line =~ /^\+\s*#\s*define\s+\w+\s+$String$/) {
 				$msg_type = "";
 
-			# EFI_GUID is another special case
-			} elsif ($line =~ /^\+.*\bEFI_GUID\s*\(/) {
+			# More special cases
+			} elsif ($line =~ /^\+.*\bEFI_GUID\s*\(/ ||
+				 $line =~ /^\+\s*(?:\w+)?\s*DEFINE_PER_CPU/) {
+				$msg_type = "";
+
+			# URL ($rawline is used in case the URL is in a comment)
+			} elsif ($rawline =~ /^\+.*\b[a-z][\w\.\+\-]*:\/\/\S+/i) {
 				$msg_type = "";
 
 			# Otherwise set the alternate message types
@@ -2929,20 +3149,6 @@ sub process {
 			     "adding a line without newline at end of file\n" . $herecurr);
 		}
 
-# Blackfin: use hi/lo macros
-		if ($realfile =~ m@arch/blackfin/.*\.S$@) {
-			if ($line =~ /\.[lL][[:space:]]*=.*&[[:space:]]*0x[fF][fF][fF][fF]/) {
-				my $herevet = "$here\n" . cat_vet($line) . "\n";
-				ERROR("LO_MACRO",
-				      "use the LO() macro, not (... & 0xFFFF)\n" . $herevet);
-			}
-			if ($line =~ /\.[hH][[:space:]]*=.*>>[[:space:]]*16/) {
-				my $herevet = "$here\n" . cat_vet($line) . "\n";
-				ERROR("HI_MACRO",
-				      "use the HI() macro, not (... >> 16)\n" . $herevet);
-			}
-		}
-
 # check we are in a valid source file C or perl if not then ignore this hunk
 		next if ($realfile !~ /\.(h|c|pl|dtsi|dts)$/);
 
@@ -2972,6 +3178,12 @@ sub process {
 			}
 		}
 
+# check for assignments on the start of a line
+		if ($sline =~ /^\+\s+($Assignment)[^=]/) {
+			CHK("ASSIGNMENT_CONTINUATIONS",
+			    "Assignment operator '$1' should be on the previous line\n" . $hereprev);
+		}
+
 # check for && or || at the start of a line
 		if ($rawline =~ /^\+\s*(&&|\|\|)/) {
 			CHK("LOGICAL_CONTINUATIONS",
@@ -2979,8 +3191,8 @@ sub process {
 		}
 
 # check indentation starts on a tab stop
-		if ($^V && $^V ge 5.10.0 &&
-		    $sline =~ /^\+\t+( +)(?:$c90_Keywords\b|\{\s*$|\}\s*(?:else\b|while\b|\s*$))/) {
+		if ($perl_version_ok &&
+		    $sline =~ /^\+\t+( +)(?:$c90_Keywords\b|\{\s*$|\}\s*(?:else\b|while\b|\s*$)|$Declare\s*$Ident\s*[;=])/) {
 			my $indent = length($1);
 			if ($indent % 8) {
 				if (WARN("TABSTOP",
@@ -2992,7 +3204,7 @@ sub process {
 		}
 
 # check multi-line statement indentation matches previous line
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    $prevline =~ /^\+([ \t]*)((?:$c90_Keywords(?:\s+if)\s*)|(?:$Declare\s*)?(?:$Ident|\(\s*\*\s*$Ident\s*\))\s*|(?:\*\s*)*$Lval\s*=\s*$Ident\s*)\(.*(\&\&|\|\||,)\s*$/) {
 			$prevline =~ /^\+(\t*)(.*)$/;
 			my $oldindent = $1;
@@ -3102,6 +3314,7 @@ sub process {
 		      $line =~ /^\+[a-z_]*init/ ||
 		      $line =~ /^\+\s*(?:static\s+)?[A-Z_]*ATTR/ ||
 		      $line =~ /^\+\s*DECLARE/ ||
+		      $line =~ /^\+\s*builtin_[\w_]*driver/ ||
 		      $line =~ /^\+\s*__setup/)) {
 			if (CHK("LINE_SPACING",
 				"Please use a blank line after function/struct/union/enum declarations\n" . $hereprev) &&
@@ -3148,7 +3361,7 @@ sub process {
 			# known declaration macros
 		      $sline =~ /^\+\s+$declaration_macros/ ||
 			# start of struct or union or enum
-		      $sline =~ /^\+\s+(?:union|struct|enum|typedef)\b/ ||
+		      $sline =~ /^\+\s+(?:static\s+)?(?:const\s+)?(?:union|struct|enum|typedef)\b/ ||
 			# start or end of block or continuation of declaration
 		      $sline =~ /^\+\s+(?:$|[\{\}\.\#\"\?\:\(\[])/ ||
 			# bitfield continuation
@@ -3181,6 +3394,12 @@ sub process {
 # check we are in a valid C source file if not then ignore this hunk
 		next if ($realfile !~ /\.(h|c)$/);
 
+# check for unusual line ending [ or (
+		if ($line =~ /^\+.*([\[\(])\s*$/) {
+			CHK("OPEN_ENDED_LINE",
+			    "Lines should not end with a '$1'\n" . $herecurr);
+		}
+
 # check if this appears to be the start function declaration, save the name
 		if ($sline =~ /^\+\{\s*$/ &&
 		    $prevline =~ /^\+(?:(?:(?:$Storage|$Inline)\s*)*\s*$Type\s*)?($Ident)\(/) {
@@ -3222,18 +3441,6 @@ sub process {
 			     "CVS style keyword markers, these will _not_ be updated\n". $herecurr);
 		}
 
-# Blackfin: don't use __builtin_bfin_[cs]sync
-		if ($line =~ /__builtin_bfin_csync/) {
-			my $herevet = "$here\n" . cat_vet($line) . "\n";
-			ERROR("CSYNC",
-			      "use the CSYNC() macro in asm/blackfin.h\n" . $herevet);
-		}
-		if ($line =~ /__builtin_bfin_ssync/) {
-			my $herevet = "$here\n" . cat_vet($line) . "\n";
-			ERROR("SSYNC",
-			      "use the SSYNC() macro in asm/blackfin.h\n" . $herevet);
-		}
-
 # check for old HOTPLUG __dev<foo> section markings
 		if ($line =~ /\b(__dev(init|exit)(data|const|))\b/) {
 			WARN("HOTPLUG_SECTION",
@@ -3686,19 +3893,48 @@ sub process {
 			     "type '$tmp' should be specified in [[un]signed] [short|int|long|long long] order\n" . $herecurr);
 		}
 
+# check for unnecessary <signed> int declarations of short/long/long long
+		while ($sline =~ m{\b($TypeMisordered(\s*\*)*|$C90_int_types)\b}g) {
+			my $type = trim($1);
+			next if ($type !~ /\bint\b/);
+			next if ($type !~ /\b(?:short|long\s+long|long)\b/);
+			my $new_type = $type;
+			$new_type =~ s/\b\s*int\s*\b/ /;
+			$new_type =~ s/\b\s*(?:un)?signed\b\s*/ /;
+			$new_type =~ s/^const\s+//;
+			$new_type = "unsigned $new_type" if ($type =~ /\bunsigned\b/);
+			$new_type = "const $new_type" if ($type =~ /^const\b/);
+			$new_type =~ s/\s+/ /g;
+			$new_type = trim($new_type);
+			if (WARN("UNNECESSARY_INT",
+				 "Prefer '$new_type' over '$type' as the int is unnecessary\n" . $herecurr) &&
+			    $fix) {
+				$fixed[$fixlinenr] =~ s/\b\Q$type\E\b/$new_type/;
+			}
+		}
+
 # check for static const char * arrays.
 		if ($line =~ /\bstatic\s+const\s+char\s*\*\s*(\w+)\s*\[\s*\]\s*=\s*/) {
 			WARN("STATIC_CONST_CHAR_ARRAY",
 			     "static const char * array should probably be static const char * const\n" .
 				$herecurr);
-               }
+		}
+
+# check for initialized const char arrays that should be static const
+		if ($line =~ /^\+\s*const\s+(char|unsigned\s+char|_*u8|(?:[us]_)?int8_t)\s+\w+\s*\[\s*(?:\w+\s*)?\]\s*=\s*"/) {
+			if (WARN("STATIC_CONST_CHAR_ARRAY",
+				 "const array should probably be static const\n" . $herecurr) &&
+			    $fix) {
+				$fixed[$fixlinenr] =~ s/(^.\s*)const\b/${1}static const/;
+			}
+		}
 
 # check for static char foo[] = "bar" declarations.
 		if ($line =~ /\bstatic\s+char\s+(\w+)\s*\[\s*\]\s*=\s*"/) {
 			WARN("STATIC_CONST_CHAR_ARRAY",
 			     "static char array declaration should probably be static const char\n" .
 				$herecurr);
-               }
+		}
 
 # check for const <foo> const where <foo> is not a pointer or array type
 		if ($sline =~ /\bconst\s+($BasicType)\s+const\b/) {
@@ -3810,10 +4046,10 @@ sub process {
 
 # avoid BUG() or BUG_ON()
 		if ($line =~ /\b(?:BUG|BUG_ON)\b/) {
-			my $msg_type = \&WARN;
-			$msg_type = \&CHK if ($file);
-			&{$msg_type}("AVOID_BUG",
-				     "Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()\n" . $herecurr);
+			my $msg_level = \&WARN;
+			$msg_level = \&CHK if ($file);
+			&{$msg_level}("AVOID_BUG",
+				      "Avoid crashing the kernel - try using WARN_ON & recovery code rather than BUG() or BUG_ON()\n" . $herecurr);
 		}
 
 # avoid LINUX_VERSION_CODE
@@ -3828,28 +4064,10 @@ sub process {
 			     "Prefer printk_ratelimited or pr_<level>_ratelimited to printk_ratelimit\n" . $herecurr);
 		}
 
-# printk should use KERN_* levels.  Note that follow on printk's on the
-# same line do not need a level, so we use the current block context
-# to try and find and validate the current printk.  In summary the current
-# printk includes all preceding printk's which have no newline on the end.
-# we assume the first bad printk is the one to report.
-		if ($line =~ /\bprintk\((?!KERN_)\s*"/) {
-			my $ok = 0;
-			for (my $ln = $linenr - 1; $ln >= $first_line; $ln--) {
-				#print "CHECK<$lines[$ln - 1]\n";
-				# we have a preceding printk if it ends
-				# with "\n" ignore it, else it is to blame
-				if ($lines[$ln - 1] =~ m{\bprintk\(}) {
-					if ($rawlines[$ln - 1] !~ m{\\n"}) {
-						$ok = 1;
-					}
-					last;
-				}
-			}
-			if ($ok == 0) {
-				WARN("PRINTK_WITHOUT_KERN_LEVEL",
-				     "printk() should include KERN_ facility level\n" . $herecurr);
-			}
+# printk should use KERN_* levels
+		if ($line =~ /\bprintk\s*\(\s*(?!KERN_[A-Z]+\b)/) {
+			WARN("PRINTK_WITHOUT_KERN_LEVEL",
+			     "printk() should include KERN_<LEVEL> facility level\n" . $herecurr);
 		}
 
 		if ($line =~ /\bprintk\s*\(\s*KERN_([A-Z]+)/) {
@@ -3890,10 +4108,12 @@ sub process {
 
 # function brace can't be on same line, except for #defines of do while,
 # or if closed on same line
-		if (($line=~/$Type\s*$Ident\(.*\).*\s*{/) and
-		    !($line=~/\#\s*define.*do\s\{/) and !($line=~/}/)) {
+		if ($perl_version_ok &&
+		    $sline =~ /$Type\s*$Ident\s*$balanced_parens\s*\{/ &&
+		    $sline !~ /\#\s*define\b.*do\s*\{/ &&
+		    $sline !~ /}/) {
 			if (ERROR("OPEN_BRACE",
-				  "open brace '{' following function declarations go on the next line\n" . $herecurr) &&
+				  "open brace '{' following function definitions go on the next line\n" . $herecurr) &&
 			    $fix) {
 				fix_delete_line($fixlinenr, $rawline);
 				my $fixed_line = $rawline;
@@ -4014,7 +4234,7 @@ sub process {
 			my ($where, $prefix) = ($-[1], $1);
 			if ($prefix !~ /$Type\s+$/ &&
 			    ($where != 0 || $prefix !~ /^.\s+$/) &&
-			    $prefix !~ /[{,]\s+$/) {
+			    $prefix !~ /[{,:]\s+$/) {
 				if (ERROR("BRACKET_SPACE",
 					  "space prohibited before open square bracket '['\n" . $herecurr) &&
 				    $fix) {
@@ -4339,11 +4559,11 @@ sub process {
 
 					# messages are ERROR, but ?: are CHK
 					if ($ok == 0) {
-						my $msg_type = \&ERROR;
-						$msg_type = \&CHK if (($op eq '?:' || $op eq '?' || $op eq ':') && $ctx =~ /VxV/);
+						my $msg_level = \&ERROR;
+						$msg_level = \&CHK if (($op eq '?:' || $op eq '?' || $op eq ':') && $ctx =~ /VxV/);
 
-						if (&{$msg_type}("SPACING",
-								 "spaces required around that '$op' $at\n" . $hereptr)) {
+						if (&{$msg_level}("SPACING",
+								  "spaces required around that '$op' $at\n" . $hereptr)) {
 							$good = rtrim($fix_elements[$n]) . " " . trim($fix_elements[$n + 1]) . " ";
 							if (defined $fix_elements[$n + 2]) {
 								$fix_elements[$n + 2] =~ s/^\s+//;
@@ -4404,11 +4624,11 @@ sub process {
 
 #need space before brace following if, while, etc
 		if (($line =~ /\(.*\)\{/ && $line !~ /\($Type\)\{/) ||
-		    $line =~ /do\{/) {
+		    $line =~ /\b(?:else|do)\{/) {
 			if (ERROR("SPACING",
 				  "space required before the open brace '{'\n" . $herecurr) &&
 			    $fix) {
-				$fixed[$fixlinenr] =~ s/^(\+.*(?:do|\)))\{/$1 {/;
+				$fixed[$fixlinenr] =~ s/^(\+.*(?:do|else|\)))\{/$1 {/;
 			}
 		}
 
@@ -4496,6 +4716,32 @@ sub process {
 			}
 		}
 
+# check for unnecessary parentheses around comparisons in if uses
+# when !drivers/staging or command-line uses --strict
+		if (($realfile !~ m@^(?:drivers/staging/)@ || $check_orig) &&
+		    $perl_version_ok && defined($stat) &&
+		    $stat =~ /(^.\s*if\s*($balanced_parens))/) {
+			my $if_stat = $1;
+			my $test = substr($2, 1, -1);
+			my $herectx;
+			while ($test =~ /(?:^|[^\w\&\!\~])+\s*\(\s*([\&\!\~]?\s*$Lval\s*(?:$Compare\s*$FuncArg)?)\s*\)/g) {
+				my $match = $1;
+				# avoid parentheses around potential macro args
+				next if ($match =~ /^\s*\w+\s*$/);
+				if (!defined($herectx)) {
+					$herectx = $here . "\n";
+					my $cnt = statement_rawlines($if_stat);
+					for (my $n = 0; $n < $cnt; $n++) {
+						my $rl = raw_line($linenr, $n);
+						$herectx .=  $rl . "\n";
+						last if $rl =~ /^[ \+].*\{/;
+					}
+				}
+				CHK("UNNECESSARY_PARENTHESES",
+				    "Unnecessary parentheses around '$match'\n" . $herectx);
+			}
+		}
+
 #goto labels aren't indented, allow a single space however
 		if ($line=~/^.\s+[A-Za-z\d_]+:(?![0-9]+)/ and
 		   !($line=~/^. [A-Za-z\d_]+:/) and !($line=~/^.\s+default:/)) {
@@ -4510,7 +4756,7 @@ sub process {
 # return is not a function
 		if (defined($stat) && $stat =~ /^.\s*return(\s*)\(/s) {
 			my $spacing = $1;
-			if ($^V && $^V ge 5.10.0 &&
+			if ($perl_version_ok &&
 			    $stat =~ /^.\s*return\s*($balanced_parens)\s*;\s*$/) {
 				my $value = $1;
 				$value = deparenthesize($value);
@@ -4537,7 +4783,7 @@ sub process {
                }
 
 # if statements using unnecessary parentheses - ie: if ((foo == bar))
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    $line =~ /\bif\s*((?:\(\s*){2,})/) {
 			my $openparens = $1;
 			my $count = $openparens =~ tr@\(@\(@;
@@ -4554,7 +4800,7 @@ sub process {
 #	avoid cases like "foo + BAR < baz"
 #	only fix matches surrounded by parentheses to avoid incorrect
 #	conversions like "FOO < baz() + 5" being "misfixed" to "baz() > FOO + 5"
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    $line =~ /^\+(.*)\b($Constant|[A-Z_][A-Z0-9_]*)\s*($Compare)\s*($LvalOrFunc)/) {
 			my $lead = $1;
 			my $const = $2;
@@ -4746,17 +4992,6 @@ sub process {
 		while ($line =~ m{($Constant|$Lval)}g) {
 			my $var = $1;
 
-#gcc binary extension
-			if ($var =~ /^$Binary$/) {
-				if (WARN("GCC_BINARY_CONSTANT",
-					 "Avoid gcc v4.3+ binary constant extension: <$var>\n" . $herecurr) &&
-				    $fix) {
-					my $hexval = sprintf("0x%x", oct($var));
-					$fixed[$fixlinenr] =~
-					    s/\b$var\b/$hexval/;
-				}
-			}
-
 #CamelCase
 			if ($var !~ /^$Constant$/ &&
 			    $var =~ /[A-Z][a-z]|[a-z][A-Z]/ &&
@@ -4844,6 +5079,7 @@ sub process {
 			if (defined $define_args && $define_args ne "") {
 				$define_args = substr($define_args, 1, length($define_args) - 2);
 				$define_args =~ s/\s*//g;
+				$define_args =~ s/\\\+?//g;
 				@def_args = split(",", $define_args);
 			}
 
@@ -4884,12 +5120,8 @@ sub process {
 			#print "REST<$rest> dstat<$dstat> ctx<$ctx>\n";
 
 			$ctx =~ s/\n*$//;
-			my $herectx = $here . "\n";
 			my $stmt_cnt = statement_rawlines($ctx);
-
-			for (my $n = 0; $n < $stmt_cnt; $n++) {
-				$herectx .= raw_line($linenr, $n) . "\n";
-			}
+			my $herectx = get_stat_here($linenr, $stmt_cnt, $here);
 
 			if ($dstat ne '' &&
 			    $dstat !~ /^(?:$Ident|-?$Constant),$/ &&			# 10, // foo(),
@@ -4944,7 +5176,7 @@ sub process {
 				$tmp_stmt =~ s/\b(typeof|__typeof__|__builtin\w+|typecheck\s*\(\s*$Type\s*,|\#+)\s*\(*\s*$arg\s*\)*\b//g;
 				$tmp_stmt =~ s/\#+\s*$arg\b//g;
 				$tmp_stmt =~ s/\b$arg\s*\#\#//g;
-				my $use_cnt = $tmp_stmt =~ s/\b$arg\b//g;
+				my $use_cnt = () = $tmp_stmt =~ /\b$arg\b/g;
 				if ($use_cnt > 1) {
 					CHK("MACRO_ARG_REUSE",
 					    "Macro argument reuse '$arg' - possible side-effects?\n" . "$herectx");
@@ -4961,12 +5193,9 @@ sub process {
 # check for macros with flow control, but without ## concatenation
 # ## concatenation is commonly a macro that defines a function so ignore those
 			if ($has_flow_statement && !$has_arg_concat) {
-				my $herectx = $here . "\n";
 				my $cnt = statement_rawlines($ctx);
+				my $herectx = get_stat_here($linenr, $cnt, $here);
 
-				for (my $n = 0; $n < $cnt; $n++) {
-					$herectx .= raw_line($linenr, $n) . "\n";
-				}
 				WARN("MACRO_WITH_FLOW_CONTROL",
 				     "Macros with flow control statements should be avoided\n" . "$herectx");
 			}
@@ -4986,7 +5215,7 @@ sub process {
 # do {} while (0) macro tests:
 # single-statement macros do not need to be enclosed in do while (0) loop,
 # macro should not end with a semicolon
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    $realfile !~ m@/vmlinux.lds.h$@ &&
 		    $line =~ /^.\s*\#\s*define\s+$Ident(\()?/) {
 			my $ln = $linenr;
@@ -5006,11 +5235,7 @@ sub process {
 
 				$ctx =~ s/\n*$//;
 				my $cnt = statement_rawlines($ctx);
-				my $herectx = $here . "\n";
-
-				for (my $n = 0; $n < $cnt; $n++) {
-					$herectx .= raw_line($linenr, $n) . "\n";
-				}
+				my $herectx = get_stat_here($linenr, $cnt, $here);
 
 				if (($stmts =~ tr/;/;/) == 1 &&
 				    $stmts !~ /^\s*(if|while|for|switch)\b/) {
@@ -5024,27 +5249,13 @@ sub process {
 			} elsif ($dstat =~ /^\+\s*#\s*define\s+$Ident.*;\s*$/) {
 				$ctx =~ s/\n*$//;
 				my $cnt = statement_rawlines($ctx);
-				my $herectx = $here . "\n";
-
-				for (my $n = 0; $n < $cnt; $n++) {
-					$herectx .= raw_line($linenr, $n) . "\n";
-				}
+				my $herectx = get_stat_here($linenr, $cnt, $here);
 
 				WARN("TRAILING_SEMICOLON",
 				     "macros should not use a trailing semicolon\n" . "$herectx");
 			}
 		}
 
-# make sure symbols are always wrapped with VMLINUX_SYMBOL() ...
-# all assignments may have only one of the following with an assignment:
-#	.
-#	ALIGN(...)
-#	VMLINUX_SYMBOL(...)
-		if ($realfile eq 'vmlinux.lds.h' && $line =~ /(?:(?:^|\s)$Ident\s*=|=\s*$Ident(?:\s|$))/) {
-			WARN("MISSING_VMLINUX_SYMBOL",
-			     "vmlinux.lds.h needs VMLINUX_SYMBOL() around C-visible symbols\n" . $herecurr);
-		}
-
 # check for redundant bracing round if etc
 		if ($line =~ /(^.*)\bif\b/ && $1 !~ /else\s*$/) {
 			my ($level, $endln, @chunks) =
@@ -5151,12 +5362,8 @@ sub process {
 				}
 			}
 			if ($level == 0 && $block =~ /^\s*\{/ && !$allowed) {
-				my $herectx = $here . "\n";
 				my $cnt = statement_rawlines($block);
-
-				for (my $n = 0; $n < $cnt; $n++) {
-					$herectx .= raw_line($linenr, $n) . "\n";
-				}
+				my $herectx = get_stat_here($linenr, $cnt, $here);
 
 				WARN("BRACES",
 				     "braces {} are not necessary for single statement blocks\n" . $herectx);
@@ -5254,16 +5461,28 @@ sub process {
 		}
 
 # concatenated string without spaces between elements
-		if ($line =~ /$String[A-Z_]/ ||
-		    ($line =~ /([A-Za-z0-9_]+)$String/ && $1 !~ /^L$/)) {
-			CHK("CONCATENATED_STRING",
-			    "Concatenated strings should use spaces between elements\n" . $herecurr);
+		if ($line =~ /$String[A-Za-z0-9_]/ || $line =~ /[A-Za-z0-9_]$String/) {
+			if (CHK("CONCATENATED_STRING",
+				"Concatenated strings should use spaces between elements\n" . $herecurr) &&
+			    $fix) {
+				while ($line =~ /($String)/g) {
+					my $extracted_string = substr($rawline, $-[0], $+[0] - $-[0]);
+					$fixed[$fixlinenr] =~ s/\Q$extracted_string\E([A-Za-z0-9_])/$extracted_string $1/;
+					$fixed[$fixlinenr] =~ s/([A-Za-z0-9_])\Q$extracted_string\E/$1 $extracted_string/;
+				}
+			}
 		}
 
 # uncoalesced string fragments
-		if ($line =~ /$String\s*L?"/) {
-			WARN("STRING_FRAGMENTS",
-			     "Consecutive strings are generally better as a single string\n" . $herecurr);
+		if ($line =~ /$String\s*"/) {
+			if (WARN("STRING_FRAGMENTS",
+				 "Consecutive strings are generally better as a single string\n" . $herecurr) &&
+			    $fix) {
+				while ($line =~ /($String)(?=\s*")/g) {
+					my $extracted_string = substr($rawline, $-[0], $+[0] - $-[0]);
+					$fixed[$fixlinenr] =~ s/\Q$extracted_string\E\s*"/substr($extracted_string, 0, -1)/e;
+				}
+			}
 		}
 
 # check for non-standard and hex prefixed decimal printf formats
@@ -5292,16 +5511,21 @@ sub process {
 		}
 
 # check for line continuations in quoted strings with odd counts of "
-		if ($rawline =~ /\\$/ && $rawline =~ tr/"/"/ % 2) {
+		if ($rawline =~ /\\$/ && $sline =~ tr/"/"/ % 2) {
 			WARN("LINE_CONTINUATIONS",
 			     "Avoid line continuations in quoted strings\n" . $herecurr);
 		}
 
 # warn about #if 0
 		if ($line =~ /^.\s*\#\s*if\s+0\b/) {
-			CHK("REDUNDANT_CODE",
-			    "if this code is redundant consider removing it\n" .
-				$herecurr);
+			WARN("IF_0",
+			     "Consider removing the code enclosed by this #if 0 and its #endif\n" . $herecurr);
+		}
+
+# warn about #if 1
+		if ($line =~ /^.\s*\#\s*if\s+1\b/) {
+			WARN("IF_1",
+			     "Consider removing the #if 1 and its #endif\n" . $herecurr);
 		}
 
 # check for needless "if (<foo>) fn(<foo>)" uses
@@ -5348,7 +5572,8 @@ sub process {
 			my ($s, $c) = ctx_statement_block($linenr - 3, $realcnt, 0);
 #			print("line: <$line>\nprevline: <$prevline>\ns: <$s>\nc: <$c>\n\n\n");
 
-			if ($s =~ /(?:^|\n)[ \+]\s*(?:$Type\s*)?\Q$testval\E\s*=\s*(?:\([^\)]*\)\s*)?\s*(?:devm_)?(?:[kv][czm]alloc(?:_node|_array)?\b|kstrdup|kmemdup|(?:dev_)?alloc_skb)/) {
+			if ($s =~ /(?:^|\n)[ \+]\s*(?:$Type\s*)?\Q$testval\E\s*=\s*(?:\([^\)]*\)\s*)?\s*$allocFunctions\s*\(/ &&
+			    $s !~ /\b__GFP_NOWARN\b/ ) {
 				WARN("OOM_MESSAGE",
 				     "Possible unnecessary 'out of memory' message\n" . $hereprev);
 			}
@@ -5372,7 +5597,7 @@ sub process {
 		}
 
 # check for mask then right shift without a parentheses
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    $line =~ /$LvalOrFunc\s*\&\s*($LvalOrFunc)\s*>>/ &&
 		    $4 !~ /^\&/) { # $LvalOrFunc may be &foo, ignore if so
 			WARN("MASK_THEN_SHIFT",
@@ -5380,7 +5605,7 @@ sub process {
 		}
 
 # check for pointer comparisons to NULL
-		if ($^V && $^V ge 5.10.0) {
+		if ($perl_version_ok) {
 			while ($line =~ /\b$LvalOrFunc\s*(==|\!=)\s*NULL\b/g) {
 				my $val = $1;
 				my $equal = "!";
@@ -5571,6 +5796,12 @@ sub process {
 			}
 		}
 
+# check for smp_read_barrier_depends and read_barrier_depends
+		if (!$file && $line =~ /\b(smp_|)read_barrier_depends\s*\(/) {
+			WARN("READ_BARRIER_DEPENDS",
+			     "$1read_barrier_depends should only be used in READ_ONCE or DEC Alpha code\n" . $herecurr);
+		}
+
 # check of hardware specific defines
 		if ($line =~ m@^.\s*\#\s*if.*\b(__i386__|__powerpc64__|__sun__|__s390x__)\b@ && $realfile !~ m@include/asm-@) {
 			CHK("ARCH_DEFINES",
@@ -5617,13 +5848,6 @@ sub process {
 			     "__packed is preferred over __attribute__((packed))\n" . $herecurr);
 		}
 
-# Check for new packed members, warn to use care
-		if ($realfile !~ m@\binclude/uapi/@ &&
-		    $line =~ /\b(__attribute__\s*\(\s*\(.*\bpacked|__packed)\b/) {
-			WARN("NEW_PACKED",
-			     "Adding new packed members is to be done with care\n" . $herecurr);
-		}
-
 # Check for __attribute__ aligned, prefer __aligned
 		if ($realfile !~ m@\binclude/uapi/@ &&
 		    $line =~ /\b__attribute__\s*\(\s*\(.*aligned/) {
@@ -5653,7 +5877,7 @@ sub process {
 		}
 
 # Check for __attribute__ weak, or __weak declarations (may have link issues)
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    $line =~ /(?:$Declare|$DeclareMisordered)\s*$Ident\s*$balanced_parens\s*(?:$Attribute)?\s*;/ &&
 		    ($line =~ /\b__attribute__\s*\(\s*\(.*\bweak\b/ ||
 		     $line =~ /\b__weak\b/)) {
@@ -5734,34 +5958,55 @@ sub process {
 			}
 		}
 
-		# check for vsprintf extension %p<foo> misuses
-		if ($^V && $^V ge 5.10.0 &&
+# check for vsprintf extension %p<foo> misuses
+		if ($perl_version_ok &&
 		    defined $stat &&
 		    $stat =~ /^\+(?![^\{]*\{\s*).*\b(\w+)\s*\(.*$String\s*,/s &&
 		    $1 !~ /^_*volatile_*$/) {
-			my $bad_extension = "";
+			my $stat_real;
+
 			my $lc = $stat =~ tr@\n@@;
 			$lc = $lc + $linenr;
 		        for (my $count = $linenr; $count <= $lc; $count++) {
+				my $specifier;
+				my $extension;
+				my $bad_specifier = "";
 				my $fmt = get_quoted_string($lines[$count - 1], raw_line($count, 0));
 				$fmt =~ s/%%//g;
-				if ($fmt =~ /(\%[\*\d\.]*p(?![\WFfSsBKRraEhMmIiUDdgVCbGNO]).)/) {
-					$bad_extension = $1;
-					last;
+
+				while ($fmt =~ /(\%[\*\d\.]*p(\w))/g) {
+					$specifier = $1;
+					$extension = $2;
+					if ($extension !~ /[SsBKRraEhMmIiUDdgVCbGNOx]/) {
+						$bad_specifier = $specifier;
+						last;
+					}
+					if ($extension eq "x" && !defined($stat_real)) {
+						if (!defined($stat_real)) {
+							$stat_real = get_stat_real($linenr, $lc);
+						}
+						WARN("VSPRINTF_SPECIFIER_PX",
+						     "Using vsprintf specifier '\%px' potentially exposes the kernel memory layout, if you don't really need the address please consider using '\%p'.\n" . "$here\n$stat_real\n");
+					}
 				}
-			}
-			if ($bad_extension ne "") {
-				my $stat_real = raw_line($linenr, 0);
-				for (my $count = $linenr + 1; $count <= $lc; $count++) {
-					$stat_real = $stat_real . "\n" . raw_line($count, 0);
+				if ($bad_specifier ne "") {
+					my $stat_real = get_stat_real($linenr, $lc);
+					my $ext_type = "Invalid";
+					my $use = "";
+					if ($bad_specifier =~ /p[Ff]/) {
+						$ext_type = "Deprecated";
+						$use = " - use %pS instead";
+						$use =~ s/pS/ps/ if ($bad_specifier =~ /pf/);
+					}
+
+					WARN("VSPRINTF_POINTER_EXTENSION",
+					     "$ext_type vsprintf pointer extension '$bad_specifier'$use\n" . "$here\n$stat_real\n");
 				}
-				WARN("VSPRINTF_POINTER_EXTENSION",
-				     "Invalid vsprintf pointer extension '$bad_extension'\n" . "$here\n$stat_real\n");
 			}
 		}
 
 # Check for misused memsets
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    defined $stat &&
 		    $stat =~ /^\+(?:.*?)\bmemset\s*\(\s*$FuncArg\s*,\s*$FuncArg\s*\,\s*$FuncArg\s*\)/) {
 
@@ -5779,7 +6024,7 @@ sub process {
 		}
 
 # Check for memcpy(foo, bar, ETH_ALEN) that could be ether_addr_copy(foo, bar)
-#		if ($^V && $^V ge 5.10.0 &&
+#		if ($perl_version_ok &&
 #		    defined $stat &&
 #		    $stat =~ /^\+(?:.*?)\bmemcpy\s*\(\s*$FuncArg\s*,\s*$FuncArg\s*\,\s*ETH_ALEN\s*\)/) {
 #			if (WARN("PREFER_ETHER_ADDR_COPY",
@@ -5790,7 +6035,7 @@ sub process {
 #		}
 
 # Check for memcmp(foo, bar, ETH_ALEN) that could be ether_addr_equal*(foo, bar)
-#		if ($^V && $^V ge 5.10.0 &&
+#		if ($perl_version_ok &&
 #		    defined $stat &&
 #		    $stat =~ /^\+(?:.*?)\bmemcmp\s*\(\s*$FuncArg\s*,\s*$FuncArg\s*\,\s*ETH_ALEN\s*\)/) {
 #			WARN("PREFER_ETHER_ADDR_EQUAL",
@@ -5799,7 +6044,7 @@ sub process {
 
 # check for memset(foo, 0x0, ETH_ALEN) that could be eth_zero_addr
 # check for memset(foo, 0xFF, ETH_ALEN) that could be eth_broadcast_addr
-#		if ($^V && $^V ge 5.10.0 &&
+#		if ($perl_version_ok &&
 #		    defined $stat &&
 #		    $stat =~ /^\+(?:.*?)\bmemset\s*\(\s*$FuncArg\s*,\s*$FuncArg\s*\,\s*ETH_ALEN\s*\)/) {
 #
@@ -5821,7 +6066,7 @@ sub process {
 #		}
 
 # typecasts on min/max could be min_t/max_t
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    defined $stat &&
 		    $stat =~ /^\+(?:.*?)\b(min|max)\s*\(\s*$FuncArg\s*,\s*$FuncArg\s*\)/) {
 			if (defined $2 || defined $7) {
@@ -5845,7 +6090,7 @@ sub process {
 		}
 
 # check usleep_range arguments
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    defined $stat &&
 		    $stat =~ /^\+(?:.*?)\busleep_range\s*\(\s*($FuncArg)\s*,\s*($FuncArg)\s*\)/) {
 			my $min = $1;
@@ -5861,7 +6106,7 @@ sub process {
 		}
 
 # check for naked sscanf
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    defined $stat &&
 		    $line =~ /\bsscanf\b/ &&
 		    ($stat !~ /$Ident\s*=\s*sscanf\s*$balanced_parens/ &&
@@ -5869,24 +6114,18 @@ sub process {
 		     $stat !~ /(?:$Compare)\s*\bsscanf\s*$balanced_parens/)) {
 			my $lc = $stat =~ tr@\n@@;
 			$lc = $lc + $linenr;
-			my $stat_real = raw_line($linenr, 0);
-		        for (my $count = $linenr + 1; $count <= $lc; $count++) {
-				$stat_real = $stat_real . "\n" . raw_line($count, 0);
-			}
+			my $stat_real = get_stat_real($linenr, $lc);
 			WARN("NAKED_SSCANF",
 			     "unchecked sscanf return value\n" . "$here\n$stat_real\n");
 		}
 
 # check for simple sscanf that should be kstrto<foo>
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    defined $stat &&
 		    $line =~ /\bsscanf\b/) {
 			my $lc = $stat =~ tr@\n@@;
 			$lc = $lc + $linenr;
-			my $stat_real = raw_line($linenr, 0);
-		        for (my $count = $linenr + 1; $count <= $lc; $count++) {
-				$stat_real = $stat_real . "\n" . raw_line($count, 0);
-			}
+			my $stat_real = get_stat_real($linenr, $lc);
 			if ($stat_real =~ /\bsscanf\b\s*\(\s*$FuncArg\s*,\s*("[^"]+")/) {
 				my $format = $6;
 				my $count = $format =~ tr@%@%@;
@@ -5940,7 +6179,7 @@ sub process {
 
 # check for function declarations that have arguments without identifier names
 		if (defined $stat &&
-		    $stat =~ /^.\s*(?:extern\s+)?$Type\s*$Ident\s*\(\s*([^{]+)\s*\)\s*;/s &&
+		    $stat =~ /^.\s*(?:extern\s+)?$Type\s*(?:$Ident|\(\s*\*\s*$Ident\s*\))\s*\(\s*([^{]+)\s*\)\s*;/s &&
 		    $1 ne "void") {
 			my $args = trim($1);
 			while ($args =~ m/\s*($Type\s*(?:$Ident|\(\s*\*\s*$Ident?\s*\)\s*$balanced_parens)?)/g) {
@@ -5953,7 +6192,7 @@ sub process {
 		}
 
 # check for function definitions
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    defined $stat &&
 		    $stat =~ /^.\s*(?:$Storage\s+)?$Type\s*($Ident)\s*$balanced_parens\s*{/s) {
 			$context_function = $1;
@@ -5985,22 +6224,22 @@ sub process {
 			}
 		}
 
-# check for pointless casting of kmalloc return
-		if ($line =~ /\*\s*\)\s*[kv][czm]alloc(_node){0,1}\b/) {
+# check for pointless casting of alloc functions
+		if ($line =~ /\*\s*\)\s*$allocFunctions\b/) {
 			WARN("UNNECESSARY_CASTS",
 			     "unnecessary cast may hide bugs, see http://c-faq.com/malloc/mallocnocast.html\n" . $herecurr);
 		}
 
 # alloc style
 # p = alloc(sizeof(struct foo), ...) should be p = alloc(sizeof(*p), ...)
-		if ($^V && $^V ge 5.10.0 &&
-		    $line =~ /\b($Lval)\s*\=\s*(?:$balanced_parens)?\s*([kv][mz]alloc(?:_node)?)\s*\(\s*(sizeof\s*\(\s*struct\s+$Lval\s*\))/) {
+		if ($perl_version_ok &&
+		    $line =~ /\b($Lval)\s*\=\s*(?:$balanced_parens)?\s*((?:kv|k|v)[mz]alloc(?:_node)?)\s*\(\s*(sizeof\s*\(\s*struct\s+$Lval\s*\))/) {
 			CHK("ALLOC_SIZEOF_STRUCT",
 			    "Prefer $3(sizeof(*$1)...) over $3($4...)\n" . $herecurr);
 		}
 
 # check for k[mz]alloc with multiplies that could be kmalloc_array/kcalloc
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    defined $stat &&
 		    $stat =~ /^\+\s*($Lval)\s*\=\s*(?:$balanced_parens)?\s*(k[mz]alloc)\s*\(\s*($FuncArg)\s*\*\s*($FuncArg)\s*,/) {
 			my $oldfunc = $3;
@@ -6016,12 +6255,9 @@ sub process {
 			}
 			if ($r1 !~ /^sizeof\b/ && $r2 =~ /^sizeof\s*\S/ &&
 			    !($r1 =~ /^$Constant$/ || $r1 =~ /^[A-Z_][A-Z0-9_]*$/)) {
-				my $ctx = '';
-				my $herectx = $here . "\n";
 				my $cnt = statement_rawlines($stat);
-				for (my $n = 0; $n < $cnt; $n++) {
-					$herectx .= raw_line($linenr, $n) . "\n";
-				}
+				my $herectx = get_stat_here($linenr, $cnt, $here);
+
 				if (WARN("ALLOC_WITH_MULTIPLY",
 					 "Prefer $newfunc over $oldfunc with multiply\n" . $herectx) &&
 				    $cnt == 1 &&
@@ -6032,8 +6268,9 @@ sub process {
 		}
 
 # check for krealloc arg reuse
-		if ($^V && $^V ge 5.10.0 &&
-		    $line =~ /\b($Lval)\s*\=\s*(?:$balanced_parens)?\s*krealloc\s*\(\s*\1\s*,/) {
+		if ($perl_version_ok &&
+		    $line =~ /\b($Lval)\s*\=\s*(?:$balanced_parens)?\s*krealloc\s*\(\s*($Lval)\s*,/ &&
+		    $1 eq $3) {
 			WARN("KREALLOC_ARG_REUSE",
 			     "Reusing the krealloc arg is almost always a bug\n" . $herecurr);
 		}
@@ -6092,7 +6329,7 @@ sub process {
 				next if ($fline =~ /^.[\s$;]*$/);
 				$has_statement = 1;
 				$count++;
-				$has_break = 1 if ($fline =~ /\bswitch\b|\b(?:break\s*;[\s$;]*$|return\b|goto\b|continue\b)/);
+				$has_break = 1 if ($fline =~ /\bswitch\b|\b(?:break\s*;[\s$;]*$|exit\s*\(\b|return\b|goto\b|continue\b)/);
 			}
 			if (!$has_break && $has_statement) {
 				WARN("MISSING_BREAK",
@@ -6101,15 +6338,12 @@ sub process {
 		}
 
 # check for switch/default statements without a break;
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    defined $stat &&
 		    $stat =~ /^\+[$;\s]*(?:case[$;\s]+\w+[$;\s]*:[$;\s]*|)*[$;\s]*\bdefault[$;\s]*:[$;\s]*;/g) {
-			my $ctx = '';
-			my $herectx = $here . "\n";
 			my $cnt = statement_rawlines($stat);
-			for (my $n = 0; $n < $cnt; $n++) {
-				$herectx .= raw_line($linenr, $n) . "\n";
-			}
+			my $herectx = get_stat_here($linenr, $cnt, $here);
+
 			WARN("DEFAULT_NO_BREAK",
 			     "switch default: should use break\n" . $herectx);
 		}
@@ -6180,6 +6414,20 @@ sub process {
 			     "please use device_initcall() or more appropriate function instead of __initcall() (see include/linux/init.h)\n" . $herecurr);
 		}
 
+# check for spin_is_locked(), suggest lockdep instead
+		if ($line =~ /\bspin_is_locked\(/) {
+			WARN("USE_LOCKDEP",
+			     "Where possible, use lockdep_assert_held instead of assertions based on spin_is_locked\n" . $herecurr);
+		}
+
+# check for deprecated apis
+		if ($line =~ /\b($deprecated_apis_search)\b\s*\(/) {
+			my $deprecated_api = $1;
+			my $new_api = $deprecated_apis{$deprecated_api};
+			WARN("DEPRECATED_API",
+			     "Deprecated use of '$deprecated_api', prefer '$new_api' instead\n" . $herecurr);
+		}
+
 # check for various structs that are normally const (ops, kgdb, device_tree)
 # and avoid what seem like struct definitions 'struct foo {'
 		if ($line !~ /\bconst\b/ &&
@@ -6208,7 +6456,7 @@ sub process {
 		}
 
 # likely/unlikely comparisons similar to "(likely(foo) > 0)"
-		if ($^V && $^V ge 5.10.0 &&
+		if ($perl_version_ok &&
 		    $line =~ /\b((?:un)?likely)\s*\(\s*$FuncArg\s*\)\s*$Compare/) {
 			WARN("LIKELY_MISUSE",
 			     "Using $1 should generally have parentheses around the comparison\n" . $herecurr);
@@ -6225,28 +6473,6 @@ sub process {
 			}
 		}
 
-# whine about ACCESS_ONCE
-		if ($^V && $^V ge 5.10.0 &&
-		    $line =~ /\bACCESS_ONCE\s*$balanced_parens\s*(=(?!=))?\s*($FuncArg)?/) {
-			my $par = $1;
-			my $eq = $2;
-			my $fun = $3;
-			$par =~ s/^\(\s*(.*)\s*\)$/$1/;
-			if (defined($eq)) {
-				if (WARN("PREFER_WRITE_ONCE",
-					 "Prefer WRITE_ONCE(<FOO>, <BAR>) over ACCESS_ONCE(<FOO>) = <BAR>\n" . $herecurr) &&
-				    $fix) {
-					$fixed[$fixlinenr] =~ s/\bACCESS_ONCE\s*\(\s*\Q$par\E\s*\)\s*$eq\s*\Q$fun\E/WRITE_ONCE($par, $fun)/;
-				}
-			} else {
-				if (WARN("PREFER_READ_ONCE",
-					 "Prefer READ_ONCE(<FOO>) over ACCESS_ONCE(<FOO>)\n" . $herecurr) &&
-				    $fix) {
-					$fixed[$fixlinenr] =~ s/\bACCESS_ONCE\s*\(\s*\Q$par\E\s*\)/READ_ONCE($par)/;
-				}
-			}
-		}
-
 # check for mutex_trylock_recursive usage
 		if ($line =~ /mutex_trylock_recursive/) {
 			ERROR("LOCKING",
@@ -6270,9 +6496,70 @@ sub process {
 			     "Exporting world writable files is usually an error. Consider more restrictive permissions.\n" . $herecurr);
 		}
 
+# check for DEVICE_ATTR uses that could be DEVICE_ATTR_<FOO>
+# and whether or not function naming is typical and if
+# DEVICE_ATTR permissions uses are unusual too
+		if ($perl_version_ok &&
+		    defined $stat &&
+		    $stat =~ /\bDEVICE_ATTR\s*\(\s*(\w+)\s*,\s*\(?\s*(\s*(?:${multi_mode_perms_string_search}|0[0-7]{3,3})\s*)\s*\)?\s*,\s*(\w+)\s*,\s*(\w+)\s*\)/) {
+			my $var = $1;
+			my $perms = $2;
+			my $show = $3;
+			my $store = $4;
+			my $octal_perms = perms_to_octal($perms);
+			if ($show =~ /^${var}_show$/ &&
+			    $store =~ /^${var}_store$/ &&
+			    $octal_perms eq "0644") {
+				if (WARN("DEVICE_ATTR_RW",
+					 "Use DEVICE_ATTR_RW\n" . $herecurr) &&
+				    $fix) {
+					$fixed[$fixlinenr] =~ s/\bDEVICE_ATTR\s*\(\s*$var\s*,\s*\Q$perms\E\s*,\s*$show\s*,\s*$store\s*\)/DEVICE_ATTR_RW(${var})/;
+				}
+			} elsif ($show =~ /^${var}_show$/ &&
+				 $store =~ /^NULL$/ &&
+				 $octal_perms eq "0444") {
+				if (WARN("DEVICE_ATTR_RO",
+					 "Use DEVICE_ATTR_RO\n" . $herecurr) &&
+				    $fix) {
+					$fixed[$fixlinenr] =~ s/\bDEVICE_ATTR\s*\(\s*$var\s*,\s*\Q$perms\E\s*,\s*$show\s*,\s*NULL\s*\)/DEVICE_ATTR_RO(${var})/;
+				}
+			} elsif ($show =~ /^NULL$/ &&
+				 $store =~ /^${var}_store$/ &&
+				 $octal_perms eq "0200") {
+				if (WARN("DEVICE_ATTR_WO",
+					 "Use DEVICE_ATTR_WO\n" . $herecurr) &&
+				    $fix) {
+					$fixed[$fixlinenr] =~ s/\bDEVICE_ATTR\s*\(\s*$var\s*,\s*\Q$perms\E\s*,\s*NULL\s*,\s*$store\s*\)/DEVICE_ATTR_WO(${var})/;
+				}
+			} elsif ($octal_perms eq "0644" ||
+				 $octal_perms eq "0444" ||
+				 $octal_perms eq "0200") {
+				my $newshow = "$show";
+				$newshow = "${var}_show" if ($show ne "NULL" && $show ne "${var}_show");
+				my $newstore = $store;
+				$newstore = "${var}_store" if ($store ne "NULL" && $store ne "${var}_store");
+				my $rename = "";
+				if ($show ne $newshow) {
+					$rename .= " '$show' to '$newshow'";
+				}
+				if ($store ne $newstore) {
+					$rename .= " '$store' to '$newstore'";
+				}
+				WARN("DEVICE_ATTR_FUNCTIONS",
+				     "Consider renaming function(s)$rename\n" . $herecurr);
+			} else {
+				WARN("DEVICE_ATTR_PERMS",
+				     "DEVICE_ATTR unusual permissions '$perms' used\n" . $herecurr);
+			}
+		}
+
 # Mode permission misuses where it seems decimal should be octal
 # This uses a shortcut match to avoid unnecessary uses of a slow foreach loop
-		if ($^V && $^V ge 5.10.0 &&
+# o Ignore module_param*(...) uses with a decimal 0 permission as that has a
+#   specific definition of not visible in sysfs.
+# o Ignore proc_create*(...) uses with a decimal 0 permission as that means
+#   use the default permissions
+		if ($perl_version_ok &&
 		    defined $stat &&
 		    $line =~ /$mode_perms_search/) {
 			foreach my $entry (@mode_permission_funcs) {
@@ -6281,10 +6568,7 @@ sub process {
 
 				my $lc = $stat =~ tr@\n@@;
 				$lc = $lc + $linenr;
-				my $stat_real = raw_line($linenr, 0);
-				for (my $count = $linenr + 1; $count <= $lc; $count++) {
-					$stat_real = $stat_real . "\n" . raw_line($count, 0);
-				}
+				my $stat_real = get_stat_real($linenr, $lc);
 
 				my $skip_args = "";
 				if ($arg_pos > 1) {
@@ -6295,8 +6579,9 @@ sub process {
 				if ($stat =~ /$test/) {
 					my $val = $1;
 					$val = $6 if ($skip_args ne "");
-					if (($val =~ /^$Int$/ && $val !~ /^$Octal$/) ||
-					    ($val =~ /^$Octal$/ && length($val) ne 4)) {
+					if (!($func =~ /^(?:module_param|proc_create)/ && $val eq "0") &&
+					    (($val =~ /^$Int$/ && $val !~ /^$Octal$/) ||
+					     ($val =~ /^$Octal$/ && length($val) ne 4))) {
 						ERROR("NON_OCTAL_PERMISSIONS",
 						      "Use 4 digit octal (0777) not decimal permissions\n" . "$here\n" . $stat_real);
 					}
@@ -6309,30 +6594,13 @@ sub process {
 		}
 
 # check for uses of S_<PERMS> that could be octal for readability
-		if ($line =~ /\b$mode_perms_string_search\b/) {
-			my $val = "";
-			my $oval = "";
-			my $to = 0;
-			my $curpos = 0;
-			my $lastpos = 0;
-			while ($line =~ /\b(($mode_perms_string_search)\b(?:\s*\|\s*)?\s*)/g) {
-				$curpos = pos($line);
-				my $match = $2;
-				my $omatch = $1;
-				last if ($lastpos > 0 && ($curpos - length($omatch) != $lastpos));
-				$lastpos = $curpos;
-				$to |= $mode_permission_string_types{$match};
-				$val .= '\s*\|\s*' if ($val ne "");
-				$val .= $match;
-				$oval .= $omatch;
-			}
-			$oval =~ s/^\s*\|\s*//;
-			$oval =~ s/\s*\|\s*$//;
-			my $octal = sprintf("%04o", $to);
+		while ($line =~ m{\b($multi_mode_perms_string_search)\b}g) {
+			my $oval = $1;
+			my $octal = perms_to_octal($oval);
 			if (WARN("SYMBOLIC_PERMS",
 				 "Symbolic permissions '$oval' are not preferred. Consider using octal permissions '$octal'.\n" . $herecurr) &&
 			    $fix) {
-				$fixed[$fixlinenr] =~ s/$val/$octal/;
+				$fixed[$fixlinenr] =~ s/\Q$oval\E/$octal/;
 			}
 		}
 
@@ -6373,13 +6641,18 @@ sub process {
 		exit(0);
 	}
 
-	if (!$is_patch && $file !~ /cover-letter\.patch$/) {
+	if (!$is_patch && $filename !~ /cover-letter\.patch$/) {
 		ERROR("NOT_UNIFIED_DIFF",
 		      "Does not appear to be a unified-diff format patch\n");
 	}
-	if ($is_patch && $has_commit_log && $chk_signoff && $signoff == 0) {
-		ERROR("MISSING_SIGN_OFF",
-		      "Missing Signed-off-by: line(s)\n");
+	if ($is_patch && $has_commit_log && $chk_signoff) {
+		if ($signoff == 0) {
+			ERROR("MISSING_SIGN_OFF",
+			      "Missing Signed-off-by: line(s)\n");
+		} elsif (!$authorsignoff) {
+			WARN("NO_AUTHOR_SIGN_OFF",
+			     "Missing Signed-off-by: line by nominal patch author '$author'\n");
+		}
 	}
 
 	print report_dump();
diff --git a/scripts/ci/baseline.txt b/scripts/ci/baseline.txt
new file mode 100644
index 0000000..5cf1969
--- /dev/null
+++ b/scripts/ci/baseline.txt
@@ -0,0 +1,7 @@
+#
+# SPDX-License-Identifier:           GPL-2.0
+# https://spdx.org/licenses
+#
+# Copyright (C) 2018 Marvell International Ltd.
+# commit id of base tag for this branch
+f95ab1fb6e37f0601f397091bb011edf7a98b890 (tag: v2018.03) Prepare v2018.03
\ No newline at end of file
diff --git a/scripts/ci/compile.sh b/scripts/ci/compile.sh
new file mode 100755
index 0000000..d881123
--- /dev/null
+++ b/scripts/ci/compile.sh
@@ -0,0 +1,242 @@
+#!/bin/bash
+# SPDX-License-Identifier:           GPL-2.0
+# https://spdx.org/licenses
+# Copyright (C) 2018 Marvell International Ltd.
+#
+###############################################################################
+## This is the compile script for u-boot                                     ##
+## This script is called by CI automated builds                              ##
+## It may also be used interactively by users to compile the same way as CI  ##
+###############################################################################
+## WARNING: Do NOT MODIFY the CI wrapper code segments.                      ##
+## You can only modify the config and compile commands                       ##
+###############################################################################
+
+
+## =v=v=v=v=v=v=v=v=v=v=v CI WRAPPER - Do not Modify! v=v=v=v=v=v=v=v=v=v=v= ##
+set -euo pipefail
+shopt -s extglob
+##==================================== USAGE ================================##
+function usage {
+	echo """
+Usage: compile [--no_configure] [--echo_only] BUILD_NAME
+ or:   compile --list
+ or:   compile --help
+
+Compiles u-boot similar to the given CI build
+
+ -N, --no_configure   Skip configuration steps (mrproper, make defconfig)
+ -e, --echo_only      Print out the compilation sequence but do not execute it
+ -l, --list           List all supported BUILD_NAME values and exit
+ -h, --help           Display this help and exit
+
+Prerequisites:       CROSS_COMPILE must point to the cross compiler
+
+"""
+	exit 0
+}
+##============================ PARSE ARGUMENTS ==============================##
+TEMP=`getopt -a -o Nelh --long no_configure,echo_only,list,help \
+             -n 'compile' -- "$@"`
+
+if [ $? != 0 ] ; then
+	echo "Error: Failed parsing command options" >&2
+	exit 1
+fi
+eval set -- "$TEMP"
+
+no_configure=
+echo_only=
+list=
+
+while true; do
+	case "$1" in
+		-N | --no_configure ) no_configure=true; shift ;;
+		-e | --echo_only )    echo_only=true; shift ;;
+		-l | --list ) 	      list=true; shift ;;
+		-h | --help )         usage; ;;
+		-- ) shift; break ;;
+		* ) break ;;
+	esac
+done
+
+if [[ $list ]] ; then
+	DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null && pwd )"
+	echo "Supported build names:"
+	grep -v '^#' "$DIR/supported_builds.txt"
+	echo
+	echo
+	exit 0
+fi
+
+[[ $# -ne 1 ]] && usage
+build_name=$1
+
+grep ^$build_name$ ./scripts/ci/supported_builds.txt >&/dev/null ||
+	( echo "Error: Unsupported build ${build_name}"; exit -1 )
+echo "running compile.sh ${build_name}"
+## =^=^=^=^=^=^=^=^=^=^=^=^  End of CI WRAPPER code -=^=^=^=^=^=^=^=^=^=^=^= ##
+
+
+########################### U-BOOT CONFIGURATION ##############################
+case $build_name in
+	*_a70x0* )       defconfig="mvebu_db_armada8k_defconfig"; ;;
+	*_a7020_amc )    defconfig="mvebu_db_armada8k_defconfig"; ;;
+	*_a80x0_mcbin* ) defconfig="mvebu_mcbin-88f8040_defconfig"; ;;
+	*_a80x0_ucpe* )  defconfig="mvebu_ucpe-88f8040_defconfig"; ;;
+	*_a80x0* )       defconfig="mvebu_db_armada8k_defconfig"; ;;
+	*_a388_gp )    defconfig="db-88f6820-gp_defconfig"; ;;
+	*_a3900* )       defconfig="mvebu_db_armada8k_defconfig"; ;;
+	*_cn9* )        defconfig="mvebu_db_cn91xx_defconfig"; ;;
+	*_a37xx_espressobin_* )
+	                 defconfig="mvebu_espressobin-88f3720_defconfig"; ;;
+	*_a37xx_* )      defconfig="mvebu_db-88f3720_defconfig"; ;;
+	* )	echo "Error: Could not configure defconfig." \
+		" Unsupported build ${build_name}"; exit -1; ;;
+esac
+
+case $build_name in
+	uboot_2018_a70x0 )   device_tree="armada-7040-db"; ;;
+	uboot_2018_a70x0_B ) device_tree="armada-7040-db-B"; ;;
+	uboot_2018_a70x0_C ) device_tree="armada-7040-db-C"; ;;
+	uboot_2018_a70x0_D ) device_tree="armada-7040-db-D"; ;;
+	uboot_2018_a70x0_E ) device_tree="armada-7040-db-E"; ;;
+	uboot_2018_a70x0_pcac ) device_tree="armada-7040-pcac"; ;;
+	uboot_2018_a7020_amc ) device_tree="armada-7020-amc"; ;;
+	uboot_2018_a70x0_kr ) device_tree="armada-7040-db"; ;;
+
+	uboot_2018_a80x0 )   device_tree="armada-8040-db"; ;;
+	uboot_2018_a80x0_B ) device_tree="armada-8040-db-B"; ;;
+	uboot_2018_a80x0_C ) device_tree="armada-8040-db-C"; ;;
+	uboot_2018_a80x0_D ) device_tree="armada-8040-db-D"; ;;
+	uboot_2018_a80x0_E ) device_tree="armada-8040-db-E"; ;;
+	uboot_2018_a80x0_G ) device_tree="armada-8040-db-G"; ;;
+	uboot_2018_a80x0_H ) device_tree="armada-8040-db-H"; ;;
+	uboot_2018_a80x0_kr ) device_tree="armada-8040-db"; ;;
+	uboot_2018_a80x0_pm ) device_tree="armada-8040-db"; ;;
+	uboot_2018_a80x0_ddr32 ) device_tree="armada-8040-db"; ;;
+	uboot_2018_a80x0_mcbin_single_shot* )
+	device_tree="armada-8040-mcbin-single-shot"; ;;
+	uboot_2018_a80x0_mcbin* ) device_tree="armada-8040-mcbin"; ;;
+	uboot_2018_a80x0_ucpe* ) device_tree="armada-8040-ucpe"; ;;
+
+	uboot_2018_a388_gp ) device_tree="armada-388-gp"; ;;
+	uboot_2018_a3900_A ) device_tree="armada-3900-vd-A"; ;;
+	uboot_2018_a3900_B ) device_tree="armada-3900-vd-B"; ;;
+	uboot_2018_cn9130_A ) device_tree="cn9130-db-A"; ;;
+	uboot_2018_cn9130_B ) device_tree="cn9130-db-B"; ;;
+	uboot_2018_cn9130_ddr32_A ) device_tree="cn9130-db-A"; ;;
+	uboot_2018_cn9130_emmc_A ) device_tree="cn9130-db-A"; ;;
+	uboot_2018_cn9130_crb_A ) device_tree="cn9130-crb-A"; ;;
+	uboot_2018_cn9130_crb_B ) device_tree="cn9130-crb-B"; ;;
+	uboot_2018_cn9131_A ) device_tree="cn9131-db-A"; ;;
+	uboot_2018_cn9131_B ) device_tree="cn9131-db-B"; ;;
+	uboot_2018_cn9131_ddr32_A ) device_tree="cn9131-db-A"; ;;
+	uboot_2018_cn9131_emmc_A ) device_tree="cn9131-db-A"; ;;
+	uboot_2018_cn9132_A ) device_tree="cn9132-db-A"; ;;
+	uboot_2018_cn9132_B ) device_tree="cn9132-db-B"; ;;
+	uboot_2018_cn9132_ddr32_A ) device_tree="cn9132-db-A"; ;;
+	uboot_2018_cn9132_emmc_A ) device_tree="cn9132-db-A"; ;;
+
+	uboot_2018*_a37xx_ddr3_v2_A_* )
+		device_tree="armada-3720-db"; ;;
+	uboot_2018_a37xx_ddr3_v2_B_* )
+		device_tree="armada-3720-ddr3-db-v2-B"; ;;
+	uboot_2018_a37xx_ddr3_v2_C_* )
+		device_tree="armada-3720-ddr3-db-v2-C"; ;;
+	uboot_2018_a37xx_ddr4_v1_A_* )
+		device_tree="armada-3720-ddr4-db-v1-A"; ;;
+	uboot_2018_a37xx_ddr4_v3_A_* )
+		device_tree="armada-3720-ddr4-db-v3-A"; ;;
+	uboot_2018_a37xx_ddr4_v3_B_* )
+		device_tree="armada-3720-ddr4-db-v3-B"; ;;
+	uboot_2018_a37xx_ddr4_v3_C_* )
+		device_tree="armada-3720-ddr4-db-v3-C"; ;;
+	uboot_2018_a37xx_espressobin_ddr3_* )
+		device_tree="armada-3720-espressobin"; ;;
+	uboot_2018_a37xx_espressobin_ddr4_v7_1G_emmc* )
+		device_tree="armada-3720-espressobin-emmc"; ;;
+	uboot_2018_a37xx_espressobin_ddr4_v7_2G_emmc* )
+		device_tree="armada-3720-espressobin-emmc"; ;;
+	uboot_2018_a37xx_espressobin_ddr4_v7_1G* )
+		device_tree="armada-3720-espressobin"; ;;
+	uboot_2018_a37xx_espressobin_ddr4_v7_2G* )
+		device_tree="armada-3720-espressobin"; ;;
+	* ) echo "Error: Could not configure device_tree." \
+		" Unsupported build ${build_name}"; exit -1;	;;
+esac
+
+if [ $device_tree ]; then
+	device_tree="DEVICE_TREE=${device_tree}"
+fi
+
+config_cmd=""
+if [[ $build_name == "uboot_2018_a70x0_D" ||
+	$build_name == "uboot_2018_a7020_amc" ||
+	$build_name == "uboot_2018_a80x0_D" ||
+	$build_name == "uboot_2018_cn9130_B" ||
+	$build_name == "uboot_2018_cn9131_B" ||
+	$build_name == "uboot_2018_cn9132_B" ]]; then
+	config_cmd="""
+	./scripts/config -d CONFIG_MVEBU_SPI_BOOT
+	./scripts/config -e CONFIG_MVEBU_NAND_BOOT
+	./scripts/config -d CONFIG_ENV_IS_IN_SPI_FLASH
+	./scripts/config -e CONFIG_ENV_IS_IN_NAND
+	"""
+elif [[ $build_name == "uboot_2018_a37xx_espressobin_ddr4_v7_1G_emmc" ||
+	$build_name == "uboot_2018_a37xx_espressobin_ddr4_v7_2G_emmc" ||
+	$build_name == "uboot_2018_cn9130_emmc_A" ||
+	$build_name == "uboot_2018_cn9131_emmc_A" ||
+	$build_name == "uboot_2018_cn9132_emmc_A" ]]; then
+	config_cmd="""
+	./scripts/config -d CONFIG_MVEBU_SPI_BOOT
+	./scripts/config -e CONFIG_MVEBU_MMC_BOOT
+	./scripts/config -d CONFIG_ENV_IS_IN_SPI_FLASH
+	./scripts/config -e CONFIG_ENV_IS_IN_MMC
+	./scripts/config --set-val MVEBU_BOOT_PART 1
+	"""
+	if [[ $build_name == "uboot_2018_a37xx_espressobin_ddr4_v7_1G_emmc" ||
+	$build_name == "uboot_2018_a37xx_espressobin_ddr4_v7_2G_emmc" ]]; then
+	config_cmd=$config_cmd"""
+		./scripts/config --set-val MVEBU_BOOT_DEVICE 1
+	"""
+	fi
+fi
+
+build_flags="" # not used in u-boot-2018
+logfile="$$.make.log"
+###############################################################################
+
+
+## =v=v=v=v=v=v=v=v=v=v=v CI WRAPPER - Do not Modify! v=v=v=v=v=v=v=v=v=v=v= ##
+cmd="""
+set -x
+pwd"""
+## =^=^=^=^=^=^=^=^=^=^=^=^  End of CI WRAPPER code -=^=^=^=^=^=^=^=^=^=^=^= ##
+
+
+##################################### CONFIG ##################################
+[[ $no_configure ]] || cmd=$cmd"""
+make mrproper
+make ${defconfig}
+${config_cmd}"""
+
+#################################### COMPILE ##################################
+cmd=$cmd"""
+make ${device_tree} ${build_flags} -j4"""
+###############################################################################
+
+
+## =v=v=v=v=v=v=v=v=v=v=v CI WRAPPER - Do not Modify! v=v=v=v=v=v=v=v=v=v=v= ##
+if [[ $echo_only ]]; then
+	echo "$cmd"
+	exit 0
+fi
+
+(eval "$cmd") 2>&1 | tee ${logfile}
+cat $logfile
+if grep -i "warning:" $logfile; then
+	echo "Error: Build has warnings. Aborted"
+	exit -1
+fi
+## =^=^=^=^=^=^=^=^=^=^=^=^  End of CI WRAPPER code -=^=^=^=^=^=^=^=^=^=^=^= ##
diff --git a/scripts/ci/pack.sh b/scripts/ci/pack.sh
new file mode 100755
index 0000000..2485dc1
--- /dev/null
+++ b/scripts/ci/pack.sh
@@ -0,0 +1,25 @@
+#!/bin/bash
+# SPDX-License-Identifier:           GPL-2.0
+# https://spdx.org/licenses
+# Copyright (C) 2018 Marvell International Ltd.
+#
+###############################################################################
+## This is the pack script for u-boot                                        ##
+## This script is called by CI automated builds                              ##
+###############################################################################
+## WARNING: Do NOT MODIFY the CI wrapper code segments.                      ##
+## You can only modify the config and compile commands                       ##
+###############################################################################
+## Prerequisites:       DESTDIR is the path to the destination directory
+## Usage:               pack BUILD_NAME
+
+## =v=v=v=v=v=v=v=v=v=v=v CI WRAPPER - Do not Modify! v=v=v=v=v=v=v=v=v=v=v= ##
+set -exuo pipefail
+shopt -s extglob
+
+build_name=$1
+echo "running pack.sh ${build_name}"
+## =^=^=^=^=^=^=^=^=^=^=^=^  End of CI WRAPPER code -=^=^=^=^=^=^=^=^=^=^=^= ##
+
+mkdir -p $DESTDIR/dev_images
+cp u-boot.bin $DESTDIR/dev_images/
diff --git a/scripts/ci/pack_source.sh b/scripts/ci/pack_source.sh
new file mode 100755
index 0000000..6909ad8
--- /dev/null
+++ b/scripts/ci/pack_source.sh
@@ -0,0 +1,42 @@
+#!/bin/bash
+# SPDX-License-Identifier:           GPL-2.0
+# https://spdx.org/licenses
+# Copyright (C) 2018 Marvell International Ltd.
+#
+###############################################################################
+## This is the source packing script for u-boot                              ##
+## This script is called by CI automated builds                              ##
+###############################################################################
+## WARNING: Do NOT MODIFY the CI wrapper code segments.                      ##
+## You can only modify the config and compile commands                       ##
+###############################################################################
+## Prerequisites:       DESTDIR is the path to the destination directory
+## Usage:               pack_source RELEASE_VER END_TAG
+## Output:              packname
+
+## =v=v=v=v=v=v=v=v=v=v=v CI WRAPPER - Do not Modify! v=v=v=v=v=v=v=v=v=v=v= ##
+set -exuo pipefail
+shopt -s extglob
+
+release_ver=$1
+end_tag=$2
+echo "running pack_source.sh ${release_ver} ${end_tag}"
+## =^=^=^=^=^=^=^=^=^=^=^=^  End of CI WRAPPER code -=^=^=^=^=^=^=^=^=^=^=^= ##
+
+packname="u-boot-2018.03-${release_ver}"
+base_tag=`cat scripts/ci/baseline.txt | \
+	perl -nae 'next if /^#/; print \$F[0]; exit'`
+ref_to_ref="${base_tag}..${end_tag}"
+srcpkg="sources-${packname}"
+gitpkg="git-${packname}"
+
+mkdir -p ${DESTDIR}/$srcpkg
+cp -R ./* ${DESTDIR}/$srcpkg/ || true
+
+mkdir ${DESTDIR}/$gitpkg
+git format-patch -o ${DESTDIR}/$gitpkg $ref_to_ref
+
+
+## =v=v=v=v=v=v=v=v=v=v=v CI WRAPPER - Do not Modify! v=v=v=v=v=v=v=v=v=v=v= ##
+echo "packname:$packname"
+## =^=^=^=^=^=^=^=^=^=^=^=^  End of CI WRAPPER code -=^=^=^=^=^=^=^=^=^=^=^= ##
diff --git a/scripts/ci/supported_builds.txt b/scripts/ci/supported_builds.txt
new file mode 100644
index 0000000..dcc7d30
--- /dev/null
+++ b/scripts/ci/supported_builds.txt
@@ -0,0 +1,77 @@
+#
+# SPDX-License-Identifier:           GPL-2.0
+# https://spdx.org/licenses
+#
+# Copyright (C) 2018 Marvell International Ltd.
+#
+uboot_2018_a70x0
+uboot_2018_a70x0_B
+uboot_2018_a70x0_C
+uboot_2018_a70x0_D
+uboot_2018_a70x0_E
+uboot_2018_a70x0_pcac
+uboot_2018_a7020_amc
+uboot_2018_a70x0_kr
+
+uboot_2018_a80x0
+uboot_2018_a80x0_B
+uboot_2018_a80x0_C
+uboot_2018_a80x0_D
+uboot_2018_a80x0_E
+uboot_2018_a80x0_G
+uboot_2018_a80x0_H
+uboot_2018_a80x0_kr
+uboot_2018_a80x0_pm
+uboot_2018_a80x0_mcbin
+uboot_2018_a80x0_mcbin_cve_2018_3639
+uboot_2018_a80x0_mcbin_pm
+uboot_2018_a80x0_mcbin_single_shot
+uboot_2018_a80x0_mcbin_single_shot_cve_2018_3639
+uboot_2018_a80x0_mcbin_single_shot_pm
+uboot_2018_a80x0_ucpe
+uboot_2018_a80x0_ddr32
+
+uboot_2018_a388_gp
+uboot_2018_a3900_A
+uboot_2018_a3900_B
+uboot_2018_cn9130_A
+uboot_2018_cn9130_B
+uboot_2018_cn9130_ddr32_A
+uboot_2018_cn9130_emmc_A
+uboot_2018_cn9130_crb_A
+uboot_2018_cn9130_crb_B
+uboot_2018_cn9131_A
+uboot_2018_cn9131_B
+uboot_2018_cn9131_ddr32_A
+uboot_2018_cn9131_emmc_A
+uboot_2018_cn9132_A
+uboot_2018_cn9132_B
+uboot_2018_cn9132_ddr32_A
+uboot_2018_cn9132_emmc_A
+
+uboot_2018_a37xx_ddr3_v2_A_1000_800
+uboot_2018_a37xx_ddr3_v2_B_1000_800
+uboot_2018_a37xx_ddr3_v2_C_1000_800
+uboot_2018_a37xx_ddr3_v2_A_1200_750
+uboot_2018_a37xx_ddr3_v2_B_1200_750
+uboot_2018_a37xx_ddr3_v2_C_1200_750
+uboot_2018_a37xx_ddr3_v2_A_600_600
+uboot_2018_a37xx_ddr3_v2_B_600_600
+uboot_2018_a37xx_ddr3_v2_A_800_800
+uboot_2018_a37xx_ddr3_v2_B_800_800
+uboot_2018_a37xx_ddr3_v2_C_800_800
+uboot_2018_a37xx_ddr4_v1_A_1000_800
+uboot_2018_a37xx_ddr4_v3_A_1000_800
+uboot_2018_a37xx_ddr4_v3_B_1000_800
+uboot_2018_a37xx_ddr4_v3_C_1000_800
+uboot_2018_a37xx_ddr4_v1_A_800_800
+uboot_2018_a37xx_ddr4_v3_A_800_800
+uboot_2018_a37xx_ddr4_v3_B_800_800
+uboot_2018_a37xx_ddr4_v3_C_800_800
+uboot_2018_a37xx_espressobin_ddr3_1cs_1000_800
+uboot_2018_a37xx_espressobin_ddr3_2cs_1000_800
+uboot_2018_a37xx_espressobin_ddr4_v7_1G_1000_800
+uboot_2018_a37xx_espressobin_ddr4_v7_2G_1000_800
+uboot_2018_a37xx_espressobin_ddr4_v7_1G_emmc_1000_800
+uboot_2018_a37xx_espressobin_ddr4_v7_2G_emmc_1000_800
+uboot_2018_freertos_a37xx_ddr3_v2_A_1000_800
diff --git a/scripts/config b/scripts/config
new file mode 100755
index 0000000..026aeb4
--- /dev/null
+++ b/scripts/config
@@ -0,0 +1,225 @@
+#!/bin/bash
+# Manipulate options in a .config file from the command line
+
+myname=${0##*/}
+
+# If no prefix forced, use the default CONFIG_
+CONFIG_="${CONFIG_-CONFIG_}"
+
+usage() {
+	cat >&2 <<EOL
+Manipulate options in a .config file from the command line.
+Usage:
+$myname options command ...
+commands:
+	--enable|-e option   Enable option
+	--disable|-d option  Disable option
+	--module|-m option   Turn option into a module
+	--set-str option string
+	                     Set option to "string"
+	--set-val option value
+	                     Set option to value
+	--undefine|-u option Undefine option
+	--state|-s option    Print state of option (n,y,m,undef)
+
+	--enable-after|-E beforeopt option
+                             Enable option directly after other option
+	--disable-after|-D beforeopt option
+                             Disable option directly after other option
+	--module-after|-M beforeopt option
+                             Turn option into module directly after other option
+
+	commands can be repeated multiple times
+
+options:
+	--file config-file   .config file to change (default .config)
+	--keep-case|-k       Keep next symbols' case (dont' upper-case it)
+
+$myname doesn't check the validity of the .config file. This is done at next
+make time.
+
+By default, $myname will upper-case the given symbol. Use --keep-case to keep
+the case of all following symbols unchanged.
+
+$myname uses 'CONFIG_' as the default symbol prefix. Set the environment
+variable CONFIG_ to the prefix to use. Eg.: CONFIG_="FOO_" $myname ...
+EOL
+	exit 1
+}
+
+checkarg() {
+	ARG="$1"
+	if [ "$ARG" = "" ] ; then
+		usage
+	fi
+	case "$ARG" in
+	${CONFIG_}*)
+		ARG="${ARG/${CONFIG_}/}"
+		;;
+	esac
+	if [ "$MUNGE_CASE" = "yes" ] ; then
+		ARG="`echo $ARG | tr a-z A-Z`"
+	fi
+}
+
+txt_append() {
+	local anchor="$1"
+	local insert="$2"
+	local infile="$3"
+	local tmpfile="$infile.swp"
+
+	# sed append cmd: 'a\' + newline + text + newline
+	cmd="$(printf "a\\%b$insert" "\n")"
+
+	sed -e "/$anchor/$cmd" "$infile" >"$tmpfile"
+	# replace original file with the edited one
+	mv "$tmpfile" "$infile"
+}
+
+txt_subst() {
+	local before="$1"
+	local after="$2"
+	local infile="$3"
+	local tmpfile="$infile.swp"
+
+	sed -e "s:$before:$after:" "$infile" >"$tmpfile"
+	# replace original file with the edited one
+	mv "$tmpfile" "$infile"
+}
+
+txt_delete() {
+	local text="$1"
+	local infile="$2"
+	local tmpfile="$infile.swp"
+
+	sed -e "/$text/d" "$infile" >"$tmpfile"
+	# replace original file with the edited one
+	mv "$tmpfile" "$infile"
+}
+
+set_var() {
+	local name=$1 new=$2 before=$3
+
+	name_re="^($name=|# $name is not set)"
+	before_re="^($before=|# $before is not set)"
+	if test -n "$before" && grep -Eq "$before_re" "$FN"; then
+		txt_append "^$before=" "$new" "$FN"
+		txt_append "^# $before is not set" "$new" "$FN"
+	elif grep -Eq "$name_re" "$FN"; then
+		txt_subst "^$name=.*" "$new" "$FN"
+		txt_subst "^# $name is not set" "$new" "$FN"
+	else
+		echo "$new" >>"$FN"
+	fi
+}
+
+undef_var() {
+	local name=$1
+
+	txt_delete "^$name=" "$FN"
+	txt_delete "^# $name is not set" "$FN"
+}
+
+if [ "$1" = "--file" ]; then
+	FN="$2"
+	if [ "$FN" = "" ] ; then
+		usage
+	fi
+	shift 2
+else
+	FN=.config
+fi
+
+if [ "$1" = "" ] ; then
+	usage
+fi
+
+MUNGE_CASE=yes
+while [ "$1" != "" ] ; do
+	CMD="$1"
+	shift
+	case "$CMD" in
+	--keep-case|-k)
+		MUNGE_CASE=no
+		continue
+		;;
+	--refresh)
+		;;
+	--*-after|-E|-D|-M)
+		checkarg "$1"
+		A=$ARG
+		checkarg "$2"
+		B=$ARG
+		shift 2
+		;;
+	-*)
+		checkarg "$1"
+		shift
+		;;
+	esac
+	case "$CMD" in
+	--enable|-e)
+		set_var "${CONFIG_}$ARG" "${CONFIG_}$ARG=y"
+		;;
+
+	--disable|-d)
+		set_var "${CONFIG_}$ARG" "# ${CONFIG_}$ARG is not set"
+		;;
+
+	--module|-m)
+		set_var "${CONFIG_}$ARG" "${CONFIG_}$ARG=m"
+		;;
+
+	--set-str)
+		# sed swallows one level of escaping, so we need double-escaping
+		set_var "${CONFIG_}$ARG" "${CONFIG_}$ARG=\"${1//\"/\\\\\"}\""
+		shift
+		;;
+
+	--set-val)
+		set_var "${CONFIG_}$ARG" "${CONFIG_}$ARG=$1"
+		shift
+		;;
+	--undefine|-u)
+		undef_var "${CONFIG_}$ARG"
+		;;
+
+	--state|-s)
+		if grep -q "# ${CONFIG_}$ARG is not set" $FN ; then
+			echo n
+		else
+			V="$(grep "^${CONFIG_}$ARG=" $FN)"
+			if [ $? != 0 ] ; then
+				echo undef
+			else
+				V="${V/#${CONFIG_}$ARG=/}"
+				V="${V/#\"/}"
+				V="${V/%\"/}"
+				V="${V//\\\"/\"}"
+				echo "${V}"
+			fi
+		fi
+		;;
+
+	--enable-after|-E)
+		set_var "${CONFIG_}$B" "${CONFIG_}$B=y" "${CONFIG_}$A"
+		;;
+
+	--disable-after|-D)
+		set_var "${CONFIG_}$B" "# ${CONFIG_}$B is not set" "${CONFIG_}$A"
+		;;
+
+	--module-after|-M)
+		set_var "${CONFIG_}$B" "${CONFIG_}$B=m" "${CONFIG_}$A"
+		;;
+
+	# undocumented because it ignores --file (fixme)
+	--refresh)
+		yes "" | make oldconfig
+		;;
+
+	*)
+		usage
+		;;
+	esac
+done
diff --git a/scripts/config_whitelist.txt b/scripts/config_whitelist.txt
index 7cd1518..b5be9a2 100644
--- a/scripts/config_whitelist.txt
+++ b/scripts/config_whitelist.txt
@@ -1528,7 +1528,6 @@ CONFIG_PCI_MEM_BUS
 CONFIG_PCI_MEM_PHYS
 CONFIG_PCI_MEM_SIZE
 CONFIG_PCI_MSC01
-CONFIG_PCI_MVEBU
 CONFIG_PCI_NOSCAN
 CONFIG_PCI_OHCI
 CONFIG_PCI_OHCI_DEVNO
diff --git a/scripts/const_structs.checkpatch b/scripts/const_structs.checkpatch
index da775bc..ac5f126 100644
--- a/scripts/const_structs.checkpatch
+++ b/scripts/const_structs.checkpatch
@@ -1,2 +1,64 @@
-# Put structs here that should be constant
-__dummy__
+acpi_dock_ops
+address_space_operations
+backlight_ops
+block_device_operations
+clk_ops
+comedi_lrange
+component_ops
+dentry_operations
+dev_pm_ops
+dma_map_ops
+driver_info
+drm_connector_funcs
+drm_encoder_funcs
+drm_encoder_helper_funcs
+ethtool_ops
+extent_io_ops
+file_lock_operations
+file_operations
+hv_ops
+ide_dma_ops
+ide_port_ops
+inode_operations
+intel_dvo_dev_ops
+irq_domain_ops
+item_operations
+iwl_cfg
+iwl_ops
+kgdb_arch
+kgdb_io
+kset_uevent_ops
+lock_manager_operations
+machine_desc
+microcode_ops
+mlxsw_reg_info
+mtrr_ops
+neigh_ops
+net_device_ops
+nlmsvc_binding
+nvkm_device_chip
+of_device_id
+pci_raw_ops
+pipe_buf_operations
+platform_hibernation_ops
+platform_suspend_ops
+proto_ops
+regmap_access_table
+rpc_pipe_ops
+rtc_class_ops
+sd_desc
+seq_operations
+sirfsoc_padmux
+snd_ac97_build_ops
+snd_soc_component_driver
+soc_pcmcia_socket_ops
+stacktrace_ops
+sysfs_ops
+tty_operations
+uart_ops
+usb_mon_operations
+v4l2_ctrl_ops
+v4l2_ioctl_ops
+vm_operations_struct
+wacom_features
+wd_ops
diff --git a/scripts/spelling.txt b/scripts/spelling.txt
index 9a058cf..86b8733 100644
--- a/scripts/spelling.txt
+++ b/scripts/spelling.txt
@@ -10,6 +10,10 @@
 abandonning||abandoning
 abigious||ambiguous
 abitrate||arbitrate
+abnornally||abnormally
+abnrormal||abnormal
+abord||abort
+aboslute||absolute
 abov||above
 abreviated||abbreviated
 absense||absence
@@ -25,6 +29,7 @@ accessable||accessible
 accesss||access
 accidentaly||accidentally
 accidentually||accidentally
+acclerated||accelerated
 accoding||according
 accomodate||accommodate
 accomodates||accommodates
@@ -58,12 +63,15 @@ addres||address
 adddress||address
 addreses||addresses
 addresss||address
+addrress||address
 aditional||additional
 aditionally||additionally
 aditionaly||additionally
 adminstrative||administrative
 adress||address
 adresses||addresses
+adrresses||addresses
+advertisment||advertisement
 adviced||advised
 afecting||affecting
 againt||against
@@ -100,6 +108,8 @@ alue||value
 ambigious||ambiguous
 amoung||among
 amout||amount
+amplifer||amplifier
+amplifyer||amplifier
 an union||a union
 an user||a user
 an userspace||a userspace
@@ -138,6 +148,7 @@ artillary||artillery
 asign||assign
 asser||assert
 assertation||assertion
+assertting||asserting
 assiged||assigned
 assigment||assignment
 assigments||assignments
@@ -145,11 +156,15 @@ assistent||assistant
 assocation||association
 associcated||associated
 assotiated||associated
+asssert||assert
 assum||assume
 assumtpion||assumption
 asuming||assuming
 asycronous||asynchronous
 asynchnous||asynchronous
+asynchromous||asynchronous
+asymetric||asymmetric
+asymmeric||asymmetric
 atomatically||automatically
 atomicly||atomically
 atempt||attempt
@@ -157,6 +172,8 @@ attachement||attachment
 attched||attached
 attemps||attempts
 attemping||attempting
+attepmpt||attempt
+attnetion||attention
 attruibutes||attributes
 authentification||authentication
 automaticaly||automatically
@@ -172,6 +189,7 @@ avaible||available
 availabe||available
 availabled||available
 availablity||availability
+availaible||available
 availale||available
 availavility||availability
 availble||available
@@ -205,9 +223,13 @@ boardcast||broadcast
 borad||board
 boundry||boundary
 brievely||briefly
+broadcase||broadcast
 broadcat||broadcast
+bufufer||buffer
 cacluated||calculated
+caculate||calculate
 caculation||calculation
+cadidate||candidate
 calender||calendar
 calescing||coalescing
 calle||called
@@ -219,14 +241,17 @@ cancle||cancel
 capabilites||capabilities
 capabilty||capability
 capabitilies||capabilities
+capablity||capability
 capatibilities||capabilities
 capapbilities||capabilities
+caputure||capture
 carefuly||carefully
 cariage||carriage
 catagory||category
 cehck||check
 challange||challenge
 challanges||challenges
+chache||cache
 chanell||channel
 changable||changeable
 chanined||chained
@@ -240,6 +265,7 @@ charaters||characters
 charcter||character
 chcek||check
 chck||check
+checksumed||checksummed
 checksuming||checksumming
 childern||children
 childs||children
@@ -256,6 +282,7 @@ clared||cleared
 closeing||closing
 clustred||clustered
 coexistance||coexistence
+colescing||coalescing
 collapsable||collapsible
 colorfull||colorful
 comand||command
@@ -272,6 +299,7 @@ comsumer||consumer
 comsuming||consuming
 compability||compatibility
 compaibility||compatibility
+comparsion||comparison
 compatability||compatibility
 compatable||compatible
 compatibiliy||compatibility
@@ -285,6 +313,7 @@ completly||completely
 complient||compliant
 componnents||components
 compoment||component
+comppatible||compatible
 compres||compress
 compresion||compression
 comression||compression
@@ -292,8 +321,10 @@ comunication||communication
 conbination||combination
 conditionaly||conditionally
 conected||connected
+conector||connector
 connecetd||connected
 configuartion||configuration
+configuation||configuration
 configuratoin||configuration
 configuraton||configuration
 configuretion||configuration
@@ -315,6 +346,7 @@ continous||continuous
 continously||continuously
 continueing||continuing
 contraints||constraints
+contruct||construct
 contol||control
 contoller||controller
 controled||controlled
@@ -343,9 +375,12 @@ dafault||default
 deafult||default
 deamon||daemon
 decompres||decompress
+decsribed||described
 decription||description
 dectected||detected
 defailt||default
+deferal||deferral
+deffered||deferred
 defferred||deferred
 definate||definite
 definately||definitely
@@ -378,7 +413,9 @@ descritptor||descriptor
 desctiptor||descriptor
 desriptor||descriptor
 desriptors||descriptors
+desination||destination
 destionation||destination
+destoried||destroyed
 destory||destroy
 destoryed||destroyed
 destorys||destroys
@@ -400,22 +437,33 @@ didnt||didn't
 diferent||different
 differrence||difference
 diffrent||different
+differenciate||differentiate
 diffrentiate||differentiate
 difinition||definition
+dimention||dimension
 dimesions||dimensions
+dispalying||displaying
 diplay||display
+directon||direction
 direectly||directly
+diregard||disregard
 disassocation||disassociation
 disapear||disappear
 disapeared||disappeared
 disappared||disappeared
+disbale||disable
+disbaled||disabled
 disble||disable
 disbled||disabled
 disconnet||disconnect
 discontinous||discontinuous
+disharge||discharge
+disnabled||disabled
 dispertion||dispersion
 dissapears||disappears
 distiction||distinction
+divisable||divisible
+divsiors||divisors
 docuentation||documentation
 documantation||documentation
 documentaion||documentation
@@ -425,8 +473,10 @@ dorp||drop
 dosen||doesn
 downlad||download
 downlads||downloads
+droped||dropped
 druing||during
 dynmaic||dynamic
+eanable||enable
 easilly||easily
 ecspecially||especially
 edditable||editable
@@ -439,6 +489,7 @@ elementry||elementary
 eletronic||electronic
 embeded||embedded
 enabledi||enabled
+enble||enable
 enchanced||enhanced
 encorporating||incorporating
 encrupted||encrypted
@@ -447,6 +498,9 @@ encryptio||encryption
 endianess||endianness
 enhaced||enhanced
 enlightnment||enlightenment
+enqueing||enqueuing
+entires||entries
+entites||entities
 entrys||entries
 enocded||encoded
 enterily||entirely
@@ -466,6 +520,8 @@ etsbalishment||establishment
 excecutable||executable
 exceded||exceeded
 excellant||excellent
+execeeded||exceeded
+execeeds||exceeds
 exeed||exceed
 existance||existence
 existant||existent
@@ -474,6 +530,7 @@ exlcude||exclude
 exlcusive||exclusive
 exmaple||example
 expecially||especially
+experies||expires
 explicite||explicit
 explicitely||explicitly
 explict||explicit
@@ -484,9 +541,13 @@ exprimental||experimental
 extened||extended
 extensability||extensibility
 extention||extension
+extenstion||extension
 extracter||extractor
+faield||failed
 falied||failed
 faild||failed
+failded||failed
+failer||failure
 faill||fail
 failied||failed
 faillure||failure
@@ -505,6 +566,7 @@ fetaure||feature
 fetaures||features
 fileystem||filesystem
 fimware||firmware
+firmare||firmware
 firware||firmware
 finanize||finalize
 findn||find
@@ -520,6 +582,7 @@ forseeable||foreseeable
 forse||force
 fortan||fortran
 forwardig||forwarding
+frambuffer||framebuffer
 framming||framing
 framwork||framework
 frequncy||frequency
@@ -527,6 +590,7 @@ frome||from
 fucntion||function
 fuction||function
 fuctions||functions
+funcation||function
 funcion||function
 functionallity||functionality
 functionaly||functionally
@@ -537,9 +601,11 @@ funtions||functions
 furthur||further
 futhermore||furthermore
 futrue||future
+gauage||gauge
 gaurenteed||guaranteed
 generiously||generously
 genereate||generate
+genereted||generated
 genric||generic
 globel||global
 grabing||grabbing
@@ -553,6 +619,7 @@ guarentee||guarantee
 halfs||halves
 hander||handler
 handfull||handful
+hanlde||handle
 hanled||handled
 happend||happened
 harware||hardware
@@ -561,6 +628,7 @@ helpfull||helpful
 hybernate||hibernate
 hierachy||hierarchy
 hierarchie||hierarchy
+homogenous||homogeneous
 howver||however
 hsould||should
 hypervior||hypervisor
@@ -568,6 +636,8 @@ hypter||hyper
 identidier||identifier
 iligal||illegal
 illigal||illegal
+illgal||illegal
+iomaped||iomapped
 imblance||imbalance
 immeadiately||immediately
 immedaite||immediate
@@ -603,6 +673,7 @@ independed||independent
 indiate||indicate
 indicat||indicate
 inexpect||inexpected
+inferface||interface
 infomation||information
 informatiom||information
 informations||information
@@ -618,13 +689,19 @@ initation||initiation
 initators||initiators
 initialiazation||initialization
 initializiation||initialization
+initialze||initialize
 initialzed||initialized
+initialzing||initializing
 initilization||initialization
 initilize||initialize
 inofficial||unofficial
+inrerface||interface
 insititute||institute
+instace||instance
 instal||install
+instanciate||instantiate
 instanciated||instantiated
+insufficent||insufficient
 inteface||interface
 integreated||integrated
 integrety||integrity
@@ -639,6 +716,8 @@ intermittant||intermittent
 internel||internal
 interoprability||interoperability
 interuupt||interrupt
+interupt||interrupt
+interupts||interrupts
 interrface||interface
 interrrupt||interrupt
 interrup||interrupt
@@ -654,10 +733,14 @@ intialization||initialization
 intialized||initialized
 intialize||initialize
 intregral||integral
+intrerrupt||interrupt
 intrrupt||interrupt
 intterrupt||interrupt
 intuative||intuitive
+inavlid||invalid
 invaid||invalid
+invaild||invalid
+invailid||invalid
 invald||invalid
 invalde||invalid
 invalide||invalid
@@ -666,6 +749,7 @@ invalud||invalid
 invididual||individual
 invokation||invocation
 invokations||invocations
+ireelevant||irrelevant
 irrelevent||irrelevant
 isnt||isn't
 isssue||issue
@@ -683,6 +767,7 @@ langauge||language
 langugage||language
 lauch||launch
 layed||laid
+legnth||length
 leightweight||lightweight
 lengh||length
 lenght||length
@@ -696,26 +781,35 @@ licenceing||licencing
 loggging||logging
 loggin||login
 logile||logfile
+loobpack||loopback
 loosing||losing
 losted||lost
 machinary||machinery
+maibox||mailbox
 maintainance||maintenance
 maintainence||maintenance
 maintan||maintain
 makeing||making
+mailformed||malformed
 malplaced||misplaced
 malplace||misplace
 managable||manageable
 managment||management
 mangement||management
 manoeuvering||maneuvering
+manufaucturing||manufacturing
 mappping||mapping
+matchs||matches
 mathimatical||mathematical
 mathimatic||mathematic
 mathimatics||mathematics
+maximium||maximum
 maxium||maximum
 mechamism||mechanism
 meetign||meeting
+memeory||memory
+memmber||member
+memoery||memory
 ment||meant
 mergable||mergeable
 mesage||message
@@ -725,9 +819,11 @@ messsage||message
 messsages||messages
 micropone||microphone
 microprocesspr||microprocessor
+migrateable||migratable
 milliseonds||milliseconds
 minium||minimum
 minimam||minimum
+miniumum||minimum
 minumum||minimum
 misalinged||misaligned
 miscelleneous||miscellaneous
@@ -741,6 +837,7 @@ missmatch||mismatch
 miximum||maximum
 mmnemonic||mnemonic
 mnay||many
+modfiy||modify
 modulues||modules
 momery||memory
 memomry||memory
@@ -777,6 +874,7 @@ notifed||notified
 numebr||number
 numner||number
 obtaion||obtain
+obusing||abusing
 occassionally||occasionally
 occationally||occasionally
 occurance||occurrence
@@ -786,7 +884,9 @@ occurence||occurrence
 occure||occurred
 occured||occurred
 occuring||occurring
+offser||offset
 offet||offset
+offloded||offloaded
 omited||omitted
 omiting||omitting
 omitt||omit
@@ -801,6 +901,7 @@ optmizations||optimizations
 orientatied||orientated
 orientied||oriented
 orignal||original
+originial||original
 otherise||otherwise
 ouput||output
 oustanding||outstanding
@@ -820,6 +921,7 @@ packege||package
 packge||package
 packtes||packets
 pakage||package
+paket||packet
 pallette||palette
 paln||plan
 paramameters||parameters
@@ -829,23 +931,30 @@ parametes||parameters
 parametised||parametrised
 paramter||parameter
 paramters||parameters
+parmaters||parameters
 particuarly||particularly
 particularily||particularly
+partion||partition
+partions||partitions
 partiton||partition
 pased||passed
 passin||passing
 pathes||paths
 pecularities||peculiarities
 peformance||performance
+peforming||performing
 peice||piece
 pendantic||pedantic
 peprocessor||preprocessor
 perfoming||performing
+peripherial||peripheral
 permissons||permissions
 peroid||period
 persistance||persistence
 persistant||persistent
+phoneticly||phonetically
 plalform||platform
+platfoem||platform
 platfrom||platform
 plattform||platform
 pleaes||please
@@ -858,6 +967,8 @@ posible||possible
 positon||position
 possibilites||possibilities
 powerfull||powerful
+pramater||parameter
+preamle||preamble
 preample||preamble
 preapre||prepare
 preceeded||preceded
@@ -870,6 +981,7 @@ prefered||preferred
 prefferably||preferably
 premption||preemption
 prepaired||prepared
+preperation||preparation
 pressre||pressure
 primative||primitive
 princliple||principle
@@ -917,6 +1029,7 @@ psudo||pseudo
 psuedo||pseudo
 psychadelic||psychedelic
 pwoer||power
+queing||queuing
 quering||querying
 randomally||randomly
 raoming||roaming
@@ -935,6 +1048,7 @@ recommanded||recommended
 recyle||recycle
 redircet||redirect
 redirectrion||redirection
+redundacy||redundancy
 reename||rename
 refcounf||refcount
 refence||reference
@@ -944,7 +1058,9 @@ refering||referring
 refernces||references
 refernnce||reference
 refrence||reference
+registed||registered
 registerd||registered
+registeration||registration
 registeresd||registered
 registerred||registered
 registes||registers
@@ -957,6 +1073,7 @@ regulamentations||regulations
 reigstration||registration
 releated||related
 relevent||relevant
+reloade||reload
 remoote||remote
 remore||remote
 removeable||removable
@@ -973,18 +1090,25 @@ requirment||requirement
 requred||required
 requried||required
 requst||request
+reregisteration||reregistration
 reseting||resetting
+reseved||reserved
+reseverd||reserved
 resizeable||resizable
 resouce||resource
 resouces||resources
 resoures||resources
 responce||response
+resrouce||resource
 ressizes||resizes
 ressource||resource
 ressources||resources
+restesting||retesting
+resumbmitting||resubmitting
 retransmited||retransmitted
 retreived||retrieved
 retreive||retrieve
+retreiving||retrieving
 retrive||retrieve
 retuned||returned
 reudce||reduce
@@ -1006,6 +1130,7 @@ sacrifying||sacrificing
 safly||safely
 safty||safety
 savable||saveable
+scaleing||scaling
 scaned||scanned
 scaning||scanning
 scarch||search
@@ -1014,6 +1139,8 @@ searchs||searches
 secquence||sequence
 secund||second
 segement||segment
+semaphone||semaphore
+senario||scenario
 senarios||scenarios
 sentivite||sensitive
 separatly||separately
@@ -1025,9 +1152,13 @@ seperate||separate
 seperatly||separately
 seperator||separator
 sepperate||separate
+seqeunce||sequence
+seqeuncer||sequencer
+seqeuencer||sequencer
 sequece||sequence
 sequencial||sequential
 serveral||several
+servive||service
 setts||sets
 settting||setting
 shotdown||shutdown
@@ -1049,6 +1180,7 @@ sleeped||slept
 softwares||software
 speach||speech
 specfic||specific
+specfield||specified
 speciefied||specified
 specifc||specific
 specifed||specified
@@ -1071,8 +1203,12 @@ staion||station
 standardss||standards
 standartization||standardization
 standart||standard
+standy||standby
+stardard||standard
 staticly||statically
+statuss||status
 stoped||stopped
+stoping||stopping
 stoppped||stopped
 straming||streaming
 struc||struct
@@ -1085,6 +1221,7 @@ subdirectoires||subdirectories
 suble||subtle
 substract||subtract
 submition||submission
+suceed||succeed
 succesfully||successfully
 succesful||successful
 successed||succeeded
@@ -1108,6 +1245,7 @@ surpressed||suppressed
 surpresses||suppresses
 susbsystem||subsystem
 suspeneded||suspended
+suspsend||suspend
 suspicously||suspiciously
 swaping||swapping
 switchs||switches
@@ -1122,6 +1260,7 @@ swtich||switch
 symetric||symmetric
 synax||syntax
 synchonized||synchronized
+synchronuously||synchronously
 syncronize||synchronize
 syncronized||synchronized
 syncronizing||synchronizing
@@ -1130,11 +1269,14 @@ syste||system
 sytem||system
 sythesis||synthesis
 taht||that
+tansmit||transmit
 targetted||targeted
 targetting||targeting
+taskelt||tasklet
 teh||the
 temorary||temporary
 temproarily||temporarily
+thead||thread
 therfore||therefore
 thier||their
 threds||threads
@@ -1143,15 +1285,20 @@ thresold||threshold
 throught||through
 troughput||throughput
 thses||these
+tiggers||triggers
 tiggered||triggered
 tipically||typically
+timeing||timing
 timout||timeout
 tmis||this
+toogle||toggle
 torerable||tolerable
+traking||tracking
 tramsmitted||transmitted
 tramsmit||transmit
 tranasction||transaction
 tranfer||transfer
+transcevier||transceiver
 transciever||transceiver
 transferd||transferred
 transfered||transferred
@@ -1162,6 +1309,7 @@ transormed||transformed
 trasfer||transfer
 trasmission||transmission
 treshold||threshold
+trigerred||triggered
 trigerring||triggering
 trun||turn
 tunning||tuning
@@ -1169,6 +1317,8 @@ ture||true
 tyep||type
 udpate||update
 uesd||used
+uknown||unknown
+usupported||unsupported
 uncommited||uncommitted
 unconditionaly||unconditionally
 underun||underrun
@@ -1181,11 +1331,15 @@ unexpeted||unexpected
 unexpexted||unexpected
 unfortunatelly||unfortunately
 unifiy||unify
+uniterrupted||uninterrupted
 unintialized||uninitialized
+unitialized||uninitialized
 unkmown||unknown
 unknonw||unknown
 unknow||unknown
 unkown||unknown
+unamed||unnamed
+uneeded||unneeded
 unneded||unneeded
 unneccecary||unnecessary
 unneccesary||unnecessary
@@ -1204,12 +1358,15 @@ unsuccessfull||unsuccessful
 unsuported||unsupported
 untill||until
 unuseful||useless
+unvalid||invalid
 upate||update
+upsupported||unsupported
 usefule||useful
 usefull||useful
 usege||usage
 usera||users
 usualy||usually
+usupported||unsupported
 utilites||utilities
 utillities||utilities
 utilties||utilities
@@ -1233,7 +1390,9 @@ virtaul||virtual
 virtiual||virtual
 visiters||visitors
 vitual||virtual
+vunerable||vulnerable
 wakeus||wakeups
+wathdog||watchdog
 wating||waiting
 wiat||wait
 wether||whether
-- 
2.7.4

